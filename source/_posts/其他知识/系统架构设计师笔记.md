---
title: 系统架构设计师笔记(施工中)
date: 2020-12-24 10:08:59
categories: 读书笔记
tags: [读书笔记]
# top: True
---


<!-- # 第一章 绪论
## 1.1 系统架构的概念及其发展历史
### 1.1.1 系统架构的概念
&emsp;&emsp;软件架构是关于软件系统的结构、行为和属性的高级抽象。在描述阶段，其对象是直接构成系统的抽象组件以及各个组件之间的连接规则，特别是相对细致的描述组件之间的通讯。在实现阶段，这些抽象化组件被细化为实际的组件，比如具体类或对象。软件系统架构不仅指定了软件系统的组织结构和拓扑结构，而且显示了系统需求和构成组件之间的对应关系，包括设计决策的基本方法和基本原理。
# 第二章 计算机与网络基础知识
## 2.1 操作系统基础知识
### 2.1.1 操作系统的原理、类型与结构
#### 1. 操作系统的定义
&emsp;&emsp;操作系统（Operating System，OS）是计算机系统中的核心系统软件，负责管理和控制计算机系统中的硬件和软件资源，合理地组织计算机工作流程和有效地利用资源，在计算机与用户之间起接口的作用。

&emsp;&emsp;操作系统的作用：  
1. 通过资源管理，提高计算机系统的效率。
2. 改善人机界面，向用户提供友好的工作环境。
#### 2. 操作系统的分类
&emsp;&emsp;操作系统按功能不同可以分为：
* `单用户操作系统`和`批处理操作系统`
* `分时操作系统`和`实时操作系统`
* `网络操作系统`和`分布式操作系统`
* `嵌入式操作系统`
#### 3. 操作系统的特征
* 并发性
* 共享性
* 虚拟性
* 不确定性
#### 4. 操作系统的功能
* 进程管理
* 文件管理
* 存储管理
* 设备管理
* 作业管理
### 2.1.2 处理机与进程管理
#### 1. 进程的定义及其分类
&emsp;&emsp;进程是资源分配和独立运行的基本单位，是程序的一次执行，通常由程序、数据及进程控制块(PCB)组成。PCB描述了进程的基本情况，是进程存在的唯一标志。

&emsp;&emsp;进程与程序的区别：  
&emsp;&emsp;程序是静态的指令序列，进程是为执行该程序的线程而保留的资源集。

&emsp;&emsp;进程依性质不同可分为：
* `系统进程`和`用户进程`
* `父进程`和`子进程`
#### 2. 进程的状态转换与控制
&emsp;&emsp;进程有以下三种基本状态：
1. 就绪状态  
&emsp;&emsp;当进程已分配了除 CPU 以外的所有必要的资源后，只要能再获得处理机，便能立即执行，把这时的进程状态称为`就绪状态`。在一个系统中，可以有多个进程同时处于就绪状态，通常把它们排成一个队列，称为`就绪队列`。
2. 执行状态  
&emsp;&emsp;指进程已获得处理机，其程序正在执行。在单处理机系统中，只能有一个进程处于执行状态。
3. 阻塞状态  
&emsp;&emsp;指进程因发生某事件（如请求 I/O、申请缓冲空间等）而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为`阻塞状态`，有时也称为`等待`状态或`睡眠`状态。通常将处于阻塞状态的进程排成一个队列，称为`阻塞队列`。

下图是进程基本状态之间的转换图，也称为三态模型。

![进程状态转换图](https://pic.lufer.cc/images/2021/03/15/roqSZ8.png)

#### 3．挂起状态
&emsp;&emsp;在一些系统中，增加了一些新的进程状态，其中最重要的是挂起状态。引入挂起状态的原因有：
1. 对换的需要  
&emsp;&emsp;为了缓和内存紧张的情况，而将内存中处于阻塞状态的进程换至外存上，使进程又处于一种有别于阻塞状态的新状态。因为即使该进程所期待的事件发生，该进程仍不具备执行条件而不能进入就绪队列，称这种状态为挂起状态。
2. 终端用户的请求  
&emsp;&emsp;当终端用户在自己的程序运行期间，发现有可疑问题时，往往希望使自己的进程暂停下来。也就是说，使正在执行的进程暂停执行，若是就绪进程，则不接受调度以便研究其执行情况或对程序进行修改。把这种静止状态也称为挂起状态。  
3. 父进程请求  
&emsp;&emsp;父进程常希望挂起自己的子进程，以便考查和修改子进程，或者协调各子进程间的活动。
4. 负荷调节的需要  
&emsp;&emsp;当实时系统中的工作负荷较重，有可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统正常运行。
5. 操作系统的需要  
&emsp;&emsp;操作系统希望挂起某些进程，以便检查运行中资源的使用情况及进行记账。

&emsp;&emsp;综上所述，不难了解挂起状态具有以下三个属性。  
1. 被挂起的进程，原来可能处于就绪状态，此时进程（被挂起）的状态称为挂起就绪；若被挂起的进程原来处于阻塞状态，此时的状态称为挂起阻塞。不论哪种状态，该进程都是不可能被调度而执行的。
2. 处于挂起阻塞状态的进程，其阻塞条件与挂起条件无关；当进程所期待的事件出现后，进程虽不再被阻塞，但仍不能运行，这时，应将该进程从`静止阻塞`状态转换为`挂起就绪`状态。
3. 进程可以由其自身挂起，也可由用户或操作系统等将之挂起。其目的都在于阻止进程继续运行，被挂起的进程只能用显式方式来激活，以便从挂起状态中解脱出来。

&emsp;&emsp;下图所示为具有挂起操作的进程状态的演变情况：

![带有挂起操作的进程状态演变图](https://pic.lufer.cc/images/2021/03/15/roL4AO.png)

#### 4. 进程互斥与同步及PV操作
##### 1. 进程间的同步
&emsp;&emsp;异步环境下的一组并发进程之间互发消息、互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程同步。也即同步是使在异步环境下的各进程按一定的顺序和速度执行。`（协作关系）`
##### 2. 进程间的互斥
&emsp;&emsp;一组并发进程中一个或多个程序段，因共享某一共有资源而导致必须以一个不允许交叉执行的单位执行。也就是说互斥是要保证临界资源在某一时刻只被一个进程访问。`（竞争关系）`  
##### 3. 临界资源
&emsp;&emsp;一次只能供一个进程使用的资源，如打印机、公共变量和表格。
##### 4. 临界区管理原则
&emsp;&emsp;临界区是进程中对临界资源实施操作的那段程序，互斥临界区有如下管理原则：  
1. 有空则进  
&emsp;&emsp;无进程处于临界区时，若有进程要求进入临界区则立即允许其进入。
2. 无空则等  
&emsp;&emsp;当已有进程进入其临界区时，其他试图进入各自临界区的进程必须等待，以保证诸进程互斥地进入临界区。
3. 有限等待  
&emsp;&emsp;有若干进程要求进入临界区时，应在有限时间内使一进程进入临界区，即它们不应相互等待而谁也不进入临界区。
4. 让权等待  
&emsp;&emsp;对于等待进入临界区的进程必须释放其占有的 CPU。
##### 5. 信号量机制
&emsp;&emsp;信号量可以有效地实现进程的同步和互斥。在操作系统中，信号量是一个整数。当信号量大于等于 0 时，代表可供并发进程使用的资源实体数，当信号量小于零时则表示正在等待使用临界区的进程数。建立一个信号量必须说明所建信号量代表的意义和设置初值，以及建立相应的数据结构，以便指向那些等待使用该临界区的进程。  
&emsp;&emsp;对信号量只能施加特殊的操作：P 操作和 V 操作。P 操作和 V 操作都是不可分割的原子操作，也称为原语。因此，P 原语和 V 原语执行期间不允许中断发生。  
&emsp;&emsp;P（sem）操作的过程是将信号量 sem 值减 l，若 sem 的值成负数，则调用 P 操作的进程暂停执行，直到另一个进程对同一信号量做 V 操作。V（sem）操作的过程是将信号量sem 值加 1，若 sem 的值小于等于 0，则从相应队列（与 sem 有关的队列）中选一个进程并唤醒它。

&emsp;&emsp;一般 P 操作与 V 操作的定义如下所述。
```
P 操作：
P（sem）{
    sem = sem - 1;
    if（sem < 0）
        进程进入等待状态；
    else 
        继续进行；
    } 
V 操作：
V（sem）{
    sem = sem + 1;
    if（sem ≤ 0）
        唤醒队列中的一个等待进程；
    else 
        继续进行；
    }
```
&emsp;&emsp;要用 P，V 操作实现进程同步，需要引进私用信号量。私用信号量只与制约进程和被制约进程有关，而不是与整组并发进程相关。与此相对，进程互斥使用的信号量为公用信号量。首先为各并发进程设置私用信号量，然后为私用信号量赋初值，最后利用 P，V 原语和私用信号量规定各进程的执行顺序。
#### 5. 进程通信与管程
##### 1. 进程通信
&emsp;&emsp;通信是指进程间的信息交换，可分为`控制信息`的交换和`数据`的交换。  
&emsp;&emsp;控制信息的交换成为低级通信，通过信号量来实现，属于低级信息。  
&emsp;&emsp;数据交换成为高级通信，类型可以分为`共享存储系统`、`消息传递系统`和`管道通信`。方式有`直接通信`和`间接通信`。
##### 2. 管程
&emsp;&emsp;共享数据及在其上操作的一组过程构成管程。任一时刻最多只有一个进程能够真正地进入管程。
#### 6.进程调度与死锁
##### 1. 进程调度
&emsp;&emsp;进程调度即处理器调度（又称上下文转换），它的主要功能是确定在什么时候分配处理器，并确定分给哪一个进程。
##### 2. 调度方式与算法
&emsp;&emsp;进程调度的方式有两类：`剥夺方式`与`非剥夺方式`。   
&emsp;&emsp;所谓非剥夺方式是指，一旦某个作业或进程占用了处理器，别的进程就不能把处理器从这个进程手中夺走，直到该进程自己因调用原语操作而进入阻塞状态，或时间片用完而让出处理机。  
&emsp;&emsp;剥夺方式是指，当就绪队列中有进程的优先级高于当前执行进程的优先级时，便立即发生进程调度，转让处理机。

&emsp;&emsp;进程调度的算法是服务于系统目标的策略，对于不同的系统与系统目标，常采用不同的调度算法：
1. 先来先服务（First Come and First Serverd，FCFS）调度算法  
&emsp;&emsp;又称先进先出（First Inand First Out，FIFO）。就绪队列按先来后到原则排队。
2. 优先数调度  
&emsp;&emsp;优先数反映了进程优先级，就绪队列按优先数排队。有两种确定优先级的方法，即`静态优先级`和`动态优先级`。静态优先级是指进程的优先级在进程开始执行前确定，执行过程中不变，而动态优先级则可以在进程执行过程中改变。
3. 轮转法（Round Robin）  
&emsp;&emsp;就绪队列按 FCFS 方式排队。每个进程执行一次占有处理器时间都不超过规定的时间单位（时间片）若超过，则自行释放自己所占有的 CPU 而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。
##### 3. 死锁
&emsp;&emsp;当若干个进程互相竞争对方已占有的资源，无限期地等待，不能向前推进时会造成“死锁”。  
&emsp;&emsp;死锁是系统的一种出错状态，它不仅会浪费大量的系统资源，甚至还会导致整个系统的崩溃，所以死锁是应该尽量预防和避免的。
##### 4. 死锁产生的原因及条件
1. 死锁条件   
&emsp;&emsp;产生死锁的主要原因是资源竞争和进程的推进顺序不当。  
&emsp;&emsp;产生死锁的必要条件是：`互斥条件`、`保持和等待条件`、`不剥夺条件`和`环路等待条件`。  
2. 解决死锁的策略   
&emsp;&emsp;处于死锁状态的进程不能继续执行但又占用了系统资源，从而阻碍其他作业的执行。   
&emsp;&emsp;解决死锁有两种策略：一种是在`死锁发生前采用的预防和避免策略`；另一种是`在死锁发生后采用的检测与恢复策略`。  
&emsp;&emsp;死锁的预防主要是通过打破死锁产生的 4 个必要条件之一来保证不会产生死锁。采用的死锁预防策略通常有资源的`静态分配法`或`有序分配法`，它们分别打破了资源动态分配条件和循环等待条件，因此不会发生死锁。但这样做会大大降低系统资源的利用率和进程之间的并行程度。  
&emsp;&emsp;死锁避免策略，则是在系统进行资源分配时，先执行一个死锁避免算法（典型的如银行家算法），以保证本次分配不会导致死锁发生。由于资源分配很频繁，因此死锁避免策略要耗费大量的 CPU 和时间。

&emsp;&emsp;实际上，系统出现死锁的概率很小，故从系统所花的代价上看，采用死锁发生后的检测与恢复策略要比采用死锁发生前的预防与避免策略代价小一些。
#### 7. 线程
&emsp;&emsp;线程是进程中的一个实体，是被系统独立分配和调度的基本单位。同属一个进程的线程共享进程所拥有的全部资源。
### 2.1.3 存储管理
&emsp;&emsp;存储管理主要是指对内存储器的管理，存储管理的目的是尽量提高内存的使用效率，扩充主存以及对主存信息实现有效保护。  
&emsp;&emsp;存储管理的方式有分区存储管理、分页存储管理、分段存储管理、段页式存储管理和虚拟存储管理。

#### 1. 页式存储管理
&emsp;&emsp;分页的基本思想是把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，并以页面为单位进行分配。在页式存储管理中，系统中虚地址是一个有序对（页号，位移）。系统为每一个进程建立一个页表，其内容包括进程的逻辑页号与物理页号的对应关系、状态等。  
&emsp;&emsp;页式系统的动态地址转换是这样进行的：当进程运行时，其页表的首地址已在系统的动态地址转换机构中的基本地址寄存器中。执行的指令访问虚存地址（p，d）时，首先根据页号 p 查页表，由状态可知，这个页是否已经调入内存。若已调入内存，则得到该页的内存位置 p'，然后，与页内相对位移 d 组合，得到物理地址 r。如果该页尚未调入内存，则产生缺页中断，以装入所需的页，该过程如下图所示。

![页式存储动态地址转换](https://pic.lufer.cc/images/2021/03/15/rTEYIH.png)

&emsp;&emsp;页式虚拟存储管理是在页式存储管理的基础上实现虚拟存储器的。首先把作业信息作为副本存放在磁盘上，作业执行时，把作业信息的部分页面装入内存储器，作业执行时若所访问的页面已在内存中，则按页式存储管理方式进行地址转换，得到欲访问的内存绝对地址，若欲访问的页面不在内存中，则产生一个“缺页中断”，由操作系统把当前所需的页面装入内存储器中。  
&emsp;&emsp;为此，在装入作业时，就应在该作业的页表中指出哪些页已在内存储器中，哪些页还没有装入内存。可用一个标志位指示对应页是否在内存储器，可假设标志位为 1 表示该页在内存，而标志位为 0 表示该页尚未装入内存。为了能方便地从磁盘上找到作业信息的副本，故在页表中还可指出每一页副本在磁盘上的位置。

&emsp;&emsp;当内存中无空闲块时，为了装入一个页面而必须按某种算法从已在内存的页中选择一页，将它暂时调出内存，让出内存空间以存放所需装入的页面，这个工作称为“页面调度”。如何选择调出的页面是很重要的，如果采用了一个不合适的算法，就会出现这样的现象：刚被调出的页面又立即要用，因而又要把它装入，而装入不久又被选中调出，调出不久又被装入，如此反复，使调度非常频繁。这种现象称为`“抖动”`。一个好的调度算法应减少或避免抖动现象。  

&emsp;&emsp;常用的页面调度算法有：
1. 最优（OPT）算法  
&emsp;&emsp;选择不再使用或最远的将来才被使用的页，这是理想的算法，但是难以实现，常用于淘汰算法的比较。  
2. 随机（RAND）算法  
&emsp;&emsp;随机地选择被淘汰的页，开销小，但是可能选中立即就要访问的页。
3. 先进先出算法  
&emsp;&emsp;选择在内存驻留时间最长的页似乎合理，但可能淘汰掉频繁使用的页。另外，使用 FIFO 算法时，在未给予进程分配足够的页面数时，有时会出现给予进程的页面数增多，缺页次数反而增加的异常现象。  
&emsp;&emsp;FIFO 算法简单，易实现。可以把装入内存储器的那些页的页号按进入的先后顺序排成队列，每次总是调出队首的页，当装入一个新页后，把新页的页号排到队尾。
4. 最近最少使用（Least Recently Used，LRU）算法  
&emsp;&emsp;选择离当前时间最近的一段时间内使用得最少的页。这个算法的主要出发点是，如果某个页被访问了，则它可能马上就要被访问；反之，如果某个页长时间未被访问，则它在最近一段时间也不会被访问。

#### 2．段式存储管理
&emsp;&emsp;段式存储管理与页式存储管理相似。分段的基本思想是把用户作业按逻辑意义上有完整意义的段来划分，并以段为单位作为内外存交换的空间尺度。  
&emsp;&emsp;一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成。分段系统中，容许程序（作业）占据内存中许多分离的分区。每个分区存储一个程序分段。这样每个作业需要几对界限地址寄存器，判定访问地址是否越界也就更困难了。在分段存储系统中常常利用存储保护键实现存储保护。分段系统中虚地址是一个有序对（段号，位移）。系统为每个作业建立一个段表，其内容包括段号、段长、内存起始地址和状态等。状态指出这个段是否已调入内存，即内存起始地址指出这个段，状态指出这个段的访问权限。

&emsp;&emsp;分段系统的动态地址转换是这样进行的：进程执行时，其段表的首地址已在基本地址寄存器中，执行的指令访问虚存（s，d）（取指令或取操作数）时，首先根据段号 s 查段表，若段已经调入内存，则得到该段的内存起始地址，然后与段内相对地址（段内偏移量 d）相加，得到实地址。如果该段尚未调入内存，则产生缺段中断，以装入所需要的段。

&emsp;&emsp;段式虚拟存储管理仍然以段式存储管理为基础，为用户提供比内存实际容量大的虚拟空间。段式虚拟存储管理把作业中的各个分段信息都保留在磁盘上，当作业可以投入执行时，做如下操作：
* 首先把当前需要的一段或几段装入内存。
* 作业执行时，如果要访问的段已经在内存，则按照“段式存储管理”中的方式进行地址转换；如果要访问的段不在内存中，则产生一个“缺段中断”，由操作系统把当前需要的段装入内存。

&emsp;&emsp;因此，在段表中应增设段是否在内存的标志以及各段在磁盘上的位置，已在内存中的段仍要指出该段在内存中的起始地址和占用内存区长度。  
&emsp;&emsp;作业执行要访问的段时，由硬件的地址转换机构查段表。若该段在内存中，则立即把逻辑地址转换成绝对地址；若该段不在内存中，则形成“缺段中断”，由操作系统处理这个中断。  
&emsp;&emsp;处理的办法是:查内存分配表，找出一个足够大的连续区以容纳该分段，如果找不到足够大的连续区则检查空闲区的总和，若空闲区总和能满足该段要求，那么进行适当移动将分散的空闲区集中；若空闲区总和不能满足该段要求，可把内存中的一段或几段调出，然后把当前要访问的段装入内存中。段被移动、调出和装入后都要对段表中的相应表目做修改。新的段被装入后应让作业重新执行被中断的指令，这时就能找到要访问的段，也可以继续执行下去。

#### 3．段页式存储管理
&emsp;&emsp;段页式管理是段式和页式两种管理方法结合的产物，综合了段式组织与页式组织的特点，根据程序模块分段，段内再分页，内存被分划成定长的页。段页式系统中虚地址形式是（段号、页号、页内偏移），如下图所示。

![段页式系统的虚地址形式](https://pic.lufer.cc/images/2021/03/15/rTmG6I.png)

&emsp;&emsp;系统为每个进程建立一个段表，为每个段建立一个页表。段页式管理采用段式分配、页式使用的方法，便于动态连接和存储的动态分配。这种存储管理能提高内存空间的利用率。  
&emsp;&emsp;段式虚拟管理还是以段为单位分配内存空间，整段的调出、装入，有时还要移动，这些都增加了系统的开销。如果按段页式存储管理的方式，把每一段再分成若干页面，那么，每一段不必占用连续的存储空间；甚至当内存块不够时，可只将一段中的部分页面装入内存，这种管理方式称为“段页式虚拟存储管理”。  
&emsp;&emsp;段页式虚拟存储管理为每一个装入内存的作业建立一张段表，还要为每一段建立页表。段表中指出该段的页表存放位置及长度，页表中应指出该段的各页在磁盘上的位置以及页是否在内存中，若在内存中则填上占用的内存块号。作业执行时按段号查段表，找到相应的页表再根据页号查页表，由标志位判定该页是否已在内存，若是，则进行地址转换；否则进行页面调度。地址转换过程如下图所示。

![段页式存储地址转换过程](https://pic.lufer.cc/images/2021/03/15/rTmcn0.png)

&emsp;&emsp;段页式虚拟存储管理结合了段式和页式的优点，但增加了设置表格（段表、页表）和查表等开销，段页式虚拟存储器一般只在大型计算机系统中使用。

### 2.1.4 设备管理
&emsp;&emsp;设备管理的主要任务是保证在多道程序环境下，当多个进程竞争使用设备时，按一定策略分配和管理各种设备，控制设备的各种操作，完成输入/输出设备与主存之间的数据交换。  
&emsp;&emsp;设备管理的目标是提高设备的利用率，为用户提供方便统一的界面。  
&emsp;&emsp;设备管理的主要功能是动态的掌握并记录设备的状态、设备分配和释放、缓冲区管理、实现物理输入/输出设备的操作、提供设备使用的用户接口、设备的访问和控制、输入/输出缓冲和调度。

#### 1. 设备的分类
&emsp;&emsp;按`设备的使用特性`可分为：`存储设备`、`输入/输出设备`、`终端设备`和`脱机设备`。  
&emsp;&emsp;从`资源分配角度`分为：`独占设备`、`共享设备`和`虚拟设备`。    
&emsp;&emsp;按`设备的从属关系`分为：`系统设备`和`用户设备`。   
&emsp;&emsp;按`数据组织方式`分为：`块设备`和`字符设备`。     
&emsp;&emsp;按`输入/输出对象`分为：`人机通信设备`、`机机通信设备`。  
&emsp;&emsp;按`是否可交互`分为：`非交互设备`、`交互设备`。  
#### 2. 设备管理的主要技术
* 中断技术
* DMA技术
* 缓冲技术
* 虚设备与SPOOLING技术  
&emsp;&emsp;采用假脱机技术，可以将低速的独占设备改造成一种可共享的设备，而且一台物理设备可以对应若干台虚拟的同类设备。假脱机（Simultaneous Peripheral Operation On Line，SPOOLING）的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，采用一组程序或进程模拟一台输入/输出处理器。  
&emsp;&emsp;该技术利用了专门的外围控制机将低速 I/O 设备上的数据传送到高速设备上，或者相反。但是当引入多道程序后，完全可以利用其中的一道程序来模拟脱机输入时的外围控制机的功能，把低速的 I/O 设备上的数据传送到高速磁盘上；再利用另一道程序来模拟脱机输出时外围控制机的功能，把高速磁盘上的数据传送到低速的 I/O 设备上。这样便可以在主机的控制下实现脱机输入、输出的功能。此时的外围操作与 CPU 对数据的处理同时进行。
#### 3. 设备管理软件
* 中断处理程序
* 设备驱动程序
* 与设备无关的系统软件
* 用户层IO软件
#### 4. 数据传输控制方式
&emsp;&emsp;外围设备和内存之间常用的数据传送控制方式主要有以下几种：
1. 程序控制方式  
&emsp;&emsp;处理器启动数据传输，然后等设备完成。
2. 中断方式  
&emsp;&emsp;程序控制方式不能实现并发。中断方式的数据传输过程是这样的，进程启动数据传输（如读）后，该进程放弃处理器，当数据传输完成，设备控制器产生中断请求，中断处理程序对数据传输工作处理之后，让相应进程成为就绪状态。以后，该进程就可以得到所需要的数据。
3. 直接存储访问（Direct Memory Access，DMA）方式  
&emsp;&emsp;指外部设备和内存之间开辟直接的数据交换通路。除了控制状态寄存器和数据缓冲寄存器外，DMA 控制器中还包括传输字节计数器、内存地址寄存器等。DMA 方式采用窃取（或挪用）处理器的工作周期和控制总线而实现辅助存储器和内存之间的数据交换。有的 DMA 方式也采用总线浮起方式传输大批量数据。
4. 通道方式  
&emsp;&emsp;通道又称为输入/输出处理器（Input/Output Processor，IOP），可以独立完成系统交付的输入/输出任务，通过执行自身的输入/输出专用程序（称通道程序）进行内存和外设之间的数据传输。主要有 3 种通道：字节多路通道、选择通道和成组多路通道。

&emsp;&emsp;选择和衡量控制方式的原则如下：
1. 数据传送速度足够高，能满足用户的需要但又不丢失数据。
2. 系统开销小，所需的处理控制程序少。
3. 能充分发挥硬件资源的能力，使得 I/O 设备尽量处于使用状态中，而 CPU 等待时间少
#### 5. 磁盘调度算法
&emsp;&emsp;磁盘调度的意义是使各个进程对磁盘的平均访问时间最小。  
&emsp;&emsp;常用的调度算法有`先来先服务`、`最短寻道时间优先`、`扫描算法`。
### 2.1.5 文件管理
&emsp;&emsp;文件是具有符号名、在逻辑上具有完整意义的一组相关信息项的集合。操作系统根据文件名对文件进行控制和管理。  
&emsp;&emsp;文件管理的功能包括：
* 按文件名访问文件
* 统一用户接口
* 并发访问和控制
* 安全性控制
* 优化性能
* 差错恢复
#### 1. 文件的类型
&emsp;&emsp;按`文件性质和用途`可分为：`系统文件`、`库文件`和`用户文件`。  
&emsp;&emsp;按`文件的安全属性`可分为：`只读文件`、`读写文件`、`可执行文件`和`不保护文件`。  
&emsp;&emsp;按`文件的组织形式`可分为：`普通文件`、`目录文件`、`设备文件（特殊文件）`。  
&emsp;&emsp;按`信息保存期限`可分为：`临时文件`、`档案文件`和`永久文件`。  
&emsp;&emsp;按`信息流向`可分为：`输入文件`、`输出文件`、`输入/输出文件`。
#### 2. 文件的组织和结构
&emsp;&emsp;文件的`逻辑结构`分为`有结构的记录文件`和`无结构的字符流文件`。  
&emsp;&emsp;文件的`物理结构`分为`连续结构`、`链接结构`、`索引结构`和`多个物理块的索引表`。
#### 3. 文件访问方法
&emsp;&emsp;常用的访问方法有`顺序访问`和`随机访问`两种。  
&emsp;&emsp;顺序访问是指对文件中的信息按顺序依次读写。  
&emsp;&emsp;随机访问是可以按任意的次序随机地读写文件中的信息。
#### 4. 文件存储设备管理
&emsp;&emsp;文件存储设备常用的空闲空间管理方法有`位图法`、`索引法`和`链接法`。
#### 5. 文件控制块和文件目录
&emsp;&emsp;文件控制块（FCB）是系统为每个文件设置的用于描述和控制文件的数据结构，它是文件存在的唯一标志。FCB一般包含`基本信息`、`位置信息`、`存取控制信息`和`使用信息`。 
&emsp;&emsp;文件目录是文件控制块的有序集合。
### 2.1.6 作业管理
#### 1. 作业管理和作业控制
&emsp;&emsp;作业是系统为完成一个用户的计算任务（或一次事务处理）所做的工作总和。它由程序、数据和作业说明书三部分组成。  
&emsp;&emsp;作业管理程序是操作系统中用来控制作业`进入`、`执行`和`撤销`的一组程序。  
&emsp;&emsp;用户作业可以采用联机和脱机两种控制方式控制作业运行。  
&emsp;&emsp;作业控制块（JCB）是记录与该作业有关的各种信息的登记表，是作业存在的唯一标志。包括`用户名`、`作业名`、`状态标志`等信息。
#### 2. 作业调度及其常用算法
&emsp;&emsp;作业调度是指完成从`后备状态到执行状态`的转变及从`执行状态到完成状态`的转变。   
&emsp;&emsp;常用的调度算法有`先来先服务`、`短作业优先`、`响应比高优先`、`优先级调度算法`和`均衡调度算法`。
## 2.2 数据库系统基础知识
&emsp;&emsp;数据库（DB）是指长期存储在计算机内的、有组织的、可共享的数据集合。  
&emsp;&emsp;数据库系统（DBS）从广义上讲是由数据库、硬件、软件和人员组成，管理对象是数据。  
&emsp;&emsp;数据库管理系统（DBMS）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。主要功能有数据定义、数据库操作、数据库运行管理、数据组织、存储和管理、数据库的建立与维护及其他功能。   
&emsp;&emsp;DBMS通常可分为三类：关系数据库系统（RDBS）、面向对象的数据库系统（OODBS）、对象关系数据库系统（ORDBS）。  
&emsp;&emsp;数据库采用三级模式结构，结构图如下图所示。数据库系统在三级模式间提供了两级映像：`模式/内模式映像`、`外模式/模式映像`来保证数据库中数据有较高的逻辑独立性和物理独立性。

![数据库系统体系结构](https://pic.lufer.cc/images/2021/04/10/image.png)
### 2.2.1 关系数据库基础
#### 1. 数据库的结构与模式
&emsp;&emsp;数据库结构的基础是数据模型，是用来描述数据的一组概念和定义。   
&emsp;&emsp;数据模型的三要素是`数据结构`、`数据操作`以及`数据的约束条件`。   
&emsp;&emsp;关系数据模型由`关系数据结构`、`关系操作结合`和`关系完整性约束`三大要素组成。
#### 2. 实体-联系（E-R）模型
&emsp;&emsp;E-R方法主要概念有`实体`、`联系`和`属性`，该方法直接从现实世界中抽象出实体和实体间的联系。
#### 3. 数据的规范化
&emsp;&emsp;关系数据库设计理论的核心是`数据间的函数依赖`，衡量的标准是`关系规范化的程度`及`分解的无损连接`和`保持函数依赖性`。  
&emsp;&emsp;关系模型满足的确定约束条件称为范式，根据满足约束条件的级别不同，范式由低到高分为 1NF（第一范式）、2NF（第二范式）、3NF（第三范式）、BCNF（BC 范式）、4NF（第四范式）等。不同的级别范式性质不同。  
&emsp;&emsp;把一个低一级的关系模型分解为高一级关系模型的过程，称为关系模型的规范化。关系模型分解必须遵守两个准则：  
1. 无损连接性：信息不失真（不增减信息）。
2. 函数依赖保持性：不破坏属性间存在的依赖关系。

&emsp;&emsp;综合 1NF、2NF 和 3NF、BCNF 的内涵可概括如下：  
1. 非主属性完全函数依赖于码（2NF 的要求）；
2. 非主属性不传递依赖于任何一个候选码（3NF 的要求）；
3. 主属性对不含它的码完全函数依赖（BCNF 的要求）；
4. 没有属性完全函数依赖于一组非主属性（BCNF 的要求）。

#### 4. 事务管理
&emsp;&emsp;事务是数据库环境中不可分割的逻辑工作单位。一个程序可包含多个事务。  
&emsp;&emsp;事务具有4个特性（ACID）：`原子性（atomicity）`、`一致性（consistency）`、`隔离性（isolation）`、`持久性（durability）`。
#### 5. 并发控制
&emsp;&emsp;并发操作带来的问题主要有`丢失更新`、`不可重复读`、`脏数据`。  
&emsp;&emsp;并发控制的主要技术是封锁。主要类型有`排他锁`（X锁或写锁）和`共享锁`（S锁或读锁）。
#### 6. 数据库的备份与恢复
&emsp;&emsp;保护数据库的关键技术在于`建立冗余数据`，即备份数据。  
&emsp;&emsp;建立冗余数据的方法是进行`数据转储`和`建立日志文件`。  
&emsp;&emsp;数据转储分为`静态转储和动态转储`、`海量转储和增量转储`。  
&emsp;&emsp;数据库的4类故障是`事务故障`、`系统故障`、`介质故障`及`计算机病毒`。  
&emsp;&emsp;事务故障的恢复一般有两种操作：`撤销事务`和`重做事务`。  
&emsp;&emsp;介质故障的恢复需要DBA的参与，装入数据库的副本和日志文件的副本，再由系统执行撤销和重做操作。

### 2.2.2 关系数据库设计
&emsp;&emsp;数据库设计包括`结构特性设计`和`行为特性设计`两方面。  
#### 1. 数据库设计的特点
&emsp;&emsp;从数据结构即数据模型开始，以数据模型为核心展开。  
&emsp;&emsp;静态结构设计与动态行为设计分离。  
&emsp;&emsp;试探性、反复性和多步性。
#### 2. 数据库设计的方法
&emsp;&emsp;目前已有的数据库设计方法可分为四类，即`直观设计法`、`规范设计法`、`计算机辅助设计法`和`自动化设计法`。  
&emsp;&emsp;主要掌握基于3NF的设计方法。
#### 3. 数据库设计的基本步骤
&emsp;&emsp;数据库设计分为需求分析、概念结构设计、逻辑结构设计、物理结构设计、应用程序设计和运行维护6个阶段，如下图所示。

![数据库设计步骤](https://pic.lufer.cc/images/2021/04/11/image.png)

1. 需求分析  
&emsp;&emsp;需求分析阶段的任务是对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况、确定新系统功能的过程中，收集支持系统目标的基础数据及其处理方法。    
&emsp;&emsp;在需求分析中，通过自顶向下、逐步分解的方法分析系统。分析的结果用数据流图进行图形化的描述，并用一些规范的表格对数据分析结果和描述做补充，最后形成需求说明书。
2.  概念结构设计   
&emsp;&emsp;在需求分析的基础上，依照需求分析中的信息需求，对用户信息加以分类、聚集和概括，建立信息模型，并按照选定的数据库管理系统软件，把它们转换为数据的逻辑结构，再依照 软硬件环境，最终实现数据的合理存储。这一过程也称为数据建模。  
&emsp;&emsp;数据库概念结构设计的策略通常有自顶向下、自底向上、逐步扩张、混合策略。最常用的是自底向上。
3. 逻辑结构设计   
&emsp;&emsp;在概念结构设计基础上进行数据模型设计，可以使层次、网状模型和关系模型。  
&emsp;&emsp;逻辑结构设计的主要任务是确定数据模型、将E-R图转换为指定的数据模型、确定完整性约束、确定用户视图。
4. 物理结构设计    
&emsp;&emsp;对已确定的数据库逻辑结构，利用DBMS提供的方法技术，以较优的存储结构和数据存取路径、合理的数据存放位置以及存储分配，设计出一个高效的、可实现的数据库物理结构。  
&emsp;&emsp;主要工作有存储记录的格式设计、存储结构设计、存取方法设计和确定系统配置。
5. 数据库应用程序设计    
&emsp;&emsp;数据库应用系统一方面是对用户信息进行存储，另一方面是对用户处理要求进行实现。  
&emsp;&emsp;主要工作有选择设计方法、确定开发计划、选择系统架构、设计安全性策略。  
&emsp;&emsp;设计方法有结构化设计方法和面向对象设计方法两种。  
6. 数据库运行和维护    
&emsp;&emsp;主要工作有数据库的转储与恢复，数据库的安全性和完整性控制，数据库性能的监督、分析和改造，数据库的重组和重构等。

### 2.2.3 分布式数据库
#### 1. 分布式数据库的概念
&emsp;&emsp;分布式数据库是针对地理上分散，管理上又需要不同程度集中管理的需求而提出的一种数据管理信息系统。  
&emsp;&emsp;满足分布性、逻辑相关性、场地透明性和场地自治性的数据库系统被称为完全分布式数据库系统。   
&emsp;&emsp;分布式数据库系统的特点是集中控制性、数据独立性、数据冗余可控性、场地自治性和存取的有效性。 
#### 2. 分布式数据库的架构
&emsp;&emsp;分布式数据库可抽象为4层的结构模式，划分为`全局外层`、`全局概念层`、`局部概念层`、`局部内层`，各层之间还有相应的层间映射。

![分布式数据库架构图](https://pic.lufer.cc/images/2021/04/12/image.png)

### 2.2.4 商业智能
#### 1. 商业智能的基本概念
&emsp;&emsp;商业智能（BI）是企业对商业数据的搜集、管理和分析的系统过程，目的是使企业的各级决策者获得知识或洞察力，帮助他们做出对企业更有利的决策。  
&emsp;&emsp;商业智能系统主要实现将原始业务数据转换为企业决策信息的过程。它主要包括`数据预处理`、`建立数据仓库`、`数据分析`及`数据展现`4个阶段。   
&emsp;&emsp;一般认为`数据仓库`、`联机分析处理`和`数据挖掘技术`是商业智能的三大组成部分。  
#### 2. 数据仓库
&emsp;&emsp;著名的数据仓库专家 W.H.Inmon 在《Building the Data Warehouse》一书中将数据仓库定义为：数据仓库（Data Warehouse）是一个`面向主题的`、`集成的`、`相对稳定的`、且`随时间变化的`数据集合，用于支持管理决策。  
&emsp;&emsp;数据仓库采用三层架构，底层是数据仓库服务器、中间层是OLAP服务器、顶层是前端工具，如下图所示。

![数据仓库架构](https://pic.lufer.cc/images/2021/04/12/image20b3552fe02f9d10.png)

&emsp;&emsp;数据仓库的实现步骤有规划、需求研究、问题分析、数据的抽取清洗集成装载、数据仓库设计、分析报表查询、数据仓库性能优化及数据仓库的部署发布等几个步骤。  
&emsp;&emsp;数据仓库的实现方法主要有`自顶向下法`、`自底向上法`和`联合方法`。
#### 3. 多维分析海量数据分析器——OLAP
&emsp;&emsp;联机分析处理OLAP利用多维的概念，提供了切片、切块、下钻、上卷和旋转等多维度分析与跨纬度分析功能。  
&emsp;&emsp;OLAP系统架构主要分为`基于关系数据库的ROLAP`，`基于多维数据库的MOLAP`，`基于混合数据组织的HOLAP`三种。
#### 4. 数据挖掘
&emsp;&emsp;从技术角度看，数据挖掘就是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。  
&emsp;&emsp;从商业角度来看，数据挖掘是一种新的商业信息处理技术，其主要特点是对商业数据库中的大量业务数据进行抽取、转换、分析和其他模型化处理，从中提取辅助商业决策的关键性数据。  
&emsp;&emsp;数据挖掘与传统的数据分析（如查询、报表、联机应用分析）的本质区别是数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有`先知`，`有效`和`可实用`三个特征。 

1. 数据挖掘的功能  
&emsp;&emsp;数据挖掘的目标是从数据库中发现隐含的、有意义的知识，主要有以下五类功能：
    * 自动预测趋势和行为  
    &emsp;&emsp;数据挖掘自动在大型数据库中寻找预测性信息，以往需要进行大量手工分析的问题如今可以迅速直接由数据本身得出结论。一个典型的例子是市场预测问题，数据挖掘使用过去有关促销的数据来寻找未来投资中回报最大的用户，其他可预测的问题包括预报破产及认定对指定事件最可能做出反应的群体。
    * 关联分析  
    &emsp;&emsp;数据关联是数据库中存在的一类重要的可被发现的知识。若两个或多个变量的取值之间存在某种规律性，就称为关联。关联可分为简单关联、时序关联、因果关联。关联分析的目的是找出数据库中隐藏的关联网。有时并不知道数据库中数据的关联函数，即使知道也是不确定的，因此关联分析生成的规则带有可信度。
    * 聚类   
    &emsp;&emsp;数据库中的记录可被划分为一系列有意义的子集，即聚类。聚类增强了人们对客观现实的认识，是概念描述和偏差分析的先决条件。聚类技术主要包括传统的模式识别方法和数学分类学。20 世纪 80 年代初，Mchalski 提出了概念聚类技术及其要点，即在划分对象时不仅要考虑对象之间的距离，还要求划分出的类具有某种内涵描述，从而避免了传统技术的某些片面性。
    * 概念描述  
    &emsp;&emsp;概念描述就是对某类对象的内涵进行描述，并概括这类对象的有关特征。概念描述分为特征性描述和区别性描述，前者描述某类对象的共同特征，后者描述不同类对象之间的区别。生成一个类的特征性描述只涉及该类对象中所有对象的共性。生成区别性描述的方法很多，如决策树方法、遗传算法等。
    * 偏差检测  
    &emsp;&emsp;数据库中的数据常有一些异常记录，从数据库中检测这些偏差很有意义。偏差包括很多潜在的知识，如分类中的反常实例、不满足规则的特例、观测结果与模型预测值的偏差、量值随时间的变化等。偏差检测的基本方法是，寻找观测结果与参照值之间有意义的差别。
2. 常用的数据挖掘技术  
&emsp;&emsp;常用的数据挖掘技术包括关联分析、序列分析、分类、预测、聚类分析及时间序列分析等。
    * 关联分析  
    &emsp;&emsp;关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时，另一个事件也经常发生。关联分析的重点在于快速发现那些有实用价值的关联发生的事件。其主要依据是事件发生的概率和条件概率应该符合一定的统计意义。  
    &emsp;&emsp;对于结构化的数据，以客户的购买习惯数据为例，利用关联分析，可以发现客户的关联购买需要。例如，一个开设储蓄账户的客户很可能同时进行债券交易和股票交易，购买纸尿裤的男顾客经常同时购买啤酒等。利用这种知识可以采取积极的营销策略，扩展客户购买的产品范围，吸引更多的客户。通过调整商品的布局便于顾客买到经常同时购买的商品，或者通过降低一种商品的价格来促进另一种商品的销售等。   
    &emsp;&emsp;对于非结构化的数据，以空间数据为例，利用关联分析，可以发现地理位置的关联性。例如，85%的靠近高速公路的大城镇与水相邻，或者发现通常与高尔夫球场相邻的对象等。
    * 序列分析  
    &emsp;&emsp;序列分析技术主要用于发现一定时间间隔内接连发生的事件。这些事件构成一个序列，发现的序列应该具有普遍意义，其依据除了统计上的概率之外，还要加上时间的约束。
    * 分类分析  
    &emsp;&emsp;分类分析通过分析具有类别的样本的特点，得到决定样本属于各种类别的规则或方法。利用这些规则和方法对未知类别的样本分类时应该具有一定的准确度。其主要方法有基于统计学的贝叶斯方法、神经网络方法、决策树方法及支持向量机（support vector machines）等。   
    &emsp;&emsp;利用分类技术，可以根据顾客的消费水平和基本特征对顾客进行分类，找出对商家有较大利益贡献的重要客户的特征，通过对其进行个性化服务，提高他们的忠诚度。   
    &emsp;&emsp;利用分类技术，可以将大量的半结构化的文本数据，如 WEB 页面、电子邮件等进行分类。可以将图片进行分类，例如，根据已有图片的特点和类别，可以判定一幅图片属于何种类型的规则。对于空间数据，也可以进行分类分析，例如，可以根据房屋的地理位置决定房屋的档次。
    * 聚类分析  
    &emsp;&emsp;聚类分析是根据物以类聚的原理，将本身没有类别的样本聚集成不同的组，并且对每一个这样的组进行描述的过程。其主要依据是聚到同一个组中的样本应该彼此相似，而属于不同组的样本应该足够不相似。  
    &emsp;&emsp;仍以客户关系管理为例，利用聚类技术，根据客户的个人特征及消费数据，可以将客户群体进行细分。例如，可以得到这样的一个消费群体：女性占 91%，全部无子女、年龄在 31岁到 40 岁占 70%，高消费级别的占 64%，买过针织品的占 91%，买过厨房用品的占 89%，买过园艺用品的占 79%。针对不同的客户群，可以实施不同的营销和服务方式，从而提高客户的满意度。  
    &emsp;&emsp;对于空间数据，根据地理位置及障碍物的存在情况可以自动进行区域划分。例如，根据分布在不同地理位置的 ATM 机的情况将居民进行区域划分，根据这一信息，可以有效地进行 ATM 机的设置规划，避免浪费，同时也避免失掉每一个商机。  
    &emsp;&emsp;对于文本数据，利用聚类技术可以根据文档的内容自动划分类别，从而便于文本的检索。
    * 预测  
    &emsp;&emsp;预测与分类类似，但预测是根据样本的已知特征估算某个连续类型的变量的取值的过程，而分类则只是用于判别样本所属的离散类别而已。预测常用的技术是回归分析。
    * 时间序列  
    &emsp;&emsp;分析时间序列分析的是随时间而变化的事件序列，目的是预测未来发展趋势，或者寻找相似发展模式或者是发现周期性发展规律。
3. 数据挖掘的流程  
&emsp;&emsp;数据挖掘的流程为确定挖掘对象、准备数据、建立模型、数据挖掘、结果分析和知识应用。
4. 数据挖掘的应用  
&emsp;&emsp;数据挖掘的热点包括空间数据库的挖掘、多媒体数据库的挖掘、时序数据和序列数据的挖掘、文本数据库的挖掘、Web挖掘。
## 2.3 计算机网络基础知识
### 2.3.1 网络概述
&emsp;&emsp;计算机网络是指利用通信设备和线路将地理位置分散的、功能独立的计算机系统或由计算机控制的外部设备连接起来，在网络操作系统的控制下，按照约定的通信协议进行信息交换、实现资源共享的系统。  
&emsp;&emsp;计算机网络的组成元素有`网络节点`和`通信链路`。   
&emsp;&emsp;计算机网络的功能有`数据通信`、`资源共享`、`负载均衡`和`高可靠性`。

&emsp;&emsp;计算机网络按`通信距离`可分为`广域网`、`局域网`和`城域网`。  
&emsp;&emsp;按`信息交换方式`可分为`电路交换网`、`分组交换网`和`综合交换网`。  
&emsp;&emsp;按`网络拓扑结构`可分为`星形网`、`树形网`、`环形网`和`总线网`。  
&emsp;&emsp;按`通信介质`可分为`双绞线网`、`同轴电缆网`、`光纤网`和`卫星网`。  
&emsp;&emsp;按`传输带宽`可分为`基带网`和`宽带网`。  
&emsp;&emsp;按`使用范围`可分为`公用网`和`专用网`。   
&emsp;&emsp;按`速率`可分为`高速网`、`中速网`和`低速网`。  
&emsp;&emsp;按`通信方式`可分为`广播式`和`点到点式`。   
&emsp;&emsp;按`使用方式`可分为`校园网`和`企业网`。  
&emsp;&emsp;按`连接范围`可分为`内联网`和`外联网`。  
&emsp;&emsp;按`网络提供的服务`可分为`通信网`和`信息网`。  

#### 1. 网络互联模型（OSI/RM）
&emsp;&emsp;1977 年，国际标准化组织为适应网络标准化发展的需求，制定了开放系统互联参考模型（Open System Interconnection/Reference Model，OSI/RM），从而形成了网络架构的国际标准。OSI/RM 构造了由下到上的七层模型，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。  
&emsp;&emsp;在数据传输过程中，每一层都承担不同的功能和任务，以实现对数据传输过程中的各个阶段的控制。
1. 物理层   
&emsp;&emsp;物理层的主要功能是透明地完成相邻节点之间原始比特流的传输。其中“透明”的意思是指物理层并不需要关心比特代表的具体含义，而要考虑的是如何发送“0”和“1”，以及接收端如何识别。物理层在传输介质基础上作为系统和通信介质的接口，为数据链路层提供服务。
2. 数据链路层  
&emsp;&emsp;数据链路层负责在两个相邻节点之间的线路上无差错地传送以帧为单位的数据，通过流量控制和差错控制，将原始不可靠的物理层连接变成无差错的数据通道，并解决多用户竞争问题，使之对网络层显现一条可靠的链路。
3. 网络层  
&emsp;&emsp;网络层是通信子网的最高层，其主要任务是在数据链路层服务的基础上，实现整个通信子网内的连接，并通过网络连接交换网络服务数据单元（packet）。它主要解决数据传输单元分组在通信子网中的路由选择、拥塞控制和多个网络互联的问题。网络层建立网络连接为传输层提供服务。
4. 传输层  
&emsp;&emsp;传输层既是负责数据通信的最高层，又是面向网络通信的低三层（物理层、数据链路层和网络层）和面向信息处理的高三层（会话层、表示层和应用层）之间的中间层，是资源子网和通信子网的桥梁，其主要任务是为两台计算机的通信提供可靠的端到端的数据传输服务。传输层反映并扩展了网络层子系统的服务功能，并通过传输层地址为高层提供传输数据的通信端口，使系统之间高层资源的共享不必考虑数据通信方面的问题。
5. 会话层  
&emsp;&emsp;会话层利用传输层提供的端到端数据传输服务，具体实施服务请求者与服务提供者之间的通信、组织和同步它们的会话 活动，并管理它们的数据交换过程。会话层提供服务通常需要经过建立连接、数据传输和释放连接三个阶段。会话层是最薄的一层，常被省略。
6. 表示层  
&emsp;&emsp;表示层处理的是用户信息的表示问题。端用户（应用进程）之间传送的数据包含语义和语法两个方面。语义是数据的内容及其含义，它由应用层负责处理；语法是与数据表示形式有关的方面，例如，数据的格式、编码和压缩等。表示层主要用于处理应用实体面向交换的信息的表示方法，包括用户数据的结构和在传输时的比特流（或字节流）的表示。这样，即使每个应用系统有各自的信息表示法，但被交换的信息类型和数值仍能用一种共同的方法来描述。
7. 应用层  
&emsp;&emsp;应用层是直接面向用户的一层，是计算机网络与最终用户之间的界面。在实际应用中，通常把会话层和表示层归入到应用层，使 OSI/RM 成为一个简化的五层模型。
#### 2．TCP/IP 结构模型
&emsp;&emsp;虽然 OSI/RM 已成为计算机网络架构的标准模型，但因为 OSI/RM 的结构过于复杂，实际系统中采用 OSI/RM 的并不多。目前，使用最广泛的可互操作的网络架构是 TCP/IP（Transmission Control Protocol/ Internet Protocol，传输控制协议/网际协议）结构模型。  
&emsp;&emsp;与OSI/RM 结构不同，不存在一个正式的 TCP/IP 结构模型，但可根据已开发的协议标准和通信任务将其大致分成四个比较独立的层次，分别是网络接口层、网络互联层、传输层和应用层。
1. 网络接口层  
&emsp;&emsp;网络接口层大致对应于 OSI/RM 的数据链路层和物理层，TCP/IP 协议不包含具体的物理层和数据链路层，只定义了网络接口层作为物理层的接口规范。网络接口层处在 TCP/IP 结构模型的最底层，主要负责管理为物理网络准备数据所需的全部服务程序和功能。
2. 网络互联层  
&emsp;&emsp;网络互联层也称为网络层、互联网层或网际层，负责将数据报独立地从信源传送到信宿，主要解决路由选择、阻塞控制和网络互联等问题，在功能上类似于OSI/RM 中的网络层。
3. 传输层  
&emsp;&emsp;传输层负责在信源和信宿之间提供端到端的数据传输服务，相当于 OSI/RM中的传输层。
4. 应用层  
&emsp;&emsp;应用层直接面向用户应用，为用户方便地提供对各种网络资源的访问服务，包含了 OSI/RM 会话层和表示层中的部分功能。
#### 3. 常见的网络协议
1. 应用层协议   
&emsp;&emsp;在应用层中，定义了很多面向应用的协议，应用程序通过本层协议利用网络完成数据交互的任务。这些协议主要有 FTP、TFTP、HTTP、SMTP、DHCP、Telnet、DNS 和 SNMP 等。   
&emsp;&emsp;FTP（File TransportProtocol，文件传输协议）是网络上两台计算机传送文件的协议，运行在 TCP 之上，是通过 Internet 将文件从一台计算机传输到另一台计算机的一种途径。FTP 的传输模式包括 Bin（二进制）和 ASCII（文本文件）两种，除了文本文件之外，都应该使用二进制模式传输。FTP 在客户机和服务器之间需建立两条 TCP 连接，一条用于传送控制信息（使用 21 号端口），另一条用于传送文件内容（使用 20 号端口）。  
&emsp;&emsp;TFTP（Trivial FileTransfer Protocol，简单文件传输协议）是用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。TFTP 建立在 UDP（UserDatagram Protocol，用户数据报协议）之上，提供不可靠的数据流传输服务，不提供存取授权与认证机制，使用超时重传方式来保证数据的到达。  
&emsp;&emsp;HTTP（Hypertext TransferProtocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。HTTP 建立在 TCP之上，它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。  
&emsp;&emsp;SMTP（Simple Mail TransferProtocol，简单邮件传输协议）建立在 TCP 之上，是一种提供可靠且有效的电子邮件传输的协议。SMTP 是建模在 FTP 文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息，并提供与电子邮件有关的通知。  
&emsp;&emsp;DHCP（Dynamic HostConfiguration Protocol，动态主机配置协议）建立在 UDP 之上，是基于客户机/服务器模型设计的。所有的 IP 网络设定数据都由 DHCP 服务器集中管理，并负责处理客户端的 DHCP 要求；而客户端则会使用从服务器分配下来的 IP 环境数据。DHCP 通过租约（默认为 8 天）的概念，有效且动态地分配客户端的 TCP/IP 设定。当租约过半时，客户机需要向 DHCP 服务器申请续租；当租约超过 87.5%时，如果仍然没有和当初提供 IP 的 DHCP 服务器联系上，则开始联系其他的 DHCP 服务器。DHCP 分配的 IP 地址可以分为三种方式，分别是固定分配、动态分配和自动分配。  
&emsp;&emsp;Telnet（远程登录协议）是登录和仿真程序，建立在 TCP 之上，它的基本功能是允许用户登录进入远程计算机系统。以前，Telnet 是一个将所有用户输入送到远程计算机进行处理的简单的终端程序。目前，它的一些较新的版本是在本地执行更多的处理，可以提供更好的响应，并且减少了通过链路发送到远程计算机的信息数量。  
&emsp;&emsp;DNS（Domain NameSystem，域名系统）在 Internet 上域名与 IP 地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相识别 IP 地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器。DNS 通过对用户友好的名称查找计算机和服务。当用户在应用程序中输入 DNS 名称时，DNS 服务可以将此名称解析为与之相关的其他信息，例如，IP 地址。  
&emsp;&emsp;SNMP（Simple NetworkManagement Protocol，简单网络管理协议）是为了解决 Internet上的路由器管理问题而提出的，它可以在 IP、IPX、AppleTalk 和其他传输协议上使用。SNMP是指一系列网络管理规范的集合，包括协议本身、数据结构的定义和一些相关概念。目前，SNMP 已成为网络管理领域中事实上的工业标准，并被广泛支持和应用，大多数网络管理系统和平台都是基于 SNMP 的。
2. 传输层协议  
&emsp;&emsp;传输层主要有两个传输协议，分别是 TCP 和 UDP（User Datagram Protocol，用户数据报协议），这些协议负责提供流量控制、错误校验和排序服务。  
&emsp;&emsp;TCP 是整个 TCP/IP 协议族中最重要的协议之一，它在 IP 协议提供的不可靠数据服务的基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。TCP 协议一般用于传输数据量比较少，且对可靠性要求高的场合。  
&emsp;&emsp;UDP 是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信，与 TCP 相比，UDP 是一种无连接的协议，它的错误检测功能要弱得多。可以这样说，TCP 有助于提供可靠性，而 UDP 则有助于提高传输速率。UDP 协议一般用于传输数据量大，对可靠性要求不是很高，但要求速度快的场合。
3. 网络层协议  
&emsp;&emsp;网络层中的协议主要有 IP、ICMP（Internet Control Message Protocol，网际控制报文协议）、IGMP（Internet Group Management Protocol，网际组管理协议）、ARP（Address ResolutionProtocol，地址解析协议）和 RARP（Reverse Address Resolution Protocol，反向地址解析协议）等，这些协议处理信息的路由和主机地址解析。  
&emsp;&emsp;IP 所提供的服务通常被认为是无连接的和不可靠的，它将差错检测和流量控制之类的服务授权给了其他的各层协议，这正是 TCP/IP 能够高效率工作的一个重要保证。网络层的功能主要由 IP 来提供，除了提供端到端的分组分发功能外，IP 还提供很多扩充功能。例如，为了克服数据链路层对帧大小的限制，网络层提供了数据分块和重组功能，这使得很大的 IP数据包能以较小的分组在网络上传输。   
&emsp;&emsp;ARP 用于动态地完成 IP 地址向物理地址的转换。物理地址通常是指计算机的网卡地址，也称为 MAC（Media Access Control，媒体访问控制）地址，每块网卡都有唯一的地址；RARP用于动态完成物理地址向 IP 地址的转换。  
&emsp;&emsp;ICMP 是一个专门用于发送差错报文的协议，由于 IP 协议是一种尽力传送的通信协议，即传送的数据可能丢失、重复、延迟或乱序传递，所以需要一种尽量避免差错并能在发生差错时报告的机制，这就是 ICMP 的功能。  
&emsp;&emsp;IGMP 允许 Internet 中的计算机参加多播，是计算机用作向相邻多目路由器报告多目组成员的协议。多目路由器是支持组播的路由器，它向本地网络发送 IGMP 查询，计算机通过发送 IGMP 报告来应答查询。多目路由器负责将组播包转发到网络中所有组播成员。
### 2.3.2 局域网与广域网
#### 1. 局域网
&emsp;&emsp;局域网（Local Area Network，LAN）是指传输距离有限，传输速度较高，以共享网络资源为目的的网络系统。  
&emsp;&emsp;局域网通常具备以下特点：
1. 分布范围有限
2. 数据传输速率高
3. 误码率低
4. 协议相对简单、结构灵活，建网成本低、周期短，便于管理和扩充    
&emsp;&emsp;构成局域网的网络拓扑结构主要有星形结构、总线结构、环形结构和网状结构。
#### 2. 广域网
&emsp;&emsp;广域网是指覆盖范围广、传输速率相对较低，以数据通信为主要目的的数据通信网。
### 2.3.3 网络管理与网络安全
#### 1. 网络管理
&emsp;&emsp;网络管理是对计算机网络的配置、运行状态和计费等进行的管理。   
&emsp;&emsp;OSI网络管理标准中定义了网络管理的五大功能：`配置管理`、`性能管理`、`故障管理`、`安全管理`和`计费管理`。
#### 2. 计算机网络安全
&emsp;&emsp;计算机网络安全是指计算机、网络系统的硬件、软件及系统中的数据受到保护，不因偶然或恶意的原因而遭到破坏、更改、泄露，确保系统能够连续和可靠的运行。  
&emsp;&emsp;信息安全的基本要素是`保密性`、`完整性`、`可用性`、`真实性`和`可控性`。  
&emsp;&emsp;完整的信息安全保障体系应该包括`保护`、`检测`、`响应`和`恢复`4个方面。
### 2.3.4 网络工程
&emsp;&emsp;网络工程是根据用户单位的需求和具体情况，结合当前网络技术的发展和产品化程度，经过充分的需求分析和市场调研，确定网络建设方案，依据方案有计划、分步骤地实施。  
&emsp;&emsp;网络工程可分为网络规划和网络设计阶段、工程组织和实施阶段以及系统运行维护阶段。
### 2.3.5 存储及负载均衡技术
#### 1. RAID技术
&emsp;&emsp;RAID是一种由多块廉价磁盘构成的冗余阵列。使用磁盘阵列的目的是建立数据冗余、增强容错、提高容量、增进性能。
#### 2. 网络存储技术
&emsp;&emsp;网络存储采用面向网络的存储体系结构，是数据处理和数据存储分离，由专门的系统负责数据处理，存储设备或子系统负责数据的存储。  
&emsp;&emsp;网络存储体系结构大致分为三种：直连式存储（DAS）、网络连接存储（NAS）和存储区域存储（SAN）。
#### 3. 负载均衡技术
&emsp;&emsp;负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求均匀地分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。  
&emsp;&emsp;负载均衡从结构上分为本地负载均衡（Local Server Load Balance）和全域负载均衡（Global Server Load Balance），前者是指对本地的服务器群做负载均衡，后者是指对分别放置在不同的地理位置、有不同的网络及服务器群之间做负载均衡。  
&emsp;&emsp;负载均衡的实现方法有两种：
1. 把大量并发访问或数据流量分配到多个设备上处理，以减少用户等待响应的时间。
2. 将���个重负载的运算分摊到多个设备上做并行处理，再将每个设备的运行结果汇总后返回给用户。

&emsp;&emsp;目前，比较常用的负载均衡技术主要有以下几种：
1. 基于特定服务器软件的负载均衡   
&emsp;&emsp;很多网络协议都支持“重定向”功能，例如，在 HTTP 协议中支持 Location 指令，接收到这个指令的浏览器将自动重定向到 Location 指明的另一个 URL 上。由于发送 Location 指令比起执行服务请求，对 Web 服务器的负载要小得多，因此可以根据这个功能来设计一种负载均衡的服务器。当 Web 服务器认为自己负载较大的时候，它就不再直接发送回浏览器请求的网页，而是送回一个 Location 指令，让浏览器在服务器集群中的其他服务器上获得所需要的网页。
2. 基于 DNS（Domain Name Server，域名服务器）的负载均衡  
&emsp;&emsp;通过 DNS 服务中的随机名字解析来实现负载均衡，在 DNS 服务器中，可以为多个不同的地址配置同一个名字，而最终查询这个名字的客户机将在解析这个名字时得到其中一个地址。因此，对于同一个名字，不同的客户机会得到不同的地址，它们也就访问不同地址上的 Web 服务器，从而达到负载均衡的目的。  
&emsp;&emsp;DNS 负载均衡的优点是简单易行，并且服务器可以位于互联网的任意位置上。然而它也存在不少缺点，一个缺点是为了保证 DNS 数据及时更新，一般都要将 DNS 的刷新时间设置得较小，但太小就会造成太大的额外网络流量，并且更改了 DNS 数据之后也不能立即生效；另一个缺点是 DNS 负载均衡无法得知服务器之间的差异，它不能做到为性能较好的服务器多分配请求，也不能了解到服务器的当前状态，甚至会出现客户请求集中在某一台服务器上的偶然情况。
3. 反向代理负载均衡  
&emsp;&emsp;使用代理服务器可以将请求转发给内部的 Web 服务器，使用这种加速模式显然可以提升静态网页的访问速度。因此也可以考虑使用这种技术，让代理服务器将请求均匀地转发给多台内部 Web 服务器，从而达到负载均衡的目的。这种代理方式与普通的代理方式有所不同，标准代理方式是客户使用代理访问多个外部 Web 服务器，而这种代理方式是多个客户使用它访问内部 Web 服务器，因此也被称为反向代理模式。  
&emsp;&emsp;使用反向代理的好处是，可以将负载均衡和代理服务器的高速缓存技术结合在一起，以提供有益的性能；其具备额外的安全性，外部客户不能直接访问真实的服务器。并且实现起来可以采用较好的负载均衡策略，将负载非常均衡地分给内部服务器，不会出现负载集中到某个服务器的偶然现象。
4. 基于 NAT（Network Address Translation，网络地址转换）的负载均衡技术  
&emsp;&emsp;网络地址转换指的是在内部地址和外部地址之间进行转换，以便具备内部地址的计算机能访问外部网络，而当外部网络中的计算机访问地址转换网关拥有的某一外部地址时，地址转换网关能将其转发到一个映射的内部地址上。因此如果地址转换网关能将每个连接均匀转换为不同的内部服务器地址，此后，外部网络中的计算机就各自与自己转换得到的地址上的服务器进行通信，从而达到负载分担的目的。  
&emsp;&emsp;地址转换可以通过软件方式来实现，也可以通过硬件方式来实现。使用硬件方式进行操作一般称为交换，而当交换必须保存 TCP 连接信息的时候，这种针对 OSI/RM 网络层的操作就被称为第四层交换。
5. 扩展的负载均衡技术  
&emsp;&emsp;更好的方式是使用一种半中心的负载均衡方式。在这种半中心的负载均衡方式下，即当客户请求发送给负载均衡器的时候，中心负载均衡器将请求打包并发送给某个服务器，而服务器的回应请求不再返回给中心负载均衡器，而是直接返回给客户，因此中心负载均衡器只负责接受并转发请求，其网络负担就较小了。
#### 4. 服务器集群技术
&emsp;&emsp;集群是一组互相独立的服务器在网络中表现为单一的系统，并以单一系统的模式加以管理。
## 2.5 系统性能
&emsp;&emsp;系统性能是一个系统提供给用户的众多性能指标的混合体。它既包括硬件性能，也包括软件性能；既包括部件性能指标，也包括综合性能指标。  
&emsp;&emsp;系统性能包括以下4个方面的内容：
1. 性能指标   
&emsp;&emsp;描述当前流行系统主要涉及的性能指标；
2. 性能计算    
&emsp;&emsp;描述当前使用到的主要性能指标的计算方法；
3. 性能设计    
&emsp;&emsp;描述如何对现有系统进行性能上的调整优化；
4. 性能评估    
&emsp;&emsp;描述如何对当前取得的性能指标进行评价和改进。
### 2.5.1 性能指标
### 2.5.2 性能计算
&emsp;&emsp;性能指标计算的主要方法有定义法、公式法、程序检测法和仪器检测法。  
#### 1. MIPS的计算方法

$$ MIPS = \frac{\text{指令条数}}{\text{执行时间} \times 10^6}=\frac{Fz}{CPI} = IPC \times Fz $$

&emsp;&emsp;公式中，Fz 为处理机的工作主频，CPI（Cycles Per Instruction）为每条指令所需的平均时钟周期数，IPC 为每个时钟周期平均执行的指令条数。  gg
&emsp;&emsp;例如，如果要计算 Pentium IV/2.4E 处理机的运算速度，因为 Pentium IV/2.4E 处理机的IPC=2（或 CPI=0.5），Fz=2400MHz，所以 MIPSP4/2.4E = IPC′Fz=2′2400 = 4800MIPS。
#### 2．峰值计算
&emsp;&emsp;衡量计算机性能的一个重要指标就是计算峰值或者浮点计算峰值，它是指计算机每秒钟能完成的浮点计算最大次数。包括理论浮点峰值和实测浮点峰值。    
&emsp;&emsp;理论浮点峰值是该计算机理论上能达到的每秒钟能完成浮点计算最大次数，它主要是由CPU 的主频决定。  
&emsp;&emsp;理论浮点峰值 = CPU 主频′CPU 每个时钟周期执行浮点运算的次数′系统中 CPU 数    
&emsp;&emsp;希赛教育专家提示：CPU 每个时钟周期执行浮点运算的次数是由处理器中浮点运算单元的个数及每个浮点运算单元在每个时钟周期能处理几条浮点运算来决定的。
#### 3．等效指令速度
&emsp;&emsp;静态指令使用频度指的是在程序中直接统计的计算机速度。动态指令使用频度指的是在程序执行过程中统计的指令速度。在计算机发展的早期，用加法指令的运算速度来衡量计算机的速度。后来发展成为等效指令速度法或吉普森（Gibson）法，在这种方法中，通常加、减法指令占 50%，乘法指令占 15%，除法指令占 5%，程序控制指令占 15%，其他指令占15%。  
### 2.5.3 性能设计
#### 1. 阿姆达尔解决方案
&emsp;&emsp;阿姆达尔定律是这样的：系统中对某部件采用某种更快的执行方式，所获得的系统性能的改变程度，取决于这种方式被使用的频率，或所占总执行时间的比例。  
&emsp;&emsp;阿姆达尔定律定义了采用特定部件所取得的加速比。假定使用某种增强部件，计算机的性能就会得到提高，那么加速比就是如下公式所定义的比率：

$$\text{加速比}=\frac{\text{不使用增强部件时完成整个任务的时间}}{\text{使用增强部件时完成整个任务的时间}}$$

&emsp;&emsp;加速比反映了使用增强部件后完成一个任务比不使用增强部件完成同一任务加快了多少。阿姆达尔定律为计算某些情况下的加速比提供了一种便捷的方法。加速比主要取决于两个因素：
1. 在原有的计算机上，能被改进并增强的部分在总执行时间中所占的比例。这个值称之为增强比例，它永远小于等于 1。
2. 通过增强的执行方式所取得的改进，即如果整个程序使用了增强的执行方式，那么这个任务的执行速度会有多少提高，这个值是在原来条件下程序的执行时间与使用增强功能后程序的执行时间之比。

&emsp;&emsp;原来的机器使用了增强功能后，执行时间等于未改进部分的执行时间加上改进部分的执行时间：

$$\text{新的执行时间}=\text{原来的执行时间} \times [(-增强比例) \frac{\text{增强比例}}{\text{增强加速比}}]$$

总的加速比等于两种执行时间的比：

$$\text{总加速比}=\frac{\text{原来的执行时间}}{\text{新的执行时间}}=\frac{1}{[(1-\text{增强比例})+\frac{\text{增强比例}}{\text{增强加速比}}]}$$
# 第三章 信息系统基础知识
## 3.1 信息化概述
### 3.1.1 信息的定义
&emsp;&emsp;信息是对客观事物变化和特征的反应，是客观事物之间相互作用和联系的表征，是客观事物经过感知或认识后的再现。
### 3.1.2 信息的特征
#### 1. 客观性
&emsp;&emsp;信息反映了客观事物的运动状态和方式。  
&emsp;&emsp;客观性也即事实性，不符合事实的信息不仅没有价值，而且可能有副作用。
#### 2. 普遍性
&emsp;&emsp;物质的普遍性决定了信息的普遍存在，因而信息无处不在。
#### 3. 无限性
&emsp;&emsp;由于一切事物运动的状态和方式都是信息，而事物及其变化是无限多样的，因而信息是无限的。
#### 4. 动态性
&emsp;&emsp;信息是随着时间的变化而变化的。
#### 5. 依附性
&emsp;&emsp;信息是客观世界的反应，因而要依附于一定的载体而存在，需要有物质的承担者。信息不能完全脱离物质而独立存在。
#### 6. 变换性
&emsp;&emsp;信息是可变换的，它可以用不同的载体以不同的方法来负载。
#### 7. 传递性
&emsp;&emsp;信息可以在时间上或空间上从一点传递到另一点。信息在时间上的传递即是存储，在空间上的传递即是转移或扩散。
#### 8. 层次性
&emsp;&emsp;客观世界是分层次的，反应他的信息也是分层次的。信息可分为战略级、管理及和操作级。
#### 9. 系统性
&emsp;&emsp;信息可以标识位一种集合，不同类别的信息可以形成不同的整体。因而可以形成与现实世界对应的信息系统。
### 3.1.3 信息化的定义
&emsp;&emsp;信息化是在国家宏观信息政策的指导下，通过信息技术开发、信息产业的发展、信息人才的配置，最大限度的利用信息资源以满足全社会的信息需求，从而加速社会各个领域的共同发展以推进信息社会的过程。
### 3.1.4 信息化的内容
&emsp;&emsp;信息化主要围绕6个要素展开。
#### 1. 信息资源的开发利用
&emsp;&emsp;信息资源是信息化的源泉，信息资源的开发利用要解决三个问题：
1. 原始信息的采集
2. 使存在的信息在给定的时间内获得
3. 使用户获得真正需要的信息
#### 2. 信息网络的全面覆盖
&emsp;&emsp;信息网络是信息资源开发、利用的基础设施，是信息传输、交换和共享的必要手段。  
&emsp;&emsp;信息网络在国家信息化的过程中将逐步实现三网融合，最终做到三网合一。
#### 3. 信息技术的广泛应用
#### 4. 信息产业的大力发展
#### 5. 信息化人才的培养
#### 6. 信息化政策法规和标准规范建设
### 3.1.5 信息化的经济社会意义
1. 信息化促进全球化的发展
2. 信息化促进了竞技的增长
3. 信息化引发社会生活全面变革
4. 信息化对国际关系产生深远影响
### 3.1.6 信息化对组织的意义
1. 信息化引发组织的结构创新
2. 信息化推动组织的管理创新
3. 信息化促进组织的经营创新
4. 造就信息化的人才队伍
### 3.1.7 信息化的需求
#### 1. 组织信息化需求的层次性
&emsp;&emsp;一般来说信息化需求包含三个层次：战略需求，运作需求和技术需求。
#### 2. 组织信息化需求的系统性
&emsp;&emsp;各层次信息化需求之间的逻辑关系包括因果关系、依赖关系、主辅关系和协同关系等。  
&emsp;&emsp;一个组织的信息化应该遵循“总体规划、分步实施”的原则。
## 3.2 信息系统工程的总体规划
&emsp;&emsp;系统规划指根据组织的战略目标和用户提出的需求，从用户的现状出发，经过调查，对所要开发管理信息系统的技术方案、实施过程、阶段划分、开发组织和开发队伍、投资规模、资金来源及工作进度，用系统的、科学的、发展的观点进行全面规划。
### 3.2.2 信息系统工程总体规划的方法论
&emsp;&emsp;制定信息系统工程总体规划需要有效的方法论支持，其方法多种多样，用的最多的主要有三种：业务系统规划法、关键成功因素法、战略目标集合转化法。
#### 1. 业务系统规划法
&emsp;&emsp;业务系统规划（ Business Systems Planning BSP）方法既是信息系统的重要规划方法同时，也是信息系统工程总体战略规划的重要方法。  
&emsp;&emsp;实行 BSP 的前提是，在企业内有改善信息系统的要求，并且有为建设这一系统而建立总的战略的需要。因而 BSP 的基本功能是服务于信息系统建设的长期目标。  
&emsp;&emsp;信息系统必须支持企业的战略目标。可以将 BSP 看成一个转化过程，即将企业的战略转化成信息系统的战略，因此，了解企业的战略就成了 BSP 重要内容之一。  
&emsp;&emsp;BSP 的目标主要是提供信息系统规划，用以支持企业短期的和长期的信息需要。其具体目标的目标主要是提供信息系统规划，用以支持企业短期的和长期的信息需要。
#### 2. 关键成功因素法
&emsp;&emsp;在现行系统中总是存在着多个变量影响目标系统的实现，其中若干因素时关键的和主要的。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。  
&emsp;&emsp;关键成功因素法能够抓住主要矛盾，使目标的识别重点突出，为管理者提供一个结构化的方法，帮助企业确定其关键成功因素和信息需求。
#### 3. 战略目标集转化法
&emsp;&emsp;把战略目标看做是一个“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程即是把组织的战略目标转变为管理信息系统的战略目标的过程。  
## 3.3 信息化的典型应用
### 3.3.1 政府信息化与电子政务
#### 1. 电子政务的概念
&emsp;&emsp;利用信息技术和其他相关技术，将其管理和服务职能进行继承，在网络上实现政府组织结构和工作流程优化重组，超越时间、空间与部门分隔的之约，实现公务、政务、商务、事务的一体化管理与运行。
#### 3. 电子政务的技术形式
&emsp;&emsp;当前电子政务在世界范围内发展主要有两个特征：
1. 以互联网为基础设施，构建和发展电子政务。
2. 更强调政府服务功能的发挥和完善，包括政府对企业、对居民的服务以及政府各部门之间的相互服务。
#### 4. 电子政务的应用领域
&emsp;&emsp;集中在以下6个方面：
1. 面向社会的应用。
2. 政府部门之间的应用。
3. 政府部门内部的各类应用系统。
4. 设计政府部门内部的各类核心数据的应用系统。
5. 政府电子化采购。
6. 电子社区。
### 3.3.2 企业信息化与电子商务
#### 1. 企业信息化的概念
&emsp;&emsp;企业信息化就是企业利用现代信息技术，通过信息资源的深入开发和广泛利用，实现企业生产过程的自动化、管理方式的网格化、决策支持的智能化和商务运营的电子化，不断提高生产、经营、管理、决策的效率和水平，进而提高企业经济效益和企业竞争力的过程。
#### 2. 企业信息化的目的
&emsp;&emsp;根本目的在于提高企业竞争能力，使得企业具有平稳和有效运作的能力，对紧急情况和机会做出快速反应，为企业内外部用户提供有价值的信息。
#### 3. 企业信息化的规划
&emsp;&emsp;主要从以下三个层面来实现：
1. 企业战略层面。
2. 业务运作层面。
3. 管理运作层面。
#### 4. 企业信息化方法
&emsp;&emsp;主要有以下几种方法：
1. 业务流程重构方法  
&emsp;&emsp;重新审视企业的生产经营过程，利用信息技术和网络技术，对企业的组织结构和工作方法进行“彻底的、根本性的”重新设计。
2. 核心业务应用方法
3. 信息系统建设方法
4. 主题数据库方法   
&emsp;&emsp;面向企业的核心业务的数据库开展信息化。
5. 资源管理方法
6. 人力资本投资方法
### 3.3.3 企业资源规划的机构和功能
#### 1. ERP的概念
&emsp;&emsp;企业的所有资源包括三大流：物流、资金流和信息流。ERP是对这三种资源进行全面集成管理的管理信息系统。
#### 2. ERP的主要功能
&emsp;&emsp;ERP 为企业提供的功能是多层面的和全方位的。
1. 支持决策的功能。
2. 为处于不同行业的企业提供有针对性的 IT 解决方案。
3. 从企业内部的供应链发展为全行业和跨行业的供应链。
### 3.3.4 客户关系管理在企业中的应用
#### 1. CRM的概念
&emsp;&emsp;CRM主要包含以下4个内容：
1. 提供的信息要有利于更好的理解客户。
2. 流程管理要为客户提供高效、适当的体验。
3. 允许员工使用以上知识的软件。
4. 培训并改变管理要素，使员工和企业了解并且有能力提供那些构建强有力关系、提高客户忠诚度的体验。

&emsp;&emsp;CRM的目的是提高收入，核心思想是以客户为中心。
#### 2. CRM的背景
&emsp;&emsp;CRM的产生主要是以下几个因素的推动和促成的结果：
1. 管理理念的更新
2. 市场需求的拉动
3. 信息技术的推动
#### 3. CRM的内容
&emsp;&emsp;CRM系统主要由以下几个模块构成：
1. 销售自动化
2. 营销自动化
3. 客户服务与支持
4. 商业智能
#### 4. CRM的解决方案和实施过程
&emsp;&emsp;一般说来 CRM 由两部分构成，即触发中心和挖掘中心，前者指客户和 CRM 通过电话、传真、Web、E-mail 等多种方式“触发”进行沟通；挖掘中心则是指对 CRM 记录交流沟通的信息进行智能分析。由此可见，一个有效的 CRM 解决方案应该具备以下要素：
1. 畅通有效的客户交流渠道（触发中心）  
&emsp;&emsp;在通信手段极为丰富的今天，能否支持电话、Web、传真、E-mail 等各种触发手段进行交流，无疑是十分关键的。
2. 对所获信息进行有效分析（挖掘中心）
3. CRM 必须能与 ERP 很好地集成  
&emsp;&emsp;作为企业管理的前台，CRM 的市场营销和客户服务的信息必须能及时传达到后台的财务、生产等部门，这是企业能否有效运营的关键。

&emsp;&emsp;CRM 的实现过程具体说来，包含三方面的工作。一是客户服务与支持，即通过控制服务品质以赢得顾客的忠诚度，例如，对客户快速准确的技术支持、对客户投诉的快速反应、对客户提供产品查询等；二是客户群维系，即通过与顾客的交流实现新的销售，例如，通过交流赢得失去的客户等；三是商机管理，即利用数据库开展销售，例如，利用现有客户数据库做新产品推广测试，通过电话促销调查，确定目标客户群等。
#### 5. CRM的价值
1. 提高内部员工的工作效率，节省日常开支。
2. 提高客户满意度。
3. 提高客户忠诚度。
### 3.3.5 企业门户
&emsp;&emsp;一般认为惬意门户就是一个信息技术平台，这个平台可以提供个性化信息服务，它链接企业内部和外部，为企业提供一个单一的访问企业各种信息资源和应用程序的入口，企业的员工、客户、合作伙伴和供应商都可以通过这个门户获得个性化的信息和服务。
#### 1. 企业门户的功能
1. 个性化   
&emsp;&emsp;应具有定做用户工作区的内容和外观的能力，门户的个性化功能包括演示个性化、个性化的信息过滤、个性化的用户配置。
2. 演示功能
3. 知识及内容的创建与管理
4. 搜寻和检索
5. 元数据管理/分类
6. 查询/报告和分析
7. 数据管理和应用集成
8. 文档管理
9. 协同和信息共享/知识汲取和索引
10. 虚拟社区
11. 流程支持
12. 商业功能/垂直市场应用程序
13. 集中式目录支持和门户管理
14. 安全功能
#### 2. 企业门户的分类
1. 企业信息门户（EIP）
2. 企业知识门户（EKP）
3. 企业应用门户（EAP）
4. 垂直门户（vortal）
#### 3. 企业门户的要素

# 第四章 系统开发基础知识
## 4.1 软件开发方法
### 4.1.1 软件开发生命周期
&emsp;&emsp;软件生命周期可以划分为`软件定义`、`软件开发`、`软件运行与维护`三个阶段。
#### 1. 软件定义时期
&emsp;&emsp;软件定义包括`可行性研究`和`详细需求分析`过程。
* 问题定义  
&emsp;&emsp;按照软件系统工程需求来确定问题空间的性质。
* 可行性研究  
&emsp;&emsp;主要包括`技术可行性`、`经济可行性`、`操作可行性`和`社会可行性`。
* 需求分析   
&emsp;&emsp;确定系统的`功能需求`、`性能需求`和`运行环境的约束`。写出`软件需求规格说明书`、`软件系统测试大纲`和`用户手册概要`。
#### 2. 软件开发时期
&emsp;&emsp;主要分为`概要设计`、`详细设计`、`编码和测试`。
* 概要设计    
&emsp;&emsp;在软件需求规格说明书的基础上，建立系统的总体结构和模块之间的关系，定义功能模块及各模块之间的关系。
* 详细设计  
&emsp;&emsp;包括算法与数据结构、数据分布、数据组织、模块间接口信息和用户界面设计，并写出`详细设计报告`。
* 编码与测试  
&emsp;&emsp;测试可分为单元测试、集成测试、确认测试和系统测试。
#### 3. 软件运行和维护
&emsp;&emsp;软件维护是指对软件产品进行修改或对软件需求变化做出响应。

### 4.1.2 软件开发模型
&emsp;&emsp;软件开发模型是从某一个特定角度提出的软件过程的简化描述。  
&emsp;&emsp;软件过程是制作软件产品的一组活动以及结果，主要包括：
* 软件描述  
&emsp;&emsp;定义软件功能以及试用的限制。
* 软件开发  
&emsp;&emsp;软件的设计与实现
* 软件有效性检验
* 软件进化  
&emsp;&emsp;软件随着客户需求的变化不断改进
#### 1. 瀑布模型
&emsp;&emsp;顾名思义，瀑布模型就如同瀑布一样，从一个特定的阶段流向下一个阶段，如下图所示。

![瀑布模型](https://pic.lufer.cc/images/2021/03/15/rjKS91.png)

&emsp;&emsp;瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。

&emsp;&emsp;瀑布模型的主要缺点如下：
1. 软件需求分析的准确性很难确定
2. 用户和软件项目负责人需要相当长的时间才能得到初始版本，这时如果改变需求将会带来巨大损失。

#### 2. 原型模型
&emsp;&emsp;原型模型又称快速模型，如下图所示，主要有`原型开发`和`目标软件开发`两个阶段。

![原型模型](https://pic.lufer.cc/images/2021/03/22/image.png)

&emsp;&emsp;在原型开发阶段，开发人员根据用户提出的软件定义快速开发一个原型，该原型应包含目标系统的关键问题和反应目标系统的大致面貌，展示目标系统全部或部分的功能、性能等。

&emsp;&emsp;开发原型可以考虑以下三个途径：
* 利用模拟软件系统的人机界面和人机交互方式
* 真正开发一个原型
* 用其他类似软件进行比较

&emsp;&emsp;在征求用户对原型的意见后对原型进行修改完善，确认软件系统的需求并达到一致的理解，进一步开发实际系统。

&emsp;&emsp;使用原型模型需要注意：
1. 用户对系统模糊不清，无法准确回答目标系统的需求
2. 要有一定的开发环境和工具支持
3. 经过对原型的若干次修改，应收敛到目标范围内，否则可能会失败。
4. 对大型软件来说，原型可能非常复杂难以快速性能。

&emsp;&emsp;在实际工作中，由于各种原因，大多数原型都废弃不用，仅仅把建立原型的过程作为帮助定义软件需求的一种手段。

#### 3. 螺旋模型
&emsp;&emsp;螺旋模型把软件开发流程分为了多个阶段，每个阶段都包括目标设定、风险分析、开发和有效性验证、评审 4 个阶段，由这 4 个阶段进行迭代，软件开发过程每迭代一次，软件开发就前进一个层次。采用螺旋模型的软件过程如下图所示。

![螺旋模型](https://pic.lufer.cc/images/2021/03/22/imagea47f8281caf5a208.png)

#### 4. 基于可重用构建的模型
&emsp;&emsp;随着软构件技术的发展，人们开始尝试利用软构件进行搭积木式的开发，即构件组装模型。在构建组装模型中，当经过需求分析定义出软件功能后，将对构件的组装结构进行设计，将系统划分成一组构件的集合，明确构件之间的关系。在确定了系统构件后，则将独立完成每一个构件，这时既可以开发软件构件，也可以重用已有的构件，当然也可以购买或选用第三方的构件。构件是独立的、自包容的，因此架构的开发也是独立的，构件之间通过接口相互协作。构件组装模型的一般开发过程如下图所示。

![构件组装模型](https://pic.lufer.cc/images/2021/03/15/rj0pon.png)

&emsp;&emsp;构件组装模型的优点如下：
1. 构件的自包容性让系统的扩展变得更加容易
2. 设计良好的构件更容易被重用，降低软件开发成本
3. 构件的粒度较整个系统更小，因此安排开发任务更加灵活，可以将开发团队分成若干组，并行地独立开发构件。

&emsp;&emsp;然而鱼与熊掌不可兼得，构件组装模型也有明显的缺点：
1. 对构件的设计需要经验丰富的架构设计师，设计不良的构件难以实现构件的优点，降低构件组装模型的重用度。
2. 在考虑软件的重用度时，往往会对其他方面做出让步，如性能等。
3. 使用构件组装应用程序时，要求程序员熟练地掌握构件，增加了研发人员的学习成本。
4. 第三方构件库的质量会最终影响到软件的质量，而第三方构件库的质量往往是开发团队难以控制的。

### 4.1.3 敏捷方法
#### 1. 敏捷方法的特点与核心思想
1. 适应性而非预设性    
&emsp;&emsp;敏捷方法拥抱变化，利用变化来发展，甚至改变自己，最后完善自己。
2. 面向人而非面向过程  
&emsp;&emsp;充分发挥人的特性，软件开发在无过程控制和过于严格繁琐的过程控制之间取得平衡。
3. 迭代增量式的开发过程  
&emsp;&emsp;以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。每一个发行版都是在前一成功发行版的基础上进行功能需求扩充，最后满足用户所有功能需求。
#### 2. 敏捷方法的主要内容
&emsp;&emsp;敏捷方法主要包括4个核心价值观和12条过程实践规则。

&emsp;&emsp;4个核心价值观分别是：
1. 沟通  
&emsp;&emsp;设计者、开发者和客户三者之间的有效交流是开发成功的关键。
2. 简单  
&emsp;&emsp;只满足当前功能需求，不做假想设计，尽量使代码简单化。
3. 反馈  
&emsp;&emsp;设计者、开发者和客户之间及时和详尽的意见反馈是开发成功的保证。
4. 勇气  
&emsp;&emsp;在必须做出取舍或重构时，勇于抉择，勇于实践。

&emsp;&emsp;12 条过程实践规则分别是：`简单设计`、`测试驱动`、`代码重构`、`结对编程`、`持续集成`、`现场客户`、`发行版本小型化`、`系统隐喻`、`代码集体所有制`、`规则策略`、`规范代码`、`40小时工作制`。
#### 3. XP
&emsp;&emsp;XP 是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。与其他方法论相比，其最大的不同在于：
* 在更短的周期内，更早地提供具体、持续的反馈信息。
* 迭代地进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断地发展它。
* 依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。
* 依赖于口头交流、测试和源程序进行沟通。
* 倡导持续的、演化式的设计。
* 依赖于开发团队内部的紧密协作。
* 尽可能达到程序员短期利益和项目长期利益的平衡。

  
&emsp;&emsp;XP由`价值观`、`原则`、`实践`和`行为`四个部分组成，它们彼此相互依赖、关联，并通过行为贯穿于整个生命周期。

#### 4. 水晶系列方法
&emsp;&emsp;水晶方法（Crystal），是由 Alistair Cockburn 和 Jim Highsmith 建立的敏捷方法系列，其目的是发展一种提倡“机动性的”方法，包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。  
&emsp;&emsp;Crystal 家族实际上是一组经过证明、对不同类型项目非常有效的敏捷过程，它的发明使得敏捷团队可以根据其项目和环境选择最合适的 Crystal 家族成员（分为 Crystal Clear，Crystal Yellow，Crystal Orange 和 Crystal Red 分别适用于不同的项目）。水晶方法中，使用频度较高的是 Crystal Clear——透明水晶方法。透明水晶方法，适合于一个小团队来进行敏捷开发，人数在 6 人以下为宜。

&emsp;&emsp;透明水晶方法有七大体系特征：
1. 经常交付  
&emsp;&emsp;任何项目，无论大小、敏捷程度，其最重要的一项体系特征是每过几个月就向用户交付已测试的运行代码。如果你使用了此体系特征，你就会发现，“经常交付”的作用还是很让人吃惊的。  
&emsp;&emsp;项目主办者根据团队的工作进展获得重要反馈。用户有机会发现他们原来的需求是否是他们真正想要的，也有机会将观察结果反馈到开发当中。开发人员打破未决问题的死结，从而实现对重点的持续关注。团队得以调整开发和配置的过程，并通过完成这些工作鼓舞团队的士气。
2. 反思改进  
&emsp;&emsp;在我们的开发中，时常会出现这样那样的问题，技术难题、各种烦心事等，这会在很大的程度上影响项目的进展。而且，如果其他任务对这项任务有依赖的话，那么其他的任务也会被推迟，这就很可能会导致项目的失败。    
&emsp;&emsp;换句话说，如果我们能够经常在迭代会中及时地反思和改进，那么，这种事情应该是不会发生的，或者说发生了，也能够很快地找到解决方案去应对它。事实上，从慌乱的日常开发中，抽出一点时间来思考更为行之有效的工作方法就已经足够了。
3. 渗透式交流  
&emsp;&emsp;渗透交流就是信息流向团队成员的背景听觉，使得成员就像通过渗透一样获取相关信息。这种交流通常都是通过团队成员在同一间工作室内工作而实现的。若其中一名成员提出问题，工作室内的其他成员可以选择关注或不关注的态度，可以加入到这个问题的讨论当中来，也可以继续忙自己的工作。
4. 个人安全  
&emsp;&emsp;个人安全指的是当你指出困扰你的问题时，你不用担心受到报复。个人安全非常重要，有了它，团队可以发现和改正自身的缺点。没有它，团队成员们知而不言，缺点则愈发严重以至于损害整个团队。个人安全是迈向信任的第一步。有了信任，团队协作才能真正地实施，开发效率也就会直线上升的。
5. 焦点  
&emsp;&emsp;所谓“焦点”，就是确定首先要做什么，然后安排时间，以平和的心态开展工作。确保团队成员清楚地了解他们自己最重要的任务是什么，确保他们能够有充分的时间去完成这些任务。
6. 与专家用户建立方便的联系  
&emsp;&emsp;与专家用户持续建立方便的联系能够给团队提供：对经常交付进行配置以及测试的地方，关于成品质量的快速反馈，关于设计理念的快速反馈，最新的（用户）需求。  
7. 配有自动测试、配置管理和经常集成功能的技术环境  
&emsp;&emsp;自动测试可以为开发人员在代码修改后就可以进行自动测试，并且能够发现存在的一些bug，以至开发人员能够及时地进行修改，对于他们来说，节省了时间，提高了效率，而且还不用为烦人的测试而苦恼。  
&emsp;&emsp;配置管理系统允许人们不同步地对工作进行检查，可撤销更改，并且可以将某一系统设置保存后进行新系统的发布，当新系统出现问题，即可还原原系统的设置。  
&emsp;&emsp;经常集成可以使得团队在一天之内对系统进行多次集成。其实，团队越频繁地对系统进行集成，他们就能够越快地发现错误，堆积到一起的错误也会越少，并使他们产生更新的灵感。  
&emsp;&emsp;最好的团队是将这三大技术结合成“持续测试集成技术”。这样做他们可以在几分钟内发现因集成所产生的错误。
#### 5. 开放式源码
&emsp;&emsp;开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障（debug）的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。
#### 6. SCRUM
&emsp;&emsp;Scrum 是一个用于开发和维持复杂产品的框架，是一个增量的、迭代的开发过程。在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个 Sprint，每个 Sprint 的建议长度是 2 到 4 周(互联网产品研发可以使用 1 周的 Sprint)。在 Scrum 中，使用产品 Backlog 来管理产品的需求，产品 Backlog 是一个按照商业价值排序的需求列表，列表条目的体现形式通常为`用户故事`。Scrum 团队总是先开发对客户具有较高价值的需求。  
&emsp;&emsp;在 Sprint 中，Scrum 团队从产品 Backlog 中挑选最高优先级的需求进行开发。挑选的需求在 Sprint 计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为 Sprint backlog。在每个迭代结束时，Scrum 团队将递交潜在可交付的产品增量。   
&emsp;&emsp;Scrum 起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。Scrum 的基本流程如下图所示。

![Scrum流程图](https://pic.lufer.cc/images/2021/03/15/swwUmt.png)]

##### 1．Scrum 的五个活动
&emsp;&emsp;Scrum 主要包括：产品待办事项列表梳理、Sprint 计划会议、每日 Scrum 会议、Sprint评审会议、Sprint 回顾会议等五个活动。
1. 产品待办事项列表梳理  
&emsp;&emsp;产品待办事项通常会很大，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表梳理是一个始终贯穿整个 Scrum 项目的活动。该活动包含但不限于以下的内容：保持产品待办事项列表有序、把看起来不再重要的事项移除或者降级、增加或提升涌现出来的或变得更重要的事项、将事项分解成更小的事项、将事项归并为更大的事项、对事项进行估算。  
&emsp;&emsp;产品待办事项列表梳理的一个最大好处是为即将到来的几个 Sprint 做准备。为此，梳理时会`特别关注那些即将被实现的事项`。需要考虑不少因素，这包括但不限于以下的内容：   
&emsp;&emsp;理想情况下，下一个 Sprint 的备选事项都应该提升“商业价值”。开发团队需要能够在一个 Sprint 内完成每一个事项。每个人都需要清楚预期产出是什么。  
&emsp;&emsp;产品开发决定了，有可能需要其他的技能和输入。因此，产品待办事项列表梳理最好是所有团队成员都参与的活动，而不单单是产品负责人。
2. Sprint 计划会议  
&emsp;&emsp;每个 Sprint 都以 Sprint 计划会议作为开始，这是一个`固定时长`的会议，在这个会议中，Scrum 团队共同选择和理解在即将到来的 Sprint 中要完成的工作。  
&emsp;&emsp;整个团队都要参加 Sprint 计划会议。针对排好序的产品待办事项列表（Product Backlog），产品负责人和开发团队成员讨论每个事项，并对该事项达成共识，包括根据当前的“完成的定义”，为了完成该事项所需要完成的所有事情。所有的 Scrum 会议都是限定时长的。Sprint 计划会议推荐时长是 Sprint 中的`每周对应两小时`或者更少（例如，一个 Sprint 包含 2 个星期，则 Sprint 计划会议时长应为 4 个小时或者更少）。因为会议是限制时长的,Sprint 计划会议的成功十分依赖于产品待办事项列表的质量。这就是产品待办事项列表梳理十分重要的原因。  
&emsp;&emsp;在 Scrum 中，Sprint 计划会议有两部分：  
&emsp;&emsp;`第一部分：需要完成哪些工作？`  
&emsp;&emsp;在会议的第一部分，产品负责人向开发团队介绍`排好序的产品待办事项`，整个 Scrum 团队共同理解这些工作。  
&emsp;&emsp;Sprint 中需要完成的产品待办事项数目完全由开发团队决定。为了决定做多少，开发团队需要考虑当前产品增量的状态，团队过去的工作情况，团队当前的生产能力，以及排好序的产品待办事项列表。做多少工作只能由开发团队决定。产品负责人或任何其他人，都不能给开发团队强加更多的工作量。  
&emsp;&emsp;通常 Sprint 都有个目标，称作 Sprint 目标。这将十分有效地帮助大家更加专注于需要完成的工作的本质，而不必花太多精力去关注那些对于我们需要完成的工作并不重要的小细节。   
&emsp;&emsp;`第二部分：如何完成工作？`    
&emsp;&emsp;在会议的第二部分里，开发团队需要根据当前的“完成的定义”一起决定如何实现下一个产品增量。他们进行足够的设计和计划，从而有信心可以在 Sprint 中完成所有工作。前几天的工作会被分解成小的单元，每个工作单元不超过一天。之后要完成的工作可以稍大些，以后再对它们进行分解。  
&emsp;&emsp;决定如何完成工作是开发团队的职责，决定做什么则是产品负责人的职责。在计划会议的第二部分，产品负责人可以继续留下来回答问题，以及澄清一些误解。  
&emsp;&emsp;不管怎样，团队应该很容易找到产品负责人。  
&emsp;&emsp;Sprint 计划会议最终需要 Scrum 团队对 Sprint 需要完成工作的数量和复杂度达成共识，并预期在一个合理的条件范围内完成它们。开发团队预测并共同承诺他们要完成的工作量。总而言之：在 Sprint 计划会议中，开发团队和产品负责人一起考虑并讨论产品待办事项，确保他们对这些事项的理解，选择一些他们预测能完成的事项，创建足够详细的计划来确保他们能够完成这些事项。  
&emsp;&emsp;最终产生的待办事项列表就是“Sprint 待办事项列表（Sprint Backlog）”。
3. 每日 Scrum 会议  
&emsp;&emsp;开发团队是自组织的。开发团队通过每日 Scrum 会议来确认他们仍然可以实现 Sprint 的目标。这个会议`每天在同样的时间和同样的地点`召开。每一个开发团队成员需要提供以下三点信息：  
&emsp;&emsp;从上一个每日 Scrum 到现在，我完成了什么；从现在到下一个每日 Scrum，我计划完成什么；有什么阻碍了我的进展。  
&emsp;&emsp;每日 Scrum 中可能有简要的问题澄清和回答，但是不应该有任何话题的讨论。通常，许多团队会在每日 Scrum 之后马上开会处理他们遇到的任何问题。   
&emsp;&emsp;每日 Scrum 既不是向管理层汇报，也不是向产品负责人或者 ScrumMaster 汇报。它是一个开发团队`内部的沟通会议`，来保证他们对现状有一致的了解。只有 Scrum 团队的成员，包括 ScrumMaster 和产品负责人，可以在会议中发言。其他感兴趣的人可以来旁听。在必要时，开发团队会基于会议中的发现重新组织他们的工作来完成 Sprint 的目标。  
&emsp;&emsp;每日 Scrum 是 Scrum 的一个关键组成部分，它可以带来透明性,信任和更好的绩效。它能帮助快速发现问题，并促进团队的自组织和自立。所有 Scrum 会议都是限定时长的。每日 Scrum 通常`不超过 15 分钟`。
4. Sprint 评审会议  
&emsp;&emsp;Sprint 结束时，Scrum 团队和相关人员一起评审 Sprint 的产出。Sprint 评审会议的推荐时长是 Sprint 中的每一周对应一个小时（例如，一个 Sprint 包含 2 个星期，则 Sprint 评审会议时长为 2 个小时）。  
&emsp;&emsp;讨论围绕着 Sprint 中完成的产品增量。由于 Sprint 的产出会涉及一些人的“利益”，因此一个明智的做法是邀请他们参加这个会议，这会很有帮助。这个会议是个非正式的会议,帮助大家了解我们目前进展到哪里，并一起讨论我们下一步如何推进。每个人都可以在Sprint 评审会议上发表意见。当然，产品负责人会对未来做出最终的决定，并适当地调整产品待办事项列表 Product Backlog。  
&emsp;&emsp;团队会找到他们自己的方式来开 Sprint 评审会议。通常会演示产品增量,整个小组也会经常讨论他们在 Sprint 中观察到了什么、有哪些新的产品想法出现。他们还会讨论产品待办事项列表的状态、可能的完成日期以及在这些日期前能完成什么。Sprint 评审会议向每个人展示了当前产品增量的概况。因此，通常都会在 Sprint 评审会议中调整产品待办事项列表。
5. Sprint 回顾会议  
&emsp;&emsp;在每个 Sprint 结束后,Scrum 团队会聚在一起开 Sprint 回顾会议,目的是回顾一下团队在流程人际关系以及工具方面做得如何。团队识别出哪些做得好,哪些做得不好,并找出潜在的改进事项,为将来的改进制定计划。Sprint 回顾会议的推荐时长是 Sprint 中的每一周对应一个小时（例如，一个 Sprint 包含 2 个星期，则 Sprint 回顾会议时长为 2 个小时）。  
&emsp;&emsp;Scrum 团队总是在 Scrum 的框架内，改进他们自己的流程。

##### 2．Scrum 的 5 大价值观
&emsp;&emsp;Scrum 的 5 大价值观为：
* 承诺—愿意对目标做出承诺。
* 专注—把你的心思和能力都用到你承诺的工作上去。
* 开放—Scrum 把项目中的一切开放给每个人看。
* 尊重—每个人都有他独特的背景和经验。
* 勇气—有勇气做出承诺，履行承诺，接受别人的尊重。
#### 7. FDD
&emsp;&emsp;FDD 是一个迭代的开发模型。FDD 的每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供精确的项目进度报告和状态信息。同敏捷方法一样，FDD 弱化了过程在软件开发中的地位。虽然 FDD 中也定义了开发的过程，不过一个几页纸就能完全描述的过程深受开发者的喜爱。
##### 1．FDD角色定义
&emsp;&emsp;FDD 认为，有效的软件开发不可缺少的三个要素是：`人`、`过程`和`技术`。软件开发不能没有过程，也不能没有技术，但软件开发中最重要的是人。个人的生产率和人的技能将会决定项目的成败。为了让项目团队能够紧密地工作在一起，FDD 定义了 6 种关键的项目角色：
1. 项目经理  
&emsp;&emsp;项目经理是开发的组织者，但项目经理不是开发的主宰。对于项目团队来说，项目经理应该是团队的保护屏障。他将同团队外界（如高层领导、人事甚至写字楼的物业管理员）进行沟通，努力为团队提供一个适宜的开发环境。
2. 首席架构设计师  
&emsp;&emsp;负责系统架构的设计。
3. 开发经理  
&emsp;&emsp;开发经理负责团队日常的开发，解决开发中出现的技术问题与资源冲突。
4. 主程序员  
&emsp;&emsp;主程序员将带领一个小组完成特征的详细设计和构建的工作，一般要求主程序员具有一定的工作经验，并能够带动小组的工作。
5. 程序员  
&emsp;&emsp;若干个程序员在主程序员的带领下形成一个开发小组，按照特征开发计划完成开发。
6. 领域专家  
&emsp;&emsp;领域专家是对业务领域精通的人，一般由客户、系统分析员等担当。领域专家作为关键的项目角色正是敏捷宣言中“业务人员同开发人员紧密合作”的体现。 

&emsp;&emsp;根据项目规模的大小，有些角色是可以重复的。例如在一个小规模项目中，项目经理自身的能力很强，他就可以同时担当项目经理、首席架构设计师和开发经理的角色。

##### 2．核心过程
&emsp;&emsp;FDD 共有 5 个核心过程，如下图所示。

![FDD核心过程](https://pic.lufer.cc/images/2021/03/15/saOaGD.png)

1. 开发整体对象模型  
&emsp;&emsp;开发整体对象模型也就是`业务建模`的阶段。不过 FDD 强调的是系统地完整地面向对象建模，这种做法有助于把握整个系统，而不仅仅关注系统中的若干个点。在这一阶段，`领域专家和首席架构设计师`相互配合，完成整体对象模型。
2. 构造特征列表  
&emsp;&emsp;完成系统建模后，需要构造一个完整的特征列表。所谓特征指的是一个小的、对客户有价值的功能。采用动作、结果和目标来描述特征，特征的粒度最好可以在两周之内实现。在这一阶段中，可以整理出系统的需求。
3. 计划特征开发  
&emsp;&emsp;任何一个软件项目都必须有计划——无论是重载方法还是敏捷方法。在这一阶段中，`项目经理`根据构造出的特征列表、特征间的依赖关系进行计划，安排开发任务。
4. 特征设计  
&emsp;&emsp;在这一阶段，`主程序员`将带领特征小组对特征进行详细设计，为后面的构建做准备。
5. 特征构建  
&emsp;&emsp;特征构建和特征设计这两个阶段合并起来可以看做特征的实现阶段，这两个阶段反复地迭代，直到完成全部的开发。

##### 3．最佳实践
&emsp;&emsp;组成 FDD 的最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性。  
&emsp;&emsp;其中最有特色的莫过于`类的个体所有`。几乎所有的开发模型都是代码共有，程序员们负责开发系统中的全部代码，并通过配置管理和变更控制来保持代码的一致性。在 FDD 中，`将类分配给特定的任何小组`，分配给 A 成员的代码将全部由 A 来维护，除 A 外的角色都不能修改它，只能使用它。这样做当然有它的优点：个人对所分配的类很容易保持概念的完整性；开发类代码的人肯定是最熟悉这个类的主人；而对这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过 FDD 也提到了类个体所有的缺陷：项目中的依赖关系增强、当 A 需要 B 修改他自己的类时，必须等待 B 完成修改才能使用；类的个体所有增加了员工离职的损失。面对这些优点和缺陷，显然 FDD 认为类的个体所有对系统开发更有帮助。
&emsp;&emsp;除类的个体所有外，`审查`也是 FDD 中很具特色的一项实践。不少人都认为审查是非常严格的软件过程所特有的，因为进行审查不但要花费不少的人力和时间，对审查者本身的素质也有要求。然而在 FDD 中，明确地将审查作为一项最佳实践提出。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格审查制度保证软件质量。有效的审查可以发现很多潜在的问题，而这些问题往往是无法通过测试发现的，例如建模、需求和设计期的缺陷。这些潜在的缺陷大多要到系统测试甚至发布后才能发现，修正这些缺陷的代价是很大的。
#### 8. ASD
&emsp;&emsp;ASD (Adaptive Software Development)方法由 Jim Highsmith 提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。

### 4.1.4 RUP
#### 1. RUP概述
&emsp;&emsp;统一过程（Unified Process，UP）是由 Rational 公司开发的一种迭代的软件过程，是一个优秀的软件开发模型，它提供了完整的开发过程解决方案，可以有效地降低软件开发过程的风险，经过裁剪的 UP 可以适应各种规模的团队和系统。
#### 2. RUP的生命周期
&emsp;&emsp;UP 是一个很有特色的模型，它本身是一个二维的结构，如下图所示。

![UP模型](https://pic.lufer.cc/images/2021/03/15/rjBUuF.md.png)

&emsp;&emsp;RUP中有9个核心工作流，位于图的左侧。

1. 业务建模  
&emsp;&emsp;理解待开发系统所在的机构及其商业运作，确保所有参与人员对待开发系统所在的机构有共同的认识，评估待开发系统对所在机构的影响。
2. 需求  
&emsp;&emsp;定义系统功能及用户界面，使客户知道系统的功能，使开发人员理解系统的需求，为项目预算及计划提供基础。
3. 分析与设计  
&emsp;&emsp;把需求分析的结果转化为分析与设计模型。
4. 实现  
&emsp;&emsp;把设计模型转换为实现结果，对开发的代码做单元测试，将不同实现人员开发的模块集成为可执行系统。
5. 测试  
&emsp;&emsp;检查各个子系统的交互与集成，验证所有需求是否均被正确实现，对发现的软件质量上的缺陷进行归档，对软件质量提出改进建议。
6. 部署  
&emsp;&emsp;打包、分发、安装软件，升级旧系统。培训用户及销售人员，提供技术支持。
7. 配置与变更管理  
&emsp;&emsp;跟踪并维护系统开发过程中产生的所有制品的一致性和完整性。
8. 项目管理  
&emsp;&emsp;为软件开发项目提供计划，软件分配，执行，监控等方面的指导，为风险管理提供框架。
9. 环境  
&emsp;&emsp;为软件开发机构提供软件开发环境，即提供过程管理和工具的支持。

&emsp;&emsp;RUP把生命周期划分为多个循环，每个循环都由4个连续的阶段组成，如图上侧所示。

1. 初始阶段  
&emsp;&emsp;定义最终产品试图和业务模型，并确定系统范围。
2. 细化阶段  
&emsp;&emsp;设计并确定系统的架构，制定工作计划及资源要求。
3. 构造阶段  
&emsp;&emsp;构造产品并继续演进需求、架构、计划直至产品提交。
4. 移交阶段  
&emsp;&emsp;把产品提交给用户使用。

#### 3. RUP的特点
1. 用例驱动  
&emsp;&emsp;需求分析、设计、实现和测试等活动都是用例驱动。
2. 以架构为中心  
&emsp;&emsp;软件架构是关于构成系统的元素、这些元素之间的交互、元素和元素之间的组成模式以及作用在这些组成模式上的约束等方面的描述。  
&emsp;&emsp;对于一个软件系统，不同人员关心的内容是不一样的，因此软件的架构是一个多维的结构，通常会采用多个视图来描述软件架构。在RUP中，通常采用如下图所示的“4+1”视图模型。  
![image.png](https://pic.lufer.cc/images/2021/03/25/image.png)  
&emsp;&emsp;分析和测试人员关心的是系统的行为，因此会侧重于用例视图。最终和用户关心的是系统的功能，所以会侧重于逻辑视图。程序员关心的是系统的配置、装配等问题，因此会侧重于实现视图。系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，因此会侧重于进程视图。系统工程师关心的是系统的发布、安装、拓扑结构等问题，因此会侧重于部署视图。
3. 迭代与增量  
&emsp;&emsp;RUP强调要用迭代和增量的方式来开发软件。

#### 4. RUP裁剪
&emsp;&emsp;RUP是一个通用的模板，通过对RUP进行裁剪可以获得很多不同的软件开发过程。

&emsp;&emsp;针对一个软件项目，RUP裁剪可分为以下几步：
1. 确定本项目的软件开发过程需要那些工作流  
&emsp;&emsp;可根据项目的规模、类型对核心流做一些取舍。
2. 确定每个工作流要产出哪些制品  
&emsp;&emsp;如规定某个工作流要产出哪些制品。
3. 确定4个阶段之间如何演进  
&emsp;&emsp;以风险控制为原则，决定每个阶段要执行哪些工作流，每个工作流执行到什么程度，产出的制品有哪些，每个制品完成到什么程度等。
4. 确定每个阶段内的迭代计划  
&emsp;&emsp;规划每次迭代开发的内容有哪些。
5. 规划工作流内部结构  
&emsp;&emsp;通常用活动图的形式给出。

### 4.1.5 软件系统工具
#### 1. 软件开发工具
1. 需求分析工具
2. 基于自然语言或图形描述的工具
3. 基于形式化需求定义语言的工具
4. 其他需求分析工具
#### 2. 设计工具
#### 3. 编码与排错工具
#### 4. 软件维护工具
1. 版本控制工具
2. 文档分析工具
3. 开发信息库工具
4. 逆向工程工具
5. 再工程工具
#### 5. 软件管理和软件支持工具
1. 项目管理工具
2. 配置管理工具
3. 软件评价工具
4. 软件开发工具的评价和选择
    * 功能
    * 易用性
    * 稳健性
    * 硬件要求和性能
    * 服务和支持

## 4.5 软件的重用
&emsp;&emsp;软件重用是指在两次或多次不同的软件开发过程中重复的使用相同或相似软件元素的过程。  
&emsp;&emsp;软件元素主要包括需求分析文档、设计过程、设计文档、程序代码、测试用例和领域知识等。

&emsp;&emsp;软件重用可以分为横向重用和纵向重用。  
&emsp;&emsp;横向重用是指重用不同应用领域中的软件元素。例如标准函数库。  
&emsp;&emsp;纵向重用是指在一类具有较多公共性的应用领域之间进行软部件重用。

&emsp;&emsp;常见的软件重用形式包括：
1. 源代码重用  
&emsp;&emsp;这是最简单也是最常见的重用形式，但由于软件系统的复杂性，很难大规模地重用已有源代码。
2. 架构重用  
&emsp;&emsp;架构重用也很常见，随着软件架构风���和设计模式的推广和应用，架构重用已经对软件开发产生了重大的影响。
3. 应用框架的重用  
&emsp;&emsp;随着软件技术的发展，应用框架的重用变得越来越普遍，很多成熟的软件公司都建立了自己的开发框架。在开源社区中，世界各地的技术爱好者也在不断地推出应用了各种新技术的开发框架，例如，应用了 AOP（Aspect Oriented Programming，面向方面编程）技术的 Spring 等。
4. 业务建模的重用  
&emsp;&emsp;虽然不同的软件的业务领域各自不同，但人们还是总结出了一些常见领域的建模方法，重用这些领域模型可以降低因领域知识不足而造成的需求风险。
5. 文档及过程的重用  
&emsp;&emsp;软件文档和软件过程也是软件开发中不可或缺的元素，有效地重用这些文档和过程也有助于提高开发效率和软件质量、降低开发成本。
6. 软件服务的重用  
&emsp;&emsp;随着 Web 服务的提出，人们越来越关注服务的重用。SOA（Service-Oriented Architecture，面向服务的架构）提出了面向服务的软件架构，并定义了相应的标准。
# 第五章 软件架构设计
## 5.1 软件架构概念
### 5.1.1 软件架构的定义
&emsp;&emsp;一个程序和计算机系统软件的架构是指系统的一个或多个结构。结构中包括软件的构件，构件的外部可见属性以及它们之间的相互关系。  
&emsp;&emsp;软件架构仍在不断发展中，还没有形成一个统一的、公认的定义，这里仅举出几个较权威的定义。
* 定义 1  
&emsp;&emsp;软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。
* 定义 2  
&emsp;&emsp;软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。
* 定义 3  
&emsp;&emsp;软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000）  


&emsp;&emsp;前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件”更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。

&emsp;&emsp;为了更好地理解软件架构的定义，特作如下说明：
1. 架构是对系统的抽象  
&emsp;&emsp;它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的“外部可见”属性。
2. 架构由多个结构组成  
&emsp;&emsp;结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。
3. 任何软件都存在架构，但不一定有对该架构的具体表述文档  
&emsp;&emsp;即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。
4. 元素及其行为的集合构成架构的内容  
&emsp;&emsp;体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。
5. 架构具有“基础”性  
&emsp;&emsp;它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。
6. 架构隐含有“决策”  
&emsp;&emsp;架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。

&emsp;&emsp;在设计软件架构时也必须考虑硬件特性和网络特性，因此，软件架构与系统架构二者间的区别其实不大。但是，在大多情况下，架构设计师在软件方面的选择性较之硬件方面，其自由度大得多。因此，使用“软件架构”这一术语，也表明了一个观点：架构设计师通常将架构的重点放在软件部分。  
&emsp;&emsp;将软件架构置于商业背景中进行观察，可以发现软件架构对企业非常重要。
1. 影响架构的因素  
&emsp;&emsp;软件系统的项目干系人（客户、用户、项目经理、程序员、测试人员、市场人员等）对软件系统有不同的要求开发组织（项目组）有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。  
&emsp;&emsp;这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。
2. 架构对上述诸因素具有反作用  
&emsp;&emsp;例如，影响开发组织的结构。架构描述了系统的大粒度（宏观）总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序；影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于：系统的示范性、架构的可复用性及团队开发经验的提升，同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。
### 5.1.2 软件架构设计与生命周期
#### 1. 需求分析阶段
&emsp;&emsp;在本质上，需求和架构设计面临的是不同的对象：一个是问题空间，一个是解空间。从需求模型向架构模型转换时主要关注两个问题：
1. 如何根据需求模型构件架构模型
2. 如何保证模型转换的可追踪性
#### 2. 设计阶段
&emsp;&emsp;设计阶段主要可分为三个层次：
1. 架构的基本概念  
&emsp;&emsp;即架构模型由哪些元素组成，这些组成元素之间按照何种原则组织。
2. 体系结构描述语言  
&emsp;&emsp;是支持构件、构件间连接方式及其配置的描述语言。
3. 架构模型的多视图表示    
&emsp;&emsp;从不同的视角描述特定的体系结构，从而得到多个视图，并将这些视图组织起来以描述整体的架构模型。

#### 3. 实现阶段
&emsp;&emsp;为了有效实现从架构设计向实现的转换，实现阶段的体系结构研究主要从以下几个方面开展：
1. 研究基于架构的开发过程支持，如项目组织结构、配置管理等。
2. 寻求从架构向实现过渡的途径，如将程序设计语言元素引入架构阶段、模型映构件组装、复用中间件等。
3. 研究基于架构的测试技术。

&emsp;&emsp;为了填补高层架构模型和底层实现之间的鸿沟，通过封装底层的实现细节，模型转换、精化等手段缩小概念之间的差距，典型方法如下：
1. 在架构模型中引入实现阶段的概念，如引入程序设计语言元素等。
2. 通过模型转换技术，将高层的架构模型逐步精化呈能够支持实现的模型。
3. 封装底层的实现细节，使之成为较大粒度构件，在架构指导下通过构件组装的方式实现系统，这往往需要底层中间件平台的支持。

#### 4. 构件组装阶段
&emsp;&emsp;构件组装阶段研究的主要内容包括：
1. 如何支持可复用构件构件的互联。
2. 组装过程中如何检测并消除体系结构失配的问题。

#### 5. 部署阶段
&emsp;&emsp;架构对软件部署的作用如下：
1. 提供高层的体系结构视图描述部署阶段的软硬件模型。
2. 基于架构模型可以分析部署方案的质量属性，从而选择合理的部署方案。

#### 6. 后开发阶段
&emsp;&emsp;这一阶段的研究主要包括：
1. 动态软件体系结构  
&emsp;&emsp;主要可以分为以下两个部分
    * 体系结构设计阶段的支持    
    &emsp;&emsp;主要包括变化的描述、根据变化如何生成修改策略、描述修改过程、在高抽象层次保证修改的可行性以及分析、推理所带来的影响等。
    * 运行时刻基础设施的支持    
    &emsp;&emsp;主要包括系统体系结构的维护、保证体系结构修改在约束范围内、提供系统的运行时刻心系、分析修改后的体系结构符合指定的属性、正确映射体系结构构造元素的变化到实现模块、保证系统重要子系统连续执行并保持状态、分析和测试运行系统。
2. 体系结构恢复与重建  
&emsp;&emsp;架构重建是指从已实现的系统中获取体系结构的过程。一般重建的输出是一组体系结构视图。现有的重建方法可以分为4类：
    * 手工体系结构重建
    * 工具支持的手工重建
    * 通过查询语言来自动建立聚集
    * 使用其他技术，比如数据挖掘等。

### 5.1.3 软件架构的重要性
#### 1. 架构设计能够满足系统的品质
&emsp;&emsp;系统的功能性是软件架构师通过组成体系架构的多种元素之间的交互作用来支持的。架构设计用于实现雄的品质如性能、安全性和可维护性等。通过架构设计文档化，可以尽早的评估项目的这些品质。
#### 2. 架构设计使受益人达成一致的目标
&emsp;&emsp;架构设计的过程使得不同的受益人达成一致的目标，体系架构的过程需要确保架构设计被清楚的传达与理解。
#### 3. 架构设计能够支持计划编制过程
&emsp;&emsp;架构设计将确定组件之间的依赖关系，直接支持项目计划和项目管理的活动。
#### 4. 架构设计对系统开发有指导性
&emsp;&emsp;架构设计的主要目标就是确保体系架构能够为设计人员和实现人员所承担的工作提供可靠的框架。架构师必须明确地定义体系架构，因为它确定了体系架构的重要元素，例如系统的组件、组件之间的接口以及组件之间的通信。
#### 5. 架构设计能够有效地管理复杂性
&emsp;&emsp;体系架构通过构件及构件之间的关系，描述了一个抽象的系统，因而提供了高层次的复杂管理的方法。
#### 6. 架构设计为复用奠定了基础
&emsp;&emsp;架构设计过程可以同时支持使用和建立复用资源。
#### 7. 架构设计能够降低维护费用
#### 8. 架构设计能够支持冲突分析
&emsp;&emsp;架构设计可以允许我们在采取改变之前推断它所产生的影响。 

## 5.2 基于架构的软件开发方法
### 5.2.1 架构的设计方法概述
&emsp;&emsp;基于架构的软件设计（Architecture-Based Software Design，ABSD）是一种架构驱动方法。这种方法有 3 个基础：
1. 功能的分解  
&emsp;&emsp;在功能分解中，ABSD 方法使用已有的基于模块的内聚和耦合技术。
2. 通过选择架构风格来实现质量和业务需求。
3. 软件模板的使用  
&emsp;&emsp;软件模板利用了一些软件系统的结构。

&emsp;&emsp;ABSD 方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，这有助于降低架构设计的随意性。
### 5.2.2 基于架构的开发模型
&emsp;&emsp;基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为`架构需求`、`设计`、`文档化`、`复审`、`实现`、`演化`等 6 个子过程，如下图所示。

![基于架构的软件开发模型](https://pic.lufer.cc/images/2021/03/15/sghqsg.png)

### 5.2.3 架构需求
&emsp;&emsp;需求是指用户对目标软件系统在`功能`、`行为`、`性能`、`设计约束`等方面的期望。需求过程如下图所示

![架构需求过程](https://pic.lufer.cc/images/2021/03/15/sg4I0J.png)

#### 1. 需求获取  
&emsp;&emsp;架构需求一般来自三个方面，分别是`系统的质量目标`、`系统的业务目标`和`系统开发人员的业务目标`。软件架构需求获取过程主要是定义开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务上的功能需求。与此同时，还要获得软件质量属性，满足一些非功能需求。
#### 2. 标识构件  
&emsp;&emsp;在`架构需求过程图`中虚框部分属于标识构件过程，该过程为系统生成初始逻辑结构，包含大致的构件。这一过程又可分为三步来实现。
1. 生成类图  
2. 对类进行分组  
&emsp;&emsp;一般地，与其他类隔离的类形成一个组，由泛化关联的类组成一个附加组，由聚合或组合关联的类也形成一个附加组。
3. 把类打包成构件  
&emsp;&emsp;这些构件可以分组合并成更大的构件。
#### 3. 需求评审  
&emsp;&emsp;组织一个由不同代表（如分析人员、客户、设计人员、测试人员）组成的小组，对架构需求及相关构件进行仔细的审查。审查的主要内容包括所获取的需求是否真实反映了用户的要求，类的分组是否合理，构件合并是否合理等。  
&emsp;&emsp;必要时，可以在“需求获取—标识构件—需求评审”之间进行迭代。
### 5.2.4 架构设计
&emsp;&emsp;架构需求用来激发和调整设计决策，不同的视图被用来表达与质量目标有关的信息。架构设计是一个迭代过程，如果要开发的系统能够从已有的系统中导出大部分，则可以使用已有系统的设计过程。架构设计过程如下图所示。

![架构设计过程](https://pic.lufer.cc/images/2021/03/15/sgIqsO.png)

#### 1. 提出软件架构模型  
&emsp;&emsp;在建立架构的初期，选择一个合适的架构风格是首要的。在这个风格基础上，开发人员通过架构模型，可以获得关于架构属性的理解。此时，虽然这个模型是理想化的（其中的某些部分可能错误地表示了应用的特征），但是该模型为将来的实现和演化过程建立了目标。
#### 2. 把已标识的构件映射到软件架构中  
&emsp;&emsp;把在架构需求阶段已标识的构件映射到架构中，将产生一个中间结构，这个中间结构只包含那些能明确适合架构模型的构件。
#### 3. 分析构件之间的相互作用    
&emsp;&emsp;为了把所有已标识的构件集成到架构中，必须认真分析这些构件的相互作用和关系。
#### 4. 产生软件架构  
&emsp;&emsp;一旦决定了关键的构件之间的关系和相互作用，就可以在第 2 阶段得到的中间架构的基础上进行细化。
#### 5. 设计评审
&emsp;&emsp;一旦设计了软件架构，我们必须邀请独立于系统开发的外部人员对架构进行评审。
### 5.2.5 架构文档化
&emsp;&emsp;文档是在系统演化的每一个阶段，系统设计与开发人员的通信媒介，是为验证架构设计和提炼或修改这些设计（必要时）所执行预先分析的基础。  
&emsp;&emsp;架构文档化过程的主要输出结果是`架构需求规格说明`和`测试架构需求的质量设计说明书`这两个文档。
### 5.2.6 架构复审
&emsp;&emsp;在一个主版本的软件架构分析之后，要安排一次由`外部人员`（用户代表和领��专家）参加的复审。  
&emsp;&emsp;复审的目的是`标识潜在的风险`，以及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否在设计中得到体现、层次是否清晰、构件的划分是否合理、文档表达是否明确、构件的设计是否满足功能与性能的要求等等。  
### 5.2.7 架构实现
&emsp;&emsp;所谓“实现”就是要用实体来显示出一个软件架构，即要符合架构所描述的结构性设计决策，分割成规定的构件，按规定方式互相交互。架构的实现过程如下图所示。

![架构实现过程](https://pic.lufer.cc/images/2021/03/15/sgTd4s.png)

&emsp;&emsp;上图中的虚框部分是架构的实现过程。整个实现过程是以复审后的文档化的架构说明书为基础的，每个构件必须满足软件架构中说明的对其他构件的责任。这些决定即实现的约束是在系统级或项目范围内做出的，每个构件上工作的实现者是看不见的。  
&emsp;&emsp;在架构说明书中，已经定义了系统中构件与构件之间的关系。因为在架构层次上，构件接口约束对外唯一地代表了构件，所以可以从构件库中查找符合接口约束的构件，必要时开发新的满足要求的构件。  
&emsp;&emsp;然后，按照设计提供的结构，通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成。  
&emsp;&emsp;最后一步是测试，包括单个构件的功能性测试和被组装应用的整体功能和性能测试。
### 5.2.8 架构演化
&emsp;&emsp;在构件开发过程中，最终用户的需求可能还有变动。在软件开发完毕，正常运行后，由一个单位移植到另一个单位，需求也会发生变化。在这两种情况下，就必须相应地修改软件架构，以适应新的软件需求。架构演化过程如下图所示。架构演化是`使用系统演化步骤去修改应用`，以满足新的需求。主要包括以下七个步骤：

![架构演化过程](https://pic.lufer.cc/images/2021/03/15/sg7NM6.png)

#### 1. 需求变动归类  
&emsp;&emsp;首先必须对用户需求的变化进行归类，使变化的需求与已有构件对应。对找不到对应构件的变动，也要做好标记，在后续工作中，将创建新的构件，以对应这部分变化的需求。
#### 2. 制订架构演化计划  
&emsp;&emsp;在改变原有结构之前，开发组织必须制订一个周密的架构演化计划，作为后续演化开发工作的指南。
#### 3. 构件变动  
&emsp;&emsp;修改、增加或删除构件在演化计划的基础上，开发人员可根据在第一步得到的需求变动的归类情况，决定是否修改或删除存在的构件、增加新构件。最后，对修改和增加的构件进行功能性测试。
#### 4. 更新构件的相互作用  
&emsp;&emsp;随着构件的增加、删除和修改，构件之间的控制流必须得到更新。
#### 5. 构件组装与测试  
&emsp;&emsp;通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成，形成新的架构。然后对组装后的系统的整体功能和性能进行测试。
#### 6. 技术评审  
&emsp;&emsp;对以上步骤进行确认，进行技术评审。评审组装后的架构是否反映需求变动，符合用户需求。如果不符合，则需要在第 2 到第 6 步之间进行迭代。
#### 7. 演化后的架构  
&emsp;&emsp;在原来系统上所作的所有修改必须集成到原来的架构中，完成一次演化过程，产生演化后的架构。


## 5.3 软件架构风格
&emsp;&emsp;软件架构设计的一个核心问题是能否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。基于这个目的，学者们开始研究和实践软件架构的风格和类型问题。    
### 5.3.1 软件架构风格概述
&emsp;&emsp;软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式（ idiomatic paradigm）。架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。

### 5.3.2 经典软件架构风格
#### 1. 管道和过滤器
&emsp;&emsp;在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。此风格特别重要的过滤器必须是独立的实体，它不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。一个管道/过滤器网络输出的正确性并不依赖于过滤器进行增量计算过程的顺序。  
&emsp;&emsp;下图是管道/过滤器风格的示意图。一个典型的管道/过滤器架构的例子是以 UNIX shell 编写的程序。UNIX 既提供一种符号，以连接各组成部分（UNIX 的进程），又提供某种进程运行时机制以实现管道。另一个著名的例子是传统的编译器。传统的编译器一直被认为是一种管道系统，在该系统中，一个阶段（包括词法分析、语法分析、语义分析和代码生成）的输出是另一个阶段的输入。

![管道/过滤器风格的架构](https://pic.lufer.cc/images/2021/03/15/yhiFF1.png)

&emsp;&emsp;管道/过滤器风格的软件架构具有许多很好的特点：
1. 使得软构件具有良好的隐蔽性和高内聚、低耦合的特点；
2. 允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成；
3. 支持软件重用。只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来；
4. 系统维护和增强系统性能简单。新的过滤器可以添加到现有系统中来；旧的可以被改进的过滤器替换掉；
5. 允许对一些如吞吐量、死锁等属性的分析；
6. 支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其他任务并行执行。
 
&emsp;&emsp;但是，这样的系统也存在着若干不利因素。
1. 通常导致进程成为批处理的结构。这是因为虽然过滤器可增量式地处理数据，但它们是独立的，所以设计者必须将每个过滤器看成一个完整的从输入到输出的转换；
2. 不适合处理交互的应用。当需要增量地显示改变时，这个问题尤为严重；
3. 因为在数据传输上没有通用的标准，每个过滤器都增加了解析和合成数据的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。
#### 2. 数据抽象和面向对象组织
&emsp;&emsp;抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍使用面向对象系统。这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。  
&emsp;&emsp;下图是数据抽象和面向对象风格的示意图。

![数据抽象和面向对象风格的架构](https://www.853tv.cn/imgs/2021/03/bb10ec06b2d5bf85.png)

&emsp;&emsp;这种风格的两个重要特征为：
1. 对象负责维护其表示的完整性；
2. 对象的表示对其他对象而言是隐蔽的。因为一个对象对它的客户隐藏了自己的表示，所以这些对象可以不影响它的客户就能改变其实现方法。

&emsp;&emsp;面向对象的系统有许多优点，并早已为人所知：
1. 因为对象对其他对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其他的对象；
2. 设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。

&emsp;&emsp;但是，面向对象的系统也存在着某些问题：
1. 为了使一个对象和另一个对象通过过程调用等进行交互，必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象；
2. 必须修改所有显式调用它的其他对象，并消除由此带来的一些副作用。例如，如果 A 使用了对象 B，C 也使用了对象 B，那么，C 对 B 的使用所造成的对 A 的影响可能是料想不到的。
#### 3. 事件驱动系统
&emsp;&emsp;构件不直接调用一个系统，而是触发或广播一个或多个事件。系统中的其他构件中的过程在一个或多个事件中注册。当一个事件被触发，系统自动调用在这个事件中注册的所有过程，这样一个事件的触发就导致了另一模块中的过程的调用
#### 4. 分层系统
&emsp;&emsp;层次系统组织成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层只对相邻的层可见。这样的系统中构件在一些层实现了虚拟机（在另一些层次系统中层是部分不透明的）。连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束。    
&emsp;&emsp;这种风格支持基于可增加抽象层的设计。这样，允许将一个复杂问题分解成一个增量步骤序列的实现。由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。  
&emsp;&emsp;下图是层次系统风格的示意图。层次系统最广泛的应用是分层通信协议。在这一应用领域中，每一层提供一个抽象的功能，作为上层通信的基础。较低的层次定义低层的交互，最低层通常只定义硬件物理连接。

![层次系统风格的架构](https://www.853tv.cn/imgs/2021/03/2bc86053168c7ea1.png)

&emsp;&emsp;层次系统有许多可取的属性：
1. 支持基于抽象程度递增的系统设计，使设计者可以把一个复杂系统按递增的步骤进行分解；
2. 支持功能增强，因为每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的上下层；
3. 支持重用。只要提供的服务接口定义不变，同一层的不同实现可以交换使用。这样，就可以定义一组标准的接口，而允许各种不同的实现方法。

&emsp;&emsp;但是，层次系统也有其不足之处：
1. 并不是每个系统都可以很容易地划分为分层的模式，甚至即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来；
2. 很难找到一个合适的、正确的层次抽象方法。
#### 5. 仓库系统及知识库



<!-- 
# 第七章 系统规划
&emsp;&emsp;系统计划主要用于描述从项目提出、选择到确立的过程，包括系统项目的提出与可行性分析，系统方案的制订、评价和改进，新旧系统的分析和比较，以及现有软件、硬件和数据资源的有效利用等问题。
## 7.1 项目的提出与选择
&emsp;&emsp;组织在信息化的过程中，可能基于各种动机提出系统项目的建设，有关人员要根据这些动机，提出和确定信息系统的工作范围，确定项目立项，提出系统选择方案，给出选择结果。
### 7.1.1 项目的立项目标和动机
&emsp;&emsp;企事业单位在其自身的经营管理过程中，对于项目的立项建设可能具有多种动机，通常可归结为下列几种。
1. 进行基础研究并获取技术  
&emsp;&emsp;此类项目通常由大学院校或企业集团的战略研究性部门提出和实施。小规模的研究组织可能仅仅是企业中的一个研发部门或从事研发工作的团队；中大规模的研究组织包括研究所或研究院这种独立建制的单位；大规模的研究性项目可类似于国家 863 计划等跨行业、跨地域协作的国家级重大项目立项。
2. 进行应用研发并获得产品  
&emsp;&emsp;此类项目通常由企业进行立项和开发，企业立项的基本动机通常是为了得到应用软件产品并向目标客户群进行销售从而获取利润等。产品一般会基于某类特定客户群体的需求进行设计，有明确和具体的研发目标需求，有严格的时间限制、资源预算等，因此可归入 “应用研发”型软件。  
&emsp;&emsp;应用研发型软件通常具有一定的通用性，客户广泛，既可能是面向个人消费者的工具软件（例如 Office、杀毒软件、游戏软件等），也可能是面向特定领域或行业的工具软件（例如 SQL Server 数据库、AutoCAD 工程绘图软件、Rational Rose 这样的建模工具软件等）。
3. 提供技术服务  
&emsp;&emsp;对此类项目进行立项的企业通常能向目标客户群提供比较全面的技术服务而不是单一的软件产品。因此企业的服务范围可能包含提供技术和解决方案的咨询、利用现有产品进行系统集成和服务、面向特定客户的软件项目定制开发、对现有的软件系统进行升级和改造、提供软件应用相关的技术支持、服务和培训等服务中的一个或多个内容。   
&emsp;&emsp;总的来说，此类组织通常会面向一个特定行业、具有相对稳定性的客户群体，通过提供一种综合性服务来获取市场价值，因此可以把此类公司看做“服务”导向的组织。
4. 信息技术产品的使用者  
&emsp;&emsp;信息技术的使用者是最终客户。对他们来说，软件项目的立项动机既不是为了得到软件产品而进行销售，也不是为了提供技术服务，而是通过购买产品或服务来得到使用价值。例如：一个消费者购买了绘图软件是为了存储和处理个人数码相机中的照片；而一个企业通过实施 ERP（Enterprise Resource Planning，企业资源计划）可能是为了达到生产能力的控制、生产计划科学性、提高管理水平、获取新的决策能力、降低库存成本、提高资金周转率、建立面向市场订单生产方式等目标，并期望通过这些目标的实现来增强企业竞争力、获取更大的市场份额。对信息技术的使用者来说，信息技术是一种手段，同时也是一种成本。如何用最小的成本和风险获得满意的效果是客户最关心的问题。

### 7.1.2 项目的选择和确定
&emsp;&emsp;系统项目的选择至少包含两种实用性目的，一个是软件开发公司在诸多的产品方向中`选择适当的方向`进行研究和开发，另一种是客户从诸多的产品中购买`适合自己需要的产品或技术方案`进行实施。与系统项目提出的问题一样，并不存在一个统一模式进行系统项目的选择和取舍，但可以提出进行项目取舍和评估的若干原则。通过使用项目取舍和评估的原则，可以逐步排除那些不符合需求的项目定义，从而找到比较适合的项目或产品开发方向。
#### 1．选择有核心价值的产品/项目或开发方向
&emsp;&emsp;这个策略关键在于确定什么样的系统项目是有价值的。由于立项单位所处的行业、在行业中的位置、立项目标等因素不同，对软件项目的价值判断也不同。但“有核心价值的软件项目”通常总是和企业或客户的核心业务相关的。  
&emsp;&emsp;美国哈佛商学院的著名教授Michael Porter曾经在他的《竞争优势》（CompetitiveAdvantage）一书中提出了`“价值链”`的概念，价值链把企业运作的各种活动划分为产品设计、产品生产、产品营销和产品应用等独立领域，企业的价值链也可以进一步和上游供货商与下游买主的价值链相连，从而构成一个产业的价值链。如果以“价值链”的观点来看待软件产品或项目，软件是作为一种技术服务手段被运用到企业业务的价值链上的，通过实现价值链中的关键业务的信息化从而最终改善客户单位的企业质量，同时也使软件开发公司获得现实的经济利益。  
&emsp;&emsp;因此，在企业或客户经营活动中对价值链增值最大的部分，就是企业或客户的“核心业务”。针对核心业务的信息化产品或项目，通常都是具有高价值的，也可以说，所谓的 “行业信息化”的关键就是该行业中这些核心业务的信息化改造。例如：
1. 对生产制造业的企业来说，生产计划、库存控制、实现面向订单的生产就是核心业务，无论实施 ERP 还是小规模的 MIS 系统，针对这些部分的软件功能总是被客户认为是最有价值的。
2. 对于金融保险行业来说，由于保险公司的基本职责是分摊风险和补偿损失，所以一般要求保险公司有足够的分散风险的能力。因此，管理保单数据的业务系统、评估风险的定损系统等就是非常有价值的软件系统。
3. 对于教育行业来说，因为学校的核心职能是教书育人，因此与教研、教学、考试、评价等业务相关的软件系统，以及支持上述业务开展的教育资源库软件、电子图书馆软件等就是高价值的软件系统。
 
&emsp;&emsp;总之，选择软件项目，必须首先考察软件应用的行业、业务和目标，以便判明要建设的软件项目价值。
#### 2．评估项目风险、收益和代价
&emsp;&emsp;在判断出一个潜在的软件项目后，还应评估项目实施的风险、收益和维护付出的代价。对于开发产品进行销售的情况，主要评估的是产品的预期收益和为完成开发投入的各种资源（包括时间、人力、资金等），项目的风险主要是技术难度、技术能力、经济能力和各种资源是否能承担、是否是企业需要优先实施的项目、是否符合行业标准和国家政策规定（例如：在电子签章没有经过国家法律许可之前，使用电子签章替代手工操作可能是有风险的）等。  
&emsp;&emsp;对于购买产品或技术服务的客户来说，还应该评估项目实施后对自身业务变更，组织机构和人员职责的影响，现有的业务流程和人员的 IT 技能是否能满足要求，是否需制定相关的系统维护、运行规约和规章制度等。而项目实施的实际开销，除购买产品或服务的开支外，通常还包括各种系统维护、改进、培训，招聘新职员，变更业务流程等各种应用方面的开销。以总持有成本（Total Owner Cost，TOC）来评估信息化的代价才能比较准确地得到项目的实际代价。  
&emsp;&emsp;评估项目风险、预期收益和代价后，可筛选掉多数不符合企业要求的建议项目。
#### 3．评估项目的多种实施方式
&emsp;&emsp;对于已经确认有价值、并且有能力开发的软件项目，则可以进一步参照企业现状考察项目的实施方式。这种实施方式通常既包括了前面对项目风险、预期收益和资源开销的评估，也包含了企业对现阶段经营目标和现有资源如何合理运用的考虑。这个过程通常由项目的负责人和企业中高层经理进行决策，决策结果决定了项目的实施优先级及具体的实施方式。  
&emsp;&emsp;需要说明的是，企业完成软件项目的方式并不单纯限制于自己组建开发团队进行软件项目或软件产品开发的策略。根据具体情况不同，还可能使用诸如转包开发业务给外部公司、直接 OEM（Original Equipment Manufacture，原始设备制造商）软件产品并进行系统集成、购买关键技术并进行“软件集成”方式的开发、完成技术方案和设计，然后寻求外部公司进行编码等各种方式。对这些项目实施方式的取舍，主要依据依然是对项目风险、收益和资源开销综合平衡的考虑。
#### 4．平衡地选择适合的方案
&emsp;&emsp;人们在选择可行的方案时，总是希望得到高质量、低成本的产品和方案。软件开发人员通常也很愿意在产品开发中，向产品加入创造性的内容。另一方面，客户单位在面对诸多的投标方案时，会听到各种各样关于技术先进性、快速开发、产品质量稳定可靠、价格如何低廉、推荐的方案有多少成功应用等宣传。然而：
1. 新技术可能意味着未来更多的变化从而导致风险，也意味着未来产品的使用者需要更多的学习和导入期，而采用成熟的技术则可能享受不到新技术带来的好处。
2. 不基于某种快速开发技术或平台构造的产品可能会延长项目开发时间从而导致更多的开销，但基于某种平台的产品又可能使得用户未来“绑定”在某种平台之上，减少未来的自由选择性。
3. 不考虑系统的扩展性则很可能在业务变更时，会受阻于已经实施的 IT 设施，但过多考虑系统的扩展性，软件接口通常就需要花费较大的力气进行设计，那么用户是否在当前的购买中为一些自己并不需要的特性多支付成本？尤其在软件技术高速发展的今天，当用户期望进行系统升级的时候，常常会发现原来的计算体系已经早就被开发单位淘汰和抛弃。
4. 价格低廉的产品可能具有好的质量，也可能有些功能并不那么让人满意，而最重要的是，当关注这些具有先进性、低成本及拥有众多成功应用的产品或方案的时候，项目的选择者容易失去对自己目标的关注，即这些先进技术或宣传的产品特性是否确实是自己需要的？

&emsp;&emsp;事实上，对性能的要求常常是充满矛盾的，任何时候都不存在一个完美无缺的方案，只存在一个对当前的项目目标相对比较适合的方案。项目的决策者必须从最终的项目目标出发，判明各种功能或性能的重要性和优先级。在抛弃明显存在问题的“差”项目后，选择项目的基本立场应该是“适合”，而不是尽可能的“好”。（实际上任何超出预期设定目标的“好”性能，通常都意味着更多的成本。）  
&emsp;&emsp;更进一步地看，“适合”的方案就是平衡考虑开发单位利益和客户满意度的方案。

![顾客质量模型图](https://pic.lufer.cc/images/2021/03/15/sWYfHg.png)

&emsp;&emsp;上图是 Noriaki Kano 提出的顾客质量模型图，要求质量是客户认为产品应该具备的功能或性能，实现越多客户会越满意；假想质量是客户想当然认为产品应具备的功能或性能，客户并不能正确描述自己想当然要得到的这些功能或性能需求；兴奋质量则是客户要求范围外的功能或性能（但通常是软件开发者很乐意赋予产品的技术特性），实现这些性 能客户会更高兴，但不实现也不影响其购买的决策。  
&emsp;&emsp;显然，项目开发方更多考虑的是项目风险和回报。而客户更多关心的是成本和购买后的满意度。好的方案必须平衡考虑这些因素。系统分析师应尽可能用技术手段来平衡这些彼此对立的要求，保证在项目预期投入资源可接受的范围内，尽量实现客户要求质量对应的功能和性能、发掘客户假想质量对应的功能要求并进行沟通确认，但按自身所服务企业的经营目标平衡考虑客户兴奋质量的实现策略（是努力提供兴奋质量的功能、争取忠诚的客户获得远期潜在的收益，还是削减这些功能、以便使项目的成本最小化）。

>系统设计师常犯的一个错误，就是用自己对技术的兴趣产生的兴奋质量，来替换客户最基本的要求质量和假想质量。而企业经营者常犯的错误，则可能是对客户提出的合理要求质量视而不见；或者走向另一个极端，不加区分地把一切未经评估的假想要求质量不断指派给软件开发团队。这些都是错误的做法。

### 7.1.3 项目提出和选择的结果
&emsp;&emsp;系统项目提出和选择的结果，最终会以“产品/项目建议书”的方式来体现。典型的应用场景是：
1. 在投标项目中，产品/项目建议书通常是乙方提交给甲方竞标方案的一部分；
2. 企业单位在确立了要开发某类型产品后，对该产品进行多角度的评估，最终项目立项人向上级提交供决策的建议报告的主要内容就是“产品/项目建议书”。

&emsp;&emsp;产品/项目建议书是一个包含多种综合内容的报告，涉及的范围通常要比《GB8567-1988》标准中规定的标准——“项目可行性分析报告”的内容更全面。在项目建议书中，可能包含如下几个部分：

>用户单位、项目或产品的立项背景、需求来源和目标性的介绍；  
>用户的内外部环境、组织机构、现有的 IT 设施情况等；  
>用户的业务模型和业务规划；  
>预期要建设的技术系统在用户业务中的位置和作用；  
>信息化后的用户业务模型、软件应用方式、相关的部署环境、运行规则、管理规范等；  
>为实现信息化业务模型，技术系统的产品需求定义（功能、性能、约束）和部署方式等；  
>产品或项目的技术框架；  
>项目的要点、技术难点、主要实施障碍等；  
>项目或产品的可行性研究结果；  
>项目可选择的实施方式、组织方式、沟通和协调机制等；  
>项目的资源范围和预算（人、财、物、时间等）；  
>项目的成本/收益分析；  
>……

&emsp;&emsp;其他项目建议书可能包含的内容，或以单独文档列举的内容可能包括：

>项目风险及影响评估；  
>项目进度计划；  
>项目质量计划；  
>项目过渡期资金的获得方式、财务计划；  
>产品或项目的商务模式、盈利模式论述；  
>同类产品或公司的市场调查结果，以及竞争性比较；  
>企业成功案例、资质等；  
>商务条款或供应商/客户合同；  
>……

&emsp;&emsp;项目建议书标志着项目立项和选择阶段性工作的完成，一旦项目建议书被批准通过，项目即可进入正式的开发准备和实施阶段。

## 7.2 可行性研究与效益分析
&emsp;&emsp;在项目计划和选择的过程中，需要完成的首要目标是对项目进行估算。项目估算的范围涉及方方面面，例如项目或产品开发的范围、投入和回报、项目风险、作用和意义等。在传统软件工程方法中，是以`可行性研究`的方式来组织项目的主要估算内容。  
&emsp;&emsp;可行性研究的范围可能覆盖技术、经济、执行、环境等各种需要评估的因素，但它并不是最后的详细计划（例如：项目的时间进度及人员安排）。通常在进行可行性研究的阶段，项目的目标或产品的最终方向也是极易变化的。  
&emsp;&emsp;但可行性研究的意义在于，虽然可行性研究不能指出项目最终的详细计划和方向，但可行性研究可以在项目定义阶段用较小的代价识别出错误构思的系统，从而规避未来更多的资源投入的损失（时间、资金、人力、机会），或者因遭遇到无法逾越的技术障碍或环境障碍导致的不可避免的失败。  
&emsp;&emsp;对于那些可行性研究表明可执行的软件项目来说，可行性研究的结果也不承诺系统的收益一定很大或技术风险和资源投入就一定很低，但可行性研究的结果设立了一个“底线”，即如果做什么，风险和收益是什么样的控制范围。这些评估结果给了未来的项目评估、项目风险控制，甚至在资源剧烈变化的情况下有计划有重点地削减功能、重定义项目开发范围，提供了非常有价值的方向性指引。

### 7.2.1 可行性研究的内容
&emsp;&emsp;可行性研究的主要内容包括`经济可行性`、`技术可行性`、`法律可行性`、`执行可行性`和`方案的选择` 5个部分。
#### 1．经济可行性
&emsp;&emsp;经济可行性主要评估项目的开发成本及项目成功后可能获得的经济收益。多数项目只有开发成本能控制在企业可接受的范围内的时候，项目才有可能被批准执行。而经济收益的考虑则非常广泛，例如：项目技术开发的直接现金收入、新产品在生命周期中预期的总销售收入、技术积累、对公司业务和产品线的完善和支持、开辟新市场和利润增长点、进入预期能带来较高收益的新市场、提高客户满意度和忠诚度、打击竞争对手抢夺市场份额、获得新的信息化能力从而改善经营或管理格局等。
#### 2．技术可行性
&emsp;&emsp;技术可行性评估对于假想的软件系统需要实现的功能和性能，以及技术能力约束。技术可行性分析可通过“提问—回答”的方式来进行论证，包括：
1. 技术  
&emsp;&emsp;现有的技术能力和 IT 技术的发展现状足以支持想象中的系统目标实现吗？
2. 资源  
&emsp;&emsp;现有的资源（掌握技术的职员、公司的技术积累、构件库、软硬件条件等）足以支持项目实施吗？技术风险在评估的哪个范围内？
3. 目标  
&emsp;&emsp;在目前设定的系统目标中，哪些目标会遭遇到较强的技术障碍？尤其是那些被设定为必须实现的系统目标。

&emsp;&emsp;由于在可行性研究阶段，项目的目标是比较模糊的，因此技术可行性最好与项目功能、性能和约束的定义同时进行。在可行性研究阶段，调整开发目标和选择可行的技术体系均是可用的手段，而一旦项目进入开发阶段，任何调整都意味着更多的开销。  
&emsp;&emsp;需要再次指出的是，技术可行性绝不仅仅是论证在技术上是否可实现，实际上还包含了在当前资源条件下的技术可行性。  
&emsp;&emsp;投资不足、时间不足、预设的开发目标技术难度过大、没有足够的技术积累、没有熟练的职员可用、没有足够的合作公司和外包资源积累等均是技术可行性的约束。软件系统的技术评估者通常都只考虑技术手段是否能实现而忽视了当前的资源条件和环境，从而对技术可行性研究得出了过于乐观的结果，这种错误判断对后期的项目实施会导致灾难性的后果！  
&emsp;&emsp;加强前期的项目调研、寻求专家的咨询以及采用具有大量成功应用案例、被广泛支持的技术标准和事实标准等均有助于改善项目的技术可行性。
#### 3．法律可行性
&emsp;&emsp;法律可行性评估可能由系统开发引发的侵权或法律责任，可能包括合同的订立和条款，职责、侵权情况的设定，违约、争议的解决等方方面面的内容。法律可行性还包括国家政策和法律的限制，例如：在政府信息化的领域中使用未被认可的加密算法或未经许可在产品中使用了其他公司被保护的软件技术、构件等。
#### 4．执行可行性
&emsp;&emsp;执行可行性也称操作可行性，它主要评估预期的软件系统在真实环境中能够被应用的程度和实施过程中障碍。例如：ERP 系统建成后的数据采集和数据质量问题，或客户工作人员没有足够的 IT 技能等。这些问题虽然与软件系统本身无关，但如果不经评估，很可能会导致投入巨资建成的软件系统毫无用处。  
&emsp;&emsp;执行可行性还需要评估对用户的各种影响，包括对现有 IT 设施的影响、对用户组织机构的影响、对现有业务流程的影响、对地点的影响、对经费开支的影响等。如果某项影响会过多改变客户的现状，需要将这些因素作进一步的讨论并和软件系统的使用者进行沟通，提出建议的解决方法。
#### 5．方案的选择
&emsp;&emsp;评估系统或产品开发的可选方法。一般来说，同样的项目，可以采用不同的方法来实现。甚至一个大项目的若干个子系统的实现方法也不一样。如何进行系统分解、如何定义各子系统的功能、性能和界面，实现方案不唯一。可以采用折中的方法，反复比较各个方案的成本和效益，选择可行的方案。

### 7.2.2 成本效益分析
&emsp;&emsp;效益分析实际上包含了“成本—收益”的分析。从内容上来看，效益分析是可以包含在可行性研究的经济可行性分析中的。但效益分析的目的在于，对项目开发目标的成本及可度量的项目现金收入和无形收益进行一次专门化的评估。这种以经济回报为收益的评估结果，是得到企业管理、决策层批准项目实施的重要因素。  
&emsp;&emsp;效益分析中的成本分析，将尽可能地列举所有项目涉及的直接财务支出数字，以便管理层协调和制订各种资源的支出计划。效益分析中的收益分析，将尽可能清晰地列举实施项目带来的各种直接经济收益和无形收益，以便管理层理解项目的价值和给予项目资源上的支持。否则，一旦项目所需要的各种资源不能按计划投入，项目失败的风险将大大增加，并且除了变更项目预设的开发目标外，几乎没有可供选择的应急方案。
#### 1．项目可能涉及的成本
&emsp;&emsp;项目的成本部分，通常包括：
* 基础建设支出  
&emsp;&emsp;如房屋和设施，办公设备，平台软件，必需的工具软件等购置费用。
* 一次性支出  
&emsp;&emsp;如研究咨询费用、调研费、管理费用、培训费、差旅费、其他一次性杂费等。
* 运行维护费用  
&emsp;&emsp;如设备租金和定期维护费用、定期消耗品支出、通信费、人员工资奖金、房屋租金、公共设施维护及其他经常性的支出项目。
#### 2．项目可能涉及的收益
&emsp;&emsp;项目的收益，通常可以分为`一次性收益`、`非一次性收益`和`不可定量的收益`三个部分。
1. 一次性收益
    * 开支的缩减  
    &emsp;&emsp;包括改进了的系统的运行所引起的开支缩减，如资源要求的减少，运行效率的改进，数据进入、存储和恢复技术的改进，系统性能的可监控，软件的转换和优化，数据压缩技术的采用，处理的集中化和分布化等。
    * 价值的增升  
    &emsp;&emsp;包括由于一个应用系统的使用价值的增升所引起的收益，如资源利用的改进，管理和运行效率的改进及出错率的减少等。
    * 其他  
    &emsp;&emsp;如从多余设备出售回收的收入等。
2. 非一次性收益  
&emsp;&emsp;在整个系统生命期内由于运行所建议系统而导致的按月的、按年的能用人民币表示的收益，包括开支的减少。
3. 不可定量的收益  
&emsp;&emsp;无法直接用人民币表示的收益，如服务的改进，由操作失误引起的风险的减少，信息掌握情况的改进，组织机构给外界形象的改善等。有些不可捉摸的收益只能大概估计或进行极值估计（按最好和最差情况估计）。
#### 3．效益分析的若干指标和进一步的分析
1. 收益/投资比  
&emsp;&emsp;软件项目实施后整个系统生命期的收益/投资比值。
2. 投资回收周期  
&emsp;&emsp;收益的累计数开始超过支出的累计数的时间。
3. 敏感性分析  
&emsp;&emsp;分析项目中的一些关键性因素如系统生命期长度、系统的工作负荷量、工作负荷的类型、处理速度、设备和软件的配置等因素发生变化或进行合理搭配时，对开支和收益的影响最灵敏的范围估计。通常当项目需要在不同因素之间取舍和调整的时候，需要参考敏感性分析的内容。

### 7.2.3 可行性分析报告
&emsp;&emsp;在国家标准《GB8567-1988》中，规定了可行性分析报告的详细格式和内容。这个规范文本基本上涵盖了可行性分析需要考察的问题，可作为书写可行性研究报告的参考文档模板。 不管可行性报告的形式如何，最重要的内容应当有以下几项。

* 项目背景：包括问题描述、实现环境和限制条件；  
* 管理概要和建议：包括重要的研究结果、说明、建议和影响；  
* 候选方案：包括候选系统的配置和最终方案的选择标准；  
* 系统描述：包括系统工作范围的简要说明和被分配系统元素的可行性；  
* 经济可行性（成本/效益分析）：包括经费概算和预期的经济效益；  
* 技术可行性（技术风险评价）：包括技术实力、已有工作基础和设备条件；  
* 法律可行性：包括系统开发可能导致的侵权，违法和责任等；  
* 用户使用可行性：包括用户单位的行政管理，工作制度和使用人员的素质；  
* 其他与项目有关的问题：例如，其他方案介绍和未来可能的变化。  
* 可行性研究报告首先由项目负责人审查（审查内容是否可靠），再上报给上级主管审阅（评估项目的地位）。从可行性研究报告中应当得出“行或不行”的决断。

## 7.3 方案的制订和改进
&emsp;&emsp;在系统方案阶段，主要完成的工作则是解释“系统如何实现”的问题。系统方案制订的最主要内容，包括以下几个方面。
### 7.3.1 确定软件架构
&emsp;&emsp;在问题定义阶段得到的软件概念模型使用各种工具定义了项目的开发目标。在系统方案制订阶段才开始真正考虑如何去实现软件。其中最重要的工作，就是制定系统的实现架构。  
&emsp;&emsp;系统的实现架构与一些很具体的方面相关：
1. 分析模型的结构  
&emsp;&emsp;例如，采用结构化分析方法得到的功能分解体系，或面向对象的类和“对象－关系图”、“对象－行为图”。
2. 一些对应于系统目标的最基本、最重要的实现要素  
&emsp;&emsp;例如，关键的用例、最主要的控制类、对象组织的模式、常用和最关键的实现算法模型等。这些实现要素对应于系统目标实现最重要的场景，表示了整个系统最主要的控制流程和实现机制。
3. 特性和要点的解释  
&emsp;&emsp;这些附加的内容解释系统的一些特性、服务等是如何实现的。
### 7.3.2 确定实现的各种关键性要素和实现手段关键性的实现要素
&emsp;&emsp;通常包括：
* 关键的用例、最主要的控制类、功能和服务的首要组织方式（例如网站首页）；
* 对象的组织模式；
* 常用和最关键的实现算法模型。关键性的实现手段通常包括：
* 选定基础计算平台，如操作系统、数据库、Web 服务器、中间件平台等；
* 选定开发工具和开发环境，如计算机语言、构件库、工具软件等。
### 7.3.3 归结目标到最适合的计算体系
&emsp;&emsp;通常，提供开发工具和开发环境的组织总是有一些标准的计算体系可以选择（例如.NET和 J2EE 等），因此对于大多数系统开发项目来说，比较各种标准计算体系与预期目标之间的匹配程度即可选定计算体系。选择标准的计算体系去实现系统可以忽略大多数基础平台和底层支撑技术的实现问题，从而大大提高系统的质量、降低开发风险和成本。开发人员常根据基础平台的系统实现能力支持，公司或项目组在特定实现平台上的技术积累，甚至技术的“先进性”或流行程度这样的因素去选择系统的实现技术体系。  
&emsp;&emsp;在另一些情况下，出于各种诸如用户投资力度，与用户现有的 IT 设施保持一致性、兼容性、扩展性及未来维护的能力等因素，系统的基础平台很可能在项目的论证阶段就已经被确定，如操作系统、数据库系统、Web 服务器、开发工具或开发环境等。在这种情况下，系统的实现体系实际上已经确定。  
&emsp;&emsp;通过同时参考系统概念模型，将前面得到的系统功能清单和系统实现的各种关键要素整理并分类，然后与现有的技术、标准的实现体系进行比较和匹配，就可以将系统概念模型定义的系统目标，进一步映射到真正可计算、可实现的系统架构上。这个过程可以理解为一种不断归结、比较并匹配的过程。  
&emsp;&emsp;进行匹配的过程常常是一种双向的选择和探究过程，一方面拿出一个系统目标中的功能或实现要素，询问：这部分功能属于表示层、业务逻辑、还是数据服务？另一方面，也研究标准计算体系提供的功能，例如：放在业务逻辑层合适吗？技术人员具有这方面的开发经验积累吗？甚至是标准构件或服务可用吗？   
&emsp;&emsp;各种标准的计算体系可能很复杂，但通常总是包括一些逻辑上的划分，例如，.NET 体系将应用系统理解为表示层、事务逻辑层和数据服务层三个层次构成。
1. 表示层  
&emsp;&emsp;用户的界面部分。例如，单一应用程序的用户界面、C/S 计算模式的客户端、B/S 模式在浏览器中运行的 HTML、DHTML、Scripting、JavaApplet、ActiveX 等。
2. 事务逻辑层  
&emsp;&emsp;负责处理表示层的应用请求，完成商务逻辑的计算任务，并将处理结果返回给用户。事务逻辑处理层是将原先置于客户端的事务逻辑分离出来，集中置于服务器部分，为所有用户共享。事务逻辑层是整个应用的核心部分，而组件对象模型 COM 则相当于其心脏。事务逻辑层通过 COM 进行事务处理，并由 IIS（Internet Information Server，Internet 信息服务器）和 MTS（Microsoft Transaction Server，微软事务处理服务器）为各种应用组件提供完善的管理。
3. 数据服务层  
&emsp;&emsp;为应用提供数据来源。和以往的两层架构不同，数据库不再和每个活动客户保持一个连接，而是若干个客户通过应用逻辑组件共享数据库的连接，从而减少连接次数，提高数据服务器的性能和安全性。

&emsp;&emsp;相同的三层计算模式，也会表现为不同的实现方式。例如，表示层可能是单一应用系统的用户界面、C/S 计算的客户端、或 B/S 计算的 Web 页面和元素；事务逻辑层可能是单一应用系统的程序模块、C/S 的服务器端服务、B/S 应用服务器中的业务脚本或业务对象；当利用类似存储过程来实现数据操作逻辑的时候，存储过程也被看作事务逻辑层的一部分，但如果利用 ADO（ActiveX Data Object，ActiveX 数据对象）这样的数据访问组件访问数据时，ADO 和后台的数据库系统及数据库的逻辑则被看作数据服务层的一部分。  
&emsp;&emsp;在必要的情况下，某个层次还可能进一步细分，例如，使用面向对象设计方法的系统常常会将事务逻辑层划分为基本的计算对象、业务对象及黏合业务对象实现功能的脚本 “胶水”或一些控制类。  
&emsp;&emsp;不同标准的计算体系的逻辑划分，甚至同一个计算体系的不同版本，通常也不会套用这样的三层分类方式，但却有类似之处。下图表示了利用 JSP 开发 Web 程序的计算模式。JSP 页面构成了前端的表示层，EJB 构成了业务逻辑层，JDBC（Java DataBase Connectivity，Java 数据库连接）和后台的数据库构成了数据服务层。

![利用 JSP 开发 Web 程序的计算模式](https://pic.lufer.cc/images/2021/03/15/sI0gvF.png)

&emsp;&emsp;对于小规模的网站系统，开发者可能直接在 JSP 页面中书写所有的应用逻辑脚本，这样业务逻辑层就和表示层合并了，而对于使用 J2EE 体系的开发人员来说，利用 EJB 的容器、对象操作语言等机制直接实现了对象级的接口，开发人员直接在业务逻辑层去构思应用，JDBC 和后台数据库系统的数据服务层被隐含在 J2EE 的平台机制内，在更高的抽象级别上被屏蔽。  
&emsp;&emsp;因此，归结系统实现要素到计算体系的时候，要点在于理解各种计算体系的大致分层和构成，比较实现要素的目标和实现手段之间的“适合程度”，而不是生搬硬套某种实现机制，或盲目追求某种“流行的”或“先进的”算体系。
系统方案制订后，需要根据有关标准进行评价，找出不符合实际的地方，然后进行改进。

## 7.4 新旧系统的分析和比较
&emsp;&emsp;计算机技术飞速发展，日新月异，许多企业因为业务发展的需要和市场竞争的压力，需要建设新的企业信息系统。在这种升级改造的过程中，怎么处理和利用那些历史遗留下来的老系统，成为影响新系统建设成败和开发效率的关键因素之一。通常称这些老系统为遗留系统。  
&emsp;&emsp;目前，学术和工业界对遗留系统的定义没有统一的意见。Bennett 在 1995 年对遗留系统做了如下的定义：遗留系统是不知道如何处理但对组织又至关重要的系统。Brodie 和Stonebraker 对遗留系统的定义如下：遗留系统是指任何基本上不能进行修改和演化以满足新的变化了的业务需求的信息系统。  
&emsp;&emsp;笔者认为，遗留系统应该具有以下特点：
1. 系统虽然能完成企业中许多重要的业务管理工作，但已经不能完全满足要求。一般实现业务处理电子化及部分企业管理功能，很少涉及经营决策。
2. 系统在性能上已经落后，采用的技术已经过时。如多采用主机/终端形式或小型机系统，软件使用汇编语言或第三代程序设计语言的早期版本开发，使用文件系统而不是数据库。
3. 通常是大型的系统，已经融入企业的业务运行和决策管理机制之中，维护工作十分困难。
4. 系统没有使用现代系统工程方法进行管理和开发，现在基本上已经没有文档，很难理解。

&emsp;&emsp;在企业信息系统升级改造过程中，如何处理和利用遗留系统，成为新系统建设的重要组成部分。处理恰当与否，直接关系到新系统的成败和开发效率。遗留系统的演化方式可以有很多种，根据系统的技术条件、商业价值及维护和运行系统的组织特征不同，可以采取继续维护、某种形式的重构或替代策略，或者联合使用几种策略。究竟采用哪些策略来处理遗留系统，需要根据对遗留系统的所有系统特性的评价来确定。
### 7.4.1 遗留系统的评价方法
&emsp;&emsp;对遗留系统评价的目的是为了获得对遗留系统更好的理解，这是遗留系统演化的基础，是任何遗留系统演化项目的起点。本文的评价方法包括度量`系统技术水准`、`商业价值`和`与之关联的组织特征`，其结果作为选择处理策略的基础。  
&emsp;&emsp;评价方法由一系列活动组成，如下图所示。

![评价活动](https://pic.lufer.cc/images/2021/03/15/sIBWz8.png)

#### 1．启动评价
&emsp;&emsp;评价是为了获得对遗留系统的足够深度的理解，从技术、商业和企业角度对系统的理解为系统处理策略提供基础，开始评价前，需要了解以下问题。
1. 对企业来说，遗留系统是否是至关重要的  
&emsp;&emsp;在评价过程中，可能会发现系统对企业的继续运作产生的影响不大。在这种情况下，就没有必要考虑系统的演化问题。
2. 企业的商业目标是什么  
&emsp;&emsp;从商业观点来看，评估师必须理解企业的商业目标，因为商业目标产生演化需求。
3. 演化需求是什么  
&emsp;&emsp;演化需求来自企业的商业目标和评价活动。需求必须是可见的，以便决定已存在的系统是否能满足需求。
4. 所期望的系统寿命多长  
&emsp;&emsp;一个系统的寿命由软件和硬件的服务能力决定，一旦系统硬件或支撑软件过时，系统的有效性就受到限制。
5. 系统使用期限多久  
&emsp;&emsp;如果系统的使用期限只是短期的，就没有必要花费成本来演化系统。相反，如果系统将在相当长的时期内支持主要业务流程，则必须进行演化。
6. 系统的技术状态如何  
&emsp;&emsp;例如，如果应用软件的技术状况很差，则很难理解，维护费用会很高。
7. 企业是否愿意改变  
&emsp;&emsp;企业对改变的态度是遗留系统演化成功的关键因素之一。
8. 企业是否有能力承受演化  
&emsp;&emsp;企业的技术成熟度，员工的素质，支撑工具的级别等都是影响演化的因素。
#### 2．商业价值评价
&emsp;&emsp;商业价值评价的目标是判断遗留系统对企业的重要性。在多数情况下，重要业务过程的改变意味着旧的系统现在仅仅具有外围价值，修改这种系统只需花费少许财力和物力。  
&emsp;&emsp;在其他情况下，系统的业务价值很大，需要继续维护运行。可以在概要和详细两个级别上进行遗留系统的商业价值评价。

&emsp;&emsp;概要级评价将为更加详细的分析提供信息。概要级评价包括：
1. 咨询  
&emsp;&emsp;向有关专家进行咨询，包括最终用户和负责业务处理的管理人员。
2. 评价问卷  
&emsp;&emsp;问卷应该标识系统在业务处理过程中的哪些地方使用，本系统与其他系统的关系，如果系统不再运行所需的代价，系统已有的缺点和存在的问题等。问题的准确性依赖于所评价的系统。
3. 进行评价  
&emsp;&emsp;有了问卷的基础后，必须认真分析系统是如何使用的，这往往会发现系统的价值，而这在问卷中是得不到的。

>详细级评价包括应用系统不符合业务规范的风险分析，这种分析十分费时，最好由业务分析师来完成详细级的评价。
#### 3．外部环境评价
&emsp;&emsp;外部环境评价系统的外部技术环境是指硬件、支撑软件和企业基础设施的统一体。
1. 硬件  
&emsp;&emsp;系统硬件包括许多需要进行常规性维护的部件，这些硬件或者在一个站点，或者分布在许多站点并由网络连接。一般来说，遗留系统的硬件包括主机和小型机、磁盘驱动器、磁带、终端、打印机和网络硬件。  
&emsp;&emsp;与商业价值评价类似，硬件评价也可以分为概要级评价和详细级评价。概要级评价把遗留系统作为一个整体，提供硬件质量估计。详细级评价包括识别系统中的每个部件。在这两种情况下，必须识别一系列特征，用作评价的基础。特征的选择取决于要评价的系统，系统的一些常见特征有供应商、维护费用、失效率、年龄、功能、性能等。  
&emsp;&emsp;具体评价方法是：每一个部件（或整个系统）在每个特征上分配一个价值分数（取值为1～4），然后把所有分数相加，获得该部件的总分。
2. 支撑软件  
&emsp;&emsp;系统的支撑软件环境也由许多部分组成，可包括操作系统、数据库、事务处理程序、编译器、网络软件、应用软件等。一般来说，支撑软件是依赖于某个硬件的，应用软件依赖于系统软件。在评价过程中，必须考虑这种依赖性。支撑软件的评价方法类似于硬件评价，在此省略。
3. 企业基础设施  
&emsp;&emsp;企业基础设施包括开发和维护系统的企业职责和运行该系统的企业职责（两者可能为同一个企业），这些基础设施是很难评价的，但对遗留系统的演化起关键作用。因此必须考虑以下问题：

1. 企业和使用者的类型  
&emsp;&emsp;企业或者有自己的系统开发队伍，或者所有开发和应用管理都是请其他企业完成。系统用户或许只重复一些记录性工作，或许包括一些更有技术性的工作。开发组织的技术成熟度。  
2. 开发组织的技术成熟度  
&emsp;&emsp;包括是否使用了现代系统工程方法，是否遵循了统一的标准，是否进行了过程改进等。  
3. 企业的培训过程  
&emsp;&emsp;如果企业（包括开发方和客户方）的培训做得好，遗留系统的演化可能会更成功。  
4. 系统支持人员的技术水平  
&emsp;&emsp;如果系统支持人员的水平和经验不够，就不要急于对系统做大的改动。  
5. 企业是否愿意改变  
&emsp;&emsp;企业对改变的态度是遗留系统演化成功的关键因素之一。企业基础设施的评价方法类似于硬件评价，在此省略。
#### 4．应用软件评价
&emsp;&emsp;应用软件评价也有两个级别。
1. 系统级  
&emsp;&emsp;把整个系统看作是不可分的原子，评价时不考虑系统的任何部分。
2. 部件级  
&emsp;&emsp;关注系统的每个子系统，考虑每个子系统的特征，包括复杂性、数据、文档、外部依赖性、合法性、维护记录、大小、安全性等。

&emsp;&emsp;具体评价方法也与硬件评价类似，在此省略。
#### 5．分析评价结果评价
&emsp;&emsp;活动将产生硬件、支撑软件、企业基础设施和应用软件的特征值矩阵，这些特征值体现了遗留系统当前的技术因素，其加权平均值代表了系统的技术水平。  
&emsp;&emsp;计算公式如下：

$$OR=(P1ORH+P2ORS+P3OAF+ P4ORA)/4$$

&emsp;&emsp;其中 ORH 是硬件的评价值，ORS 是支撑软件的评价值，ORF 是企业基础设施的评价值，ORA 是应用软件的评价值，Pi (1 i 4) 分别是它们的权系数，即第 i 个评价值对遗留系统的影响因子。  
&emsp;&emsp;把对技术水平的全面评价结果与商业评价进行比较，可以为系统演化提供第一手的资料。具体方法是按照商业评价分值和技术水平分值的情况，把评价结果分为四种类型，如下图所示。

![评价结果分析](https://pic.lufer.cc/images/2021/03/15/sIrRKS.png)

### 7.4.2 遗留系统的演化策略
&emsp;&emsp;在评价结果分析图中，把对遗留系统的评价结果分列在坐标的四个象限内。对处在不同象限的遗留系统采取不同的演化策略。
#### 1．淘汰策略
&emsp;&emsp;第 3 象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的商业价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。  
&emsp;&emsp;完全淘汰是一种极端性策略，一般是企业的业务产生了根本的变化，遗留系统基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。  
&emsp;&emsp;对遗留系统的完全淘汰是企业资源的根本浪费，应该善于“变废为宝”，通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。
#### 2．继承策略
&emsp;&emsp;第 4 象限为低水平、高价值区，即遗留系统的技术含量较低，可满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业业务对该系统仍有很大的依赖性。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。  
&emsp;&emsp;要做到对遗留系统的继承，必须对系统进行分析，得到旧系统的功能模型和数据模型，这种分析可以部分代替或验证系统的需求分析。  
&emsp;&emsp;如果遗留系统的维护文档不完整，而又必须解析系统的功能模型和数据模型，那将是一项十分艰巨的任务。这时可使用有关系统重构的 CASE 工具，通过分析系统的代码生成系统结构图或其他报告。
#### 3．改造策略
&emsp;&emsp;第 1 象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有较大的生命力，且具有较高的商业价值，基本上能够满足企业业务运作和决策支持的要求。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。  
&emsp;&emsp;这些改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变。数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型转化的过程。
#### 4．集成策略
&emsp;&emsp;第 2 象限为高水平、低价值区，即遗留系统的技术含量较高，但其商业价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但从企业全局来看，多个这样的系统，他们各自基于不同的平台，不同的数据模型，无法互联互通，数据还不一致，这就是很严重的问题了。  
&emsp;&emsp;对这种遗留系统的演化策略为集成。  
&emsp;&emsp;在集成过程中，可采用由互连系统构成的系统的架构，遗留系统可作为从属系统来描述。在企业信息系统建设过程中，如何处理那些遗留系统，将会是越来越突出的问题，因为即使是今天看来很先进的系统在明天也会成为遗留系统。对遗留系统的处理恰当与否，直接关系到新系统的成败和开发效率。如何建立一套系统的、行之有效的方法，以期望对实际工作有所指导，已成为一个迫切的问题。在实际工程项目中，遇到处理遗留系统的问题时，要具体情况具体分析，选择最佳的演化策略。

# 第八章 系统分析与设计方法
&emsp;&emsp;对于架构设计师而言，如何进行系统设计是其“看家本领”，而设计是在对系统进行分析的基础上进行的，否则，设计就是“无米之炊”。从软件开发项目中的角色分配来看，系统架构设计师应该在信息系统项目管理师的协调下，与系统分析师协同工作。
## 8.1 定义问题与归结模型
&emsp;&emsp;软件系统的目的是解决问题，因此在建模之初最重要的步骤是对问题的分析与定义，并在此基础上归结模型，这样才能够获得切实有效的模型。定义问题的过程包括：理解真实世界中的问题和用户的需要，并提出满足这些需要的解决方案的过程。
### 8.1.1 问题分析
&emsp;&emsp;问题分析的目标就是在开发之前对要解决的问题有一个更透彻的理解。为了达到这一目标，通常需要经过在问题定义上达成共识，理解问题的本质，确定项目干系人和用户，定义系统的边界和确定系统实现的约束这五个步骤。
#### 1．在问题定义上达成共识
&emsp;&emsp;要检验大家是否在问题的定义上达成了共识，最简单的方法就是把问题写出来，看看是否能够获得大家的认可。而要使得这个过程更加有效，应该将问题用标准化的格式写出来，根据 UP 的建议，应该包括以下几个方面的要素。
1. 问题概述  
&emsp;&emsp;用简短的几句话，将所理解的问题本质描述出来；
2. 影响  
&emsp;&emsp;说明该问题将会对哪些项目干系人（Stakeholder，风险承担者）产生影响；
3. 结果  
&emsp;&emsp;确定问题对项目干系人和商业活动会产生什么样的影响；
4. 优点  
&emsp;&emsp;概要性地提出解决方案，并列举出该解决方案的主要优点。

&emsp;&emsp;在问题定义上达成共识，就能够有效地将开发团队的理解与用户的需求达成一致，这样就能够使得整个系统的开发沿着合理的方向发展。
#### 2．理解问题的本质
&emsp;&emsp;每一句描述都会夹杂着叙述者的个人理解和判断，因此透过表面深入本质，理解问题背后的问题，是问题分析阶段一个十分关键的任务。其中一种技术是“根本原因”分析，这是一种提示问题或其表象的根本原因的系统化方法。在实际的应用中，常使用`因果鱼骨图`和`帕累托图`两种方法。
1. 因果鱼骨图  
&emsp;&emsp;因果鱼骨图是一种有效的探寻问题根源的技术，它通过直观的图形找出问题或现象的所有潜在原因，从而追踪出问题的根源。它能够帮助人们将问题的原因而放在首位，提供了一种运用集体智慧解决问题的方法。在使用时，通常按照以下步骤进行。  
&emsp;&emsp;将问题简明扼要地写在右边的方框里；  
&emsp;&emsp;确定问题潜在原因的主要类别，将它们连到鱼的脊骨上；  
&emsp;&emsp;用头脑风暴法寻找原因并归类。  
&emsp;&emsp;下图是鱼骨图的一个示例。  
![鱼骨图示例](https://pic.lufer.cc/images/2021/03/15/sjMluQ.png)  
2. 帕累托图。  
&emsp;&emsp;帕累托图是采用直方图的形式，根据问题的相对频率或大小从高往低降序排列，帮助设计师将精力集中在重要的问题上。它为 80%的问题找到关键的 20%的原因，它可以一目了然地显示出各个问题的相对重要程度，有助于预防在解决了一些问题后，却使另外一些问题变得更糟的现象发生。在使用时，通常按照以下步骤进行。  
&emsp;&emsp;明确问题：也就是前面达成共识的问题定义；  
&emsp;&emsp;找出问题的各种可能原因：通常可以利用头脑风暴来收集意见，并通过参考以往积累的资料和运营的数据来综合分析；  
&emsp;&emsp;选择评价标准和考察期限：最常用的评价标准包括频率（占总原因的百分比）和费用（产生的影响），而考察的期限则应具有相应问题的代表性，并不是越长越好；  
&emsp;&emsp;收集各种原因发生的频率及费用数据；  
&emsp;&emsp;将原因按照发生的频率或费用从大到小排列起来；  
&emsp;&emsp;将原因排在横轴上，频率或费用排列在纵轴上，形成如下图所示的结果。  
&emsp;&emsp;这样就能够将造成问题的关键原因捕获出来，以便指导设计出更符合需要、更能够解决问题的解决方案。  
![帕累托图示例](https://pic.lufer.cc/images/2021/03/15/sjMRgO.png)  
#### 3．确定项目干系人和用户
&emsp;&emsp;要想有效地解决问题，必须了解用户和其他相关的项目干系人（任何将从新系统或应用的实现中受到实质性影响的人）的需要。不同的项目干系人通常对问题有不同的看法和不同的需要，这些在解决问题时必须加以考虑。事实上，许多项目干系人就是系统的用户，这一部分通常是易于识别的；但还有一部分项目干系人是系统的间接用户，甚至只是受系统影响的商业结果，这一部分不易识别，但十分重要。  
&emsp;&emsp;在寻找项目干系人时，可以思考：系统的用户是谁？系统的客户（购买者）是谁？还有哪些人会受到系统输出的影响？系统完成并投入使用后，有谁会对它进行评估？还有没有其他系统内部或外部的客户，他们的需要有没有必要去考虑？系统将来由谁来维护？
#### 4．定义系统的边界
&emsp;&emsp;系统的边界是指解决方案系统和现实世界之间的边界。在系统边界中，信息以输入和输出的形式流入系统并由系统流向系统外的用户，所有和系统的交互都是通过系统和外界的接口进行的。在定义系统的边界时，将世界分为两个部分：系统及与系统进行交互的事物。要描述系统的边界有两种方法：一种是结构化分析中的“上下文范围图”，另一种则是面向对象分析中的“用例模型”。

1. 上下文范围图  
&emsp;&emsp;也就是数据流图中的顶层图，它是一个反��领域信息的模型，能够清晰地显示出系统的工作职责和相邻系统的职责起止之处，从而让读者能够从宏观的层面去了解系统。下图就是一个描述“证券经纪人系统”的上下文范围图。  
![上下文范围图示例](https://pic.lufer.cc/images/2021/03/15/sjQmZ9.png)  
2. 用例模型  
&emsp;&emsp;用例模型则通过引入参与者来描述“和系统进行交互的事物”，只要识别了参与者，自然而然系统的界限就确定下来了。在寻找参与者时，可以思考以下问题：谁会对系统提供信息？谁会在系统中使用信息？谁会从系统中删除信息？谁将操作系统？系统将会在哪里被使用？系统从哪里得到信息？哪些外部系统要和系统进行交互？  
&emsp;&emsp;然后，再根据每个参与者的功能需求，识别出代表系统功能的用例，从而界定系统的边界。而关于用例模型的更多细节，请参考 [8.4.3](#8.4.3-统一建模语言) 节。
#### 5．确定系统实现的约束
&emsp;&emsp;由于各种因素的存在，会对解决方案的选择造成一定的限制，称这种限制为约束。每条约束都将影响到最后的解决方案的形成，甚至会影响是否能够提出解决方案。  
&emsp;&emsp;在考虑约束时，首先应该考察到不同的约束源，其中包括进度、投资收益、人员、设备预算、环境、操作系统、数据库、主机和客户机系统、技术问题、行政问题、已有软件、公司总体战略和程序、工具和语言的选择、人员及其他资源限制等。

### 8.1.2 问题定义
&emsp;&emsp;通过对问题进行细致周密的分析，就可以对其进行综合的定义。对于一个问题的完整定义，通常应包括目标、功能需求和非功能需求三个方面。
#### 1．目标
&emsp;&emsp;目标是指构建系统的原因，它是最高层次的用户需求，是业务上的需要，而功能、性能需求则必须是以某种形式对该目标做出贡献。在描述目标时，应该注意以下几个方面。
* 优势：目标应该不仅仅是解决问题，还要提供业务上的优势；
* 度量：不仅要说明业务的优势，而且还必须提供度量这种优势的标准；
* 合理性：要确保完成解决方案所需的工作量少于所获得的业务优势，这才是合理的解决方案；
* 可行性：要探寻能够满足度量标准的解决方案；
* 可达成性：对于组织而言，是否具备获取该系统的技能，构建完成后是否能够操作它。

&emsp;&emsp;例如，下面就是一个很好的目标描述的例子。
>目标：在冬季道路养护支出上节省费用  
>优势：减少除冰和道路养护的费用  
>度量标准：除冰费用将在目前道路养护费用的基础上降低25%，冰对道路的损伤将降低50% 

#### 2．功能需求
&emsp;&emsp;功能需求是用来指明系统必须做的事情，只有这些行为的存在，才有系统存在的价值。功能需求应该源于业务需求，它只与问题域相关，与解决方案域无关。也就是说，功能需求是在与用户或某个业务人员交谈时，他们所描述的内容是为了完成他们某部分的工作而必须做的事情。而在设计解决方案时，会遇到一些限制条件，这些东西也是“系统需求” 的一部分，不过应该是设计约束或非功能需求形式指定。  
&emsp;&emsp;在规定功能需求时要注意其详细程度。由于这些需求是业务需求，因此应该由业务人员来验证。也就是说，用户应该能够指明系统要达到有用的程度，功能是否已经足够；考虑到工作的成果，它的功能是否正确。另外，在描述功能需求时，应该注意需求的二义性。而二义性主要体现在以下几个方面:
1. 同名异义的词  
&emsp;&emsp;在自然语言中存在许多同名但异义的词语，应该谨慎地排除它们带来的影响。
2. 代词  
&emsp;&emsp;在需求描述中，代词经常会产生指代不明的现象，应该尽量避免使用，而是换成主语及宾语。
#### 3．非功能需求
&emsp;&emsp;非功能需求是系统必须具备的属性，这些属性可以看作是一些使产品具有吸引力、易用、快速或可靠的特征或属性。非功能需求并不改变产品的功能，它是为工作赋予特征的。在识别功能需求和非功能需求时，有一种十分有用的思维模式：功能需求是以动词为特征的，而非功能性需求则是以副词为特征的。非功能需求主要包括以下几种:
1. 观感需求  
&emsp;&emsp;即产品外观的精神实质，也就是与用户界面的观感相关的一组属性。
2. 易用性需求  
&emsp;&emsp;也就是产品的易用性程度，以及特殊的可用性考虑，通常包括用户的接受率、因为引入该产品而提高的生产效率、错误率、特殊人群的可用性等指标。
3. 性能需求  
&emsp;&emsp;也就是关于功能实现要求有多快、多可靠、多少处理量及多精确的约束。例如：速度、精度、安全性、容量、值范围、吞吐量、资源使用效率、可靠性（平均无故障时间）、可用性（不停机时间）、可扩展性等。
4. 可操作性需求  
&emsp;&emsp;衡量产品的操作环境，以及对该操作环境必须考虑的问题。
5. 可维护性和可移植性需求  
&emsp;&emsp;期望的改变，以及完成改变允许的时间。
6. 安全性需求  
&emsp;&emsp;产品的安全保密性，通常体现为保密性、完整性和可获得性。
7. 文化和政策需求  
&emsp;&emsp;由产品的开发者和使用者所带来的特别需求。
8. 法律需求  
&emsp;&emsp;哪些法律和标准适用于本产品。
## 8.2 需求分析与软件设计
&emsp;&emsp;需求分析是软件生命周期中相当重要的一个阶段。根据 Standish Group 对 23000 个项目进行的研究结果表明，28%的项目彻底失败，46%的项目超出经费预算或者超出工期，只有约 26%的项目获得成功。需求分析工作在整个软件开发生命周期中有着十分重要的意义。而在这些高达 74%的不成功项目中，有约 60%的失败是源于需求问题，也就是差不多有一半的项目都遇到了这个问题，这一可怕的现象引起人们对需求分析的高度重视。需求分析阶段的主要任务是通过开发人员与用户之间的广泛交流，不断澄清一些模糊的概念，最终形成一个完整的、清晰的、一致的需求说明。  
&emsp;&emsp;而当明确了用户的需求之后，下一步的任务就是对未来的软件系统进行设计，它是确定系统实现的关键工作。需求分析和设计的方法对软件开发过程而言是十分重要的，因此必须扎实地掌握它。  
&emsp;&emsp;需求分析与软件设计是软件生存期中最重要的两个步骤，需求分析解决的是“做什么”的问题，系统设计则是解决“怎么做”的问题。

### 8.2.1 需求分析的任务与过程
&emsp;&emsp;需求分析所要做的工作是深入描述软件的功能和性能，确定软件设计的限制和软件同其他系统元素的接口细节，定义软件的其他有效性需求，细化软件要处理的数据域。用一句话概括就是：需求分析主要是确定待开发软件的功能、性能、数据、界面等要求。需求分析的实现步骤通常包括：`获取当前系统的物理模型`，`抽象出当前系统的逻辑模型`，`建立目标系统的逻辑模型`三个部分。具体来说，需求分析阶段的工作可以分成 4 个方面：
1. 问题识别  
&emsp;&emsp;用于发现需求、描述需求，主要包括功能需求、性能需求、环境需求、可靠性需求、安全保密需求、用户界面需求、资源使用需求、软件成本消耗与开发进度需求，以此来预先估计以后系统可能达到的目标。
2. 分析与综合  
&emsp;&emsp;就是对问题进行分析，然后在此基础上整合出解决方案。这个步骤经常是反复进行的，常用的方法有面向数据流的结构化分析方法（Structured Analysis，SA），面向数据结构的 Jackson 方法，面向对象的分析方法（Object Oriented Analysis，OOA），以及用于建立动态模型的状态迁移图和 Petri 网。
3. 编制需求分析的文档  
&emsp;&emsp;就是对已经确定的需求进行文档化描述，该文档通常称为《需求规格说明书》。
4. 需求分析与评审  
&emsp;&emsp;它是需求分析工作的最后一步，主要是对功能的正确性、完整性和清晰性，以及其他需求给予评价。
#### 1．需求的分类
&emsp;&emsp;软件需求就是系统必须完成的事及必须具备的品质。具体来说，软件需求包括功能需求、非功能需求和设计约束三方面内容。各种需求的概念示意图如下图所示。

![需求概念示意图](https://pic.lufer.cc/images/2021/03/15/sxXJuF.png)

* 功能需求  
&emsp;&emsp;是指系统必须完成的那些事，即为了向它的用户提供有用的功能，产品必须执行的动作。
* 非功能需求  
&emsp;&emsp;是指产品必须具备的属性或品质，如性能、响应时间、可靠性、容错性、扩展性等。
* 设计约束  
&emsp;&emsp;也称为限制条件、补充规约，这通常是对解决方案的一些约束说明，例如必须采用国有自主知识版权的数据库系统，必须在 UNIX 操作系统之下运行等。

&emsp;&emsp;除了这三种需求之外，还有业务需求、用户需求、系统需求这三个处于不同层面的概念，充分地理解这样的模型才能够更加清晰地理清需求的脉络。

* 业务需求（Business Requirement）  
&emsp;&emsp;是指反映组织机构或客户对系统、产品高层次的目标要求，通常问题定义本身就是业务需求。
* 用户需求（User Requirement）  
&emsp;&emsp;是指描述用户使用产品必须要完成什么任务，怎么完成的需求，通常是在问题定义的基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立从用户角度出发的需求。
* 系统需求（System Requirement）  
&emsp;&emsp;是从系统的角度来说明软件的需求，它包括用特性说明的功能需求、质量属性、非功能需求及设计约束。

&emsp;&emsp;分析师经常围绕着“功能需求”来展开工作，而功能需求大部分都是从“系统需求” 的角度来分析与理解的，也就是用“开发人员”的视角来理解需求。但要想真正地得到完整的需求，仅戴上“开发人员”的眼镜是不够的，还需要“领域专家”的眼镜，要从更高的角度来理解需求，这就是“业务需求”；同时还应该更好地深入用户，了解他们的使用场景，了解他们的想法，这就是“用户需求”。这是一个理解层次的问题，并不仅仅是简单的概念。
#### 2．需求工程
&emsp;&emsp;需求工程就是包括创建和维护系统需求文档所必需的一切活动的过程，主要包括需求开发和需求管理两大工作。
1. 需求开发  
&emsp;&emsp;包括`需求捕获`、`需求分析`、`编写规格说明书`和`需求验证` 4 个阶段。在这个阶段需要完成确定产品所期望的用户类型、获取每种用户类型的需求、了解实际用户任务和目标及这些任务所支持的业务需求、分析源于用户的信息、对需求进行优先级分类、将所收集的需求编写成为软件规格说明书和需求分析模型、对需求进行评审等工作。
2. 需求管理  
&emsp;&emsp;通常包括`定义需求基线`、`处理需求变更`、`需求跟踪`等方面的工作。

&emsp;&emsp;这两个方面是相辅相成的，需求开发是主线，是目标；需求管理是支持，是保障。换句话说，需求开发是努力更清晰、更明确地掌握客户对系统的需求；而需求管理则是对需求的变化进行管理的过程。
#### 3．需求分析方法
&emsp;&emsp;需求分析的方法可谓种类繁多，不过如果按照分解方式的不同，可以很容易地划分出几种类型。本节先从分析方法发展的历史，对其建立一个概要性的认识，在本章的后面几节中将详细说明最具有代表性的结构化分析与设计、面向对象分析与设计两种方法。
1. 结构化分析方法  
&emsp;&emsp;最初的分析方法都不成体系，而且通常都只包括一些笼统的告诫，在 20 世纪 70 年代分析技术发展的分水岭终于出现了。这时人们开始尝试使用标准化的方法，开发和推出各种名为“结构化分析”的方法论，而 Tom DeMacro 则是这个领域最有代表性和权威性的专家。
2. 软系统方法  
&emsp;&emsp;这是一个过渡性的方法论，并未真正流行过，它的出现只是证明了结构化分析方法的一些不足。因为结构化分析方法采用的相对形式化的模型不仅与社会观格格不入，而且在解决“不确定性”时显得十分无力。最有代表性的软系统方法是 Checkland方法。
3. 面向对象分析方法  
&emsp;&emsp;在 20 世纪 90 年代，结构化方法的不足在面对多变的商业世界时，显得更加苍白无力，这就催使了 OOA 的迅速发展。
4. 面向问题域的分析（Problem Domain Oriented Analysis，PDOA）  
&emsp;&emsp;现在又发现面向对象分析方法也存在着很多的不足，应运而生了一些新的方法论，PDOA 就是其中一种。不过现在还在研究阶段，并未广泛应用。

### 8.2.2 如何进行系统设计
&emsp;&emsp;在实践中，系统设计与其说是在设计，不如说是在选择和妥协。  
&emsp;&emsp;系统目标包括但不限制于功能、性能、健壮性、开发周期、交付日期等。不幸的是，这些目标往往是矛盾的，提高软件性能直接意味着开发周期的增加、交付日期的推迟，盲目地增加功能可能导致性能降低，维护成本提高。  
&emsp;&emsp;软件设计者的难题在于在如此众多的目标之间找到这个平衡点，并且明确知道如何设计能实现这个平衡，既可以让投资者觉得在预算之内，又能让用户相对满意。可行性分析阶段应该已经论述了这样一个平衡点，可是如果设计者发现没有这样一个平衡点，如同没有一个设计者能让人骑着自行车到月球上去，那么设计者只能提出放弃某个方面的过度要求，否则系统要遭受必然失败的命运。更多的情况是没有经验的设计者不知道是否存在这些平衡点，更不知道如何利用合理的设计及有效的工具来达到平衡。因此设计者需要了解可以解决问题的各种方案，并清楚知道各个方案的效果、成本、缺点，以及这些方案的区别，并在各种方案中进行选择。而这些，不是一个人能在一两天了解的。
&emsp;&emsp;没有一个设计者会完全重新开始设计一个系统，他们总参考多个与目标系统相类似的系统，再从中进行甄别、取舍和补充来作为新系统的设计。要成为优秀的设计者，了解、掌握、消化、总结前人和自己以前的设计成果是最好的方法，这似乎也是唯一的方法。
&emsp;&emsp;设计者的苦恼有时候和编程人员一样。计算机系统的发展如此迅速，解决方案也越来越多，如同编程语言的发展，同时，随着人类社会的进步，投资者和客户也提出了越来越高的要求，这又需要设计者不断学习、创造新的方案。
&emsp;&emsp;但系统设计也并非没有规律可以遵循，人们在实践中发现优秀的系统设计一般在以下几个方面都很出色。
1. 组件的独立性  
&emsp;&emsp;审视自己设计的系统，是否做到了高内聚、低耦合？
2. 例外的识别和处理  
&emsp;&emsp;谁能保证系统使用者都精确按照使用说明书使用？
3. 防错和容错  
&emsp;&emsp;当网络中断、数据库崩溃这样的灾难性事件发生时，系统也跟着崩溃吗？

&emsp;&emsp;而且，更幸运的是，也有一些技术能够改进系统设计，这些方法包括：降低复杂性、通过合约进行设计、原型化设计、错误树分析等。
### 8.2.3 软件设计的任务与活动
&emsp;&emsp;软件设计是一个把软件需求变换成软件表示的过程。最初这种表示只是描绘出软件的总体框架，然后再进一步细化，并在此框架中填入细节。
#### 1.软件设计的两个阶段
&emsp;&emsp;从工程管理角度，软件设计可以分为两个步骤：
1. 概要设计  
&emsp;&emsp;也称为高层设计，将软件需求转化为数据结构和软件的系统结构。例如，如果采用结构化设计，则将从宏观的角度将软件划分成各个组成模块，并确定模块的功能及模块之间的调用关系。
2. 详细设计  
&emsp;&emsp;也称为低层设计，将对结构表示进行细化，得到详细的数据结构与算法。同样的，如果采用结构化设计，则详细设计的任务就是为每个模块进行设计。
#### 2．主要的设计方法比较
&emsp;&emsp;在结构化设计风行的时代，主流的设计方法还包括 Jackson 方法和 Parnas 方法。结构化方法侧重于“模块相对独立且功能单一，使模块间联系弱、模块内联系强”；而 Jackson 方法则是从数据结构导出模块结构；Parnas 方法的主要思想则是将可能引起变化的因素隐藏在有关模块内部，使这些因素变化时的影响范围受到限制，它只提供了重要的设计准则，但没有规定出具体的工作步骤。  
&emsp;&emsp;而近年来，对象技术凭借其对数据的高效封装及良好的消息机制，实现了高内聚、低耦合的系统设计，成了现代软件设计的主流方法学。

## 8.3 结构化分析与设计
&emsp;&emsp;结构化分析与设计方法是一种面向数据流的需求分析和设计方法，它适用于分析和设计大型数据处理系统，是一种简单、实用的方法，曾获得广泛的应用。
### 8.3.1 结构化分析
&emsp;&emsp;结构化分析方法的基本思想是自顶向下逐层分解。分解和抽象是人们控制问题复杂性的两种基本手段。对于一个复杂的问题，人们很难一下子考虑问题的所有方面和全部细节，通常可以把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题，经过多次逐层分解，每个最底层的问题都是足够简单、容易解决的，于是复杂的问题也就迎刃而解了。这个过程就是分解过程。  
&emsp;&emsp;结构化分析与面向对象分析方法之间的最大差别是：结构化分析方法把系统看作一个过程的集合体，包括人完成的和电脑完成的；而面向对象方法则把系统看成一个相互影响的对象集。结构化分析方法的特点是利用数据流图来帮助人们理解问题，对问题进行分析。  
&emsp;&emsp;结构化分析一般包括以下工具：数据流图（Data Flow Diagram，DFD）、数据字典（DataDictionary，DD）、结构化语言、判定表、判定树。在接下来的部分将对它们一一做简单介绍。  
&emsp;&emsp;结构化系统分析方法从总体上来看是一种强烈依赖数据流图的自顶向下的建模方法。它不仅是需求分析技术，也是完成需求规格化的有效技术手段。
####  1．结构化分析的工作步骤
&emsp;&emsp;在介绍具体的结构化分析方法之前，先对如何进行结构化分析做一个总结性描述，以帮助大家更好地应用该方法。
1. 研究“物质环境”  
&emsp;&emsp;首先，应画出当前系统（可能是非计算机系统，或是半计算机系统）的数据流图，说明系统的输入、输出数据流，说明系统的数据流情况，以及经历了哪些处理过程。在这个数据流图中，可以包括一些非计算机系统中数据流及处理的命名，例如部门名、岗位名、报表名等。这个过程可以帮助分析员有效地理解业务环境，在与用户的充分沟通与交流中完成。
2. 建立系统逻辑模型  
&emsp;&emsp;当物理模型建立完成之后，接下来的工作就是画出相对于真实系统的等价逻辑数据流图。在前一步骤建立的数据流图的基础上，将所有自然数据流都转成等价的逻辑流，例如，将现实世界的报表存储在计算机系统中的文件里；又如将现实世界中“送往总经理办公室”改为“报送报表”。
3. 划清人机界限  
&emsp;&emsp;最后，确定在系统逻辑模型中，哪些将采用自动化完成，哪些仍然保留手工操作。这样，就可以清晰地划清系统的范围。
#### 2．数据流图
&emsp;&emsp;DFD 是一种图形化的系统模型，它在一张图中展示信息系统的主要需求，即输入、输出、处理（过程）、数据存储。由于从 DFD 中可以很容易地看出系统紧密结合的各个部分，而且整个图形模式只有 5 个符号需要记忆，所以深受分析人员的喜爱，因而广为流行。
&emsp;&emsp;如下图所示，DFD 中包括以下几个基本元素。

![数据流图符号集](https://pic.lufer.cc/images/2021/03/15/y9AVgS.png)

* 过程  
&emsp;&emsp;也称为加工，一步步地执行指令，完成输入到输出的转换。  
* 外部实体  
&emsp;&emsp;也称为源/宿，系统之外的数据源或目的。  
* 数据存储  
&emsp;&emsp;也称为文件，存放数据的地方，一般是以文件、数据库等形式出现。  
* 数据流  
&emsp;&emsp;从一处到另一处的数据流向，如从输入或输出到一个过程的数据流。  
* 实时连接  
&emsp;&emsp;当过程执行时，外部实体与过程之间的来回通信。  

1. 数据流图的层次  
&emsp;&emsp;正如前面提到的，结构化分析的思路是依赖于数据流图进行自顶而下的分析。这也是因为系统通常比较复杂，很难在一张图上将所有的数据流和加工描述清楚。因此，数据流图提供一种表现系统高层和低层概念的机制。也就是先绘制一张较高层次的数据流图，然后在此基础上，对其中的过程（处理）进行分解，分解成为若干独立的、低层次的、详细的数据流图，而且可以这样逐一地分解下去，直至系统被清晰地描述出来。  
![数据流图的层次](https://pic.lufer.cc/images/2021/03/15/y9Al40.png)  
2. Context图  
&emsp;&emsp;Context 图，也就是系统上下文范围关系图。这是描述系统最高层结构的 DFD 图。它的特点是，将整个待开发的系统表示为一个过程，将所有的外部实体和进出系统的数据流都画在一张图中。  
![Context图实例](https://pic.lufer.cc/images/2021/03/15/y9Atu4.png)   
&emsp;&emsp;Context 图用来描述系统有什么输入、输出数据流，与哪些外部实体直接相关，可以把整个系统的范围勾画出来。
3. 逐级分解  
&emsp;&emsp;当完成了 Context 图的建模之后，就可以在此基础上进行进一步的分解。以Context图实例为例，进行再分解，在对原有流程了解的基础上，可以得到如下图所示的结果。  
![DFD 0层图实例](https://pic.lufer.cc/images/2021/03/15/y9AcKe.png)  
&emsp;&emsp;上图是在 Context 图的基础上做的第一次分解，而在 Context 图中只有一个过程，那就是系统，将其编号为 0。而接下来对 Context 图进行的分解，其实就是对这个编号为0的过程进行更细化的描述，在这里引入了新的过程、数据存储，为了能够区分其位置的级别，在这层次上的过程将以 1、2、3 为序列进行编号。  
&emsp;&emsp;由于这是对过程 0 的分解，因此也称之为 DFD 0 层图。而可以根据需要对 DFD 0 层图上的过程（编号为 1、2、3）进行类似的分解，那么就称之为 DFD 1 层图，在 DFD 1 层图中引入的新过程，其编号规则就是 1.1，1.2…，以及 2.1，2.2…，以此类推，直到完成分析工作。  
&emsp;&emsp;另外，这里存在一个很关键的要点，那就是 DFD 0 层图是 Context 图的细化，因此所有的输入和输出应该与 Context 图完全一致，否则就说明存在着错误。
4. 如何画 DFD   
&emsp;&emsp;DFD 的绘制是一个自顶向下、由外到里的过程，通常按照以下几个步骤进行。  
    * 画系统的输入和输出  
    &emsp;&emsp;就是在图的边缘标出系统的输入、输出数据流。这一步其实是决定研究的内容和系统的范围。在画的时候，可以先将尽可能多的输入、输出画出来，然后再删除多余的，增加遗漏的。  
    * 画数据流图的内部  
    &emsp;&emsp;将系统的输入、输出用一系列的处理连接起来，可以从输入数据流画向输出数据流，也可以从中间画出去。
    * 为每一个数据流命名  
    &emsp;&emsp;命名的好坏与数据流图的可理解性密切相关，应避免使用空洞的名字。
    * 为加工命名  
    &emsp;&emsp;注意应该使用动宾短语。

#### 3.细化记录 DFD 部件
&emsp;&emsp;为了更好地描述 DFD 的部件，结构化分析方法还引入了数据字典、结构化语言及决策树、决策表等方法。通过使用这些工具，能对数据流图中描述不够清晰的地方进行有效的补充。其中数据字典应用最为广泛，下面将详细说明数据字典的相关使用方法。  
&emsp;&emsp;数据字典技术是一种很实用、有效的表达数据格式的手段。它是对所有与系统相关的数据元素的一个有组织的列表和精确严格的定义，使得用户和系统分析员对于输入、输出、存储成分和中间计算机有共同的理解。通常数据字典的每一个条目中包括以下信息。
1. 名称  
&emsp;&emsp;数据或控制项、数据存储或外部实体的主要名称，如果有别名的还应该将别名列出来。
2. 何处使用/如何使用  
&emsp;&emsp;使用数据或控制项的加工列表，以及如何使用。
3. 内容描述  
&emsp;&emsp;说明该条目的内容组成，通常采用以下符号进行说明。  
    * =：由…构成  
    * +：和，代表顺序连接的关系  
    * [ | ]：或，代表从中选择一个  
    * {}*：n 次重复  
    * （）：代表可选的数据项  
    * \*…\*：表示特定限制的注释  
4. 补充信息  
&emsp;&emsp;关于数据类型、默认值、限制等信息。

下面就是一个数据字典的实例：
> 客户基本信息=客户编号+客户名称+身份证号码+手机+家庭电话  
> 客户编号 = {0…9}8  
> 客户名称 = {字}4  
> 身份证号码 = [{0…9}15|{0…9}18]  
> 手机 = [{0…9}11|{0…9}12]  
> 家庭电话 =（区号）+本地号区号 = {0…9}4  
> 本地号 = [{0…9}7|{0…9}8]  

### 8.3.2 结构化设计
&emsp;&emsp;结构化设计包括架构设计、接口设计、数据设计和过程设计等任务。它是一种面向数据流的设计方法，是以结构化分析阶段所产生的成果为基础，进一步自顶而下、逐步求精和模块化的过程。
#### 1．概要设计与详细设计的主要任务
&emsp;&emsp;概要设计阶段的主要任务是设计软件的结构、确定系统是由哪些模块组成，以及每个模块之间的关系。它采用结构图（包括模块、调用、数据）来描述程序的结构，此外还可以使用层次图和 HIPO（层次图加输入/处理/输出图）。  
&emsp;&emsp;整个过程主要包括：复查基本系统模型、复查并精化数据流图、确定数据流图的信息流类型（包括交换流和事务流）、根据流类型分别实施变换分析或事务分析、根据软件设计原则对得到的软件结构图进一步优化。  
&emsp;&emsp;而详细设计阶段的主要任务则是确定应该如何具体地实现所要求的系统，得出对目标系统的精确描述。它采用自顶向下、逐步求精的设计方式和单入口单出口的控制结构。常使用的工具包括程序流程图、盒图、PAD（Problem Analysis Diagram，问题分析图）、PDL（ProgramDesign Language，程序设计语言）。
#### 2．结构图
&emsp;&emsp;如下图所示，结构图的基本成分包括模块、调用（模块之间的调用关系）和数据（模块间传递及处理数据信息）。

![结构图的基本成分](https://pic.lufer.cc/images/2021/03/15/y98F1J.png)

&emsp;&emsp;结构图是在需求分析阶段产生的数据流图的基础上进行进一步的设计。它将 DFD 图中的信息流分为两种类型。
* 变换流  
&emsp;&emsp;信息首先沿着输入通路进入系统，并将其转换为内部表示，然后通过变换中心（加工）的处理，再沿着输出转换为外部形式离开系统。具有这种特性的加工流就是变换流。
* 事务流  
&emsp;&emsp;信息首先沿着输入通路进入系统，事务中心根据输入信息的类型在若干个动作序列（活动流）中选择一个执行，这种信息流称为事务流。
#### 3．程序流程图和盒图
&emsp;&emsp;程序流程图和盒图都是用来描述程序的细节逻辑的，其符号如下图所示。

![程序流程图和盒图基本符号示意图](https://pic.lufer.cc/images/2021/03/15/y98JBt.png)

&emsp;&emsp;程序流程图的特点是简单、直观、易学，但它的缺点也正是由于其随意性而使得画出来的流程图容易成为非结构化的流程图。而盒图正是为了解决这一问题设计的，它是一种符合结构化程序设计原则的图形描述工具。  
&emsp;&emsp;盒图的主要特点是功能域明确、无法任意转移控制、容易确定全局数据和局部数据的作用域、容易表示嵌套关系、可以表示模块的层次结构。但它也带来了一个副作用，那就是修改相对比较困难。
#### 4．PAD 和 PDL
&emsp;&emsp;PAD 是问题分析图的缩写，它符合自顶向下、逐步求精的原则，也符合结构化程序设计的思想，它最大的特点在于能够很方便地转换为程序语言的源程序代码。
&emsp;&emsp;PDL 则是语言描述工具的缩写，它和高级程序语言很相似，也包括数据说明部分和过程部分，还可以带注解等成分，但它是不可执行的。PDL 是一种形式化语言，其控制结构的描述是确定的，但内部的描述语法是不确定的。PDL 通常也被称为伪码。
### 8.3.3 模块设计
&emsp;&emsp;在结构化方法中，模块化是一个很重要的概念，它是将一个待开发的软件分解成为若干个小的简单部分——模块，每个模块可以独立地开发、测试。这是一种复杂问题的“分而治之”原则，其目的是使程序的结构清晰、易于测试与修改。  
&emsp;&emsp;具体来说，模块是指执行某一特定任务的数据结构和程序代码。通常将模块的接口和功能定义为其外部特性，将模块的局部数据和实现该模块的程序代码称为内部特性。而在模块设计时，最重要的原则就是实现信息隐蔽和模块独立。模块经常具有连续性，也就意味着作用于系统的小变动将导致行为上的小变化，同时规模说明的小变动也将影响到一小部分模块。
#### 1．信息隐蔽原则
&emsp;&emsp;信息隐蔽是开发整体程序结构时使用的法则，即将每个程序的成分隐蔽或封装在一个单一的设计模块中，并且尽可能少地暴露其内部的处理。通常将难的决策、可能修改的决策、数据结构的内部连接以及对它所做的操作细节、内部特征码、与计算机硬件有关的细节等隐蔽起来。通过信息隐蔽可以提高软件的可修改性、可测试性和可移植性，它也是现代软件设计的一个关键性原则。
#### 2．模块独立性原则
&emsp;&emsp;模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系最简单。保持模块的高度独立性，也是设计过程中的一个很重要的原则。通常用耦合（模块之间联系的紧密程度）和内聚（模块内部各元素之间联系的紧密程度）两个标准来衡量，设计的目标是高内聚、低耦合。
模块的内聚类型通常可以分为 7 种，根据内聚度从高到低排序，如下表所示。

|内聚类型|描述|
|----|----|
|功能内聚|完成单一功能，各个部分协同工作，缺一不可|
|顺序内聚|处理元素相关，而且必须顺序执行|
|通信内聚|所有处理元素集中在一个数据结构的区域上|
|过程内聚|处理元素相关，而且必须按特定的次序执行|
|瞬时内聚|所包含的任务必须在同一时间间隔内执行（如初始化模块）|
|逻辑内聚|完成逻辑上相关的一组任务|
|偶然内聚|完成一组没有关系或松散关系的任务|

&emsp;&emsp;与此相对应的，模块的耦合性类型通常也分为 7 种，根据耦合度从低到高排序，如下表所示。

|耦合类型|描述|
|----|----|
|非直接耦合|没有直接联系，互相不依赖对方|
|数据耦合|借助参数表传递简单数据|
|标记耦合|一个数据结构的一部分借助于接口来传递|
|控制耦合|模块间传递的信息中包含用于控制模块内部逻辑的信息|
|外部耦合|与软件以外的环境有关|
|公共耦合|多个模块引用同一个全局数据区|
|内容耦合|一个模块访问另一个模块的内部数据<br>一个模块不通过正常入口转到另一个模块的内部<br>两个模块有一部分代码重叠<br>一个模块有多个入口|

&emsp;&emsp;除了满足以上两大基本原则之外，通常在模块分解时还需要注意：保持模块的大小适中，尽可能减少调用的深度，直接调用该模块的个数应该尽量大，但调用其他模块的个数则不宜过大；保证模块是单入口、单出口的；模块的作用域应该在控制域之内；功能应该是可预测的。

## 8.4 面向对象的分析与设计
&emsp;&emsp;面向对象方法是一种非常实用的软件开发方法，它一出现就受到软件技术人员的青睐，现已成为计算机科学研究的一个重要领域，并逐渐成为软件开发的一种主要方法。面向对象方法以客观世界中的对象为中心，其分析和设计思想符合人们的思维方式，分析和设计的结构与客观世界的实际比较接近，容易被人们接受。在面向对象方法中，分析和设计的界面并不明显，它们采用相同的符号表示，能够方便地从分析阶段平滑地过渡到设计阶段。此外，在现实生活中，用户的需求经常会发生变化，但客观世界的对象及对象间的关系比较稳定，因此用面向对象方法分析和设计的结构也相对比较稳定。
### 8.4.1 面向对象的基本概念
#### 1．对象和类
&emsp;&emsp;对象是系统中用来描述客观事物的一个实体，它由`对象标识`（名称）、`属性`（状态、数据、成员变量）和`服务`（操作、行为、方法）三个要素组成，它们被封装为一个整体，以接口的形式对外提供服务。  
&emsp;&emsp;在现实世界中，每个实体都是对象，如学生、书籍、收音机等；每个对象都有它的操作，例如书籍的页数，收音机的频道、按钮等属性，以及收音机的切换频道等操作。  
&emsp;&emsp;而类则是对具有相同属性和服务的一个或一组对象的抽象。类与对象是抽象描述和具体实例的关系，一个具体的对象被称为类的一个实例。在系统设计过程中，类可以分为三种类型，分别是实体类、边界类和控制类。
1. 实体类  
&emsp;&emsp;实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息，例如，在线教育平台系统可以提取出学员类和课程类，它们都属于实体类。实体类通常都是永久性的，它们所具有的属性和关系是长期需要的，有时甚至在系统的整个生存期都需要。  
&emsp;&emsp;实体类是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型的转化中，一个参与者一般对应于实体类。通常可以从 SRS 中的那些与数据库表（需要持久存储）对应的名词着手来找寻实体类。通常情况下，实体类一定有属性，但不一定有操作。
2. 控制类  
&emsp;&emsp;控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词，例如，用例“身份验证”可以对应于一个控制类“身份验证器”，它提供了与身份验证相关的所有操作。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象（控制类的实例）通常控制其他对象，因此，它们的行为具有协调性。  
&emsp;&emsp;控制类将用例的特有行为进行封装，控制对象的行为与特定用例的实现密切相关，当系统执行用例的时候，就产生了一个控制对象，控制对象经常在其对应的用例执行完毕后消亡。  
&emsp;&emsp;通常情况下，控制类没有属性，但一定有方法。
3. 边界类  
&emsp;&emsp;边界类用于封装在用例内、外流动的信息或数据流。边界类位于系统与外界的交接处，包括所有窗体、报表、打印机和扫描仪等硬件的接口，以及与其他系统的接口。要寻找和定义边界类，可以检查用例模型，每个参与者和用例交互至少要有一个边界类，`边界类使参与者能与系统交互`。边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。常见的边界类有窗口、通信协议、打印机接口、传感器和终端等。实际上，在系统设计时，产生的报表都可以作为边界类来处理。  
&emsp;&emsp;边界类用于系统接口与系统外部进行交互，边界对象将系统与其外部环境的变更（例如，与其他系统的接口的变更、用户需求的变更等）分隔开，使这些变更不会对系统的其他部分造成影响。通常情况下，边界类可以既有属性也有方法。
#### 2．继承与泛化
&emsp;&emsp;继承是面向对象方法中重要的概念，用来说明特殊类（子类）与一般类（父类）的关系，而通常用泛化来说明一般类与特殊类的关系，也就是说它们是一对多关系。  
&emsp;&emsp;如下图所示，“交通工具”是“自行车”和“小轿车”的泛化；“自行车”和“小轿车”从“交通工具”中继承。

![继承与泛化示意图](https://pic.lufer.cc/images/2021/03/15/yCquzq.png)

#### 3．多态与重载
&emsp;&emsp;多态（即多种形式）性是指一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或表现出不同的行为，通常是使用重载和改写两项技术来实现的。一般有 4 种不同形式的多态，如下表所示。

|多态类型|描述|
|----|----|
|重载（专用多态）|描述一个函数名称有多种不同的实现方式，通常可以在编译时基于类型签名来区分各个重载函数的名称|
|改写（包含多态）|是重载的一种特殊情况，只发生在有关父类和子类之间关系中。通常签名相同，内容不一样|
|多态变量（赋值多态强制多态）|声明为一种类型，但实际上却可以包含另一种类型数值的变量|
|泛型（模板、参数多态）|它提供了一种创建通用工具的方法，可以在特定场合将其特化|

&emsp;&emsp;注 1：重载也称为过载、重置；    
&emsp;&emsp;注 2：参数多态和包含多态称为通用多态，重载多态和强制多态称为特定多态。

>虽然重载和改写都是在多种潜在的函数体中，选择和调用某一个函数或方法并对其进行执行，但它们的本质区别在于：重载是编译时执行的（静态绑定），而改写则是运行时选择的（动态绑定）。

#### 4．模板类
&emsp;&emsp;也称为类属类，它用来实现参数多态机制。一个类属类是关于一组类的一个特性抽象，它强调的是这些类的成员特征中与具体类型无关的那些部分，而用变元来表示与具体类型有关的那些部分。
#### 5．消息和消息通信
&emsp;&emsp;消息就是向对象发出的服务请求，它通常包括提供服务的对象标识、消息名、输入信息和回答信息。消息通信则是面向对象方法学中的一个重要原则，它与对象的封装原则密不可分，为对象间提供了唯一合法的动态联系的途径。

### 8.4.2 面向对象分析
&emsp;&emsp;面向对象分析的目标是开发一系列模型，这些模型描述计算机软件，当它工作时以满足一组客户定义的需求。对象技术的流行，演化出了数十种不同的 OOA 方法，每个方法都引入了一个产品或系统分析的过程、一组过程演化的模型及使软件工程师能够以一致的方式创建每个模型的符号体系。其中比较流行的方法包括 OMT、OOA、OOSE、Booch 方法等，而OMT、OOSE、Booch 最后则统一成为 UML。
#### 1．OOA/OOD 方法
&emsp;&emsp;这是由 Peter Coad 和 Edward Yourdon 提出的，OOA 模型中包括主题、对象类、结构、属性和服务 5 个层次，需经过标识对象类、标识结构与关联（包括继承、聚合、组合、实例化等）、划分主题、定义属性、定义服务 5 个步骤来完成整个分析工作。  
&emsp;&emsp;OOD 中将继续贯穿 OOA 中的 5 个层次和 5 个活动，它由人机交互部件、问题域部件、任务管理部件、数据管理部件 4 个部分组成，其主要的活动就是这 4 个部件的设计工作。  
1. 设计问题域部分  
&emsp;&emsp;OOA 的结果恰好是 OOD 的问题域部件，分析的结果在 OOD 中可以被改动或增补，但基于问题域的总体组织框架是长时间稳定的。
2. 设计人机交互部件  
&emsp;&emsp;人机交互部件在上述结果中加入人机交互的设计和交互的细节，包括窗口和输出报告的设计。可以用原型来帮助实际交互机制进行开发和选择。
3. 设计任务管理部分  
&emsp;&emsp;这部分主要是识别事件驱动任务，识别时钟驱动任务，识别优先任务和关键任务，识别协调者，审查每个任务并定义每个任务。
4. 设计数据管理部分  
&emsp;&emsp;数据管理部分提供了在数据管理系统中存储和检索对象的基本结构，其目的是隔离数据管理方法对其他部分的影响。
#### 2．Booch 方法
&emsp;&emsp;Booch 认为软件开发是一个螺旋上升的过程，每个周期中包括标识类和对象、确定类和对象的含义、标识关系、说明每个类的接口和实现 4 个步骤。它的模型中主要包括如下表所示的几种图形。

||静态模型|动态模型|
|----|----|----|
|逻辑模型|类图<br>对象图|状态转换图<br>时序图|
|物理模型|模块图<br>进程图||

&emsp;&emsp;Booch 方法的开发过程是一个迭代的、渐进式的系统开发过程，它可以分为宏过程和微过程两类。宏过程用于控制微过程，是覆盖几个月或几周所进行的活动，它包括负责建立核心需求的概念化，为所期望的行为建立模型的分析，建立架构的设计，形成实现的进化，以及管理软件交付使用的维护等 5 个主要活动。  
&emsp;&emsp;而微过程则基本上代表了开发人员的日常活动，它由 4 个重要、没有顺序关系的步骤组成：在给定的抽象层次上识别出类和对象，识别出这些类和对象的语义，识别出类间和对象间的关系，实现类和对象。
#### 3．OMT 方法
&emsp;&emsp;OMT 是对象建模技术的缩写，它是由 Jam Rambaugh 及其同事合作开发的，它主要用于分析、系统设计和对象设计。包括对象模型（静态的、结构化的系统的“数据”性质，通常采用类图）、动态模型（瞬时的、行为化的系统“控制”性质，通常使用状态图）和功能模型（表示变化的系统的“功能”性质，通常使用数据流图）。OMT 方法的三大模型如下表所示。

|模型|说明|主要技术|
|----|----|----|
|对象模型|描述系统中对象的静态结构，对象之间的关系、属性、操作。它表示静态的、结构上的、系统的“数据”特征|对象图|
|动态模型|描述与时间和操作顺序有关的系统特征，如激发事件、事件序列、确定事件先后关系的状态。它表示瞬时、行为上的、系统的“控制”特征|状态图|
|功能模型|描述与值的变换有关的系统特征：功能、映射、约束和函数依赖|数据流图|

#### 4.OOSE 方法
&emsp;&emsp;OOSE 是面向对象软件工程的缩写，它是由 Ivar Jacobson 提出的。它在 OMT 的基础上，对功能模型进行了补充，提出了“用例”的概念，最终取代数据流图进行需求分析和建立功能模型。

### 8.4.3 统一建模语言
&emsp;&emsp;统一建模语言（Unified Modeling Language，UML）是用于系统的可视化建模语言，它将OMT、OOSE 和 Booch 方法中的建模语言和方法有机地融合在一起，是国际统一的软件建模标准。虽然它源于 OO 软件系统建模领域，但由于其内建了大量扩展机制，也可以应用于更多的领域中，例如工作流程、业务领域等。
#### 1．UML 是什么
&emsp;&emsp;UML是一种语言：UML 在软件领域中的地位与价值就像“1、2、3、+、 、…”等符号在数学领域中的地位一样。它为软件开发人员之间提供了一种用于交流的词汇表和一种用于软件蓝图的标准语言。  
&emsp;&emsp;UML是一种可视化语言：UML 只是一组图形符号，它的每个符号都有明确语义，是一种直观、可视化的语言。  
&emsp;&emsp;UML是一种可用于详细描述的语言：UML 所建的模型是精确的、无歧义和完整的，因此适合于对所有重要的分析、设计和实现决策进行详细描述。  
&emsp;&emsp;UML是一种构造语言：UML 虽然不是一种可视化的编程语言，但其与各种编程语言直接相连，而且有较好的映射关系，这种映射允许进行正向工程、逆向工程。  
&emsp;&emsp;UML是一种文档化语言：它适合于建立系统架构及其所有的细节文档。
#### 2．UML 的结构
&emsp;&emsp;UML由`构造块`、`公共机制`和`架构`三个部分组成。
1. 构造块  
&emsp;&emsp;构造块也就是基本的 UML 建模元素（事物）、关系和图。  
&emsp;&emsp;建模元素：包括结构事物（类、接口、协作、用例、活动类、组件、节点等）、行为事物（交互、状态机）、分组事物（包）、注释事物。  
&emsp;&emsp;关系：包括关联关系、依赖关系、泛化关系、实现关系。  
&emsp;&emsp;图：UML 2.0 包括 14 种不同的图，分为表示系统静态结构的静态模型（包括类图、对象图、包图、构件图、部署图、制品图），以及表示系统动态结构的动态模型（包括对象图、用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图）。
2. 公共机制  
&emsp;&emsp;公共机制是指达到特定目标的公共 UML 方法，主要包括规格说明、修饰、公共分类和扩展机制 4 种。  
&emsp;&emsp;规格说明：规格说明是元素语义的文本描述，它是模型的重要组成部分。  
&emsp;&emsp;修饰：UML 为每一个模型元素设置了一个简单的记号，还可以通过修饰来表达更多的信息。  
&emsp;&emsp;公共分类：包括类元与实体（类元表示概念，而实体表示具体的实体）、接口和实现（接口用来定义契约，而实现就是具体的内容）两组公共分类。  
&emsp;&emsp;扩展机制：包括约束（添加新规则来扩展元素的语义）、构造型（用于定义新的 UML建模元素）、标记值（添加新的特殊信息来扩展模型元素的规格说明）。
3. 架构  
&emsp;&emsp;UML 对系统架构的定义是：系统的组织结构，包括系统分解的组成部分、它们的关联性、交互、机制和指导原则，这些提供系统设计的信息。而具体来说，就是指 5个系统视图。  
&emsp;&emsp;逻辑视图：以问题域的语汇组成的类和对象集合。  
&emsp;&emsp;进程视图：可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例。  
&emsp;&emsp;实现视图：对组成基于系统的物理代码的文件和组件进行建模。  
&emsp;&emsp;部署视图：把组件物理地部署到一组物理的、可计算的节点上。  
&emsp;&emsp;用例视图：最基本的需求分析模型。
#### 3．用例图基础
&emsp;&emsp;用例是什么呢？Ivar Jacobson 是这样描述的：“用例实例是在系统中执行的一系列动作，这些动作将生成特定参与者可见的价值结果。一个用例定义一组用例实例。”首先，从定义中得知用例是由一组用例实例组成的，用例实例也就是常说的“使用场景”，就是用户使用系统的一个实际的、特定的场景。其次，可以知道，用例应该给参与者带来可见的价值，这点很关键。最后，用例是在系统中的。  
&emsp;&emsp;而用例模型描述的是外部参与者所理解的系统功能。用例模型用于需求分析阶段，它的建立是系统开发者和用户反复讨论的结果，表明了开发者和用户对需求规格达成的共识。下图是一个用例图的例子。

![用例图示例](https://pic.lufer.cc/images/2021/03/15/yCvNMn.png)

1. 参与者  
&emsp;&emsp;参与者代表与系统接口的任何事物或人，它是指代表某一种特定功能的角色，因此，参与者都是虚拟的概念。在 UML 中，用一个小人表示参与者。  
&emsp;&emsp;用例图示例中的“图书管理员”就是参与者。对于该系统来说，可能可以充当图书管理员角色的有多个人，由于他们对系统均起着相同的作用，扮演相同的角色，因此只用一个参与者来表示。切忌不要为每一个可能与系统交互的真人画出一个参与者。
2. 用例  
&emsp;&emsp;用例是对系统行为的动态描述，它可以促进设计人员、开发人员与用户的沟通，理解正确的需求，还可以划分系统与外部实体的界限，是系统设计的起点。在识别出参与者之后，可以使用下列问题帮助识别用例。  
&emsp;&emsp;每个参与者的任务是什么？  
&emsp;&emsp;有参与者将要创建、存储、修改、删除或读取系统中的信息吗？  
&emsp;&emsp;什么用例会创建、存储、修改、删除或读取这个信息？  
&emsp;&emsp;参与者需要通知系统外部的突然变化吗？  
&emsp;&emsp;需要通知参与者系统中正在发生的事情吗？  
&emsp;&emsp;什么用例将支持和维护系统？  
&emsp;&emsp;所有的功能需求都对应到用例中了吗？   
&emsp;&emsp;系统需要何种输入/输出？输入从何处来？输出到何处？  
&emsp;&emsp;当前运行系统的主要问题是什么？
3. 包含和扩展  
&emsp;&emsp;两个用例之间的关系可以主要概括为两种情况。一种是用于重用的包含关系，用构造型`<<include>>`或者`<<use>>`表示；另一种是用于分离出不同的行为，用构造型`<<extend>>`表示。  
&emsp;&emsp;包含关系：当可以从两个或两个以上的原始用例中提取公共行为，或者发现能够使用一个组件来实现某一个用例的部分功能是很重要的事时，应该使用包含关系来表示。所提取出来的公共行为称为抽象用例。包含关系的例子如下图所示。  
![包含关系示例](https://pic.lufer.cc/images/2021/03/15/yCzDgJ.png)  
&emsp;&emsp;扩展关系：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种事情。可以将这个用例分为一个主用例和一个或多个辅用例，描述可能更加清晰。扩展关系的例子如下图所示。  
![拓展关系示例](https://pic.lufer.cc/images/2021/03/15/yCzyuR.png)  
#### 4．类图和对象图基础
&emsp;&emsp;在面向对象建模技术中，将客观世界的实体映射为对象，并归纳成一个个类。类、对象和它们之间的关联是面向对象技术中最基本的元素。对于一个想要描述的系统，其类模型和对象模型揭示了系统的结构。在 UML 中，类和对象模型分别由类图和对象图表示。类图技术是 OO 方法的核心。下图是一个类图的实例。

![类图示例](https://pic.lufer.cc/images/2021/03/15/yCzTKA.png)

1. 类和对象  
&emsp;&emsp;对象与人们对客观世界的理解相关。人们通常用对象描述客观世界中某个具体的实体。所谓类是对一类具有相同特征的对象的描述。而对象是类的实例。在 UML中，类的可视化表示为一个划分成三个格子的长方形（下面两个格子可省略）。在类图示例图中，“书籍”、“借阅记录”等都是一个类。  
&emsp;&emsp;类的获取和命名：最顶部的格子包含类的名字。类的命名应尽量用应用领域中的术语，应明确、无歧义，以利于开发人员与用户之间的相互理解和交流。  
&emsp;&emsp;类的属性：中间的格子包含类的属性，用以描述该类对象的共同特点。该项可省略。类图示例图中“书籍”类有“书名”、“书号”等属性。UML 规定类的属性的语法为： “可见性 属性名：类型 = 默认值 {约束特性}”。  
&emsp;&emsp;可见性包括 Public、Private 和 Protected，分别用+、-、#号表示。   
&emsp;&emsp;类型表示该属性的种类：它可以是基本数据类型，例如整数、实数、布尔型等，也可以是用户自定义的类型。一般它由所涉及的程序设计语言确定。约束特性则是用户对该属性性质的一个约束说明。例如“{只读}”说明该属性是只读属性。  
&emsp;&emsp;类的操作（Operation）：该项可省略。操作用于修改、检索类的属性或执行某些动作。操作通常也被称为功能，但是它们被约束在类的内部，只能作用到该类的对象上。操作名、返回类型和参数表组成操作界面。UML 规定操作的语法为：“可见性：操作名（参数表）：返回类型 {约束特性}”。  
&emsp;&emsp;类图描述了类和类之间的静态关系。定义了类之后，就可以定义类之间的各种关系了。
2. 类之间的关系  
&emsp;&emsp;在建立抽象模型时，会发现很少有类会单独存在，大多数都将会以某种方式互相协作，因此还需要描述这些类之间的关系。关系是事物间的连接，在面向对象建模中，有 4 个很重要的关系。
    * 依赖关系  
    &emsp;&emsp;有两个元素 X、Y，如果修改元素 X 的定义可能会引起对另一个元素 Y 的定义的修改，则称元素 Y 依赖于元素 X。在 UML 中，使用带箭头的虚线表示依赖关系。  
    &emsp;&emsp;在类中，依赖由多种原因引起，如：一个类向另一个类发消息；一个类是另一个类的数据成员；一个类是另一个类的某个操作参数。如果一个类的界面改变，它发出的任何消息可能不再合法。
    * 泛化关系  
    &emsp;&emsp;泛化关系描述了一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。继承关系是泛化关系的反关系，也就是说子类是从父类中继承的，而父类则是子类的泛化。在 UML 中，使用带空心箭头的实线表示，箭头指向父类。  
    &emsp;&emsp;在 UML 中，对泛化关系有 3 个要求：  
    &emsp;&emsp;子类应与父类完全一致，父类所具有的关联、属性和操作，子类都应具有���  
    &emsp;&emsp;子类中除了与父类一致的信息外，还包括额外的信息。  
    &emsp;&emsp;可以使用子父类实例的地方，也可以使用子类实例。  
    * 关联关系  
    &emsp;&emsp;关联表示两个类之间存在某种语义上的联系。例如，一个人为一家公司工作，一家公司有许多办公室。就认为人和公司、公司和办公室之间存在某种语义上的联系。  
    &emsp;&emsp;关联关系提供了通信的路径，它是所有关系中最通用的、语义最弱的。在 UML 中，用一条实线来表示关联关系。
    * 聚合关系  
    &emsp;&emsp;聚合是一种特殊形式的关联。聚合表示类之间的关系是整体与部分的关系。例如一辆轿车包含四个车轮、一个方向盘、一个发动机和一个底盘，就是聚合的一个例子。在 UML中，用一个带空心菱形的实线表示，空心菱形指向的是代表“整体”的类。`部分与整体的生命周期可以不相同`
    * 组合关系  
    &emsp;&emsp;如果聚合关系中的表示“部分”的类的存在，与表示“整体”的类有着紧密的关系，例如“公司”与“部门”之间的关系，那么就应该使用“组合”关系来表示。在 UML 中，用带有实心菱形的实线表示，菱形指向的是代表“整体”的类。`部分与整体的生命周期是相同的`
    * 实现关系  
    &emsp;&emsp;实现关系是用来规定接口和实现接口的类或组件之间的关系的。接口是操作的集合，这些操作用于规定类或组件的服务。在 UML 中，用一个带空心箭头的虚线表示。
3. 多重性问题  
&emsp;&emsp;重复度又称多重性，多重性表示为一个整数范围 n…m，整数 n 定义所连接的最少对象的数目，而 m 则为最多对象数（当不知道确切的最大数时，最大数用\*号表示）。最常见的多重性有：0…1；0…\*；1…1；1…\*；\*。
多重性是用来说明关联的两个类之间的数量关系的，例如：  
&emsp;&emsp;书与借书记录之间的关系，就应该是 1 对 0…1 的关系，也就是一本书可以有 0 个或 1 个借书记录。  
&emsp;&emsp;经理与员工之间的关系，则应为 1 对 0…*的关系，也就是一个经理可以领导 0 个或多个员工。  
&emsp;&emsp;学生与选修课程之间的关系，就可以表示为 0…\*对 1…\*的关系，也就是一个学生可以选择1 门或多门课程，而一门课程可以有 0 个或多个学生选修。
4. 类图  
&emsp;&emsp;对于软件系统，其类模型和对象模型类图描述类和类之间的静态关系。与数据模型不同，它不仅显示了信息的结构，同时还描述了系统的行为。类图是定义其他图的基础。
5. 对象图  
&emsp;&emsp;UML 中对象图与类图具有相同的表示形式。对象图可以看作是类图的一个实例。对象是类的实例；对象之间的链（Link）是类之间的关联的实例。对象与类的图形表示相似，均为划分成两个格子的长方形（下面的格子可省略）。上面的格子是对象名，对象名下有下画线；下面的格子记录属性值。链的图形表示与关联相似。对象图常用于表示复杂类图的一个实例。
#### 5．交互图基础
&emsp;&emsp;交互图是表示各组对象如何依某种行为进行协作的模型。通常可以使用一个交互图来表示和说明一个用例的行为。在 UML 中，包括 3 种不同形式的交互图，强调对象交互行为顺序的顺序图，强调对象协作的通信图（UML1.X 版本中称为“协作图”），强调消息的具体时间的定时图，它们之间没有什么本质不同，只是排版不尽相同而已。
1. 顺序图  
&emsp;&emsp;顺序图用来描述对象之间动态的交互关系，着重体现对象间消息传递的时间顺序。顺序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，并且可以发送信息。下图是一个顺序图的示例。    
![顺序图示例](https://pic.lufer.cc/images/2021/03/15/yPgGbq.png)     
&emsp;&emsp;如上图所示，顺序图存在两个轴，水平轴表示不同的对象，即图中的 Client、Factory、Product 等；而垂直轴表示时间，表示对象及类的生命周期。  
&emsp;&emsp;对象间的通信通过在对象的生命线间画消息来表示。消息的箭头指明消息的类型。顺序图中的消息可以是信号、操作调用或类似于 C++中的 RPC（Remote Procedure Calls）和 Java中的 RMI（Remote Method Invocation）。当收到消息时，接收对象立即开始执行活动，即对象被激活了。通过在对象生命线上显示一个细长矩形框来表示激活。  
&emsp;&emsp;消息可以用消息名及参数来标识，消息也可带有顺序号。消息还可带有条件表达式，表示分支或决定是否发送消息。如果用于表示分支，则每个分支是相互排斥的，即在某一时刻仅可发送分支中的一个消息。
2. 通信图  
&emsp;&emsp;通信图用于描述相互合作的对象间的交互关系和链接关系。虽然顺序图和通信图都用来描述对象间的交互关系，但侧重点不一样。顺序图着重体现交互的时间顺序，通信图则着重体现交互对象间的静态链接关系。下图就是与顺序图示例相对应的通信图，可以从下图中很明显地发现它与顺序图之间的异同点。   
![通信图示例](https://pic.lufer.cc/images/2021/03/15/yPfylD.png)  
3. 定时图  
&emsp;&emsp;如果要表示的交互具有很强的时间特性（例如，现实生活中的电子工程、实时控制等系统中），在 UML 1.X 中是无法有效地表示出来的。而在 UML 2.0 中引入了一种新的交互图来解决这类问题，这就是着重表示定时约束的定时图。  
&emsp;&emsp;根据 UML 的定义，定时图实际上是一种特殊形式的顺序图（即一种变化），它与顺序图的区别主要体现在以下几个方面。  
&emsp;&emsp;坐标轴交换了位置，改为从左到右来表示时间的推移。  
&emsp;&emsp;用生命线的“凹下凸起”来表示状态的变化，每个水平位置代表一种不同的状态，状态的顺序可以有意义、也可以没有意义。  
&emsp;&emsp;生命线可以跟在一根线后面，在这根线上显示一些不同的状态值。  
&emsp;&emsp;可以显示一个度量时间值的标尺，用刻度来表示时间间隔。  
&emsp;&emsp;下图是一个定时图的实际例子，其中小黑点加曲线表示的是注释。它用来表示一个电子门禁系统的控制逻辑，该门禁系统包括门（物理的门）、智能读卡器（读取用户的智能卡信息）、处理器（用来处理是否开门的判断）。   
![定时图实例](https://pic.lufer.cc/images/2021/03/15/yPhZh6.png)    
&emsp;&emsp;在这个例子中，它所表示的意思是一开始读卡器是启用的（等用户来刷卡）、处理器是空闲的（没有验证的请求）、门是关的；接着，当用户刷卡时，读卡器就进入了“等待校验”的状态，并发一个消息给处理器，处理器就进入了校验状态。如果校验通过，就发送一个“禁用”消息给读卡器（因为门开的时候，读卡器就可以不工作），使读卡器进入禁用状态；并且自己转入启用状态，这时门的状态变成了“开”。而门“开”了 30 秒钟（根据时间刻度得知）之后，处理器将会把它再次“关”上，并且发送一个“启用”消息给读卡器（门关了，读卡器开始重新工作），这时读卡器再次进入启用状态，而处理器已经又回到了空闲状态。  
&emsp;&emsp;从上面的例子中，不难看出定时图所包含的图元并不多，主要包括生命线、状态、状态变迁、消息、时间刻度，可以根据自身的需要来使用它。
#### 6．状态图基础状态图
&emsp;&emsp;用来描述一个特定对象的所有可能状态及其引起状态转移的事件。大多数面向对象技术都用状态图表示单个对象在其生命周期中的行为。一个状态图包括一系列的状态及状态之间的转移。下图是一个数码冲印店的订单状态图实例。  

![状态图示例](https://pic.lufer.cc/images/2021/03/15/yP54t1.png) 

&emsp;&emsp;状态图包括以下���分。  
&emsp;&emsp;状态：又称为中间状态，用圆角矩形框表示；  
&emsp;&emsp;初始状态：又称为初态，用一个黑色的实心圆圈表示，在一张状态图中只能够有一个初始状态；  
&emsp;&emsp;结束状态：又称为终态，在黑色的实心圆圈外面套上一个空心圆，在一张状态图中可能有多个结束状态；  
&emsp;&emsp;状态转移：用箭头说明状态的转移情况，并用文字说���引发这个状态变化的相应事件是什么。  
&emsp;&emsp;一个状态也可能被细分为多个子状态，那么如果将这些子状态都描绘出来的话，那这个状态就是复合状态。  
&emsp;&emsp;状态图适合用于表述在不同用例之间的对象行为，但并不适合用于表述包括若干用例协作的对象行为。通常不会需要对系统中的每一个类绘制相应的状态图，而通常会在业务流程、控制对象、用户界面的设计方面使用状态图。  
#### 7．活动图基础
&emsp;&emsp;活动图的应用非常广泛，它既可用来描述操作（类的方法）的行为，也可以描述用例和对象内部的工作过程。活动图是由状态图变化而来的，它们各自用于不同的目的。活动图依据对象状态的变化来捕获动作（将要执行的工作或活动）与动作的结果。活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的变迁可能需要事件的触发）。
1. 基本活动图  
&emsp;&emsp;下图是一个基本活动图的例子。   
![活动图示例](https://pic.lufer.cc/images/2021/03/15/yP5HXD.png) 
&emsp;&emsp;如图所示，活动图与状态图类似，包括了初始状态、终止状态，以及中间的活动状态，每个活动之间，也就是一种状态的变迁。在活动图中，还引入了以下几个概念。  
&emsp;&emsp;判定：说明基于某些表达式的选择性路径，在 UML 中使用菱形表示。  
&emsp;&emsp;分支与组合：由于活动图建模时，经常会遇到并发流，因此在 UML 中引入了如上图所示的粗线来表示分支和组合。
2. 带泳道的活动图  
&emsp;&emsp;在前面说明的基本活动图中，虽然能够描述系统发生了什么，但没有说明该项活动由谁来完成。而针对 OOP 而言，这就意味着活动图没有描述出各个活动由哪个类来完成。要想解决这个问题，可以通过泳道来解决这一问题。它将活动图的逻辑描述与顺序图、协作图的责任描述结合起来。下图是一个使用了泳道的例子。  
![带泳道的活动图示例](https://pic.lufer.cc/images/2021/03/15/yP5xht.png)  
3. 对象流  
&emsp;&emsp;在活动图中可以出现对象。对象可以作为活动的输入或输出，对象与活动间的输入/输出关系由虚线箭头来表示。如果仅表示对象受到某一活动的影响，则可用不带箭头的虚线来连接对象与活动。
4. 信号  
&emsp;&emsp;在活动图中可以表示信号的发送与接收，分别用发送和接收标识来表示。  
&emsp;&emsp;发送和接收标识也可与对象相连，用于表示消息的发送者和接收者。
#### 8．构件图基础
&emsp;&emsp;构件图是面向对象系统的物理方面进行建模要用的两种图之一。它可以有效地显示一组构件，以及它们之间的关系。构件图中通常包括构件、接口及各种关系。下图是一个构件图的例子。   
![构件图示例](https://pic.lufer.cc/images/2021/03/15/yPIwuD.png)    
&emsp;&emsp;通常构件指的是源代码文件、二进制代码文件和可执行文件等。而构件图就是用来显示编译、链接或执行时构件之间的依赖关系的。例如，在上图中，就是说明 QueryClient.exe将通过调用 QueryServer.exe 来完成相应的功能，而 QueryServer.exe 则需要 Find.exe 的支持， Find.exe 在实现时调用了 Query.dll。  
&emsp;&emsp;通常来说，可以使用构件图完成以下工作。  
&emsp;&emsp;对源代码进行建模：这样可以清晰地表示出各个不同源程序文件之间的关系。  
&emsp;&emsp;对可执行体的发布建模：如图所示，将清晰地表示出各个可执行文件、DLL 文件之间的关系。  
&emsp;&emsp;对物理数据库建模：用来表示各种类型的数据库、表之间的关系。  
&emsp;&emsp;对可调整的系统建模：例如对应用了负载均衡、故障恢复等系统的建模。  
&emsp;&emsp;在绘制构件图时，应该注意侧重于描述系统的静态实现视图的一个方面，图形不要过于简化，应该为构件图取一个直观的名称，在绘制时避免产生线的交叉。
#### 9．部署图基础
&emsp;&emsp;部署图，也称为实施图，它和构件图一样，是面向对象系统的物理方面建模的两种图之一。构件图是说明构件之间的逻辑关系，而部署图则是在此基础上更进一步地描述系统硬件的物理拓扑结构及在此结构上执行的软件。部署图可以显示计算结点的拓扑结构和通信路径、结点上运行的软件构件，常用于帮助理解分布式系统。  
&emsp;&emsp;下图就是与构件图示例对应的部署图，这样的图示可以使系统的安装、部署更为简单。 

![部署图示例](https://pic.lufer.cc/images/2021/03/15/yPTy1P.png)

&emsp;&emsp;在部署图中，通常包括以下一些关键的组成部分。
1. 节点和连接  
&emsp;&emsp;节点代表一个物理设备及其上运行的软件系统，如一台 UNIX 主机、一个 PC 终端、一台打印机、一个传感器等。  
&emsp;&emsp;如上图所示，“客户端：个人 PC”和“服务器”就是两个节点。在 UML 中，使用一个立方体表示一个节点，节点名放在左上角。节点之间的连线表示系统之间进行交互的通信路径，在 UML 中被称为连接。通信类型则放在连接旁边的“《》”之间，表示所用的通信协议或网络类型。
2. 构件和接口  
&emsp;&emsp;在部署图中，构件代表可执行的物理代码模块，如一个可执行程序。  
&emsp;&emsp;逻辑上它可以与类图中的包或类对应。例如，在部署图示例中，“服务器”结点中包含“QueryServer.exe”、“Find.exe”和“Query.dll”3 个构件。  
&emsp;&emsp;在面向对象方法中，类和构件等元素并不是所有的属性和操作都对外可见。它们对外提供了可见操作和属性，称之为类和构件的接口。界面可以表示为一头是小圆圈的直线。在部署图示例中，“Query.dll”构件提供了一个“查询”接口。

## 8.5 用户界面设计
&emsp;&emsp;接口设计主要包括三个方面的内容：一是设计软件构件间的接口；二是设计模块和其他非人的信息生产者和消费者（如外部实体）的接口；三是人（如用户）和计算机间界面设计。  
&emsp;&emsp;软件构件间接口的设计与架构的设计紧密相关���而设计模块和外部实体的接口则与详细设计相关，人机界面接口是相当容易被忽视的环节，在此就对其重点内容进行一个概要性描述。
### 8.5.1 用户界面设计的原则
&emsp;&emsp;用户界面设计必须考虑软件使用者的体力和脑力，根据 Theo Mandel 的总结，设计时必须遵从三个黄金法则。  
&emsp;&emsp;置用户于控制之下：具体来说就是以不强迫用户进入不必要的或不希望的动作的方式来定义交互模式、提供灵活的交互、允许用户交互可以被中断和撤销、当技能级别增长时可以使交互流水化并允许定制交互、使用户隔离内部技术细节、设计应允许用户和出现在屏幕上的对象直接交互。  
&emsp;&emsp;减少用户的记忆负担：具体来说就是减少对短期记忆的要求、建立有意义的默认、定义直觉性的捷径、界面的视觉布局应该基于对真实世界的隐喻、以不断进展的方式提示信息。  
&emsp;&emsp;保持界面的一致：具体来说，就是允许用户将当前任务放入有意义的语境、在应用系列内保持一致性，如果过去的交互模型已经建立了用户期望，除非有不得已的理由，否则不要改变它。  
&emsp;&emsp;除此之外，还应该考虑下表所示的设计原则。

|原则|描述|
|----|----|
|用户熟悉|界面所使用的术语和概念应该来自于用户的体验，这些用户是将要使用系统最多的人|
|意外最小化|永远不要让用户对系统的行为感到吃惊|
|可恢复性|界面应该有一种机制来允许用户从错误中回复|
|用户指南|在错误发生时，界面应该提供有意义的反馈，并有上下文感知能力的用户帮助功能|
|用户差异性|界面应该为不同类型用户提供合适的交互功能|

### 8.5.2 用户界面设计过程
&emsp;&emsp;用户界面的设计过程也应该是迭代的，它通常包括 4 个不同的框架活动，如下图所示。

![用户界面设计过程](https://pic.lufer.cc/images/2021/03/15/yVxGxf.png)

1. 用户、任务和环境分析  
&emsp;&emsp;着重于分析将和系统交互的用户的特点。记录下技术级别、业务理解及对新系统的一般感悟，并定义不同的用户类别。然后对用户将要完成什么样的任务进行详细的标识和描述。最后对用户的物理工作环境进行了解与分析。
2. 界面设计  
&emsp;&emsp;主要包括建立任务的目标和意图，为每个目标或意图制定特定的动作序列，按在界面上执行的方式对动作序列进行规约，指明系统状态，定义控制机制，指明控制机制如何影响系统状态，指明用户如何通过界面上的信息来解释系统状态。
3. 实现  
&emsp;&emsp;就是根据界面设计进行实现，前期可以通过原型工具来快速实现，减少返工的工作量。
4. 界面确认  
&emsp;&emsp;界面实现后就可以进行一些定性和定量的数据收集，以进行界面的评估，以调整界面的设计。

## 8.6 工作流设计
&emsp;&emsp;工作流技术的发展，经过多年的努力，取得了一定的成果。但在实际应用中，应用的企业还是较少，应用的范围窄，效果不理想。  
&emsp;&emsp;流程的设计是对设计者更高的挑战，现实中对计算机所管理的流程需要灵活的定义、方便的路径修改、容易使用，可是这几个目标是矛盾的。更严重的是，如何分析现实中的流程本身就是个困难的问题，更不用谈如何来设计实现了。流程设计的主要困难实际上也就是软件的主要困难：现实复杂性。  
&emsp;&emsp;任何对现实的描述（图形也罢，文字也罢）都是不完美的，“不识庐山真面目”是设计面临的共同难题。设计者不得不意识到所有的流程模型都是对现实的简化，计算机只根据确定的信息作判断，而现实中的流程存在大量的不确定性，虽然计算机专家们自信地告诉企业管理者这是管理的问题，信誓旦旦地保证可以用计算机系统来“完善”企业的管理，但他们似乎没有意识到企业管理已经发展了几百年，而计算机还没有百年的历史。    
&emsp;&emsp;人们常常抱怨计算机系统的流程设计太过刻板，因为许多时候，标准流程是先于应用构造的且由一些集中的权威强制执行的，所以这种刻板性是不可避免的。同时，对参与者而言缺乏自由度导致工作流管理系统显得很不友好。结果是它们经常被忽略或绕过，甚至最终被放弃。  
&emsp;&emsp;另外的困难是：对于流程处理，不但名称众多，例如，动态模型、工作流等，而且对流程的定义也是千姿百态。面对这些困难，设计者无疑需要巨大的勇气来进行流程设计。
### 8.6.1 工作流设计概述
&emsp;&emsp;限于篇幅，这里只列出工作流管理联盟对于工作流的定义：“工作流是一类能够完全或者部分自动执行的经营过程，根据一系列过程规则、文档、信息或任务在不同的执行者之间传递、执行”。
1. 工作流  
&emsp;&emsp;简单地说，工作流是现实中的具体工作从开始到结束过程的抽象和概括。这个过程包括了众多因素：任务顺序、路线规则、时间时限约束等。
2. 流程定义  
&emsp;&emsp;流程定义是指对业务过程的形式化表示，它定义了过程运行中的活动和所涉及的各种信息。这些信息包括过程的开始和完成条件、构成过程的活动及进行活动间导航的规则、用户所需要完成的任务、可能被调用的应用、工作流间的引用关系，以及工作流数据的定义。这个定义的过程可能是由设计者用纸和笔来完成的，但越来越多的设计者倾向于使用流程定义工具来完成这个工作。
3. 流程实例  
&emsp;&emsp;也常常称为工作，是一个流程定义的运行实例。例如客户的一次订购过程，客服中心受理的一次客户投诉过程等。
4. 工作流管理系统  
&emsp;&emsp;和数据库管理系统类似，是一个软件系统。这个程序存储流程的定义，按照所使用的流程定义来触发流程状态的改变，推动流程的运转。这个推动的依据常常称为工作流引擎。
5. 流程定义工具  
&emsp;&emsp;同样是一套软件系统，这个软件和工作流管理系统的关系就如同数据库设计工具和数据库管理系统的关系一样。它可能是独立的软件，也可能是工作流管理系统的一部分。如前所说，设计者常常使用流程定义工具来完成流程定义的工作。它提供一些常用的工作流元素素材，以提高设计者的效率。
6. 参与者  
&emsp;&emsp;回答业务流程中“谁”这个问题。它可以是具体的人或者角色（企业内部有特别共同作用的多个人），也可以是自动化系统，甚至是其他系统。
7. 活动  
&emsp;&emsp;活动是流程定义中的一个元素，一次活动可能改变流程处理数据的内容、流程的状态，并可能将流程推动到其他活动中去。活动可以由人来完成，也可以是系统自动的处理过程，典型的自动处理是当活动超过了这个活动可以容忍的时限时，自动过程将向流程定义中指定的参与者发出一条消息。
8. 活动所有者  
&emsp;&emsp;参与者之一，他有权决定该活动是否结束，当他决定活动结束时，将活动推动到其他活动中，可能是下一个活动，也可能是前一个活动。
9. 工作所有者  
&emsp;&emsp;工作所有者是有权整体控制流程实例执行过程的参与者。
10. 工作项  
&emsp;&emsp;代表流程实例中活动的参与者将要执行的工作。
 
&emsp;&emsp;要分析现实中的处理流程，必须首先描述目标系统的流程，这个过程也可以称为建模。流程是个复杂的事务，必须从多方面才可以描述一个流程，包括：`“谁”`，流程的参与者；`“什么”`，参与者做什么工作；`“何时”`，工作完成的时间限制，还需要说明工作的数据流和完成工作的控制流。人们认为自然语言在描述如此复杂的事务时容易引起歧义，所以人们定义了一些形式化语言试图在自然语言中挑选一个子集，这个子集既可以真正描述流程，又能够摆脱自然语言的复杂和多变，实际上想在人和机器在理解处理流程上架起一座桥梁，如同其他计算机语言及后来发展的统一建模语言一样，这些形式化的语言也称为“工作流定义语言”。  
&emsp;&emsp;同样，为了描述实际中的处理流程，人们也想到了图形的方式。有限状态自动机是一种分析状态和改变状态的良好工具，这种方法需要完全列出流程中所有状态及这些状态的组合，当处理流程变得庞大时，自动机所对应的状态图膨胀得太厉害。由于 Petri 网有严格的数学基础和图形化的规范语义，在描述离散事件动态系统方面的能力已经得到公认，具有较强的模型分析能力，在工作流的描述和分析中已经是人们广泛采用的一种方法。虽然有人认为图形并非工作流的最佳表示方法，但由于图形的直观性，大多数设计者都愿意采用图形的描述方式。有关有限状态自动机和 Petri 网的论述请参考其他书籍。

### 8.6.2 工作流管理系统
&emsp;&emsp;根据工作流管理联盟（Workflow Management Coalition，WFMC）的定义，工作流管理系统是一种“在工作流形式化表示的驱动下，通过软件的执行而完成工作流定义、管理及执行的系统”，其主要目标是对业务过程中各活动发生的先后次序及与活动相关的相应人力或信息资源的调用进行管理，而实现业务过程的自动化。  
&emsp;&emsp;如同关系数据库一样，现在已经出现了专门的工作流管理系统，这些系统经过专门的设计，从不同的角度负责解决设计者在流程设计中遇到的共同问题：节点定义、路径选择、数据流动等。不幸的是，和关系数据库共同基于关系代数、支持标准的 SQL 不同，这些工作流管理系统基于不同的数学模型，提供完全不同的接口。所以这些工作流管理系统各具特色，但在通用性和其他系统相互协作上的不足使得这些系统的应用受到了限制。  
&emsp;&emsp;WFMC 给出了包含六个基本模块的参考模型，这六个模块被认为是工作流管理系统的最基本组成，这个参考模型同时包括了这些模块之间的接口标准。
1. 流程定义工具  
&emsp;&emsp;这部分软件提供图形化或者其他方式的界面给设计者。由设计者将实际工作流程进行抽象，并将设计者提交的流程定义转换为形式化语言描述，提供给计算机工作流执行服务进行流程实例处理的依据。
2. 工作流执行服务  
&emsp;&emsp;这个服务程序是工作流管理系统的核心，它使用一种或者多种数据流引擎，对流程定义进行解释，激活有效的流程实例，推动流程实例在不同的活动中运转。和客户应用程序、其他工作流服务执行程序及其他应用程序进行交互，从而完成流程实例的创建、执行和管理工作。同时这部分软件为每个用户维护一个活动列表，告诉用户当前必须处理的任务。如果有必要，还可以通过电子邮件甚至是短消息的形式提醒用户任务的到达。
3. 其他工作流执行服务  
&emsp;&emsp;大型的企业工作流应用，往往包括多个工作流管理系统。这就需要这些工作流管理系统之间进行有效的交互，避免画地为牢、信息孤岛的现象出现。
4. 客户应用程序  
&emsp;&emsp;这是给最终用户的界面，用户通过使用这部分软件对工作流的数据进行必要的处理，如果用户是当前活动的拥有者，还可通过客户应用程序改变流程实例的活动，将流程实例推动到另外一个活动中。
5. 被调用应用程序  
&emsp;&emsp;这常常是对工作流所携带数据的处理程序，用得很多的是电子文档的处理程序。它们由工作流执行服务在流程实例的执行过程中调用，向最终用户展示待处理数据。在流程定义中应该定义这些应用程序的信息，包括名称、调用方式、参数等。
6. 管理和监控工具  
&emsp;&emsp;如同数据库管理系统或多或少地提供一些方式告诉管理员当前数据库的使用状态一样，工作流管理系统也应该提供对流程实例的状态查询、挂起、恢复、销毁等操作，同时提供系统参数、系统运行情况统计等数据。

&emsp;&emsp;看到这里，没有处理流程设计经验的设计者一定已经云里雾里了。确实，流程设计是系统设计中最困难的一部分，它的复杂性直接来源于现实世界的复杂性。而且直到现在，人们对流程的设计，仍然是在探索之中。
## 8.7 简单分布式计算机应用系统的设计
&emsp;&emsp;网络极大地扩展了计算机的应用范围，同时，由于升级到更强的服务器的费用常常远远高于购买多台档次稍低的机器，更何况虽然计算机有了长足的发展，可是单台计算机的功能仍然十分有限，利用联网的计算机协同工作，共同完成复杂的工作成为相对成本较低的选择，而且可以完成单台计算机所无法完成的任务。分布式系统使得这一目标成为可能。另外，网络本质上并不可靠，特别是远程通信，分布式系统还带来了并发和同步的问题。  
&emsp;&emsp;分布式系统可以由两种完全不同的方式来进行协同和合作，第一种是基于实例的协作。这种方式所有的实例都处理自己范围内的数据，这些对象实例的地位是相同的，当一个对象实例必须要处理不属于它自己范围的数据时，它必须和数据归宿的对象实例通信，请求另外一个对象实例进行处理。请求对象实例可以启动对象、调用远程对象的方法，以及停止运行远程实例。基于实例的协作具有良好的灵活性，但由于实例之间的紧密联系复杂的交互模型，使得开发成本提高，而且，由于实例必须能够通过网络找到，所以通信协议必须包括实例的生存周期管理，这使得基于实例的协作大多只限于统一的网络，对于复杂的跨平台的系统就难以应付。所以基于实例的协作适用于比较小范围内网络情况良好的环境中，这种环境常常被称为近连接。这种情况下对对象的生存周期管理所带来不寻常的网络流量是可以容忍的。  
&emsp;&emsp;使用基于实例的协作常常使用被称为“代理”的方法，某个对象实例需要调用远程对象时，它可以只和代理打交道，由代理完成和远程对象实例的通信工作：创建远程对象，提交请求、得到结果，然后把结果提交给调用的对象实例。这样，这个对象实例甚至可以不知道自己使用了远程对象。当远程对象被替换掉（升级）时，对本地代码也没有什么需要修改的地方。  
&emsp;&emsp;另外一种方式是基于服务的协作，该方法试图解决基于实例的协作的困难。它只提供远程对象的接口，用户可以调用这些方法，却无法远程创建和销毁远程对象实例。这样减少了交互，简化了编程，而且使得跨平台协作成为可能。同样由于只提供接口，这种协作方式使得对象间的会话状态难以确定，而且通信的数据类型也将有所限制，基本上很难使用自定义的类型。基于服务的协作适用于跨平台的网络，网络响应较慢的情况，这种环境常称为远连接，这时，简化交互性更为重要，而频繁的网络交换数据会带来难以容忍的延时。  
&emsp;&emsp;基于服务的协作往往采用分层次的结构，高层次的应用依赖于低层次的对象，而低层次对象实例的实现细节则没有必要暴露给高层次对象，这种安排使得高层次的实现不受低层次如何实现的影响，同时，当低层次服务修改时，高层次的服务也不应该受到影响。  
&emsp;&emsp;设计者在进行设计时，通常会倾向于比较细致的设计，对象往往提供了大量的操作和方法，响应许多不同的消息，以增加达到系统的灵活性、可维护性等。这在单个系统中没有什么问题，当考虑分布式系统的设计时，这种细致的设计所带来对对象方法的大量调用会比较严重地影响性能，所以在分布式系统中，倾向于使用大粒度的设计方式，往往在一个方法中包含了许多参数，每个方法基本上代表了一个独立的功能。当然这样的设计使得参数的传递变得复杂，当需要修改参数时，需要对比较大范围的一段过程代码进行修改，而不是像小粒度设计一样，只需要修改少量的代码。

## 8.8 系统运行环境的集成与设计
&emsp;&emsp;在设计一个新的系统时，设计者必须考虑目标系统的运行环境问题，人们往往认为软件应该能够在任何环境中运行，常常看到这样的系统，硬件已经升级了多次，而软件还是原来的软件。软件的运行环境是指系统运行的设备、操作系统和网络配置。  
&emsp;&emsp;本节给出软件运行的几个典型环境，设计者可以从这几种典型环境中选择适合自己的目标系统的环境，也可以将这些典型环境做一些组合，来满足自己设计的系统的特殊要求。
### 1．集中式系统
&emsp;&emsp;早期的计算机系统没有什么可以选择的，除了集中式系统。所有的操作都集中于一台主机中，而操作员必须在主机的附近操作，结果也在附近给出。这种系统仍然广泛地应用于批处理应用系统及更大的分布式系统的一部分。集中式系统常见于银行、保险、证券行业，它们含有大规模的处理应用。而现在流行的电子商务又给大型处理机注入了新的活力，人们发现电子商务要面对大量的事务，需要大型处理机来处理。但是，实践中很少单独使用集中式系统，因为大量的系统需要处理在地理上分布得很远的连接请求，这些请求有的需要实时响应，并可能要发送到其他某个地方的一个集中式系统。所以，在现代的系统中，集中式系统通常是某个分布式系统的一个环节。  
&emsp;&emsp;集中式系统由以下几个部分组成。
1. 单计算机结构  
&emsp;&emsp;这种结构简单、容易维护，但是处理能力受到限制。
2. 集群结构  
&emsp;&emsp;由多个计算机组成，这些计算机具有类似的硬件平台、操作系统等。通常采用负载均衡、资源共享等方式实现更大的处理能力和容量。
3. 多计算机结构  
&emsp;&emsp;由多个计算机组成，这些计算机之间操作环境可能不同。适用于当系统可以分解成多个不同的子系统时。
### 2．分布式系统
&emsp;&emsp;分布式系统由于网络的普遍延伸，费用的不断降低而越来越成为大型系统的首选环境。分布式系统必须基于网络，这个网络可以是在一个地域内的局域网，也可以是跨越不同城市乃至国家的广域网。对比集中式的计算机环境，分布式系统有着多种多样的形式。这也给设计者在确定系统运行环境时带来一定的烦恼。
### 3．C/S 结构
&emsp;&emsp;系统由提供服务的服务器和发起请求、接受结果的客户机构成。这种结构是一种可以使用很多方式实现的通用结构模型。并非只限于数据库的 C/S 结构，典型的还有网络打印服务系统，现在流行的网络游戏也显然是基于这种结构的。
### 4．多层结构
&emsp;&emsp;这种结构是 C/S 结构的扩展，典型的分为由存储数据的数据库服务器作为数据层、实现商业规则的程序作为逻辑层、管理用户输入输出的视图层所组成的三层结构。当系统更复杂时，可以再增加其他层次构成多层结构。  
&emsp;&emsp;多层结构形式复杂，功能多样。实现多层结构常常需要来实现不同层次间通信的专门程序——管件，也称为中间件。中间件大多数实现远程程序调用、对象请求调度等功能。
现代企业级的计算机系统大量地基于分布式结构。支持分布式系统的软件也曾经如同雨后春笋。系统如何分层、如何处理分布带来的同步等问题也就同样在考验设计者。
### 5.Internet、Intranet 和 Extranet
&emsp;&emsp;Internet 是全球的网络集合，使用通用的 TCP/IP 协议来相互连接。Internet 提供电子邮件、文件传输、远程登录等服务。Intranet 是私有网络，只限于内部使用，也使用 TCP/IP协议。Extranet 是一个扩展的 Intranet。它包括企业之外的和企业密切相关合作的其他企业。Extranet 允许分离的组织交换信息并进行合作，这样就形成了一个虚拟组织。现在的 VPN技术允许在公用网络上架构只对组织内部开发服务。  
&emsp;&emsp;Web 同样基于 C/S 结构，实际上 Web 接口是一个通用的接口，不是只能使用浏览器的协议，它同样能够在普通的程序中使用。Internet 和 Web 已经给设计者提供了一个非常富有吸引力的选择方案。它的优势在于：它们已经成为网络的事实上的标准，支持它们的软件已经广泛地存在于全世界的计算机中，而且通信费用已经下降到很有竞争力的水平。从某种程度上来说，企业可以把 Internet 当作自己廉价的广域网。没有它们，电子商务还是水中月。  
&emsp;&emsp;当然，事物有相反的一面，当设计者试图采用 Internet 时，必须考虑其不利的一面。Internet 的安全性过去是，现在是，以后仍然是设计者头痛的问题。其他诸如可靠性、系统吞吐量、不断发展的技术和标准都是影响系统选择它们作为运行环境的不利因素。设计者应该根据目标系统的实际需要来选择不同的运行环境。不过，已经有越来越多的公司提供支持 Internet 和电子商务的接口。

## 8.9 系统过渡计划
&emsp;&emsp;当新系统似乎开发完毕，要取代原来的系统时，系统过渡就是设计者不得不面对的问题。不幸的是，这个问题比许多人想象得要复杂，和软件开发一样，存在着许多冲突和限制。例如，费用、客户关系、后勤保证和风险等。设计者需要考虑的问题也很多，其中比较重要的几个问题是：  
&emsp;&emsp;如果同时运行两个系统，会给客户造成多大的开销；  
&emsp;&emsp;如果直接运行新系统，客户面对的风险有多大；  
&emsp;&emsp;对新系统试运行时的查错和纠错，以及出现严重错误而导致停止运行时的应急措施；  
&emsp;&emsp;客户运行新系统将面临的不利因素有哪些；  
&emsp;&emsp;人员的培训。

&emsp;&emsp;使用不同的系统过渡方案意味着不同的风险，不同的费用及不同的复杂度。
### 1．直接过渡
&emsp;&emsp;这是一种快速的系统过渡方式，当新系统运行时，立即关闭原来的系统。这种过渡方式非常简单，没有后勤保障的问题，也不要消耗很多资源。同时，它也意味着大风险，目标系统的特性决定了风险的大小。设计者主要要权衡当新系统失败时，系统停止运行或者勉强运行给客户带来的损失有多大。由于这种过渡方式简单而费用低廉，对于可以容忍停机一段时间的系统的实践者，可以采用这种方式。
### 2．并行过渡
&emsp;&emsp;设计者采用并行过渡方式，让新系统和旧系统在一段时间里同时运行，通过这样的旧系统作为新系统的备份，可以大大降低系统过渡的风险。可是并行过渡显然比直接过渡要消耗更多的资源：现有的硬件资源必须保证能同时跑两套系统，这常常意味着增加服务器和额外的存储空间，需要增加人员来同时使用两套系统，或者增加现有员工的工作量，让他们同时操作两套系统。这种方式同时也增加了管理和后勤保障的复杂度。据统计，并行过渡时期的开销是旧系统单独运行时的 2.5～3 倍。  
&emsp;&emsp;设计者还会发现有些系统无法使用并行过渡的方式，主要是客户没有足够的资源来维持两个系统同时运行，另外一种情况是新、旧系统差别太大，旧系统的数据无法为新系统采用。当客户无法使用并行过渡，又想尽可能地减少风险，设计者可以使用部分并行过渡的策略，使并行的开销减少到客户能够接受的范围内。
### 3．阶段过渡
&emsp;&emsp;通常在系统非常复杂、过于庞大以至于无法一次性进行过渡时采用，也适用于分阶段开发的系统。设计者需要设计一系列步骤和过程来完成整个系统的过渡，这种过渡方式和系统的复杂程度相关，随着系统的不同往往有很大的不同。和并行过渡一样，阶段过渡也能够减少风险，显然局部的失败要比全体的失败更容易接受，带来的损失更小。阶段过渡也带来了复杂性，有时候比并行过渡更加复杂。

# 第九章 软件架构设计

### 9.1.3 架构的模型
&emsp;&emsp;软件架构作为一个有机的整体，可以分解成多个侧面来认识，每个侧面强调它的不同方面的特征，从而使架构设计师能整体地把握它的重点。我们可以将软件架构归纳成 5 种模型：结构模型、框架模型、动态模型、过程模型和功能模型。最常用的是结构模型和动态模型。
1. 结构模型  
&emsp;&emsp;这是一个最直观、最普遍的建模方法。这种方法以架构的构件、连接件和其他概念来刻画结构，并力图通过结构来反映系统的重要语义内容，包括系统的配置、约束、隐含的假设条件、风格、性质。研究结构模型的核心是架构描述语言。
2. 框架模型  
&emsp;&emsp;框架模型与结构模型类似，但它不太侧重描述结构的细节而更侧重于整体的结构。框架模型主要以一些特殊的问题为目标建立只针对和适应该问题的结构。
3. 动态模型  
&emsp;&emsp;动态模型是对结构或框架模型的补充，研究系统“大颗粒”的行为性质。例如，描述系统的重新配置或演化。动态可能指系统总体结构的配置、建立或拆除通信通道或计算的过程。
4. 过程模型  
&emsp;&emsp;过程模型研究构造系统的步骤和过程。因而结构是遵循某些过程脚本的结果。
5. 功能模型  
&emsp;&emsp;该模型认为架构由一组功能构件按层次组成，且下层向上层提供服务。它可以看作是一种特殊的框架模型。

&emsp;&emsp;这 5 种模型各有所长，也许将 5 种模型有机地统一在一起，形成一个完整的模型来刻画软件架构更合适。即将软件架构视为这些模型的统一体，通过这些模型的表述（文档）来完整反映软件架构。例如，Kruchten 在 1995 年提出了一个“4+1”的视图模型。“4+1” 视图模型从 5 个不同的视角包括逻辑视图、进程视图、物理视图、开发视图和场景视图来描述软件架构。每一个视图只关心系统的一个侧面，5 个视图结合在一起才能反映系统的软件架构的全部内容。“4+1”视图模型如下图所示。

![“4+1”视图模型](https://pic.lufer.cc/images/2021/03/15/yM6WeP.png)

1. 逻辑视图  
&emsp;&emsp;主要支持系统的功能需求，即系统提供给最终用户的服务。在逻辑视图中，系统分解成一系列的功能抽象，这些抽象主要来自问题领域。这种分解不但可以用来进行功能分析，而且可用作标识在整个系统的各个不同部分的通用机制和设计元素。在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。逻辑视图中使用的风格为面向对象的风格，逻辑视图设计中要注意的主要问题是要保持一个单一的、内聚的对象模型贯穿整个系统。
2. 开发视图  
&emsp;&emsp;也称为模块视图，主要侧重于软件模块的组织和管理。软件可通过程序库或子系统进行组织，这样，对于一个软件系统，就可以由不同的人进行开发。开发视图要考虑软件内部的需求，如软件开发的容易性、软件的重用和软件的通用性，要充分考虑由于具体开发工具的不同而带来的局限性。开发视图通过系统输入输出关系的模型图和子系统图来描述。可以在确定了软件包含的所有元素之后描述完整的开发角度，也可以在确定每个元素之前，列出开发视图原则。
3. 进程视图  
&emsp;&emsp;侧重于系统的运行特性，主要关注一些非功能性的需求，例如系统的性能和可用性。进程视图强调并发性、分布性、系统集成性和容错能力，以及逻辑视图中的主要抽象的进程结构。它也定义逻辑视图中的各个类的操作具体是在哪一个线程中被执行的。进程视图可以描述成多层抽象，每个级别分别关注不同的方面。
4. 物理视图  
&emsp;&emsp;主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结构、系统安装、通信等问题。当软件运行于不同的节点上时，各视图中的构件都直接或间接地对应于系统的不同节点上。因此，从软件到节点的映射要有较高的灵活性，当环境改变时，对系统其他视图的影响最小。
5. 场景  
&emsp;&emsp;可以看作是那些重要系统活动的抽象，它使四个视图有机地联系起来，从某种意义上说，场景是最重要的需求抽象。在开发架构时，它可以帮助设计者找到架构的构件和它们之间的作用关系。同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的。场景可以用文本表示，也可以用图形表示。

>&emsp;&emsp;逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。

## 9.2 架构需求与软件质量属性
&emsp;&emsp;架构的基本需求主要是在满足功能属性的前提下，关注软件质量属性，架构设计则是为满足架构需求（质量属性）寻找适当的“战术”。  
&emsp;&emsp;软件属性包括功能属性和质量属性，但是，软件架构（及软件架构设计师）重点关注的是质量属性。因为，在大量的可能结构中，可以使用不同的结构来实现同样的功能性，即功能性在很大程度上是独立于结构的，架构设计师面临着决策（对结构的选择），而功能性所关心的是它如何与其他质量属性进行交互，以及它如何限制其他质量属性。
### 9.2.1 软件质量属性
&emsp;&emsp;《GB/T16260-1996(idt ISO／IEC9126：1991)信息技术软件产品评价质量特性及其使用指南》中描述的软件质量特性包括`功能性`、`可靠性`、`易用性`、`效率`、`可维护性`、`可移植性`等6个方面，每个方面都包含若干个子特性。  
&emsp;&emsp;功能性：适合性、准确性、互操作性、依从性、安全性；  
&emsp;&emsp;可靠性：成熟性、容错性、易恢复性；  
&emsp;&emsp;易用性：易理解性、易学性、易操作性；  
&emsp;&emsp;效率：时间特性、资源特性；  
&emsp;&emsp;可维护性：易分析性、易改变性、稳定性、易测试性；  
&emsp;&emsp;可移植性：适应性、易安装性、遵循性、易替换性；  

&emsp;&emsp;正如上述列举与分类，软件的质量属性很多，也有各种不同的分类法和不同的表述。虽然术语没有统一的定义，但其含义可以认为业界已有共识。下面选取常用的质量属性术语，并做逐一说明。
#### 1．运行期质量属性
&emsp;&emsp;性能：性能是指软件系统及时提供相应服务的能力。包括`速度`、`吞吐量`和`持续高速性`三方面的要求。  
&emsp;&emsp;安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。  
&emsp;&emsp;易用性：指软件系统易于被使用的程度。  
&emsp;&emsp;可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。  
&emsp;&emsp;互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。  
&emsp;&emsp;可靠性：软件系统在一定的时间内无故障运行的能力。  
&emsp;&emsp;持续可用性：指系统长时间无故障运行的能力。与可靠性相关联，常将其纳入可靠性中。  
&emsp;&emsp;鲁棒性：是指软件系统在一些非正常情况（如用户进行了非法操作、相关的软硬件系统发生了故障等）下仍能够正常运行的能力。也称健壮性或容错性。
#### 2.开发期质量属性
&emsp;&emsp;易理解性：指设计被开发人员理解的难易程度。  
&emsp;&emsp;可扩展性：软件因适应新需求或需求变化而增加新功能的能力。也称为灵活性。  
&emsp;&emsp;可重用性：指重用软件系统或某一部分的难易程度。  
&emsp;&emsp;可测试性：对软件测试以证明其满足需求规范的难易程度。   
&emsp;&emsp;可维护性：当需要修改缺陷、增加功能、提高质量属性时，定位修改点并实施修改的难易程度；  
&emsp;&emsp;可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。 

&emsp;&emsp;在实践中，架构设计师追求质量属性常常陷入“鱼和熊掌”的两难境地，这就需要架构设计师的决策智慧了。下表反映了质量属性之间的相互制约关系（正相关或负相关），其中“+”代表“行属性”能促进“列属性”；而“-”则相反。例如，第一列符号说明许多属性（行）对性能（列）有副作用，第一行符号说明性能（行）对许多属性（列）有副作用，认识这一点，对于架构决策的权衡很重要。

||性能|安全性|持续可用性|可互操作性|可靠性|鲁棒性|易用性|可测试性|可重用性|可维护性|可扩展性|可移植性|
|-|-|-|-|-|-|-|-|-|-|-|-|-|
|性能||||-|-|-|-|-||-|-|-|
|安全性|-|||-|||-|-|-||||
|持续可用性|||||+|+|||||||
|可互操作性|-|-|||||||||+|+|
|可靠性|+||+|||+|+|+||+|+||
|鲁棒性|-||+||+||+||||||
|易用性|-|||||+||-|||||
|可测试性|-||+||+||+|||+|+||
|可重用性|-|-||+|-|||+||+|+|+|
|可维护性|-||+||+|||+|||+||
|可扩展性|-|-|||+|||+||+||+|
|可移植性|-|||+||||+|+||+||


### 9.2.2 6个质量属性及实现
&emsp;&emsp;本节从架构关注点来研究质量属性实现，将质量属性分为 6 种：可用性、可修改性、性能、安全性、可测试性、易用性。其他的质量属性一般可纳入这几个属性中（在其他文献中为了强调常单列出来），例如，可扩充性可归入可修改性中（修改系统容量），可移植性也可以作为平台的可修改性来获得。对于未能纳入的其他质量属性，可以用本章的方法进行研
究。  
&emsp;&emsp;那么，如何描述质量属性需求呢？采用质量属性场景作为一种描述规范，它由以下6个部分组成，如下图所示。

![质量属性场景](https://pic.lufer.cc/images/2021/03/15/y1X7fU.png)

&emsp;&emsp;刺激源：生成该刺激的实体（人、计算机系统或其他激励器）；  
&emsp;&emsp;刺激：刺激到达系统时可能产生的影响（即需要考虑和关注的情况）；  
&emsp;&emsp;环境：该刺激在某条件内发生。如系统可能正处于过载情况；  
&emsp;&emsp;制品：系统中受刺激的部分（某个制品被刺激）；  
&emsp;&emsp;响应：刺激到达后所采取的行动；  
&emsp;&emsp;响应度量：当响应发生时，应能够以某种方式对应其度量，用于对是否满足需求的测试。

&emsp;&emsp;需要将一般的质量属性场景（一般场景）与具体的质量属性场景（具体场景）区别开来，前者是指独立于具体系统、适合于任何系统的一般性场景；而后者是指适合于正在考虑的某个特定系统的场景，具体场景通常是指从一般场景中抽取特定的、面向具体系统的内容。下面几个小节中为每个质量属性提供一张表，该表中给出了质量属性场景每部分的一些可能取值，整体上形成一个一般场景的表格描述。在实际应用时，根据系统的具体情况，从该表中选取适当的值，就能变成具体场景（可读性强、可应用），可以把具体场景的集合作为系统的质量属性需求。  
&emsp;&emsp;实现这些质量属性的基本设计决策，称为“战术”，而把战术的集合称为“架构策略”。  
&emsp;&emsp;这些架构策略供架构设计师选择。下面几个小节将对各质量属性的战术进行示例性的总结。
&emsp;&emsp;“战术”作为逻辑部件位于质量属性场景图的制品中，它旨在控制对刺激的响应。
#### 1．可用性及其实现战术
##### 1. 可用性的描述  
&emsp;&emsp;可用性的描述如下表所示。

|场景的部分|可能的值|
|-|-|
|刺激源|系统内部、系统外部|
|刺激|错误：疏忽（构建对某输入未做出反应）、崩溃、时间不当（响应时间太早或太迟）、响应不当（以一个不正确的值来响应）|
|制品|系统的处理器、通信通道、存储器、进程|
|环境|正常操作、降级模式|
|响应|系统应记录检测事件，并进行如下一个或多个活动：<br> * 将其记录下来<br>* 通知适当的各方，包括用户和其他系统<br>* 根据规则屏蔽导致错误或故障的事件源<br>* 不可用（进入修理状态）<br>* 继续在正常或降级模型下运行|
|响应度量|可用时间、修复时间、各种情况的时间间隔|

&emsp;&emsp;可用性一般场景可以用下图表示。

![可用性一般场景](https://pic.lufer.cc/images/2021/03/15/y1xdOJ.png)

&emsp;&emsp;对一般场景进行具体化可以得到可用性具体场景，如下图所示。

![可用性的一个具体场景（示例）](https://pic.lufer.cc/images/2021/03/15/y1xhmd.png)

##### 2. 可用性战术  
&emsp;&emsp;可用性战术的目标是阻止错误发展成故障，至少能够把错误的影响限制在一定范围内，从而使修复成为可能。战术分为：错误检测、错误恢复、错误预防。
1. 错误检测  
&emsp;&emsp;命令/响应：一个构件发出一个命令，并希望在预定义的时间内收到一个来自审查构件的响应，例如远程错误的检测。  
&emsp;&emsp;心跳（计时器）：一个构件定期发出一个心跳消息，另一个构件收听到消息，如果未收到心跳消息，则假定构件失败，并通知错误纠正构件。  
&emsp;&emsp;异常：当出现异常时，异常处理程序开发执行。
2. 错误恢复  
&emsp;&emsp;表决：通过冗余构件（或处理器）与表决器连接，构件按相同的输入及算法计算输出值交给表决器，由表决器按表决算法（如多数规则）确定是否有构件出错，表决通常用在控制系统中。  
&emsp;&emsp;主动冗余（热重启、热备份）：所有的冗余构件都以并行的方式对事件做出响应。它们都处在相同的状态，但仅使用一个构件的响应，丢弃其余构件的响应。错误发生时通过切换的方式使用另一个构件的响应。
被动冗余（暧重启/双冗余/三冗余）：一个构件（主构件）对事件做出响应，并通知其他构件（备用的）必须进行的状态更新（同步）。当错误发生时，备用构件从最新同步点接替主构件的工作。  
&emsp;&emsp;备件：备件是计算平台配置用于更换各种不同的故障构件。  
&emsp;&emsp;状态再同步：主动和被动冗余战术要求所恢复的构件在重新提供服务前更新其状态。更新方法取决于可以承受的停机时间、更新的规模及更新的内容多少。  
&emsp;&emsp;检查点/回滚：检查点就是使状态一致的同步点，它或者是定期进行，或者是对具体事件做出响应。当在两检查点之间发生故障时，则以这个一致状态的检查点（有快照）和之后发生的事务日志来恢复系统（数据库中常使用）。
3. 错误预防  
&emsp;&emsp;从服务中删除：如删除进程再重新启动，以防止内存泄露导致故障的发生。  
&emsp;&emsp;事务：使用事务来保证数据的一致性，即几个相关密切的步骤，要么全成功，要么都不成功。  
&emsp;&emsp;进程监视器：通过监视进程来处理进程的错误。
#### 2．可修改性及其实现战术
##### 1. 可修改性的描述
&emsp;&emsp;可修改性的描述如下表所示。

|场景的部分|可能的值|
|-|-|
|刺激源|最终用户、开发人员、系统管理员|
|刺激|增加/删除/修改/改变：功能、质量属性、容量|
|制品|用户界面、平台、环境或关联系统|
|环境|运行时、编译时、构建时、设计时|
|响应|查找要修改的位置，进行修改（不影响其他功能），进行测试，部署所修改的内容|
|响应度量|对修改的成本进行度量，对修改的影响进行度量|


##### 2. 可修改性战术  
&emsp;&emsp;包括局部化修改、防止连锁反应、推迟绑定时间。
1. 局部化修改  
&emsp;&emsp;在设计期间为模块分配责任，以便把预期的变更限制在一定的范围内，从而降低修改的成本。  
&emsp;&emsp;维持语义的一致性：语义的一致性指的是模块中责任之间的关系，使这些责任能够协同工作，不需要过多地依赖其他模块。耦合和内聚指标反映一致性，应该根据一组预期的变更来度量语义一致性。使用“抽象通用服务”（如应用框架的使用和其他中间软件的使用）来支持可修改性是其子战术。  
&emsp;&emsp;预期期望的变更：通过对变更的预估，进行预设、准备，从而使变更的影响最小。  
&emsp;&emsp;泛化该模块：使一个模块更通用、更广泛的功能。  
&emsp;&emsp;限制可能的选择：如在更换某一模块（如处理器）时，限制为相同家族的成员。  
2. 防止连锁反应  
&emsp;&emsp;由于模块之间有各种依赖性，因此，修改会产生连锁反应。防止连锁反应的战术如下。  
&emsp;&emsp;信息隐藏：就是把某个实体的责任分解为更小的部分，并选择哪些信息成为公有的，哪些成为私有的，通过接口获得公有责任。  
&emsp;&emsp;维持现有的接口：尽可能维持现有接口的稳定性。例如通过添加接口（通过新的接口提供新的服务）可以达到这一目的。  
&emsp;&emsp;限制通信路径：限制与一个给定的模块共享数据的模块。这样可以减少由于数据产生/使用引入的连锁反应。  
&emsp;&emsp;仲裁者的使用：在具有依赖关系的两个模块之间插入一个仲裁者，以管理与该依赖相关的活动。仲裁者有很多种类型，例如：桥、调停者、代理等就是可以提供把服务的语法从一种形式转换为另一种形式的仲裁者。
3.  推迟绑定时间  
&emsp;&emsp;系统具备在运行时进行绑定并允许非开发人员进行修改（配置）。  
&emsp;&emsp;运行时注册：支持即插即用。  
&emsp;&emsp;配置文件：在启动时设置参数。  
&emsp;&emsp;多态：在方法调用的后期绑定。  
&emsp;&emsp;构件更换：允许载入时绑定。  
#### 3．性能及其实现战术
##### 1. 性能的描述  
&emsp;&emsp;性能描述如下表所示。

|场景的部分|可能的值|
|-|-|
|刺激源|系统内部或外部|
|刺激|定期事件、随机事件、偶然事件|
|制品|系统|
|环境|正常模式、超载模式|
|响应|处理刺激、改变服务级别|
|响应度量|度量等待、期限、吞吐量、缺失率、数据丢失等|

##### 2. 性能战术  
&emsp;&emsp;性能与时间相关，影响事件的响应时间有两个基本因素。  
&emsp;&emsp;资源消耗：事件到达后进入一系列的处理程序，每一步处理都要占用资源，而且在处理过程中消息在各构件之间转换，这些转换也需要占用资源。  
&emsp;&emsp;闭锁时间：指对事件处理时碰到了资源争用、资源不可用或对其他计算的依赖等情况，就产生了等待时间。  
&emsp;&emsp;性能的战术有如下几种。
1. 资源需求  
&emsp;&emsp;减少处理事件流所需的资源：提高计算效率（如改进算法）、减少计算开销（如在可修改性与性能之间权衡，减少不必要的代理构件）。  
&emsp;&emsp;减少所处理事件的数量：管理事件率、控制采样频率。  
&emsp;&emsp;控制资源的使用：限制执行时间（如减少迭代次数）、限制队列大小。
2. 资源管理  
&emsp;&emsp;引入并发：引入并发对负载平衡很重要。  
&emsp;&emsp;维持数据或计算的多个副本：C/S 结构中客户机 C 就是计算的副本，它能减少服务器计算的压力；高速缓存可以存放数据副本（在不同速度的存储库之间的缓冲）。  
&emsp;&emsp;增加可用资源：在成本允许时，尽量使用速度更快的处理器、内存和网络。  
3. 资源仲裁  
&emsp;&emsp;资源仲裁战术是通过如下调度策略来实现的：  
&emsp;&emsp;先进/先出（FIFO）；   
&emsp;&emsp;固定优先级调度：先给事件分配特定的优先级，再按优先级高低顺序分配资源；  
&emsp;&emsp;动态优先级调度：轮转调度、时限时间最早优先；  
&emsp;&emsp;静态调度：可以离线确定调度。
#### 4．安全性及其实现战术
##### 1. 安全性的描述
&emsp;&emsp;安全性的描述如下表所示。

|场景的部分|可能的值|
|-|-|
|刺激源|对敏感资源进行访问的人或系统（合法的、非法的）|
|刺激|试图：显示数据、改变/删除数据、访问系统服务、降低系统服务的可用性|
|制品|系统服务、系统中的数据|
|环境|在线或离线、联网或断网、有或无防火墙|
|响应|对用户身份验证、阻止或允许对数据或服务的访问、授予可回收访问权、加密信息、限制服务的可用性、通知用户或系统|
|响应度量|增加安全性的成本、检测或确定攻击的可能性、降低服务级别后的成功率、恢复数据/服务|

##### 2. 安全性战术  
&emsp;&emsp;包括抵抗攻击、检测攻击和从攻击中恢复。
1. 抵抗攻击  
&emsp;&emsp;对用户进行身份验证：包括动态密码、一次性密码、数字证书及生物识别等；  
&emsp;&emsp;对用户进行授权：即对用户的访问进行控制管理；  
&emsp;&emsp;维护数据的机密性：一般通过对数据和通信链路进行加密来实现；  
&emsp;&emsp;维护完整性：对数据添加校验或哈希值；  
&emsp;&emsp;限制暴露的信息；  
&emsp;&emsp;限制访问：如用防火墙、DMZ 策略。  
2. 检测攻击  
&emsp;&emsp;一般通过“入侵检测”系统进行过滤、比较通信模式与历史基线等方法。
3. 从攻击中恢复  
&emsp;&emsp;恢复：与可用性中的战术相同；  
&emsp;&emsp;识别攻击者：作为审计追踪，用于预防性或惩罚性目的。
#### 5．可测试性及其实现战术
##### 1. 可测试性的描述 
&emsp;&emsp;可测试性的描述如下表所示。

|场景的部分|可能的值|
|-|-|
|刺激源|各类测试人员（单元测试、集成测试、验收、用户）|
|刺激|一种测试|
|制品|设计、代码段、完整的应用|
|环境|设计时、开发时、编译时、部署时|
|响应|提供测试的状态值、测试环境与案例的准备|
|响应度量|测试成本、出现故障的概率、执行时间等|

##### 2. 可测试性战术  
&emsp;&emsp;包括输入/输出和内部监控。
1. 输入/输出  
&emsp;&emsp;记录/回放：指捕获跨接口的信息，并将其作为测试专用软件的输入；  
&emsp;&emsp;将接口与实现分离：允许使用实现的替代（模拟器）来支持各种测试目的；  
&emsp;&emsp;优化访问线路/接口：用测试工具来捕获或赋予构件的变量值。  
2. 内部监控  
&emsp;&emsp;当监视器处于激活状态时，记录事件（如通过接口的信息）。
#### 6．易用性及其实现战术
##### 1. 易用性的描述
&emsp;&emsp;易用性的描述如下表所示。

|场景的部分|可能的值|
|-|-|
|刺激源|最终用户|
|刺激|学习系统特性、有效使用系统、使错误的影响最低、适配系统、对系统满意|
|制品|系统|
|环境|运行时或配置时|
|响应|支持“学习系统特性”的相应：界面为用户所熟悉或使用帮助系统<br>支持“有效使用系统”的相应：数据/命令聚合或复用、界面是导航、操作的一致性、多个活动同时进行<br>支持“使错误的影响最低”的相应：撤销/取消、从故障中恢复、<br>支持“适配系统”的相应：界面为用户所熟悉或使用帮助系统<br>支持“对系统满意”的相应：界面为用户所熟悉或使用帮助系统|
|响应度量|测试成本、出现故障的概率、执行时间等|


##### 2. 易用性战术  
&emsp;&emsp;包括运行时战术、设计时战术和支持用户主动操作。
1. 运行时战术  
&emsp;&emsp;任务的模型：维护任务的信息，使系统了解用户试图做什么，并提供各种协助；  
&emsp;&emsp;用户的模型：维护用户的信息，例如使系统以用户可以阅读页面的速度滚动页面；  
&emsp;&emsp;系统的模型：维护系统的信息，它确定了期望的系统行为，并向用户提供反馈。  
2. 设计时战术  
&emsp;&emsp;将用户接口与应用的其余部分分离开来，预计用户接口会频繁发生变化，因此，单独维护用户接口代码将实现变更局部化。这与可修改性相关。
3. 支持用户主动操作  
&emsp;&emsp;支持用户的主动操作，如支持“取消”、“撤销”、“聚合”和 “显示多个视图”。




### 1.1.3 数据表示
1. 原码  
如果机器字长为n，那么原码的定义如下：  
若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^(n-1) + |X|。  
若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2^0 + |X|。  
`负数首位为1`
2. 反码
如果机器字长为n，那么反码的定义如下：  
若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^n - 1 + |X|。  
若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2-2^-(n-1) + |X|。  
`负数按位取反`
3. 补码
如果机器字长为n，那么补码的定义如下：  
若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^n + |X|。  
若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2 + |X|。 
`负数按位取反+1`
4. 移码
在机器字长为n，偏移量为2^(n-1)的情况下，纯整数的移码为2^(n-1)+X,纯小数的移码为1+X。`补码符号位取反即可得到移码`  

### 1.1.4 校验码
计算机通常使用校验码的方法来检测传送的数据是否出问题。  
`码距`:一个编码系统中任意两个合法编码之间至少有多少个二进制位不同  
1. 奇偶校验码  
通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者偶数（偶校验），从而使码距变为2。  
常见的有：`水平奇偶校验码`，`垂直奇偶校验码`，`水平垂直校验码`
2. 海明码
海明码利用奇偶性来检错和纠错。在数据位之间的特定位置上插入K个校验位，通过扩大码距来实现检错和纠错。
3. 循环冗余校验码
利用多项式为K个数据位产生R个校验位，编码长度K+R记为N，N为CRC码的字长，又称为(n,k)码。    --> -->
